
TFM_SBSFU_Boot.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .provision    00000796  0c002000  0c002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .BL2_NoHdp_Code 000003f6  0c011800  0c011800  00021800  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0000dff0  0c002900  0c002900  00002900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .ARM.exidx    00000008  0c0108f0  0c0108f0  000108f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .copy.table   00000018  0c0108f8  0c0108f8  000108f8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .zero.table   00000010  0c010910  0c010910  00010910  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000154  30030000  0c010920  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000e2d0  30030154  0c010a74  00020154  2**2
                  ALLOC
  8 .msp_stack    00001404  3003e424  0c01ed44  0002e424  2**0
                  ALLOC
  9 .heap         00000000  3003f828  3003f828  00021bf6  2**0
                  CONTENTS
 10 .ARM.attributes 00000036  00000000  00000000  00021bf6  2**0
                  CONTENTS, READONLY
 11 .comment      0000007b  00000000  00000000  00021c2c  2**0
                  CONTENTS, READONLY
 12 .debug_info   00056d5d  00000000  00000000  00021ca7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000b723  00000000  00000000  00078a04  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0002633a  00000000  00000000  00084127  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00002538  00000000  00000000  000aa461  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00003538  00000000  00000000  000ac999  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  00038330  00000000  00000000  000afed1  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0003319b  00000000  00000000  000e8201  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    0012ce08  00000000  00000000  0011b39c  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame  00007750  00000000  00000000  002481a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stab         00000084  00000000  00000000  0024f8f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      00000117  00000000  00000000  0024f978  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .BL2_NoHdp_Code:

0c011800 <mpu_armv8m_enable>:
               (MPU_ARMV8M_MAIR_ATTR_CODE_VAL << MPU_MAIR0_Attr1_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_DATA_VAL << MPU_MAIR0_Attr2_Pos) |
               (MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_VAL << MPU_MAIR0_Attr3_Pos);

  mpu->CTRL =
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c011800:	2900      	cmp	r1, #0
 c011802:	bf14      	ite	ne
 c011804:	2104      	movne	r1, #4
 c011806:	2100      	moveq	r1, #0
    (hfnmi_en   ? MPU_CTRL_HFNMIENA_Msk   : 0);
 c011808:	2a00      	cmp	r2, #0
 c01180a:	bf14      	ite	ne
 c01180c:	2202      	movne	r2, #2
 c01180e:	2200      	moveq	r2, #0
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c011810:	6803      	ldr	r3, [r0, #0]
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c011812:	4807      	ldr	r0, [pc, #28]	; (c011830 <mpu_armv8m_enable+0x30>)
    (privdef_en ? MPU_CTRL_PRIVDEFENA_Msk : 0) |
 c011814:	4311      	orrs	r1, r2
  mpu->MAIR0 = (MPU_ARMV8M_MAIR_ATTR_DEVICE_VAL << MPU_MAIR0_Attr0_Pos) |
 c011816:	6318      	str	r0, [r3, #48]	; 0x30
  mpu->CTRL =
 c011818:	6059      	str	r1, [r3, #4]

  /*Ensure all configuration is written before enable*/

  mpu->CTRL |= MPU_CTRL_ENABLE_Msk;
 c01181a:	685a      	ldr	r2, [r3, #4]
 c01181c:	f042 0201 	orr.w	r2, r2, #1
 c011820:	605a      	str	r2, [r3, #4]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 c011822:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c011826:	f3bf 8f6f 	isb	sy

  /* Enable MPU before next instruction */
  __DSB();
  __ISB();
  return MPU_ARMV8M_OK;
}
 c01182a:	2000      	movs	r0, #0
 c01182c:	4770      	bx	lr
 c01182e:	bf00      	nop
 c011830:	44ffaa04 	.word	0x44ffaa04

0c011834 <mpu_armv8m_region_enable>:
  enum mpu_armv8m_error_t ret_val = MPU_ARMV8M_OK;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c011834:	684a      	ldr	r2, [r1, #4]
{
 c011836:	b510      	push	{r4, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
 c011838:	f012 041f 	ands.w	r4, r2, #31
 c01183c:	d125      	bne.n	c01188a <mpu_armv8m_region_enable+0x56>
  /* region_limit doesn't need to be aligned but the scatter
   * file needs to be setup to ensure that partitions do not overlap.
   */
  /* don't disable MPU */

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c01183e:	780b      	ldrb	r3, [r1, #0]
  MPU_Type *mpu = (MPU_Type *)dev->base;
 c011840:	6800      	ldr	r0, [r0, #0]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
 c011842:	f022 021f 	bic.w	r2, r2, #31
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
 c011846:	6083      	str	r3, [r0, #8]
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c011848:	7c0b      	ldrb	r3, [r1, #16]
 c01184a:	f003 0301 	and.w	r3, r3, #1
 c01184e:	4313      	orrs	r3, r2
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
 c011850:	7c8a      	ldrb	r2, [r1, #18]
 c011852:	00d2      	lsls	r2, r2, #3
 c011854:	f002 0218 	and.w	r2, r2, #24
 c011858:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
 c01185a:	7c4b      	ldrb	r3, [r1, #17]
 c01185c:	005b      	lsls	r3, r3, #1
 c01185e:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
 c011862:	4313      	orrs	r3, r2

  mpu->RBAR = base_cfg;
 c011864:	60c3      	str	r3, [r0, #12]

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit - 1) & MPU_RLAR_LIMIT_Msk;
 c011866:	688b      	ldr	r3, [r1, #8]
 c011868:	3b01      	subs	r3, #1
 c01186a:	f023 021f 	bic.w	r2, r3, #31

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
 c01186e:	68cb      	ldr	r3, [r1, #12]
 c011870:	005b      	lsls	r3, r3, #1
 c011872:	f003 030e 	and.w	r3, r3, #14
 c011876:	4313      	orrs	r3, r2
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
 c011878:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
 c01187c:	6103      	str	r3, [r0, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c01187e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c011882:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
 c011886:	4620      	mov	r0, r4
}
 c011888:	bd10      	pop	{r4, pc}
    return MPU_ARMV8M_ERROR;
 c01188a:	2001      	movs	r0, #1
 c01188c:	e7fc      	b.n	c011888 <mpu_armv8m_region_enable+0x54>
	...

0c011890 <boot_jump_to_ns_image>:
 *  - There are secrets in the memory: KDF parameter, symmetric key,
 *    manufacturer sensitive code/data, etc.
 */
__attribute__((naked)) void boot_jump_to_ns_image(uint32_t reset_handler_addr)
{
  __ASM volatile(
 c011890:	4607      	mov	r7, r0
 c011892:	f000 f82d 	bl	c0118f0 <boot_clean_ns_ram_area>
 c011896:	2000      	movs	r0, #0
 c011898:	4601      	mov	r1, r0
 c01189a:	4602      	mov	r2, r0
 c01189c:	4603      	mov	r3, r0
 c01189e:	4604      	mov	r4, r0
 c0118a0:	4605      	mov	r5, r0
 c0118a2:	4606      	mov	r6, r0
 c0118a4:	4680      	mov	r8, r0
 c0118a6:	4681      	mov	r9, r0
 c0118a8:	4682      	mov	sl, r0
 c0118aa:	4683      	mov	fp, r0
 c0118ac:	4684      	mov	ip, r0
 c0118ae:	4686      	mov	lr, r0
 c0118b0:	f027 0701 	bic.w	r7, r7, #1
 c0118b4:	47bc      	blxns	r7

0c0118b6 <execute_loader>:
{
 c0118b6:	b508      	push	{r3, lr}
  TFM_LL_SECU_UpdateLoaderRunTimeProtections();
 c0118b8:	f000 f8ce 	bl	c011a58 <TFM_LL_SECU_UpdateLoaderRunTimeProtections>
  SCB_NS->VTOR = LOADER_NS_CODE_START;
 c0118bc:	4b04      	ldr	r3, [pc, #16]	; (c0118d0 <execute_loader+0x1a>)
 c0118be:	4a05      	ldr	r2, [pc, #20]	; (c0118d4 <execute_loader+0x1e>)
 c0118c0:	6093      	str	r3, [r2, #8]
  __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 c0118c2:	681a      	ldr	r2, [r3, #0]
 c0118c4:	f382 8888 	msr	MSP_NS, r2
  boot_jump_to_ns_image(vt->reset);
 c0118c8:	6858      	ldr	r0, [r3, #4]
 c0118ca:	f7ff ffe1 	bl	c011890 <boot_jump_to_ns_image>
 c0118ce:	bf00      	nop
 c0118d0:	0807a000 	.word	0x0807a000
 c0118d4:	e002ed00 	.word	0xe002ed00

0c0118d8 <boot_clear_bl2_ram_area>:
  __IO uint32_t *pt = (uint32_t *)BL2_DATA_START;
  uint32_t index;

  for (index = 0; index < (BL2_DATA_SIZE / 4); index++)
  {
    pt[index] = 0;
 c0118d8:	2100      	movs	r1, #0
{
 c0118da:	4b03      	ldr	r3, [pc, #12]	; (c0118e8 <boot_clear_bl2_ram_area+0x10>)
  for (index = 0; index < (BL2_DATA_SIZE / 4); index++)
 c0118dc:	4a03      	ldr	r2, [pc, #12]	; (c0118ec <boot_clear_bl2_ram_area+0x14>)
    pt[index] = 0;
 c0118de:	f843 1b04 	str.w	r1, [r3], #4
  for (index = 0; index < (BL2_DATA_SIZE / 4); index++)
 c0118e2:	4293      	cmp	r3, r2
 c0118e4:	d1fb      	bne.n	c0118de <boot_clear_bl2_ram_area+0x6>
  }
}
 c0118e6:	4770      	bx	lr
 c0118e8:	30030000 	.word	0x30030000
 c0118ec:	3003fc00 	.word	0x3003fc00

0c0118f0 <boot_clean_ns_ram_area>:
#endif /* TFM_ERROR_HANDLER_NON_SECURE */
  uint32_t index;
  /* clean all SRAM1 */
  for (index = 0; index < (_SRAM1_SIZE_MAX / 4); index++)
  {
    pt[index] = 0;
 c0118f0:	2100      	movs	r1, #0
{
 c0118f2:	4b08      	ldr	r3, [pc, #32]	; (c011914 <boot_clean_ns_ram_area+0x24>)
  for (index = 0; index < (_SRAM1_SIZE_MAX / 4); index++)
 c0118f4:	4a08      	ldr	r2, [pc, #32]	; (c011918 <boot_clean_ns_ram_area+0x28>)
    pt[index] = 0;
 c0118f6:	f843 1b04 	str.w	r1, [r3], #4
  for (index = 0; index < (_SRAM1_SIZE_MAX / 4); index++)
 c0118fa:	4293      	cmp	r3, r2
 c0118fc:	d1fb      	bne.n	c0118f6 <boot_clean_ns_ram_area+0x6>
  }
  /* unsecure all SRAM1 */
  for (index = 0; index < 24 ; index++)
 c0118fe:	2300      	movs	r3, #0
  {
    /* assume loader is only in SRAM1 */
    GTZC_MPCBB1_S->VCTR[index] = 0;
 c011900:	4618      	mov	r0, r3
 c011902:	4a06      	ldr	r2, [pc, #24]	; (c01191c <boot_clean_ns_ram_area+0x2c>)
 c011904:	f103 0140 	add.w	r1, r3, #64	; 0x40
  for (index = 0; index < 24 ; index++)
 c011908:	3301      	adds	r3, #1
 c01190a:	2b18      	cmp	r3, #24
    GTZC_MPCBB1_S->VCTR[index] = 0;
 c01190c:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
  for (index = 0; index < 24 ; index++)
 c011910:	d1f8      	bne.n	c011904 <boot_clean_ns_ram_area+0x14>
  }
}
 c011912:	4770      	bx	lr
 c011914:	30000100 	.word	0x30000100
 c011918:	30030100 	.word	0x30030100
 c01191c:	50032c00 	.word	0x50032c00

0c011920 <Error_Handler>:
#define WHILE_1_OPCODE 0xe7fe
  typedef void (*nsfptr_t)(void) __attribute__((cmse_nonsecure_call));
  nsfptr_t nsfptr = (nsfptr_t)(SRAM1_BASE_NS + 1);
  __IO uint16_t *pt = (uint16_t *)SRAM1_BASE_NS;
  /*  copy while(1) instruction */
  *pt = WHILE_1_OPCODE;
 c011920:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 c011924:	f24e 72fe 	movw	r2, #59390	; 0xe7fe
{
 c011928:	b510      	push	{r4, lr}
  *pt = WHILE_1_OPCODE;
 c01192a:	801a      	strh	r2, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
 c01192c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c011930:	f3bf 8f6f 	isb	sy
  /* Flush and refill pipeline  */
  __DSB();
  __ISB();
  /*  call non secure while(1) */
  nsfptr();
 c011934:	4c14      	ldr	r4, [pc, #80]	; (c011988 <Error_Handler+0x68>)
 c011936:	0864      	lsrs	r4, r4, #1
 c011938:	0064      	lsls	r4, r4, #1
 c01193a:	4620      	mov	r0, r4
 c01193c:	4621      	mov	r1, r4
 c01193e:	4622      	mov	r2, r4
 c011940:	4623      	mov	r3, r4
 c011942:	ed9f 0a12 	vldr	s0, [pc, #72]	; c01198c <Error_Handler+0x6c>
 c011946:	eddf 0a11 	vldr	s1, [pc, #68]	; c01198c <Error_Handler+0x6c>
 c01194a:	ed9f 1a10 	vldr	s2, [pc, #64]	; c01198c <Error_Handler+0x6c>
 c01194e:	eddf 1a0f 	vldr	s3, [pc, #60]	; c01198c <Error_Handler+0x6c>
 c011952:	ed9f 2a0e 	vldr	s4, [pc, #56]	; c01198c <Error_Handler+0x6c>
 c011956:	eddf 2a0d 	vldr	s5, [pc, #52]	; c01198c <Error_Handler+0x6c>
 c01195a:	ed9f 3a0c 	vldr	s6, [pc, #48]	; c01198c <Error_Handler+0x6c>
 c01195e:	eddf 3a0b 	vldr	s7, [pc, #44]	; c01198c <Error_Handler+0x6c>
 c011962:	ed9f 4a0a 	vldr	s8, [pc, #40]	; c01198c <Error_Handler+0x6c>
 c011966:	eddf 4a09 	vldr	s9, [pc, #36]	; c01198c <Error_Handler+0x6c>
 c01196a:	ed9f 5a08 	vldr	s10, [pc, #32]	; c01198c <Error_Handler+0x6c>
 c01196e:	eddf 5a07 	vldr	s11, [pc, #28]	; c01198c <Error_Handler+0x6c>
 c011972:	ed9f 6a06 	vldr	s12, [pc, #24]	; c01198c <Error_Handler+0x6c>
 c011976:	eddf 6a05 	vldr	s13, [pc, #20]	; c01198c <Error_Handler+0x6c>
 c01197a:	ed9f 7a04 	vldr	s14, [pc, #16]	; c01198c <Error_Handler+0x6c>
 c01197e:	eddf 7a03 	vldr	s15, [pc, #12]	; c01198c <Error_Handler+0x6c>
 c011982:	f7fd fc9d 	bl	c00f2c0 <__gnu_cmse_nonsecure_call>
  /* an infinite loop,  and a reset for single fault injection */
  static __IO int once = 1;
  while (once);
  NVIC_SystemReset();
#endif  /*  TFM_ERROR_HANDLER_NON_SECURE */
}
 c011986:	bd10      	pop	{r4, pc}
 c011988:	20000001 	.word	0x20000001
 c01198c:	00000000 	.word	0x00000000

0c011990 <jumper>:
{
 c011990:	b538      	push	{r3, r4, r5, lr}
    if (ImageValidStatus[image_index] != IMAGE_VALID)
 c011992:	4c21      	ldr	r4, [pc, #132]	; (c011a18 <jumper+0x88>)
{
 c011994:	4605      	mov	r5, r0
    if (ImageValidStatus[image_index] != IMAGE_VALID)
 c011996:	7822      	ldrb	r2, [r4, #0]
 c011998:	2a55      	cmp	r2, #85	; 0x55
 c01199a:	d004      	beq.n	c0119a6 <jumper+0x16>
      BOOT_LOG_ERR("Error while double controlling images validation");
 c01199c:	481f      	ldr	r0, [pc, #124]	; (c011a1c <jumper+0x8c>)
 c01199e:	f7fc fc99 	bl	c00e2d4 <puts>
      Error_Handler();
 c0119a2:	f7ff ffbd 	bl	c011920 <Error_Handler>
    if (ImageValidStatus[image_index] != IMAGE_VALID)
 c0119a6:	7863      	ldrb	r3, [r4, #1]
 c0119a8:	2b55      	cmp	r3, #85	; 0x55
 c0119aa:	d004      	beq.n	c0119b6 <jumper+0x26>
      BOOT_LOG_ERR("Error while double controlling images validation");
 c0119ac:	481b      	ldr	r0, [pc, #108]	; (c011a1c <jumper+0x8c>)
 c0119ae:	f7fc fc91 	bl	c00e2d4 <puts>
      Error_Handler();
 c0119b2:	f7ff ffb5 	bl	c011920 <Error_Handler>
  TFM_BL2_CopySharedData();
 c0119b6:	f7f3 f89d 	bl	c004af4 <TFM_BL2_CopySharedData>
  if (Ospi_Flash_Config_Exe() != ARM_DRIVER_OK)
 c0119ba:	f7f2 f9f5 	bl	c003da8 <Ospi_Flash_Config_Exe>
 c0119be:	b120      	cbz	r0, c0119ca <jumper+0x3a>
    BOOT_LOG_ERR("Error while configuring ospi flash in execution");
 c0119c0:	4817      	ldr	r0, [pc, #92]	; (c011a20 <jumper+0x90>)
 c0119c2:	f7fc fc87 	bl	c00e2d4 <puts>
    Error_Handler();
 c0119c6:	f7ff ffab 	bl	c011920 <Error_Handler>
  if (otfdec_is_key_valid())
 c0119ca:	f7f1 fc89 	bl	c0032e0 <otfdec_is_key_valid>
 c0119ce:	b138      	cbz	r0, c0119e0 <jumper+0x50>
    if (otfdec_config() != ARM_DRIVER_OK)
 c0119d0:	f7f1 fcc6 	bl	c003360 <otfdec_config>
 c0119d4:	b120      	cbz	r0, c0119e0 <jumper+0x50>
      BOOT_LOG_ERR("Error while configuring otfdec (on the fly decryption)");
 c0119d6:	4813      	ldr	r0, [pc, #76]	; (c011a24 <jumper+0x94>)
 c0119d8:	f7fc fc7c 	bl	c00e2d4 <puts>
      Error_Handler();
 c0119dc:	f7ff ffa0 	bl	c011920 <Error_Handler>
  if (HAL_ICACHE_Invalidate() != HAL_OK)
 c0119e0:	f7f6 fb08 	bl	c007ff4 <HAL_ICACHE_Invalidate>
 c0119e4:	b108      	cbz	r0, c0119ea <jumper+0x5a>
    Error_Handler();
 c0119e6:	f7ff ff9b 	bl	c011920 <Error_Handler>
  TFM_LL_SECU_UpdateRunTimeProtections();
 c0119ea:	f000 f8a5 	bl	c011b38 <TFM_LL_SECU_UpdateRunTimeProtections>
  SCB->VTOR = (uint32_t)vector;
 c0119ee:	4b0e      	ldr	r3, [pc, #56]	; (c011a28 <jumper+0x98>)
  vt = (struct arm_vector_table *)vector;
 c0119f0:	4c0e      	ldr	r4, [pc, #56]	; (c011a2c <jumper+0x9c>)
  SCB->VTOR = (uint32_t)vector;
 c0119f2:	609d      	str	r5, [r3, #8]
  vt = (struct arm_vector_table *)vector;
 c0119f4:	6025      	str	r5, [r4, #0]
  TFM_LL_SECU_UpdateRunTimeProtections();
 c0119f6:	f000 f89f 	bl	c011b38 <TFM_LL_SECU_UpdateRunTimeProtections>
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c0119fa:	2300      	movs	r3, #0
 c0119fc:	f383 880a 	msr	MSPLIM, r3
  __set_MSP(vt->msp);
 c011a00:	6823      	ldr	r3, [r4, #0]
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 c011a02:	681b      	ldr	r3, [r3, #0]
 c011a04:	f383 8808 	msr	MSP, r3
  __ASM volatile ("dsb 0xF":::"memory");
 c011a08:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c011a0c:	f3bf 8f6f 	isb	sy
  boot_jump_to_next_image(vt->reset);
 c011a10:	6823      	ldr	r3, [r4, #0]
 c011a12:	6858      	ldr	r0, [r3, #4]
 c011a14:	f000 f8de 	bl	c011bd4 <boot_jump_to_next_image>
 c011a18:	30030004 	.word	0x30030004
 c011a1c:	0c00f9c8 	.word	0x0c00f9c8
 c011a20:	0c00fa00 	.word	0x0c00fa00
 c011a24:	0c00fa37 	.word	0x0c00fa37
 c011a28:	e000ed00 	.word	0xe000ed00
 c011a2c:	30030184 	.word	0x30030184

0c011a30 <enable_hdp_protection>:
{
#ifdef TFM_HDP_PROTECT_ENABLE
  do
  {
    /* Activate HDP protection */
    SET_BIT(FLASH->SECHDPCR, FLASH_SECHDPCR_HDP1_ACCDIS);
 c011a30:	4b08      	ldr	r3, [pc, #32]	; (c011a54 <enable_hdp_protection+0x24>)
 c011a32:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 c011a36:	f042 0201 	orr.w	r2, r2, #1
 c011a3a:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
  } while ((FLASH->SECHDPCR & FLASH_SECHDPCR_HDP1_ACCDIS) != FLASH_SECHDPCR_HDP1_ACCDIS);
 c011a3e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
 c011a42:	07d2      	lsls	r2, r2, #31
 c011a44:	d5f5      	bpl.n	c011a32 <enable_hdp_protection+0x2>

  if ((FLASH->SECHDPCR & FLASH_SECHDPCR_HDP1_ACCDIS) != FLASH_SECHDPCR_HDP1_ACCDIS)
 c011a46:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
 c011a4a:	07db      	lsls	r3, r3, #31
 c011a4c:	d401      	bmi.n	c011a52 <enable_hdp_protection+0x22>
  {
    /* Security issue : execution stopped ! */
    Error_Handler();
 c011a4e:	f7ff bf67 	b.w	c011920 <Error_Handler>
  }
#endif /* TFM_HDP_PROTECT_ENABLE */
}
 c011a52:	4770      	bx	lr
 c011a54:	50022000 	.word	0x50022000

0c011a58 <TFM_LL_SECU_UpdateLoaderRunTimeProtections>:
{
 c011a58:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  enable_hdp_protection();  
 c011a5a:	f7ff ffe9 	bl	c011a30 <enable_hdp_protection>
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011a5e:	4a30      	ldr	r2, [pc, #192]	; (c011b20 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0xc8>)
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSMPU;  
 c011a60:	4930      	ldr	r1, [pc, #192]	; (c011b24 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0xcc>)
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011a62:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c011a64:	f043 0301 	orr.w	r3, r3, #1
 c011a68:	6613      	str	r3, [r2, #96]	; 0x60
 c011a6a:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c011a6c:	f003 0301 	and.w	r3, r3, #1
 c011a70:	9302      	str	r3, [sp, #8]
 c011a72:	9b02      	ldr	r3, [sp, #8]
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSMPU;  
 c011a74:	690b      	ldr	r3, [r1, #16]
 c011a76:	f043 0302 	orr.w	r3, r3, #2
 c011a7a:	610b      	str	r3, [r1, #16]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011a7c:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c011a7e:	f043 0301 	orr.w	r3, r3, #1
 c011a82:	6613      	str	r3, [r2, #96]	; 0x60
 c011a84:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c011a86:	f003 0301 	and.w	r3, r3, #1
 c011a8a:	9303      	str	r3, [sp, #12]
 c011a8c:	9b03      	ldr	r3, [sp, #12]
  SYSCFG->CSLCKR |= SYSCFG_CNSLCKR_LOCKNSMPU;
 c011a8e:	690b      	ldr	r3, [r1, #16]
 c011a90:	f043 0302 	orr.w	r3, r3, #2
 c011a94:	610b      	str	r3, [r1, #16]
  \brief   Disable SAU
  \details Disables the Security Attribution Unit (SAU).
 */
__STATIC_INLINE void TZ_SAU_Disable(void)
{
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
 c011a96:	4b24      	ldr	r3, [pc, #144]	; (c011b28 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0xd0>)
 c011a98:	6818      	ldr	r0, [r3, #0]
 c011a9a:	f020 0001 	bic.w	r0, r0, #1
 c011a9e:	6018      	str	r0, [r3, #0]
  SAU->RNR  = 0;
 c011aa0:	2000      	movs	r0, #0
 c011aa2:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)LOADER_NS_DATA_START) & SAU_RBAR_BADDR_Msk;
 c011aa4:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 c011aa8:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)LOADER_NS_DATA_LIMIT) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c011aaa:	f500 303f 	add.w	r0, r0, #195584	; 0x2fc00
 c011aae:	f200 30e1 	addw	r0, r0, #993	; 0x3e1
 c011ab2:	6118      	str	r0, [r3, #16]
  SAU->RNR  = 1;
 c011ab4:	2001      	movs	r0, #1
 c011ab6:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)PERIPH_BASE_NS & SAU_RBAR_BADDR_Msk);
 c011ab8:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 c011abc:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)PERIPH_BASE_NS + 0xFFFFFFF) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c011abe:	481b      	ldr	r0, [pc, #108]	; (c011b2c <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0xd4>)
 c011ac0:	6118      	str	r0, [r3, #16]
  SAU->RNR  = 3;
 c011ac2:	2003      	movs	r0, #3
 c011ac4:	6098      	str	r0, [r3, #8]
  SAU->RBAR = ((uint32_t)LOADER_NS_CODE_START) & SAU_RBAR_BADDR_Msk;
 c011ac6:	481a      	ldr	r0, [pc, #104]	; (c011b30 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0xd8>)
 c011ac8:	60d8      	str	r0, [r3, #12]
  SAU->RLAR = (((uint32_t)LOADER_NS_CODE_LIMIT) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c011aca:	f500 40bf 	add.w	r0, r0, #24448	; 0x5f80
 c011ace:	3061      	adds	r0, #97	; 0x61
 c011ad0:	6118      	str	r0, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c011ad2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c011ad6:	f3bf 8f6f 	isb	sy
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
 c011ada:	6818      	ldr	r0, [r3, #0]
 c011adc:	f040 0001 	orr.w	r0, r0, #1
 c011ae0:	6018      	str	r0, [r3, #0]
    SCB->NSACR = (SCB->NSACR & ~(SCB_NSACR_CP10_Msk | SCB_NSACR_CP11_Msk)) |
 c011ae2:	4814      	ldr	r0, [pc, #80]	; (c011b34 <TFM_LL_SECU_UpdateLoaderRunTimeProtections+0xdc>)
 c011ae4:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
 c011ae8:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
 c011aec:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c011af0:	f8d0 3234 	ldr.w	r3, [r0, #564]	; 0x234
                   ((FPU_FPCCR_TS_VAL        << FPU_FPCCR_TS_Pos       ) & FPU_FPCCR_TS_Msk       ) |
 c011af4:	f023 53e0 	bic.w	r3, r3, #469762048	; 0x1c000000
                   ((FPU_FPCCR_CLRONRETS_VAL << FPU_FPCCR_CLRONRETS_Pos) & FPU_FPCCR_CLRONRETS_Msk) |
 c011af8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    FPU->FPCCR = (FPU->FPCCR & ~(FPU_FPCCR_TS_Msk | FPU_FPCCR_CLRONRETS_Msk | FPU_FPCCR_CLRONRET_Msk)) |
 c011afc:	f8c0 3234 	str.w	r3, [r0, #564]	; 0x234
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011b00:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c011b02:	f043 0301 	orr.w	r3, r3, #1
 c011b06:	6613      	str	r3, [r2, #96]	; 0x60
 c011b08:	6e13      	ldr	r3, [r2, #96]	; 0x60
 c011b0a:	f003 0301 	and.w	r3, r3, #1
 c011b0e:	9301      	str	r3, [sp, #4]
 c011b10:	9b01      	ldr	r3, [sp, #4]
  SYSCFG->CSLCKR |= SYSCFG_CSLCKR_LOCKSAU;
 c011b12:	690b      	ldr	r3, [r1, #16]
 c011b14:	f043 0304 	orr.w	r3, r3, #4
 c011b18:	610b      	str	r3, [r1, #16]
}
 c011b1a:	b005      	add	sp, #20
 c011b1c:	f85d fb04 	ldr.w	pc, [sp], #4
 c011b20:	50021000 	.word	0x50021000
 c011b24:	50010000 	.word	0x50010000
 c011b28:	e000edd0 	.word	0xe000edd0
 c011b2c:	4fffffe1 	.word	0x4fffffe1
 c011b30:	0807a000 	.word	0x0807a000
 c011b34:	e000ed00 	.word	0xe000ed00

0c011b38 <TFM_LL_SECU_UpdateRunTimeProtections>:
  uint32_t start_offset = ((offset - SRAM2_BASE_S)/ SRAM2_PAGE_SIZE);
  uint32_t end_offset = start_offset + (len -1)/SRAM2_PAGE_SIZE;
  uint32_t index;
  uint32_t val[2]={0, 0};

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011b38:	4b20      	ldr	r3, [pc, #128]	; (c011bbc <TFM_LL_SECU_UpdateRunTimeProtections+0x84>)
{
 c011b3a:	b510      	push	{r4, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011b3c:	6e1a      	ldr	r2, [r3, #96]	; 0x60

#if 0
  BOOT_LOG_INF("SRAM2 write protection [0x%x] : %x", (uint32_t)&SYSCFG_S->SWPR,  val[0]);
  BOOT_LOG_INF("SRAM2 write protection [0x%x] : %x", (uint32_t)&SYSCFG_S->SWPR2, val[1]);
#endif
  SYSCFG_S->SWPR  = val[0];
 c011b3e:	2400      	movs	r4, #0
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011b40:	f042 0201 	orr.w	r2, r2, #1
 c011b44:	661a      	str	r2, [r3, #96]	; 0x60
  SYSCFG_S->SWPR2 = val[1];
 c011b46:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011b4a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
{
 c011b4c:	b086      	sub	sp, #24
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 c011b4e:	f003 0301 	and.w	r3, r3, #1
 c011b52:	9300      	str	r3, [sp, #0]
 c011b54:	9b00      	ldr	r3, [sp, #0]
  SYSCFG_S->SWPR  = val[0];
 c011b56:	4b1a      	ldr	r3, [pc, #104]	; (c011bc0 <TFM_LL_SECU_UpdateRunTimeProtections+0x88>)
 c011b58:	621c      	str	r4, [r3, #32]
  SYSCFG_S->SWPR2 = val[1];
 c011b5a:	625a      	str	r2, [r3, #36]	; 0x24
  enable_hdp_protection();
 c011b5c:	f7ff ff68 	bl	c011a30 <enable_hdp_protection>
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c011b60:	4b18      	ldr	r3, [pc, #96]	; (c011bc4 <TFM_LL_SECU_UpdateRunTimeProtections+0x8c>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c011b62:	a901      	add	r1, sp, #4
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c011b64:	9302      	str	r3, [sp, #8]
  region_cfg.region_limit = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE - 1;
 c011b66:	f503 330f 	add.w	r3, r3, #146432	; 0x23c00
 c011b6a:	f203 33ff 	addw	r3, r3, #1023	; 0x3ff
 c011b6e:	9303      	str	r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c011b70:	2302      	movs	r3, #2
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c011b72:	4815      	ldr	r0, [pc, #84]	; (c011bc8 <TFM_LL_SECU_UpdateRunTimeProtections+0x90>)
  region_cfg.region_nr = 0;
 c011b74:	9401      	str	r4, [sp, #4]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c011b76:	9304      	str	r3, [sp, #16]
  region_cfg.attr_access = MPU_ARMV8M_AP_RO_PRIV_ONLY;
 c011b78:	f88d 3015 	strb.w	r3, [sp, #21]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c011b7c:	f88d 4016 	strb.w	r4, [sp, #22]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c011b80:	f88d 4014 	strb.w	r4, [sp, #20]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c011b84:	f7ff fe56 	bl	c011834 <mpu_armv8m_region_enable>
 c011b88:	b108      	cbz	r0, c011b8e <TFM_LL_SECU_UpdateRunTimeProtections+0x56>
    Error_Handler();
 c011b8a:	f7ff fec9 	bl	c011920 <Error_Handler>
  region_cfg.region_limit = OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_1_OFFSET + FLASH_AREA_1_SIZE - 1;
 c011b8e:	f04f 4210 	mov.w	r2, #2415919104	; 0x90000000
 c011b92:	4b0e      	ldr	r3, [pc, #56]	; (c011bcc <TFM_LL_SECU_UpdateRunTimeProtections+0x94>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c011b94:	a901      	add	r1, sp, #4
  region_cfg.region_limit = OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_1_OFFSET + FLASH_AREA_1_SIZE - 1;
 c011b96:	e9cd 2302 	strd	r2, r3, [sp, #8]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c011b9a:	2302      	movs	r3, #2
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c011b9c:	480c      	ldr	r0, [pc, #48]	; (c011bd0 <TFM_LL_SECU_UpdateRunTimeProtections+0x98>)
  region_cfg.region_nr = 0;
 c011b9e:	9401      	str	r4, [sp, #4]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c011ba0:	9304      	str	r3, [sp, #16]
  region_cfg.attr_access = MPU_ARMV8M_AP_RO_PRIV_ONLY;
 c011ba2:	f88d 3015 	strb.w	r3, [sp, #21]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c011ba6:	f88d 4016 	strb.w	r4, [sp, #22]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
 c011baa:	f88d 4014 	strb.w	r4, [sp, #20]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c011bae:	f7ff fe41 	bl	c011834 <mpu_armv8m_region_enable>
 c011bb2:	b108      	cbz	r0, c011bb8 <TFM_LL_SECU_UpdateRunTimeProtections+0x80>
    Error_Handler();
 c011bb4:	f7ff feb4 	bl	c011920 <Error_Handler>
}
 c011bb8:	b006      	add	sp, #24
 c011bba:	bd10      	pop	{r4, pc}
 c011bbc:	50021000 	.word	0x50021000
 c011bc0:	50010000 	.word	0x50010000
 c011bc4:	0c017000 	.word	0x0c017000
 c011bc8:	300300a8 	.word	0x300300a8
 c011bcc:	900fffff 	.word	0x900fffff
 c011bd0:	300300a4 	.word	0x300300a4

0c011bd4 <boot_jump_to_next_image>:
 *  - There are secrets in the memory: KDF parameter, symmetric key,
 *    manufacturer sensitive code/data, etc.
 */
__attribute__((naked)) void boot_jump_to_next_image(uint32_t reset_handler_addr)
{
    __ASM volatile(
 c011bd4:	4607      	mov	r7, r0
 c011bd6:	f7ff fe7f 	bl	c0118d8 <boot_clear_bl2_ram_area>
 c011bda:	2000      	movs	r0, #0
 c011bdc:	4601      	mov	r1, r0
 c011bde:	4602      	mov	r2, r0
 c011be0:	4603      	mov	r3, r0
 c011be2:	4604      	mov	r4, r0
 c011be4:	4605      	mov	r5, r0
 c011be6:	4606      	mov	r6, r0
 c011be8:	4680      	mov	r8, r0
 c011bea:	4681      	mov	r9, r0
 c011bec:	4682      	mov	sl, r0
 c011bee:	4683      	mov	fp, r0
 c011bf0:	4684      	mov	ip, r0
 c011bf2:	4686      	mov	lr, r0
 c011bf4:	4738      	bx	r7

Disassembly of section .text:

0c002900 <__Vectors>:
 c002900:	3003f828 	.word	0x3003f828
 c002904:	0c002ba9 	.word	0x0c002ba9
 c002908:	0c003af5 	.word	0x0c003af5
 c00290c:	0c002bd5 	.word	0x0c002bd5
 c002910:	0c002bd9 	.word	0x0c002bd9
 c002914:	0c002bdd 	.word	0x0c002bdd
 c002918:	0c002be1 	.word	0x0c002be1
 c00291c:	0c002be5 	.word	0x0c002be5
	...
 c00292c:	0c002be9 	.word	0x0c002be9
 c002930:	0c002bed 	.word	0x0c002bed
 c002934:	00000000 	.word	0x00000000
 c002938:	0c002bf1 	.word	0x0c002bf1
 c00293c:	0c002bf5 	.word	0x0c002bf5
 c002940:	0c002bf9 	.word	0x0c002bf9
 c002944:	0c002bfd 	.word	0x0c002bfd
 c002948:	0c002c01 	.word	0x0c002c01
 c00294c:	0c002c05 	.word	0x0c002c05
 c002950:	0c002c09 	.word	0x0c002c09
 c002954:	0c002c0d 	.word	0x0c002c0d
 c002958:	0c002c11 	.word	0x0c002c11
 c00295c:	0c002c15 	.word	0x0c002c15
 c002960:	0c002c19 	.word	0x0c002c19
 c002964:	0c002c1d 	.word	0x0c002c1d
 c002968:	0c002c21 	.word	0x0c002c21
 c00296c:	0c002c25 	.word	0x0c002c25
 c002970:	0c002c29 	.word	0x0c002c29
 c002974:	0c002c2d 	.word	0x0c002c2d
 c002978:	0c002c31 	.word	0x0c002c31
 c00297c:	0c002c35 	.word	0x0c002c35
 c002980:	0c002c39 	.word	0x0c002c39
 c002984:	0c002c3d 	.word	0x0c002c3d
 c002988:	0c002c41 	.word	0x0c002c41
 c00298c:	0c002c45 	.word	0x0c002c45
 c002990:	0c002c49 	.word	0x0c002c49
 c002994:	0c002c4d 	.word	0x0c002c4d
 c002998:	0c002c51 	.word	0x0c002c51
 c00299c:	0c002c55 	.word	0x0c002c55
 c0029a0:	0c002c59 	.word	0x0c002c59
 c0029a4:	0c002c5d 	.word	0x0c002c5d
 c0029a8:	0c002c61 	.word	0x0c002c61
 c0029ac:	0c002c65 	.word	0x0c002c65
 c0029b0:	0c002c69 	.word	0x0c002c69
 c0029b4:	0c002c6d 	.word	0x0c002c6d
 c0029b8:	0c002c71 	.word	0x0c002c71
 c0029bc:	0c002c75 	.word	0x0c002c75
 c0029c0:	0c002c79 	.word	0x0c002c79
 c0029c4:	0c002c7d 	.word	0x0c002c7d
 c0029c8:	0c002c81 	.word	0x0c002c81
 c0029cc:	0c002c85 	.word	0x0c002c85
 c0029d0:	0c002c89 	.word	0x0c002c89
 c0029d4:	0c002c8d 	.word	0x0c002c8d
 c0029d8:	0c002c91 	.word	0x0c002c91
 c0029dc:	0c002c95 	.word	0x0c002c95
 c0029e0:	2c99      	cmp	r4, #153	; 0x99
 c0029e2:	0c00      	lsrs	r0, r0, #16
 c0029e4:	2c9d      	cmp	r4, #157	; 0x9d
 c0029e6:	0c00      	lsrs	r0, r0, #16
 c0029e8:	2ca1      	cmp	r4, #161	; 0xa1
 c0029ea:	0c00      	.short	0x0c00
 c0029ec:	2ca5      	cmp	r4, #165	; 0xa5
 c0029ee:	0c00      	.short	0x0c00
 c0029f0:	2ca9      	cmp	r4, #169	; 0xa9
 c0029f2:	0c00      	.short	0x0c00
 c0029f4:	2cad      	cmp	r4, #173	; 0xad
 c0029f6:	0c00      	.short	0x0c00
 c0029f8:	2cb1      	cmp	r4, #177	; 0xb1
 c0029fa:	0c00      	.short	0x0c00
 c0029fc:	2cb5      	cmp	r4, #181	; 0xb5
 c0029fe:	0c00      	.short	0x0c00
 c002a00:	2cb9      	cmp	r4, #185	; 0xb9
 c002a02:	0c00      	lsrs	r0, r0, #16
 c002a04:	2cbd      	cmp	r4, #189	; 0xbd
 c002a06:	0c00      	lsrs	r0, r0, #16
 c002a08:	2cc1      	cmp	r4, #193	; 0xc1
 c002a0a:	0c00      	lsrs	r0, r0, #16
 c002a0c:	0c002cc5 	.word	0x0c002cc5
 c002a10:	2cc9      	cmp	r4, #201	; 0xc9
 c002a12:	0c00      	lsrs	r0, r0, #16
 c002a14:	2ccd      	cmp	r4, #205	; 0xcd
 c002a16:	0c00      	.short	0x0c00
 c002a18:	2cd1      	cmp	r4, #209	; 0xd1
 c002a1a:	0c00      	.short	0x0c00
 c002a1c:	2cd5      	cmp	r4, #213	; 0xd5
 c002a1e:	0c00      	.short	0x0c00
 c002a20:	2cd9      	cmp	r4, #217	; 0xd9
 c002a22:	0c00      	.short	0x0c00
 c002a24:	2cdd      	cmp	r4, #221	; 0xdd
 c002a26:	0c00      	.short	0x0c00
 c002a28:	2ce1      	cmp	r4, #225	; 0xe1
 c002a2a:	0c00      	lsrs	r0, r0, #16
 c002a2c:	2ce5      	cmp	r4, #229	; 0xe5
 c002a2e:	0c00      	lsrs	r0, r0, #16
 c002a30:	2ce9      	cmp	r4, #233	; 0xe9
 c002a32:	0c00      	.short	0x0c00
 c002a34:	2ced      	cmp	r4, #237	; 0xed
 c002a36:	0c00      	lsrs	r0, r0, #16
 c002a38:	0c002cf1 	.word	0x0c002cf1
 c002a3c:	2cf5      	cmp	r4, #245	; 0xf5
 c002a3e:	0c00      	lsrs	r0, r0, #16
 c002a40:	2cf9      	cmp	r4, #249	; 0xf9
 c002a42:	0c00      	.short	0x0c00
 c002a44:	2cfd      	cmp	r4, #253	; 0xfd
 c002a46:	0c00      	lsrs	r0, r0, #16
 c002a48:	2d01      	cmp	r5, #1
 c002a4a:	0c00      	lsrs	r0, r0, #16
 c002a4c:	0c002d05 	.word	0x0c002d05
 c002a50:	2d09      	cmp	r5, #9
 c002a52:	0c00      	lsrs	r0, r0, #16
 c002a54:	2d0d      	cmp	r5, #13
 c002a56:	0c00      	.short	0x0c00
 c002a58:	2d11      	cmp	r5, #17
 c002a5a:	0c00      	.short	0x0c00
 c002a5c:	2d15      	cmp	r5, #21
 c002a5e:	0c00      	lsrs	r0, r0, #16
 c002a60:	0c002d19 	.word	0x0c002d19
 c002a64:	2d1d      	cmp	r5, #29
 c002a66:	0c00      	.short	0x0c00
 c002a68:	2d21      	cmp	r5, #33	; 0x21
 c002a6a:	0c00      	.short	0x0c00
 c002a6c:	2d25      	cmp	r5, #37	; 0x25
 c002a6e:	0c00      	.short	0x0c00
 c002a70:	2d29      	cmp	r5, #41	; 0x29
 c002a72:	0c00      	.short	0x0c00
 c002a74:	0000      	movs	r0, r0
 c002a76:	0000      	.short	0x0000
 c002a78:	2d2d      	cmp	r5, #45	; 0x2d
 c002a7a:	0c00      	lsrs	r0, r0, #16
 c002a7c:	00000000 	.word	0x00000000
 c002a80:	2d31      	cmp	r5, #49	; 0x31
 c002a82:	0c00      	.short	0x0c00
 c002a84:	2d35      	cmp	r5, #53	; 0x35
 c002a86:	0c00      	.short	0x0c00
 c002a88:	2d39      	cmp	r5, #57	; 0x39
 c002a8a:	0c00      	.short	0x0c00
 c002a8c:	2d3d      	cmp	r5, #61	; 0x3d
 c002a8e:	0c00      	.short	0x0c00
 c002a90:	2d41      	cmp	r5, #65	; 0x41
 c002a92:	0c00      	.short	0x0c00
 c002a94:	2d45      	cmp	r5, #69	; 0x45
 c002a96:	0c00      	.short	0x0c00
 c002a98:	2d49      	cmp	r5, #73	; 0x49
 c002a9a:	0c00      	lsrs	r0, r0, #16
 c002a9c:	2d4d      	cmp	r5, #77	; 0x4d
 c002a9e:	0c00      	lsrs	r0, r0, #16
 c002aa0:	2d51      	cmp	r5, #81	; 0x51
 c002aa2:	0c00      	.short	0x0c00
 c002aa4:	2d55      	cmp	r5, #85	; 0x55
 c002aa6:	0c00      	.short	0x0c00
 c002aa8:	2d59      	cmp	r5, #89	; 0x59
 c002aaa:	0c00      	.short	0x0c00
 c002aac:	2d5d      	cmp	r5, #93	; 0x5d
 c002aae:	0c00      	.short	0x0c00
 c002ab0:	2d61      	cmp	r5, #97	; 0x61
 c002ab2:	0c00      	.short	0x0c00
 c002ab4:	0000      	movs	r0, r0
 c002ab6:	0000      	movs	r0, r0
 c002ab8:	2d65      	cmp	r5, #101	; 0x65
 c002aba:	0c00      	lsrs	r0, r0, #16
 c002abc:	0c002d69 	.word	0x0c002d69
	...
 c002ac8:	2d6d      	cmp	r5, #109	; 0x6d
 c002aca:	0c00      	.short	0x0c00
 c002acc:	2d71      	cmp	r5, #113	; 0x71
 c002ace:	0c00      	.short	0x0c00
 c002ad0:	2d75      	cmp	r5, #117	; 0x75
 c002ad2:	0c00      	.short	0x0c00
 c002ad4:	2d79      	cmp	r5, #121	; 0x79
 c002ad6:	0c00      	lsrs	r0, r0, #16
 c002ad8:	0c002d7d 	.word	0x0c002d7d
 c002adc:	2d81      	cmp	r5, #129	; 0x81
 c002ade:	0c00      	.short	0x0c00
 c002ae0:	2d85      	cmp	r5, #133	; 0x85
 c002ae2:	0c00      	.short	0x0c00
 c002ae4:	2d89      	cmp	r5, #137	; 0x89
 c002ae6:	0c00      	.short	0x0c00
 c002ae8:	2d8d      	cmp	r5, #141	; 0x8d
 c002aea:	0c00      	.short	0x0c00
 c002aec:	2d91      	cmp	r5, #145	; 0x91
 c002aee:	0c00      	lsrs	r0, r0, #16
 c002af0:	0c002d95 	.word	0x0c002d95

0c002af4 <__do_global_dtors_aux>:
 c002af4:	b510      	push	{r4, lr}
 c002af6:	4c05      	.short	0x4c05
 c002af8:	7823      	ldrb	r3, [r4, #0]
 c002afa:	b933      	.short	0xb933
 c002afc:	4b04      	ldr	r3, [pc, #16]	; (c002b10 <__do_global_dtors_aux+0x1c>)
 c002afe:	b113      	.short	0xb113
 c002b00:	4804      	ldr	r0, [pc, #16]	; (c002b14 <__do_global_dtors_aux+0x20>)
 c002b02:	e000      	b.n	c002b06 <__do_global_dtors_aux+0x12>
 c002b04:	bf00      	nop
 c002b06:	2301      	.short	0x2301
 c002b08:	7023      	strb	r3, [r4, #0]
 c002b0a:	bd10      	pop	{r4, pc}
 c002b0c:	30030154 	.word	0x30030154
 c002b10:	0000      	movs	r0, r0
 c002b12:	0000      	.short	0x0000
 c002b14:	08ec      	lsrs	r4, r5, #3
 c002b16:	0c01      	.short	0x0c01

0c002b18 <frame_dummy>:
 c002b18:	4b03b508 	.word	0x4b03b508
 c002b1c:	4903b11b 	.word	0x4903b11b
 c002b20:	4803      	ldr	r0, [pc, #12]	; (c002b30 <frame_dummy+0x18>)
 c002b22:	e000      	.short	0xe000
 c002b24:	bf00      	nop
 c002b26:	bd08      	pop	{r3, pc}
 c002b28:	0000      	movs	r0, r0
 c002b2a:	0000      	.short	0x0000
 c002b2c:	0158      	lsls	r0, r3, #5
 c002b2e:	3003      	adds	r0, #3
 c002b30:	08ec      	lsrs	r4, r5, #3
 c002b32:	0c01      	lsrs	r1, r0, #16

0c002b34 <_mainCRTStartup>:
 c002b34:	4b15      	ldr	r3, [pc, #84]	; (c002b8c <_mainCRTStartup+0x58>)
 c002b36:	2b00      	.short	0x2b00
 c002b38:	bf08      	it	eq
 c002b3a:	4b13      	ldreq	r3, [pc, #76]	; (c002b88 <_mainCRTStartup+0x54>)
 c002b3c:	f5a3469d 	.word	0xf5a3469d
 c002b40:	3a80      	subs	r2, #128	; 0x80
 c002b42:	2100      	movs	r1, #0
 c002b44:	468b      	mov	fp, r1
 c002b46:	460f      	mov	r7, r1
 c002b48:	4813      	ldr	r0, [pc, #76]	; (c002b98 <_mainCRTStartup+0x64>)
 c002b4a:	4a14      	.short	0x4a14
 c002b4c:	1a12      	subs	r2, r2, r0
 c002b4e:	f00b fa9c 	bl	c00e08a <memset>
 c002b52:	4b0f      	.short	0x4b0f
 c002b54:	2b00      	cmp	r3, #0
 c002b56:	d000      	beq.n	c002b5a <_mainCRTStartup+0x26>
 c002b58:	4b0e4798 	.word	0x4b0e4798
 c002b5c:	2b00      	cmp	r3, #0
 c002b5e:	d000      	beq.n	c002b62 <_mainCRTStartup+0x2e>
 c002b60:	4798      	blx	r3
 c002b62:	2000      	movs	r0, #0
 c002b64:	2100      	movs	r1, #0
 c002b66:	0004      	movs	r4, r0
 c002b68:	480d000d 	.word	0x480d000d
 c002b6c:	2800      	cmp	r0, #0
 c002b6e:	d002      	.short	0xd002
 c002b70:	480c      	ldr	r0, [pc, #48]	; (c002ba4 <_mainCRTStartup+0x70>)
 c002b72:	e000      	.short	0xe000
 c002b74:	bf00      	nop
 c002b76:	f00b      	.short	0xf00b
 c002b78:	fa31 0020 			; <UNDEFINED> instruction: 0xfa310020
 c002b7c:	f00a0029 	.word	0xf00a0029
 c002b80:	ff23 f00b 	vhadd.u32	d15, d3, d11
 c002b84:	bf00fa17 	.word	0xbf00fa17
 c002b88:	0000      	movs	r0, r0
 c002b8a:	0008      	movs	r0, r1
 c002b8c:	f828 3003 	strh.w	r3, [r8, r3]
	...
 c002b98:	0154      	lsls	r4, r2, #5
 c002b9a:	3003      	.short	0x3003
 c002b9c:	e424      	b.n	c0023e8 <enc_priv_key+0x334>
 c002b9e:	3003      	.short	0x3003
	...

0c002ba8 <Reset_Handler>:
 c002ba8:	4906      	ldr	r1, [pc, #24]	; (c002bc4 <Reset_Handler+0x1c>)
 c002baa:	4a07      	.short	0x4a07
 c002bac:	4b07      	ldr	r3, [pc, #28]	; (c002bcc <Reset_Handler+0x24>)
 c002bae:	1a9b      	.short	0x1a9b
 c002bb0:	dd03      	ble.n	c002bba <Reset_Handler+0x12>
 c002bb2:	3b04      	.short	0x3b04
 c002bb4:	58c8      	ldr	r0, [r1, r3]
 c002bb6:	50d0      	str	r0, [r2, r3]
 c002bb8:	dcfb      	bgt.n	c002bb2 <Reset_Handler+0xa>
 c002bba:	f001 fef5 	bl	c0049a8 <SystemInit>
 c002bbe:	f7ff ffb9 	bl	c002b34 <_mainCRTStartup>
 c002bc2:	0000      	movs	r0, r0
 c002bc4:	0920      	lsrs	r0, r4, #4
 c002bc6:	0c01      	lsrs	r1, r0, #16
 c002bc8:	0000      	movs	r0, r0
 c002bca:	3003      	adds	r0, #3
 c002bcc:	0154      	lsls	r4, r2, #5
 c002bce:	3003      	adds	r0, #3
 c002bd0:	bf90f000 	.word	0xbf90f000

0c002bd4 <HardFault_Handler>:
 c002bd4:	f7ff bffe 	b.w	c002bd4 <HardFault_Handler>

0c002bd8 <MemManage_Handler>:
 c002bd8:	bffef7ff 	.word	0xbffef7ff

0c002bdc <BusFault_Handler>:
 c002bdc:	f7ff bffe 	b.w	c002bdc <BusFault_Handler>

0c002be0 <UsageFault_Handler>:
 c002be0:	bffef7ff 	.word	0xbffef7ff

0c002be4 <SecureFault_Handler>:
 c002be4:	f7ff bffe 	b.w	c002be4 <SecureFault_Handler>

0c002be8 <SVC_Handler>:
 c002be8:	bffef7ff 	.word	0xbffef7ff

0c002bec <DebugMon_Handler>:
 c002bec:	f7ff bffe 	b.w	c002bec <DebugMon_Handler>

0c002bf0 <PendSV_Handler>:
 c002bf0:	bffef7ff 	.word	0xbffef7ff

0c002bf4 <SysTick_Handler>:
 c002bf4:	f7ff bffe 	b.w	c002bf4 <SysTick_Handler>

0c002bf8 <WWDG_IRQHandler>:
 c002bf8:	f7ff bffe 	b.w	c002bf8 <WWDG_IRQHandler>

0c002bfc <PVD_PVM_IRQHandler>:
 c002bfc:	f7ff bffe 	b.w	c002bfc <PVD_PVM_IRQHandler>

0c002c00 <RTC_IRQHandler>:
 c002c00:	bffef7ff 	.word	0xbffef7ff

0c002c04 <RTC_IRQHandler_S>:
 c002c04:	f7ff bffe 	b.w	c002c04 <RTC_IRQHandler_S>

0c002c08 <TAMP_IRQHandler>:
 c002c08:	f7ff bffe 	b.w	c002c08 <TAMP_IRQHandler>

0c002c0c <TAMP_IRQHandler_S>:
 c002c0c:	f7ff bffe 	b.w	c002c0c <TAMP_IRQHandler_S>

0c002c10 <FLASH_IRQHandler>:
 c002c10:	f7ff bffe 	b.w	c002c10 <FLASH_IRQHandler>

0c002c14 <FLASH_IRQHandler_S>:
 c002c14:	f7ff bffe 	b.w	c002c14 <FLASH_IRQHandler_S>

0c002c18 <SERR_IRQHandler>:
 c002c18:	f7ff bffe 	b.w	c002c18 <SERR_IRQHandler>

0c002c1c <RCC_IRQHandler>:
 c002c1c:	f7ff bffe 	b.w	c002c1c <RCC_IRQHandler>

0c002c20 <RCC_IRQHandler_S>:
 c002c20:	f7ff bffe 	b.w	c002c20 <RCC_IRQHandler_S>

0c002c24 <EXTI0_IRQHandler>:
 c002c24:	f7ff bffe 	b.w	c002c24 <EXTI0_IRQHandler>

0c002c28 <EXTI1_IRQHandler>:
 c002c28:	f7ff bffe 	b.w	c002c28 <EXTI1_IRQHandler>

0c002c2c <EXTI2_IRQHandler>:
 c002c2c:	f7ff bffe 	b.w	c002c2c <EXTI2_IRQHandler>

0c002c30 <EXTI3_IRQHandler>:
 c002c30:	f7ff bffe 	b.w	c002c30 <EXTI3_IRQHandler>

0c002c34 <EXTI4_IRQHandler>:
 c002c34:	f7ff bffe 	b.w	c002c34 <EXTI4_IRQHandler>

0c002c38 <EXTI5_IRQHandler>:
 c002c38:	f7ff bffe 	b.w	c002c38 <EXTI5_IRQHandler>

0c002c3c <EXTI6_IRQHandler>:
 c002c3c:	f7ff bffe 	b.w	c002c3c <EXTI6_IRQHandler>

0c002c40 <EXTI7_IRQHandler>:
 c002c40:	f7ff bffe 	b.w	c002c40 <EXTI7_IRQHandler>

0c002c44 <EXTI8_IRQHandler>:
 c002c44:	f7ff bffe 	b.w	c002c44 <EXTI8_IRQHandler>

0c002c48 <EXTI9_IRQHandler>:
 c002c48:	f7ff bffe 	b.w	c002c48 <EXTI9_IRQHandler>

0c002c4c <EXTI10_IRQHandler>:
 c002c4c:	f7ff bffe 	b.w	c002c4c <EXTI10_IRQHandler>

0c002c50 <EXTI11_IRQHandler>:
 c002c50:	f7ff bffe 	b.w	c002c50 <EXTI11_IRQHandler>

0c002c54 <EXTI12_IRQHandler>:
 c002c54:	f7ff bffe 	b.w	c002c54 <EXTI12_IRQHandler>

0c002c58 <EXTI13_IRQHandler>:
 c002c58:	f7ff bffe 	b.w	c002c58 <EXTI13_IRQHandler>

0c002c5c <EXTI14_IRQHandler>:
 c002c5c:	f7ff bffe 	b.w	c002c5c <EXTI14_IRQHandler>

0c002c60 <EXTI15_IRQHandler>:
 c002c60:	f7ff bffe 	b.w	c002c60 <EXTI15_IRQHandler>

0c002c64 <DMAMUX1_IRQHandler>:
 c002c64:	f7ff bffe 	b.w	c002c64 <DMAMUX1_IRQHandler>

0c002c68 <DMAMUX1_IRQHandler_S>:
 c002c68:	f7ff bffe 	b.w	c002c68 <DMAMUX1_IRQHandler_S>

0c002c6c <DMA1_Channel1_IRQHandler>:
 c002c6c:	f7ff bffe 	b.w	c002c6c <DMA1_Channel1_IRQHandler>

0c002c70 <DMA1_Channel2_IRQHandler>:
 c002c70:	f7ff bffe 	b.w	c002c70 <DMA1_Channel2_IRQHandler>

0c002c74 <DMA1_Channel3_IRQHandler>:
 c002c74:	f7ff bffe 	b.w	c002c74 <DMA1_Channel3_IRQHandler>

0c002c78 <DMA1_Channel4_IRQHandler>:
 c002c78:	f7ff bffe 	b.w	c002c78 <DMA1_Channel4_IRQHandler>

0c002c7c <DMA1_Channel5_IRQHandler>:
 c002c7c:	f7ff bffe 	b.w	c002c7c <DMA1_Channel5_IRQHandler>

0c002c80 <DMA1_Channel6_IRQHandler>:
 c002c80:	f7ff bffe 	b.w	c002c80 <DMA1_Channel6_IRQHandler>

0c002c84 <DMA1_Channel7_IRQHandler>:
 c002c84:	f7ff bffe 	b.w	c002c84 <DMA1_Channel7_IRQHandler>

0c002c88 <DMA1_Channel8_IRQHandler>:
 c002c88:	f7ff bffe 	b.w	c002c88 <DMA1_Channel8_IRQHandler>

0c002c8c <ADC1_2_IRQHandler>:
 c002c8c:	f7ff bffe 	b.w	c002c8c <ADC1_2_IRQHandler>

0c002c90 <DAC_IRQHandler>:
 c002c90:	bffef7ff 	.word	0xbffef7ff

0c002c94 <FDCAN1_IT0_IRQHandler>:
 c002c94:	f7ff bffe 	b.w	c002c94 <FDCAN1_IT0_IRQHandler>

0c002c98 <FDCAN1_IT1_IRQHandler>:
 c002c98:	bffef7ff 	.word	0xbffef7ff

0c002c9c <TIM1_BRK_IRQHandler>:
 c002c9c:	f7ff bffe 	b.w	c002c9c <TIM1_BRK_IRQHandler>

0c002ca0 <TIM1_UP_IRQHandler>:
 c002ca0:	bffef7ff 	.word	0xbffef7ff

0c002ca4 <TIM1_TRG_COM_IRQHandler>:
 c002ca4:	f7ff bffe 	b.w	c002ca4 <TIM1_TRG_COM_IRQHandler>

0c002ca8 <TIM1_CC_IRQHandler>:
 c002ca8:	f7ff bffe 	b.w	c002ca8 <TIM1_CC_IRQHandler>

0c002cac <TIM2_IRQHandler>:
 c002cac:	f7ff bffe 	b.w	c002cac <TIM2_IRQHandler>

0c002cb0 <TIM3_IRQHandler>:
 c002cb0:	f7ff bffe 	b.w	c002cb0 <TIM3_IRQHandler>

0c002cb4 <TIM4_IRQHandler>:
 c002cb4:	f7ff bffe 	b.w	c002cb4 <TIM4_IRQHandler>

0c002cb8 <TIM5_IRQHandler>:
 c002cb8:	f7ff bffe 	b.w	c002cb8 <TIM5_IRQHandler>

0c002cbc <TIM6_IRQHandler>:
 c002cbc:	bffef7ff 	.word	0xbffef7ff

0c002cc0 <TIM7_IRQHandler>:
 c002cc0:	f7ff bffe 	b.w	c002cc0 <TIM7_IRQHandler>

0c002cc4 <TIM8_BRK_IRQHandler>:
 c002cc4:	bffef7ff 	.word	0xbffef7ff

0c002cc8 <TIM8_UP_IRQHandler>:
 c002cc8:	f7ff bffe 	b.w	c002cc8 <TIM8_UP_IRQHandler>

0c002ccc <TIM8_TRG_COM_IRQHandler>:
 c002ccc:	bffef7ff 	.word	0xbffef7ff

0c002cd0 <TIM8_CC_IRQHandler>:
 c002cd0:	f7ff bffe 	b.w	c002cd0 <TIM8_CC_IRQHandler>

0c002cd4 <I2C1_EV_IRQHandler>:
 c002cd4:	bffef7ff 	.word	0xbffef7ff

0c002cd8 <I2C1_ER_IRQHandler>:
 c002cd8:	f7ff bffe 	b.w	c002cd8 <I2C1_ER_IRQHandler>

0c002cdc <I2C2_EV_IRQHandler>:
 c002cdc:	bffef7ff 	.word	0xbffef7ff

0c002ce0 <I2C2_ER_IRQHandler>:
 c002ce0:	f7ff bffe 	b.w	c002ce0 <I2C2_ER_IRQHandler>

0c002ce4 <SPI1_IRQHandler>:
 c002ce4:	f7ff bffe 	b.w	c002ce4 <SPI1_IRQHandler>

0c002ce8 <SPI2_IRQHandler>:
 c002ce8:	f7ff bffe 	b.w	c002ce8 <SPI2_IRQHandler>

0c002cec <USART1_IRQHandler>:
 c002cec:	f7ff bffe 	b.w	c002cec <USART1_IRQHandler>

0c002cf0 <USART2_IRQHandler>:
 c002cf0:	f7ff bffe 	b.w	c002cf0 <USART2_IRQHandler>

0c002cf4 <USART3_IRQHandler>:
 c002cf4:	f7ff bffe 	b.w	c002cf4 <USART3_IRQHandler>

0c002cf8 <UART4_IRQHandler>:
 c002cf8:	f7ff bffe 	b.w	c002cf8 <UART4_IRQHandler>

0c002cfc <UART5_IRQHandler>:
 c002cfc:	f7ff bffe 	b.w	c002cfc <UART5_IRQHandler>

0c002d00 <LPUART1_IRQHandler>:
 c002d00:	bffef7ff 	.word	0xbffef7ff

0c002d04 <LPTIM1_IRQHandler>:
 c002d04:	f7ff bffe 	b.w	c002d04 <LPTIM1_IRQHandler>

0c002d08 <LPTIM2_IRQHandler>:
 c002d08:	bffef7ff 	.word	0xbffef7ff

0c002d0c <TIM15_IRQHandler>:
 c002d0c:	f7ff bffe 	b.w	c002d0c <TIM15_IRQHandler>

0c002d10 <TIM16_IRQHandler>:
 c002d10:	bffef7ff 	.word	0xbffef7ff

0c002d14 <TIM17_IRQHandler>:
 c002d14:	f7ff bffe 	b.w	c002d14 <TIM17_IRQHandler>

0c002d18 <COMP_IRQHandler>:
 c002d18:	bffef7ff 	.word	0xbffef7ff

0c002d1c <USB_FS_IRQHandler>:
 c002d1c:	f7ff bffe 	b.w	c002d1c <USB_FS_IRQHandler>

0c002d20 <CRS_IRQHandler>:
 c002d20:	f7ff bffe 	b.w	c002d20 <CRS_IRQHandler>

0c002d24 <FMC_IRQHandler>:
 c002d24:	f7ff bffe 	b.w	c002d24 <FMC_IRQHandler>

0c002d28 <OCTOSPI1_IRQHandler>:
 c002d28:	f7ff bffe 	b.w	c002d28 <OCTOSPI1_IRQHandler>

0c002d2c <SDMMC1_IRQHandler>:
 c002d2c:	f7ff bffe 	b.w	c002d2c <SDMMC1_IRQHandler>

0c002d30 <DMA2_Channel1_IRQHandler>:
 c002d30:	f7ff bffe 	b.w	c002d30 <DMA2_Channel1_IRQHandler>

0c002d34 <DMA2_Channel2_IRQHandler>:
 c002d34:	bffef7ff 	.word	0xbffef7ff

0c002d38 <DMA2_Channel3_IRQHandler>:
 c002d38:	f7ff bffe 	b.w	c002d38 <DMA2_Channel3_IRQHandler>

0c002d3c <DMA2_Channel4_IRQHandler>:
 c002d3c:	f7ff bffe 	b.w	c002d3c <DMA2_Channel4_IRQHandler>

0c002d40 <DMA2_Channel5_IRQHandler>:
 c002d40:	bffef7ff 	.word	0xbffef7ff

0c002d44 <DMA2_Channel6_IRQHandler>:
 c002d44:	f7ff bffe 	b.w	c002d44 <DMA2_Channel6_IRQHandler>

0c002d48 <DMA2_Channel7_IRQHandler>:
 c002d48:	bffef7ff 	.word	0xbffef7ff

0c002d4c <DMA2_Channel8_IRQHandler>:
 c002d4c:	f7ff bffe 	b.w	c002d4c <DMA2_Channel8_IRQHandler>

0c002d50 <I2C3_EV_IRQHandler>:
 c002d50:	bffef7ff 	.word	0xbffef7ff

0c002d54 <I2C3_ER_IRQHandler>:
 c002d54:	f7ff bffe 	b.w	c002d54 <I2C3_ER_IRQHandler>

0c002d58 <SAI1_IRQHandler>:
 c002d58:	bffef7ff 	.word	0xbffef7ff

0c002d5c <SAI2_IRQHandler>:
 c002d5c:	f7ff bffe 	b.w	c002d5c <SAI2_IRQHandler>

0c002d60 <TSC_IRQHandler>:
 c002d60:	bffef7ff 	.word	0xbffef7ff

0c002d64 <RNG_IRQHandler>:
 c002d64:	f7ff bffe 	b.w	c002d64 <RNG_IRQHandler>

0c002d68 <FPU_IRQHandler>:
 c002d68:	bffef7ff 	.word	0xbffef7ff

0c002d6c <LPTIM3_IRQHandler>:
 c002d6c:	f7ff bffe 	b.w	c002d6c <LPTIM3_IRQHandler>

0c002d70 <SPI3_IRQHandler>:
 c002d70:	bffef7ff 	.word	0xbffef7ff

0c002d74 <I2C4_ER_IRQHandler>:
 c002d74:	f7ff bffe 	b.w	c002d74 <I2C4_ER_IRQHandler>

0c002d78 <I2C4_EV_IRQHandler>:
 c002d78:	bffef7ff 	.word	0xbffef7ff

0c002d7c <DFSDM1_FLT0_IRQHandler>:
 c002d7c:	f7ff bffe 	b.w	c002d7c <DFSDM1_FLT0_IRQHandler>

0c002d80 <DFSDM1_FLT1_IRQHandler>:
 c002d80:	bffef7ff 	.word	0xbffef7ff

0c002d84 <DFSDM1_FLT2_IRQHandler>:
 c002d84:	f7ff bffe 	b.w	c002d84 <DFSDM1_FLT2_IRQHandler>

0c002d88 <DFSDM1_FLT3_IRQHandler>:
 c002d88:	bffef7ff 	.word	0xbffef7ff

0c002d8c <UCPD1_IRQHandler>:
 c002d8c:	f7ff bffe 	b.w	c002d8c <UCPD1_IRQHandler>

0c002d90 <ICACHE_IRQHandler>:
 c002d90:	bffef7ff 	.word	0xbffef7ff

0c002d94 <OTFDEC1_IRQHandler>:
 c002d94:	f7ff bffe 	b.w	c002d94 <OTFDEC1_IRQHandler>

0c002d98 <aes_set_key>:
                       unsigned int keybits)
{
    AES_VALIDATE_RET( ctx != NULL );
    AES_VALIDATE_RET( key != NULL );

    switch (keybits) {
 c002d98:	b5372ac0 	.word	0xb5372ac0
{
 c002d9c:	4604      	mov	r4, r0
    switch (keybits) {
 c002d9e:	d056      	beq.n	c002e4e <aes_set_key+0xb6>
 c002da0:	7f80f5b2 	.word	0x7f80f5b2
 c002da4:	d02d      	beq.n	c002e02 <aes_set_key+0x6a>
 c002da6:	2a80      	.short	0x2a80
 c002da8:	d003      	beq.n	c002db2 <aes_set_key+0x1a>
            SWAP_B8_TO_B32(ctx->aes_key[6],key,24);
            SWAP_B8_TO_B32(ctx->aes_key[7],key,28);
            break;

        default :
            return (MBEDTLS_ERR_AES_INVALID_KEY_LENGTH);
 c002daa:	f06f      	.short	0xf06f
 c002dac:	001f      	movs	r7, r3

    /* allow multi-instance of CRYP use: save context for CRYP HW module CR */
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR;

    return (0);
}
 c002dae:	b003      	add	sp, #12
 c002db0:	bd30      	pop	{r4, r5, pc}
            ctx->hcryp_aes.Init.KeySize = CRYP_KEYSIZE_128B;;
 c002db2:	2300      	movs	r3, #0
 c002db4:	6283      	str	r3, [r0, #40]	; 0x28
 c002db6:	680b      	ldr	r3, [r1, #0]
 c002db8:	ba1b      	rev	r3, r3
            SWAP_B8_TO_B32(ctx->aes_key[0],key,0);
 c002dba:	6003      	str	r3, [r0, #0]
 c002dbc:	684b      	ldr	r3, [r1, #4]
 c002dbe:	ba1b      	rev	r3, r3
            SWAP_B8_TO_B32(ctx->aes_key[1],key,4);
 c002dc0:	6043      	str	r3, [r0, #4]
 c002dc2:	688b      	ldr	r3, [r1, #8]
 c002dc4:	ba1b      	rev	r3, r3
            SWAP_B8_TO_B32(ctx->aes_key[2],key,8);
 c002dc6:	6083      	str	r3, [r0, #8]
 c002dc8:	68cb      	ldr	r3, [r1, #12]
 c002dca:	ba1b      	rev	r3, r3
            SWAP_B8_TO_B32(ctx->aes_key[3],key,12);
 c002dcc:	60c3      	str	r3, [r0, #12]
    ctx->hcryp_aes.Init.DataType = CRYP_DATATYPE_8B;
 c002dce:	2304      	.short	0x2304
 c002dd0:	4a20      	ldr	r2, [pc, #128]	; (c002e54 <aes_set_key+0xbc>)
    ctx->hcryp_aes.Init.pKey = ctx->aes_key;
 c002dd2:	62e4      	str	r4, [r4, #44]	; 0x2c
    ctx->hcryp_aes.Init.DataType = CRYP_DATATYPE_8B;
 c002dd4:	e9c4 2308 	strd	r2, r3, [r4, #32]
    ctx->hcryp_aes.Init.DataWidthUnit = CRYP_DATAWIDTHUNIT_BYTE;
 c002dd8:	2301      	movs	r3, #1
 c002dda:	6463      	str	r3, [r4, #68]	; 0x44
    __HAL_RCC_AES_CLK_ENABLE();
 c002ddc:	4b1e      	ldr	r3, [pc, #120]	; (c002e58 <aes_set_key+0xc0>)
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c002dde:	f104 0520 	add.w	r5, r4, #32
    __HAL_RCC_AES_CLK_ENABLE();
 c002de2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c002de4:	4628      	mov	r0, r5
    __HAL_RCC_AES_CLK_ENABLE();
 c002de6:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c002dea:	64da      	str	r2, [r3, #76]	; 0x4c
 c002dec:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c002dee:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 c002df2:	9301      	.short	0x9301
 c002df4:	9b01      	ldr	r3, [sp, #4]
    if (HAL_CRYP_DeInit(&ctx->hcryp_aes) != HAL_OK) {
 c002df6:	f003 fd81 	bl	c0068fc <HAL_CRYP_DeInit>
 c002dfa:	b1f0      	cbz	r0, c002e3a <aes_set_key+0xa2>
        return (MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED);
 c002dfc:	006ff06f 	.word	0x006ff06f
 c002e00:	e7d5      	b.n	c002dae <aes_set_key+0x16>
            ctx->hcryp_aes.Init.KeySize = CRYP_KEYSIZE_256B;
 c002e02:	f44f      	.short	0xf44f
 c002e04:	2380      	movs	r3, #128	; 0x80
 c002e06:	6283      	.short	0x6283
 c002e08:	680b      	ldr	r3, [r1, #0]
 c002e0a:	ba1b      	.short	0xba1b
            SWAP_B8_TO_B32(ctx->aes_key[0],key,0);
 c002e0c:	6003      	str	r3, [r0, #0]
 c002e0e:	684b      	ldr	r3, [r1, #4]
 c002e10:	6043ba1b 	.word	0x6043ba1b
            SWAP_B8_TO_B32(ctx->aes_key[1],key,4);
 c002e14:	688b      	ldr	r3, [r1, #8]
 c002e16:	ba1b      	.short	0xba1b
            SWAP_B8_TO_B32(ctx->aes_key[2],key,8);
 c002e18:	6083      	str	r3, [r0, #8]
 c002e1a:	68cb      	ldr	r3, [r1, #12]
 c002e1c:	ba1b      	rev	r3, r3
            SWAP_B8_TO_B32(ctx->aes_key[3],key,12);
 c002e1e:	60c3      	str	r3, [r0, #12]
 c002e20:	ba1b690b 	.word	0xba1b690b
            SWAP_B8_TO_B32(ctx->aes_key[4],key,16);
 c002e24:	6103      	str	r3, [r0, #16]
 c002e26:	694b      	.short	0x694b
 c002e28:	ba1b      	rev	r3, r3
            SWAP_B8_TO_B32(ctx->aes_key[5],key,20);
 c002e2a:	6143      	str	r3, [r0, #20]
 c002e2c:	698b      	ldr	r3, [r1, #24]
 c002e2e:	ba1b      	.short	0xba1b
            SWAP_B8_TO_B32(ctx->aes_key[6],key,24);
 c002e30:	6183      	str	r3, [r0, #24]
 c002e32:	69cb      	ldr	r3, [r1, #28]
 c002e34:	61c3ba1b 	.word	0x61c3ba1b
            break;
 c002e38:	e7c9      	b.n	c002dce <aes_set_key+0x36>
    if (HAL_CRYP_Init(&ctx->hcryp_aes) != HAL_OK) {
 c002e3a:	4628      	.short	0x4628
 c002e3c:	f003 fd3a 	bl	c0068b4 <HAL_CRYP_Init>
 c002e40:	d1db2800 	.word	0xd1db2800
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR;
 c002e44:	6a23      	ldr	r3, [r4, #32]
 c002e46:	681b      	.short	0x681b
 c002e48:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
    return (0);
 c002e4c:	f06fe7af 	.word	0xf06fe7af
            return (MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED);
 c002e50:	0071      	lsls	r1, r6, #1
 c002e52:	e7ac      	.short	0xe7ac
 c002e54:	0000      	movs	r0, r0
 c002e56:	520c      	strh	r4, [r1, r0]
 c002e58:	50021000 	.word	0x50021000

0c002e5c <mbedtls_aes_init>:

void mbedtls_aes_init(mbedtls_aes_context *ctx)
{
    AES_VALIDATE( ctx != NULL );

    memset(ctx, 0, sizeof(mbedtls_aes_context));
 c002e5c:	f44f 7298 	mov.w	r2, #304	; 0x130
 c002e60:	f00b2100 	.word	0xf00b2100
 c002e64:	b912      	cbnz	r2, c002e6c <mbedtls_aes_free+0x6>

0c002e66 <mbedtls_aes_free>:
}


void mbedtls_aes_free(mbedtls_aes_context *ctx)
{
    if (ctx == NULL) {
 c002e66:	b120      	.short	0xb120
        *p++ = 0;
 c002e68:	2200      	movs	r2, #0
 c002e6a:	f500      	.short	0xf500
 c002e6c:	7398      	strb	r0, [r3, #14]
    while (n--) {
 c002e6e:	4298      	.short	0x4298
 c002e70:	d100      	bne.n	c002e74 <mbedtls_aes_free+0xe>
        return;
    }

    mbedtls_zeroize(ctx, sizeof(mbedtls_aes_context));
}
 c002e72:	4770      	.short	0x4770
        *p++ = 0;
 c002e74:	7002      	strb	r2, [r0, #0]
 c002e76:	3001      	.short	0x3001
 c002e78:	e7f9      	b.n	c002e6e <mbedtls_aes_free+0x8>

0c002e7a <mbedtls_aes_setkey_enc>:
 * AES key schedule (encryption)
 */
int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key,
                           unsigned int keybits)
{
    return (aes_set_key(ctx, key, keybits));
 c002e7a:	f7ff      	.short	0xf7ff
 c002e7c:	bf8d      	iteet	hi

0c002e7e <mbedtls_internal_aes_encrypt>:
int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx,
                                 const unsigned char input[16],
                                 unsigned char output[16])
{

    if (HAL_CRYP_Encrypt(&ctx->hcryp_aes, (uint32_t *)input, 16, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c002e7e:	23ff      	.short	0x23ff
{
 c002e80:	b507      	push	{r0, r1, r2, lr}
    if (HAL_CRYP_Encrypt(&ctx->hcryp_aes, (uint32_t *)input, 16, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c002e82:	3020      	.short	0x3020
 c002e84:	9300      	str	r3, [sp, #0]
 c002e86:	4613      	.short	0x4613
 c002e88:	2210      	movs	r2, #16
 c002e8a:	f003      	.short	0xf003
 c002e8c:	ff79 2800 	vsub.i64	d18, d9, d0
        return (MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED);
    }
    return (0);

}
 c002e90:	f06fbf14 	.word	0xf06fbf14
 c002e94:	006f      	lsls	r7, r5, #1
 c002e96:	2000      	.short	0x2000
 c002e98:	b003      	add	sp, #12
 c002e9a:	f85d      	.short	0xf85d
 c002e9c:	Address 0x000000000c002e9c is out of bounds.


0c002e9e <mbedtls_internal_aes_decrypt>:

int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx,
                                 const unsigned char input[16],
                                 unsigned char output[16])
{
    if (HAL_CRYP_Decrypt(&ctx->hcryp_aes, (uint32_t *)input, 16, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c002e9e:	23ff      	movs	r3, #255	; 0xff
{
 c002ea0:	3020b507 	.word	0x3020b507
    if (HAL_CRYP_Decrypt(&ctx->hcryp_aes, (uint32_t *)input, 16, (uint32_t *)output, ST_AES_TIMEOUT) != HAL_OK) {
 c002ea4:	9300      	str	r3, [sp, #0]
 c002ea6:	4613      	.short	0x4613
 c002ea8:	2210      	movs	r2, #16
 c002eaa:	f003 ffed 	blhi	c006e88 <HAL_CRYP_Decrypt>	; unpredictable branch in IT block

 c002eae:	2800      	cmpls	r0, #0
        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
    }
    return (0);
}
 c002eb0:	bf14      	ite	ne	; unpredictable <IT:ls>
 c002eb2:	f06f 006f 	mvnne.w	r0, #111	; 0x6f
 c002eb6:	2000      	moveq	r0, #0
 c002eb8:	b003      	add	sp, #12
 c002eba:	f85d fb04 	ldr.w	pc, [sp], #4

0c002ebe <mbedtls_aes_crypt_ecb>:
{
 c002ebe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c002ec0:	4615      	mov	r5, r2
 c002ec2:	461e      	.short	0x461e
    ctx->hcryp_aes.Instance->CR = ctx->ctx_save_cr;
 c002ec4:	f8d0 212c 	ldr.w	r2, [r0, #300]	; 0x12c
 c002ec8:	6a03      	ldr	r3, [r0, #32]
{
 c002eca:	4604      	mov	r4, r0
    ctx->hcryp_aes.Instance->CR = ctx->ctx_save_cr;
 c002ecc:	6b43601a 	.word	0x6b43601a
{
 c002ed0:	460f      	mov	r7, r1
    if (CRYP_AES_ECB != ctx->hcryp_aes.Init.Algorithm)
 c002ed2:	b933      	.short	0xb933
    if (mode == MBEDTLS_AES_DECRYPT) { /* AES decryption */
 c002ed4:	b18f      	cbz	r7, c002efa <mbedtls_aes_crypt_ecb+0x3c>
        ret = mbedtls_internal_aes_encrypt(ctx, input, output);
 c002ed6:	4632      	.short	0x4632
 c002ed8:	4629      	mov	r1, r5
 c002eda:	4620      	.short	0x4620
 c002edc:	f7ff ffcf 	bl	c002e7e <mbedtls_internal_aes_encrypt>
 c002ee0:	2300e010 	.word	0x2300e010
        if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK)
 c002ee4:	f100 0124 	add.w	r1, r0, #36	; 0x24
        ctx->hcryp_aes.Init.Algorithm  = CRYP_AES_ECB;
 c002ee8:	6343      	str	r3, [r0, #52]	; 0x34
        if (HAL_CRYP_SetConfig(&ctx->hcryp_aes, &ctx->hcryp_aes.Init) != HAL_OK)
 c002eea:	3020      	adds	r0, #32
 c002eec:	fc9af003 	.word	0xfc9af003
 c002ef0:	2800      	cmp	r0, #0
 c002ef2:	d0ef      	.short	0xd0ef
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c002ef4:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 c002ef8:	4632e00a 	.word	0x4632e00a
        ret = mbedtls_internal_aes_decrypt(ctx, input, output);
 c002efc:	4629      	mov	r1, r5
 c002efe:	4620      	.short	0x4620
 c002f00:	f7ff ffcd 	bl	c002e9e <mbedtls_internal_aes_decrypt>
        if( ret != 0 )
 c002f04:	2000b920 	.word	0x2000b920
    ctx->ctx_save_cr = ctx->hcryp_aes.Instance->CR;
 c002f08:	6a23      	ldr	r3, [r4, #32]
 c002f0a:	681b      	.short	0x681b
 c002f0c:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
}
 c002f10:	0000bdf8 	.word	0x0000bdf8

0c002f14 <CalculateCrc>:
  * @param  CRCx CRC Instance
  * @retval None
  */
__STATIC_INLINE void LL_CRC_ResetCRCCalculationUnit(CRC_TypeDef *CRCx)
{
  SET_BIT(CRCx->CR, CRC_CR_RESET);
 c002f14:	4b0f      	ldr	r3, [pc, #60]	; (c002f54 <CalculateCrc+0x40>)
  * @param  Data value of  the eeprom variable.
  * @param  VirtAddress address of the eeprom variable.
  * @retval 16-bit CRC value computed on Data and Virtual Address.
  */
static uint16_t CalculateCrc(NVCNT_DATA_TYPE Data, uint16_t VirtAddress)
{
 c002f16:	b513      	.short	0xb513
 c002f18:	689a      	ldr	r2, [r3, #8]
 c002f1a:	f042      	.short	0xf042
 c002f1c:	0201      	lsls	r1, r0, #8
 c002f1e:	609a      	.short	0x609a
  * @retval None
  */
__STATIC_INLINE void LL_AHB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB1ENR, Periphs);
 c002f20:	4a0d      	ldr	r2, [pc, #52]	; (c002f58 <CalculateCrc+0x44>)
 c002f22:	6c94      	.short	0x6c94
 c002f24:	f444 5480 	orr.w	r4, r4, #4096	; 0x1000
 c002f28:	6c926494 	.word	0x6c926494
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB1ENR, Periphs);
 c002f2c:	f402 5280 	and.w	r2, r2, #4096	; 0x1000
 c002f30:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 c002f32:	9a01      	ldr	r2, [sp, #4]
  * @param  PolynomCoef Value to be programmed in Programmable Polynomial value register
  * @retval None
  */
__STATIC_INLINE void LL_CRC_SetPolynomialCoef(CRC_TypeDef *CRCx, uint32_t PolynomCoef)
{
  WRITE_REG(CRCx->POL, PolynomCoef);
 c002f34:	f248 0205 	movw	r2, #32773	; 0x8005
 c002f38:	615a      	str	r2, [r3, #20]
  MODIFY_REG(CRCx->CR, CRC_CR_POLYSIZE, PolySize);
 c002f3a:	689a      	ldr	r2, [r3, #8]
 c002f3c:	f022 0218 	bic.w	r2, r2, #24
 c002f40:	f042 0208 	orr.w	r2, r2, #8
 c002f44:	609a      	str	r2, [r3, #8]
  * @param  InData value to be provided to CRC calculator between between Min_Data=0 and Max_Data=0xFFFFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_CRC_FeedData32(CRC_TypeDef *CRCx, uint32_t InData)
{
  WRITE_REG(CRCx->DR, InData);
 c002f46:	6018      	str	r0, [r3, #0]
__STATIC_INLINE void LL_CRC_FeedData16(CRC_TypeDef *CRCx, uint16_t InData)
{
  __IO uint16_t *pReg;

  pReg = (__IO uint16_t *)(__IO void *)(&CRCx->DR);                             /* Derogation MisraC2012 R.11.5 */
  *pReg = InData;
 c002f48:	8019      	strh	r1, [r3, #0]
  * @param  CRCx CRC Instance
  * @retval Current CRC calculation result as stored in CRC_DR register (16 bits).
  */
__STATIC_INLINE uint16_t LL_CRC_ReadData16(CRC_TypeDef *CRCx)
{
  return (uint16_t)READ_REG(CRCx->DR);
 c002f4a:	6818      	ldr	r0, [r3, #0]
  LL_CRC_FeedData32(CRC, Data);
  LL_CRC_FeedData16(CRC, VirtAddress);

  /* Return computed CRC value */
  return (LL_CRC_ReadData16(CRC));
}
 c002f4c:	b280      	uxth	r0, r0
 c002f4e:	b002      	add	sp, #8
 c002f50:	bd10      	pop	{r4, pc}
 c002f52:	bf00      	nop
 c002f54:	3000      	adds	r0, #0
 c002f56:	5002      	.short	0x5002
 c002f58:	1000      	asrs	r0, r0, #32
 c002f5a:	5002      	.short	0x5002

0c002f5c <tfm_plat_read_nv_counter>:
{
 c002f5c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c002f60:	46912300 	.word	0x46912300
 c002f64:	2200      	movs	r2, #0
  if (size < sizeof(NVCNT_DATA_TYPE))
 c002f66:	2903      	.short	0x2903
{
 c002f68:	4680      	mov	r8, r0
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c002f6a:	e9cd      	.short	0xe9cd
 c002f6c:	2300      	movs	r3, #0
  if (size < sizeof(NVCNT_DATA_TYPE))
 c002f6e:	d932      	.short	0xd932
  uint32_t previous_value = 0;
 c002f70:	2600      	movs	r6, #0
  counter = BL2_NV_COUNTERS_AREA_SIZE - NVCNT_ELEMENT_SIZE;
 c002f72:	f640 75f8 	movw	r5, #4088	; 0xff8
  uint32_t found = 0;
 c002f76:	4634      	mov	r4, r6
    err = FLASH_DEV_NAME.ReadData(BL2_NV_COUNTERS_AREA_ADDR + counter, &addressvalue,
 c002f78:	4b18      	ldr	r3, [pc, #96]	; (c002fdc <tfm_plat_read_nv_counter+0x80>)
 c002f7a:	695f      	ldr	r7, [r3, #20]
 c002f7c:	2208      	movs	r2, #8
 c002f7e:	4669      	mov	r1, sp
 c002f80:	47b84628 	.word	0x47b84628
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c002f84:	b9e8      	cbnz	r0, c002fc2 <tfm_plat_read_nv_counter+0x66>
 c002f86:	e9dd 2300 	ldrd	r2, r3, [sp]
 c002f8a:	1c59      	.short	0x1c59
 c002f8c:	bf08      	it	eq
 c002f8e:	f1b2      	.short	0xf1b2
 c002f90:	3fff      	subs	r7, #255	; 0xff
 c002f92:	d016      	.short	0xd016
      if (addressvalue == 0)
 c002f94:	ea52 0103 	orrs.w	r1, r2, r3
 c002f98:	2001d103 	.word	0x2001d103
}
 c002f9c:	b003      	add	sp, #12
 c002f9e:	e8bd      	.short	0xe8bd
 c002fa0:	83f0      	strh	r0, [r6, #30]
      if (NVCNT_ID_VALUE(addressvalue) == counter_id)
 c002fa2:	b291      	uxtheq	r1, r2
 c002fa4:	4541      	cmp	r1, r8
 c002fa6:	d10c      	.short	0xd10c
        crc = CalculateCrc(NVCNT_DATA_VALUE(addressvalue), NVCNT_ID_VALUE(addressvalue));
 c002fa8:	4618      	mov	r0, r3
 c002faa:	f7ff ffb3 	bl	c002f14 <CalculateCrc>
        if (crc == NVCNT_CRC_VALUE(addressvalue))
 c002fae:	f8bd      	.short	0xf8bd
 c002fb0:	2002      	movs	r0, #2
 c002fb2:	9b01      	.short	0x9b01
 c002fb4:	4290      	cmp	r0, r2
 c002fb6:	d104      	.short	0xd104
          if (found != 1)
 c002fb8:	b94c      	cbnz	r4, c002fce <tfm_plat_read_nv_counter+0x72>
 c002fba:	461e      	.short	0x461e
            found = 1;
 c002fbc:	2401      	movs	r4, #1
            *((uint32_t *)val) = NVCNT_DATA_VALUE(addressvalue);
 c002fbe:	f8c9 3000 	str.w	r3, [r9]
    counter -= NVCNT_ELEMENT_SIZE;
 c002fc2:	3d08      	subs	r5, #8
  while (counter >= PAGE_HEADER_SIZE)
 c002fc4:	d1d92d38 	.word	0xd1d92d38
 c002fc8:	f084 0001 	eor.w	r0, r4, #1
 c002fcc:	42b3e7e6 	.word	0x42b3e7e6
            if (current_value >= previous_value)
 c002fd0:	d2e3      	bcs.n	c002f9a <tfm_plat_read_nv_counter+0x3e>
 c002fd2:	461e      	.short	0x461e
 c002fd4:	e7f5      	b.n	c002fc2 <tfm_plat_read_nv_counter+0x66>
    return TFM_PLAT_ERR_INVALID_INPUT;
 c002fd6:	2003      	movs	r0, #3
 c002fd8:	e7e0      	b.n	c002f9c <tfm_plat_read_nv_counter+0x40>
 c002fda:	bf00      	nop
 c002fdc:	0c00fad0 	.word	0x0c00fad0

0c002fe0 <tfm_plat_init_nv_counter>:
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c002fe0:	2200      	movs	r2, #0
 c002fe2:	2300      	.short	0x2300
{
 c002fe4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  bool readstatus = true;
 c002fe8:	25002401 	.word	0x25002401
{
 c002fec:	b088      	sub	sp, #32
    err = FLASH_DEV_NAME.ReadData(Address + counter, &addressvalue,
 c002fee:	4f77      	.short	0x4f77
  NVCNT_ELEMENT_TYPE addressvalue = 0U;
 c002ff0:	e9cd 2302 	strd	r2, r3, [sp, #8]
    err = FLASH_DEV_NAME.ReadData(Address + counter, &addressvalue,
 c002ff4:	8014f8d7 	.word	0x8014f8d7
 c002ff8:	2208      	movs	r2, #8
 c002ffa:	a906      	add	r1, sp, #24
 c002ffc:	4628      	mov	r0, r5
 c002ffe:	47c0      	.short	0x47c0
    if ((err != ARM_DRIVER_OK) || (addressvalue != NVCNT_PAGESTAT_ERASED))
 c003000:	2800      	cmp	r0, #0
 c003002:	d13e      	.short	0xd13e
 c003004:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
      readstatus = false;
 c003008:	3301      	adds	r3, #1
 c00300a:	bf0c      	ite	eq
 c00300c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c003010:	2400      	movne	r4, #0
    counter = counter + NVCNT_ELEMENT_SIZE;
 c003012:	3508      	.short	0x3508
  while (counter < PageSize)
 c003014:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
 c003018:	d1ee      	bne.n	c002ff8 <tfm_plat_init_nv_counter+0x18>
 c00301a:	4e6d      	ldr	r6, [pc, #436]	; (c0031d0 <tfm_plat_init_nv_counter+0x1f0>)
  if (VerifyPageFullyErased(BL2_NV_COUNTERS_AREA_ADDR, BL2_NV_COUNTERS_AREA_SIZE))
 c00301c:	f0002c00 	.word	0xf0002c00
 c003020:	80af      	strh	r7, [r5, #4]
  {
    /* store in revert order , read is done in revert at the end all is in order */
    /* compute crc */
    crc = CalculateCrc(huk[loop], huk_random_id);
    /*  build element  */
    element = NVCNT_ELEMENT_VALUE(huk_random_id, huk[loop], crc);
 c003022:	f04f      	.short	0xf04f
 c003024:	0a00      	lsrs	r0, r0, #8
    HAL_Delay(500);
 c003026:	f44f      	.short	0xf44f
 c003028:	70fa      	strb	r2, [r7, #3]
 c00302a:	f003 fa53 	bl	c0064d4 <HAL_Delay>
    BOOT_LOG_INF("Initializing BL2 NV area : Power down/reset not supported...");
 c00302e:	4869      	ldr	r0, [pc, #420]	; (c0031d4 <tfm_plat_init_nv_counter+0x1f4>)
 c003030:	f00b f950 	bl	c00e2d4 <puts>
  huk[0] = NVCNT_HEADER_VALUE;
 c003034:	9600      	str	r6, [sp, #0]
    crc = CalculateCrc(huk[loop], huk_random_id);
 c003036:	f644 0155 	movw	r1, #18517	; 0x4855
 c00303a:	9800      	ldr	r0, [sp, #0]
 c00303c:	f7ff ff6a 	bl	c002f14 <CalculateCrc>
    element = NVCNT_ELEMENT_VALUE(huk_random_id, huk[loop], crc);
 c003040:	9b00      	ldr	r3, [sp, #0]
 c003042:	2400      	.short	0x2400
 c003044:	f644 0955 	movw	r9, #18517	; 0x4855
 c003048:	0303ea4a 	.word	0x0303ea4a
 c00304c:	469a      	mov	sl, r3
 c00304e:	ea49 0204 	orr.w	r2, r9, r4
 c003052:	0400      	.short	0x0400
 c003054:	ea42 0900 	orr.w	r9, r2, r0
 c003058:	e961a908 	.word	0xe961a908
 c00305c:	9a04      	ldr	r2, [sp, #16]
    /* write element  */
    err = FLASH_DEV_NAME.ProgramData(address,
 c00305e:	2208      	.short	0x2208
 c003060:	f8d7 a018 	ldr.w	sl, [r7, #24]
 c003064:	47d04620 	.word	0x47d04620
    address += sizeof(NVCNT_ELEMENT_TYPE);
    loop--;
  }

  /* clean huk footprint  */
  element = 0;
 c003068:	2200      	movs	r2, #0
 c00306a:	2300      	.short	0x2300
 c00306c:	e9cd 2304 	strd	r2, r3, [sp, #16]
  memset((void *)huk, 0, sizeof(huk));
  if (err == ARM_DRIVER_OK)
 c003070:	4859b148 	.word	0x4859b148
    BOOT_LOG_ERR("Wrong BL2 NV Area header");
 c003074:	f00b f92e 	bl	c00e2d4 <puts>
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c003078:	46202401 	.word	0x46202401
}
 c00307c:	b008      	add	sp, #32
 c00307e:	e8bd      	.short	0xe8bd
 c003080:	87f0      	strh	r0, [r6, #62]	; 0x3e
      readstatus = false;
 c003082:	2400      	.short	0x2400
 c003084:	e7c5      	b.n	c003012 <tfm_plat_init_nv_counter+0x32>
    BOOT_LOG_INF("Init BL2 NV Header area: Done");
 c003086:	4855      	.short	0x4855
 c003088:	f00b f924 	bl	c00e2d4 <puts>
    BOOT_LOG_INF("Initializing BL2 NV Counters");
 c00308c:	4854      	ldr	r0, [pc, #336]	; (c0031e0 <tfm_plat_init_nv_counter+0x200>)
 c00308e:	f00b f921 	bl	c00e2d4 <puts>
 c003092:	2403      	movs	r4, #3
 c003094:	2500      	movs	r5, #0
  /* initialize only one counter */
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
  {

    /* Check if pages are full, i.e. max number of written elements achieved */
    if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c003096:	4f53      	ldr	r7, [pc, #332]	; (c0031e4 <tfm_plat_init_nv_counter+0x204>)
    /* Calculate crc of variable data and virtual address */
    crc = CalculateCrc(data, counter_id);
    /*  build element  */
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
    /* Program variable data + virtual address + crc */
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c003098:	f8df 9158 	ldr.w	r9, [pc, #344]	; c0031f4 <tfm_plat_init_nv_counter+0x214>
    if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c00309c:	683b      	ldr	r3, [r7, #0]
 c00309e:	f5b3 7ffc 	cmp.w	r3, #504	; 0x1f8
 c0030a2:	d265      	bcs.n	c003170 <tfm_plat_init_nv_counter+0x190>
    crc = CalculateCrc(data, counter_id);
 c0030a4:	b2a1      	uxth	r1, r4
 c0030a6:	2000      	movs	r0, #0
 c0030a8:	f7ff ff34 	bl	c002f14 <CalculateCrc>
    element = NVCNT_ELEMENT_VALUE(counter_id, data, crc);
 c0030ac:	462b      	mov	r3, r5
 c0030ae:	0400      	lsls	r0, r0, #16
 c0030b0:	ea44 0200 	orr.w	r2, r4, r0
 c0030b4:	e9cd 2306 	strd	r2, r3, [sp, #24]
    err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c0030b8:	a906      	add	r1, sp, #24
 c0030ba:	2208      	movs	r2, #8
 c0030bc:	f8d9 0000 	ldr.w	r0, [r9]
 c0030c0:	47d0      	blx	sl
                                     &element,
                                     NVCNT_ELEMENT_SIZE);
    /* If program operation was failed, a Flash error code is returned */
    if (err != ARM_DRIVER_OK)
 c0030c2:	2800      	cmp	r0, #0
 c0030c4:	d154      	bne.n	c003170 <tfm_plat_init_nv_counter+0x190>
    {
      return false;
    }

    /* Increment global variables relative to write operation done*/
    uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c0030c6:	f8d9 3000 	ldr.w	r3, [r9]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c0030ca:	2d00      	cmp	r5, #0
    uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c0030cc:	f103 0308 	add.w	r3, r3, #8
 c0030d0:	f8c9 3000 	str.w	r3, [r9]
    uhNbWrittenElements++;
 c0030d4:	683b      	ldr	r3, [r7, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c0030d6:	bf08      	it	eq
 c0030d8:	2c04      	cmpeq	r4, #4
    uhNbWrittenElements++;
 c0030da:	f103 0301 	add.w	r3, r3, #1
 c0030de:	603b      	str	r3, [r7, #0]
  for (counter_id = PLAT_NV_COUNTER_3; counter_id < PLAT_NV_COUNTER_MAX; counter_id++)
 c0030e0:	d048      	beq.n	c003174 <tfm_plat_init_nv_counter+0x194>
 c0030e2:	2404      	movs	r4, #4
 c0030e4:	2500      	movs	r5, #0
 c0030e6:	e7d9      	b.n	c00309c <tfm_plat_init_nv_counter+0xbc>
  BOOT_LOG_INF("Checking BL2 NV Counter consistency");
 c0030e8:	483f      	ldr	r0, [pc, #252]	; (c0031e8 <tfm_plat_init_nv_counter+0x208>)
 c0030ea:	f00b f8f3 	bl	c00e2d4 <puts>
  if (tfm_plat_read_nv_counter(PLAT_NV_COUNTER_3, sizeof(counter_value),
 c0030ee:	aa06      	add	r2, sp, #24
 c0030f0:	2104      	movs	r1, #4
 c0030f2:	2003      	movs	r0, #3
 c0030f4:	f7ff ff32 	bl	c002f5c <tfm_plat_read_nv_counter>
 c0030f8:	b120      	cbz	r0, c003104 <tfm_plat_init_nv_counter+0x124>
    BOOT_LOG_ERR("NV Counter Not consistent %d", PLAT_NV_COUNTER_3);
 c0030fa:	2103      	movs	r1, #3
    BOOT_LOG_ERR("NV Counter Not consistent %d", PLAT_NV_COUNTER_4);
 c0030fc:	483b      	ldr	r0, [pc, #236]	; (c0031ec <tfm_plat_init_nv_counter+0x20c>)
 c0030fe:	f00b f875 	bl	c00e1ec <iprintf>
 c003102:	e7b9      	b.n	c003078 <tfm_plat_init_nv_counter+0x98>
  BOOT_LOG_INF("Consistent BL2 NV Counter %d  = 0x%x", PLAT_NV_COUNTER_3, counter_value);
 c003104:	9a06      	ldr	r2, [sp, #24]
 c003106:	2103      	movs	r1, #3
 c003108:	4839      	ldr	r0, [pc, #228]	; (c0031f0 <tfm_plat_init_nv_counter+0x210>)
 c00310a:	f00b f86f 	bl	c00e1ec <iprintf>
  if (tfm_plat_read_nv_counter(PLAT_NV_COUNTER_4, sizeof(counter_value),
 c00310e:	2104      	movs	r1, #4
 c003110:	aa06      	add	r2, sp, #24
 c003112:	4608      	mov	r0, r1
 c003114:	f7ff ff22 	bl	c002f5c <tfm_plat_read_nv_counter>
 c003118:	4604      	mov	r4, r0
 c00311a:	b108      	cbz	r0, c003120 <tfm_plat_init_nv_counter+0x140>
    BOOT_LOG_ERR("NV Counter Not consistent %d", PLAT_NV_COUNTER_4);
 c00311c:	2104      	movs	r1, #4
 c00311e:	e7ed      	b.n	c0030fc <tfm_plat_init_nv_counter+0x11c>
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c003120:	2540      	movs	r5, #64	; 0x40
  uhNbWrittenElements = 0U;
 c003122:	4f30      	ldr	r7, [pc, #192]	; (c0031e4 <tfm_plat_init_nv_counter+0x204>)
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c003124:	4e33      	ldr	r6, [pc, #204]	; (c0031f4 <tfm_plat_init_nv_counter+0x214>)
  BOOT_LOG_INF("Consistent BL2 NV Counter %d  = 0x%x", PLAT_NV_COUNTER_4, counter_value);
 c003126:	9a06      	ldr	r2, [sp, #24]
 c003128:	2104      	movs	r1, #4
 c00312a:	4831      	ldr	r0, [pc, #196]	; (c0031f0 <tfm_plat_init_nv_counter+0x210>)
 c00312c:	f00b f85e 	bl	c00e1ec <iprintf>
  uhNbWrittenElements = 0U;
 c003130:	603c      	str	r4, [r7, #0]
  uwAddressNextWrite = PAGE_HEADER_SIZE;
 c003132:	6035      	str	r5, [r6, #0]
    err = FLASH_DEV_NAME.ReadData(BL2_NV_COUNTERS_AREA_ADDR + varidx, &addressvalue,
 c003134:	2208      	movs	r2, #8
 c003136:	4628      	mov	r0, r5
 c003138:	eb0d 0102 	add.w	r1, sp, r2
 c00313c:	47c0      	blx	r8
    if ((err == ARM_DRIVER_ERROR_SPECIFIC) || (addressvalue != NVCNT_MASK_FULL))
 c00313e:	1d83      	adds	r3, r0, #6
 c003140:	d006      	beq.n	c003150 <tfm_plat_init_nv_counter+0x170>
 c003142:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c003146:	3301      	adds	r3, #1
 c003148:	bf08      	it	eq
 c00314a:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c00314e:	d00b      	beq.n	c003168 <tfm_plat_init_nv_counter+0x188>
      uhNbWrittenElements++;
 c003150:	683b      	ldr	r3, [r7, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c003152:	3508      	adds	r5, #8
      uhNbWrittenElements++;
 c003154:	3301      	adds	r3, #1
 c003156:	603b      	str	r3, [r7, #0]
      uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c003158:	6833      	ldr	r3, [r6, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c00315a:	f5b5 5f80 	cmp.w	r5, #4096	; 0x1000
      uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c00315e:	f103 0308 	add.w	r3, r3, #8
 c003162:	6033      	str	r3, [r6, #0]
  for (varidx = PAGE_HEADER_SIZE; varidx < BL2_NV_COUNTERS_AREA_SIZE; varidx += NVCNT_ELEMENT_SIZE)
 c003164:	d1e6      	bne.n	c003134 <tfm_plat_init_nv_counter+0x154>
 c003166:	e788      	b.n	c00307a <tfm_plat_init_nv_counter+0x9a>
      if (err != ARM_DRIVER_OK)
 c003168:	1c04      	adds	r4, r0, #0
 c00316a:	bf18      	it	ne
 c00316c:	2401      	movne	r4, #1
 c00316e:	e784      	b.n	c00307a <tfm_plat_init_nv_counter+0x9a>
      BOOT_LOG_ERR("Init BL2 NV counters : Failed");
 c003170:	4821      	ldr	r0, [pc, #132]	; (c0031f8 <tfm_plat_init_nv_counter+0x218>)
 c003172:	e77f      	b.n	c003074 <tfm_plat_init_nv_counter+0x94>
    BOOT_LOG_INF("Init BL2 NV counters to 0 : Done");
 c003174:	4821      	ldr	r0, [pc, #132]	; (c0031fc <tfm_plat_init_nv_counter+0x21c>)
 c003176:	f00b f8ad 	bl	c00e2d4 <puts>
    BOOT_LOG_INF("BL2 NV Area Initialized : Power Down/reset supported");
 c00317a:	4821      	ldr	r0, [pc, #132]	; (c003200 <tfm_plat_init_nv_counter+0x220>)
 c00317c:	f00b f8aa 	bl	c00e2d4 <puts>
  BOOT_LOG_INF("Checking BL2 NV area");
 c003180:	4820      	ldr	r0, [pc, #128]	; (c003204 <tfm_plat_init_nv_counter+0x224>)
 c003182:	f00b f8a7 	bl	c00e2d4 <puts>
  BOOT_LOG_INF("Checking BL2 NV area header");
 c003186:	4820      	ldr	r0, [pc, #128]	; (c003208 <tfm_plat_init_nv_counter+0x228>)
 c003188:	f00b f8a4 	bl	c00e2d4 <puts>
    err = FLASH_DEV_NAME.ReadData(address, (void *)&addressvalue,
 c00318c:	2208      	movs	r2, #8
 c00318e:	a906      	add	r1, sp, #24
 c003190:	2000      	movs	r0, #0
 c003192:	47c0      	blx	r8
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c003194:	4604      	mov	r4, r0
 c003196:	b980      	cbnz	r0, c0031ba <tfm_plat_init_nv_counter+0x1da>
 c003198:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 c00319c:	1c59      	adds	r1, r3, #1
 c00319e:	bf08      	it	eq
 c0031a0:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c0031a4:	d009      	beq.n	c0031ba <tfm_plat_init_nv_counter+0x1da>
      crc = CalculateCrc(NVCNT_DATA_VALUE(addressvalue), NVCNT_ID_VALUE(addressvalue));
 c0031a6:	b291      	uxth	r1, r2
 c0031a8:	4618      	mov	r0, r3
 c0031aa:	f7ff feb3 	bl	c002f14 <CalculateCrc>
      if (crc == NVCNT_CRC_VALUE(addressvalue))
 c0031ae:	f8bd 201a 	ldrh.w	r2, [sp, #26]
 c0031b2:	9b07      	ldr	r3, [sp, #28]
 c0031b4:	4290      	cmp	r0, r2
 c0031b6:	d101      	bne.n	c0031bc <tfm_plat_init_nv_counter+0x1dc>
        huk[loop] = NVCNT_DATA_VALUE(addressvalue);
 c0031b8:	9301      	str	r3, [sp, #4]
    if ((err == ARM_DRIVER_OK) && (addressvalue != NVCNT_PAGESTAT_ERASED))
 c0031ba:	2401      	movs	r4, #1
  if (huk[0] != NVCNT_HEADER_VALUE)
 c0031bc:	9b01      	ldr	r3, [sp, #4]
 c0031be:	42b3      	cmp	r3, r6
 c0031c0:	d101      	bne.n	c0031c6 <tfm_plat_init_nv_counter+0x1e6>
  if (!Check_Header())
 c0031c2:	2c00      	cmp	r4, #0
 c0031c4:	d190      	bne.n	c0030e8 <tfm_plat_init_nv_counter+0x108>
    BOOT_LOG_ERR("Wrong BL2 NV Area header");
 c0031c6:	4811      	ldr	r0, [pc, #68]	; (c00320c <tfm_plat_init_nv_counter+0x22c>)
 c0031c8:	e754      	b.n	c003074 <tfm_plat_init_nv_counter+0x94>
 c0031ca:	bf00      	nop
 c0031cc:	0c00fad0 	.word	0x0c00fad0
 c0031d0:	aaddeecc 	.word	0xaaddeecc
 c0031d4:	0c00f6b8 	.word	0x0c00f6b8
 c0031d8:	0c00f6fc 	.word	0x0c00f6fc
 c0031dc:	0c00f723 	.word	0x0c00f723
 c0031e0:	0c00f748 	.word	0x0c00f748
 c0031e4:	30030170 	.word	0x30030170
 c0031e8:	0c00f7cb 	.word	0x0c00f7cb
 c0031ec:	0c00f7f6 	.word	0x0c00f7f6
 c0031f0:	0c00f81b 	.word	0x0c00f81b
 c0031f4:	30030000 	.word	0x30030000
 c0031f8:	0c00f848 	.word	0x0c00f848
 c0031fc:	0c00f86d 	.word	0x0c00f86d
 c003200:	0c00f895 	.word	0x0c00f895
 c003204:	0c00f76c 	.word	0x0c00f76c
 c003208:	0c00f788 	.word	0x0c00f788
 c00320c:	0c00f7ab 	.word	0x0c00f7ab

0c003210 <tfm_plat_set_nv_counter>:
{
 c003210:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c003214:	b085      	sub	sp, #20
 c003216:	460d      	mov	r5, r1
  if ((tfm_plat_read_nv_counter(CounterId, sizeof(current_value), (uint8_t *)&current_value)
 c003218:	aa01      	add	r2, sp, #4
 c00321a:	2104      	movs	r1, #4
{
 c00321c:	4606      	mov	r6, r0
  if ((tfm_plat_read_nv_counter(CounterId, sizeof(current_value), (uint8_t *)&current_value)
 c00321e:	f7ff fe9d 	bl	c002f5c <tfm_plat_read_nv_counter>
 c003222:	4604      	mov	r4, r0
 c003224:	bb78      	cbnz	r0, c003286 <tfm_plat_set_nv_counter+0x76>
       != TFM_PLAT_ERR_SUCCESS) || (Data < current_value))
 c003226:	9b01      	ldr	r3, [sp, #4]
 c003228:	42ab      	cmp	r3, r5
 c00322a:	d82c      	bhi.n	c003286 <tfm_plat_set_nv_counter+0x76>
  if (current_value == Data)
 c00322c:	d027      	beq.n	c00327e <tfm_plat_set_nv_counter+0x6e>
  if (uhNbWrittenElements >= NVCNT_MAX_WRITTEN_ELEMENTS)
 c00322e:	4f18      	ldr	r7, [pc, #96]	; (c003290 <tfm_plat_set_nv_counter+0x80>)
 c003230:	683b      	ldr	r3, [r7, #0]
 c003232:	f5b3 7ffc 	cmp.w	r3, #504	; 0x1f8
 c003236:	d228      	bcs.n	c00328a <tfm_plat_set_nv_counter+0x7a>
  crc = CalculateCrc(Data, CounterId);
 c003238:	4631      	mov	r1, r6
 c00323a:	4628      	mov	r0, r5
 c00323c:	f7ff fe6a 	bl	c002f14 <CalculateCrc>
  element = NVCNT_ELEMENT_VALUE(CounterId, Data, crc);
 c003240:	462b      	mov	r3, r5
 c003242:	ea44 0806 	orr.w	r8, r4, r6
 c003246:	0400      	lsls	r0, r0, #16
 c003248:	ea48 0200 	orr.w	r2, r8, r0
 c00324c:	a904      	add	r1, sp, #16
 c00324e:	e961 2302 	strd	r2, r3, [r1, #-8]!
  err = FLASH_DEV_NAME.ProgramData(BL2_NV_COUNTERS_AREA_ADDR + uwAddressNextWrite,
 c003252:	f8df 8048 	ldr.w	r8, [pc, #72]	; c00329c <tfm_plat_set_nv_counter+0x8c>
 c003256:	4b0f      	ldr	r3, [pc, #60]	; (c003294 <tfm_plat_set_nv_counter+0x84>)
 c003258:	2208      	movs	r2, #8
 c00325a:	f8d8 0000 	ldr.w	r0, [r8]
 c00325e:	699b      	ldr	r3, [r3, #24]
 c003260:	4798      	blx	r3
  if (err != ARM_DRIVER_OK)
 c003262:	b980      	cbnz	r0, c003286 <tfm_plat_set_nv_counter+0x76>
  uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c003264:	f8d8 3000 	ldr.w	r3, [r8]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c003268:	462a      	mov	r2, r5
  uwAddressNextWrite += NVCNT_ELEMENT_SIZE;
 c00326a:	3308      	adds	r3, #8
 c00326c:	f8c8 3000 	str.w	r3, [r8]
  uhNbWrittenElements++;
 c003270:	683b      	ldr	r3, [r7, #0]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c003272:	4631      	mov	r1, r6
  uhNbWrittenElements++;
 c003274:	3301      	adds	r3, #1
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c003276:	4808      	ldr	r0, [pc, #32]	; (c003298 <tfm_plat_set_nv_counter+0x88>)
  uhNbWrittenElements++;
 c003278:	603b      	str	r3, [r7, #0]
  BOOT_LOG_INF("Counter %d set to 0x%x", CounterId, Data);
 c00327a:	f00a ffb7 	bl	c00e1ec <iprintf>
}
 c00327e:	4620      	mov	r0, r4
 c003280:	b005      	add	sp, #20
 c003282:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return TFM_PLAT_ERR_SYSTEM_ERR;
 c003286:	2401      	movs	r4, #1
 c003288:	e7f9      	b.n	c00327e <tfm_plat_set_nv_counter+0x6e>
    return TFM_PLAT_ERR_MAX_VALUE;
 c00328a:	2402      	movs	r4, #2
 c00328c:	e7f7      	b.n	c00327e <tfm_plat_set_nv_counter+0x6e>
 c00328e:	bf00      	nop
 c003290:	30030170 	.word	0x30030170
 c003294:	0c00fad0 	.word	0x0c00fad0
 c003298:	0c00f8d1 	.word	0x0c00f8d1
 c00329c:	30030000 	.word	0x30030000

0c0032a0 <otfdec_write_key>:
{
 c0032a0:	b538      	push	{r3, r4, r5, lr}
  if (FLASH_DEV_NAME.EraseSector(OTFDEC_KEY_ADDR) != ARM_DRIVER_OK)
 c0032a2:	4c0d      	ldr	r4, [pc, #52]	; (c0032d8 <otfdec_write_key+0x38>)
{
 c0032a4:	4605      	mov	r5, r0
  if (FLASH_DEV_NAME.EraseSector(OTFDEC_KEY_ADDR) != ARM_DRIVER_OK)
 c0032a6:	69e3      	ldr	r3, [r4, #28]
 c0032a8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 c0032ac:	4798      	blx	r3
 c0032ae:	b108      	cbz	r0, c0032b4 <otfdec_write_key+0x14>
    return BOOT_EFLASH;
 c0032b0:	2001      	movs	r0, #1
}
 c0032b2:	bd38      	pop	{r3, r4, r5, pc}
  if (FLASH_DEV_NAME.ProgramData(OTFDEC_KEY_ADDR, data, OTFDEC_KEY_SIZE)
 c0032b4:	69a4      	ldr	r4, [r4, #24]
 c0032b6:	2210      	movs	r2, #16
 c0032b8:	4629      	mov	r1, r5
 c0032ba:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 c0032be:	47a0      	blx	r4
 c0032c0:	2800      	cmp	r0, #0
 c0032c2:	d1f5      	bne.n	c0032b0 <otfdec_write_key+0x10>
  if (FLASH_DEV_NAME.ProgramData(OTFDEC_MAGIC_ADDR, otfdec_magic, OTFDEC_MAGIC_SZ)
 c0032c4:	2208      	movs	r2, #8
 c0032c6:	4905      	ldr	r1, [pc, #20]	; (c0032dc <otfdec_write_key+0x3c>)
 c0032c8:	f241 0010 	movw	r0, #4112	; 0x1010
 c0032cc:	47a0      	blx	r4
 c0032ce:	3000      	adds	r0, #0
 c0032d0:	bf18      	it	ne
 c0032d2:	2001      	movne	r0, #1
 c0032d4:	e7ed      	b.n	c0032b2 <otfdec_write_key+0x12>
 c0032d6:	bf00      	nop
 c0032d8:	0c00fad0 	.word	0x0c00fad0
 c0032dc:	0c00f9c0 	.word	0x0c00f9c0

0c0032e0 <otfdec_is_key_valid>:
{
 c0032e0:	b507      	push	{r0, r1, r2, lr}
  if (FLASH_DEV_NAME.ReadData(OTFDEC_MAGIC_ADDR, data, OTFDEC_MAGIC_SZ) == ARM_DRIVER_OK)
 c0032e2:	4b0a      	ldr	r3, [pc, #40]	; (c00330c <otfdec_is_key_valid+0x2c>)
 c0032e4:	2208      	movs	r2, #8
 c0032e6:	4669      	mov	r1, sp
 c0032e8:	f241 0010 	movw	r0, #4112	; 0x1010
 c0032ec:	695b      	ldr	r3, [r3, #20]
 c0032ee:	4798      	blx	r3
 c0032f0:	b950      	cbnz	r0, c003308 <otfdec_is_key_valid+0x28>
    if (memcmp(data, otfdec_magic, OTFDEC_MAGIC_SZ) == 0)
 c0032f2:	2208      	movs	r2, #8
 c0032f4:	4906      	ldr	r1, [pc, #24]	; (c003310 <otfdec_is_key_valid+0x30>)
 c0032f6:	4668      	mov	r0, sp
 c0032f8:	f00a fe94 	bl	c00e024 <memcmp>
 c0032fc:	fab0 f080 	clz	r0, r0
 c003300:	0940      	lsrs	r0, r0, #5
}
 c003302:	b003      	add	sp, #12
 c003304:	f85d fb04 	ldr.w	pc, [sp], #4
  return 0;
 c003308:	2000      	movs	r0, #0
 c00330a:	e7fa      	b.n	c003302 <otfdec_is_key_valid+0x22>
 c00330c:	0c00fad0 	.word	0x0c00fad0
 c003310:	0c00f9c0 	.word	0x0c00f9c0

0c003314 <otfdec_invalidate_key>:
{
 c003314:	b513      	push	{r0, r1, r4, lr}
  const uint8_t otfdec_zero[OTFDEC_MAGIC_SZ] = {0};
 c003316:	2400      	movs	r4, #0
 c003318:	e9cd 4400 	strd	r4, r4, [sp]
  if (otfdec_is_key_valid() == 1)
 c00331c:	f7ff ffe0 	bl	c0032e0 <otfdec_is_key_valid>
 c003320:	2801      	cmp	r0, #1
 c003322:	d10b      	bne.n	c00333c <otfdec_invalidate_key+0x28>
    if (FLASH_DEV_NAME.ProgramData(OTFDEC_MAGIC_ADDR, otfdec_zero, OTFDEC_MAGIC_SZ)
 c003324:	4b06      	ldr	r3, [pc, #24]	; (c003340 <otfdec_invalidate_key+0x2c>)
 c003326:	2208      	movs	r2, #8
 c003328:	4669      	mov	r1, sp
 c00332a:	f241 0010 	movw	r0, #4112	; 0x1010
 c00332e:	699b      	ldr	r3, [r3, #24]
 c003330:	4798      	blx	r3
 c003332:	1b00      	subs	r0, r0, r4
 c003334:	bf18      	it	ne
 c003336:	2001      	movne	r0, #1
}
 c003338:	b002      	add	sp, #8
 c00333a:	bd10      	pop	{r4, pc}
  return 0;
 c00333c:	4620      	mov	r0, r4
 c00333e:	e7fb      	b.n	c003338 <otfdec_invalidate_key+0x24>
 c003340:	0c00fad0 	.word	0x0c00fad0

0c003344 <otfdec_read_key>:
{
 c003344:	b508      	push	{r3, lr}
  if (FLASH_DEV_NAME.ReadData(OTFDEC_KEY_ADDR, data, OTFDEC_KEY_SIZE) != ARM_DRIVER_OK)
 c003346:	4b05      	ldr	r3, [pc, #20]	; (c00335c <otfdec_read_key+0x18>)
 c003348:	4601      	mov	r1, r0
 c00334a:	695b      	ldr	r3, [r3, #20]
 c00334c:	2210      	movs	r2, #16
 c00334e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 c003352:	4798      	blx	r3
}
 c003354:	3000      	adds	r0, #0
 c003356:	bf18      	it	ne
 c003358:	2001      	movne	r0, #1
 c00335a:	bd08      	pop	{r3, pc}
 c00335c:	0c00fad0 	.word	0x0c00fad0

0c003360 <otfdec_config>:
{
 c003360:	b530      	push	{r4, r5, lr}
 c003362:	b099      	sub	sp, #100	; 0x64
  OTFDEC_RegionConfigTypeDef OtfdecConfig = {0};
 c003364:	2100      	movs	r1, #0
 c003366:	2214      	movs	r2, #20
 c003368:	a813      	add	r0, sp, #76	; 0x4c
 c00336a:	f00a fe8e 	bl	c00e08a <memset>
  __HAL_RCC_OTFDEC1_CLK_ENABLE();
 c00336e:	4b40      	ldr	r3, [pc, #256]	; (c003470 <otfdec_config+0x110>)
  OtfdecHandle.Instance = OTFDEC1;
 c003370:	ad18      	add	r5, sp, #96	; 0x60
  __HAL_RCC_OTFDEC1_CLK_ENABLE();
 c003372:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003374:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 c003378:	64da      	str	r2, [r3, #76]	; 0x4c
 c00337a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c00337c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 c003380:	9307      	str	r3, [sp, #28]
 c003382:	9b07      	ldr	r3, [sp, #28]
  OtfdecHandle.Instance = OTFDEC1;
 c003384:	4b3b      	ldr	r3, [pc, #236]	; (c003474 <otfdec_config+0x114>)
 c003386:	f845 3d40 	str.w	r3, [r5, #-64]!
  if (HAL_OTFDEC_Init(&OtfdecHandle) != HAL_OK)
 c00338a:	4628      	mov	r0, r5
 c00338c:	f005 f970 	bl	c008670 <HAL_OTFDEC_Init>
 c003390:	4601      	mov	r1, r0
 c003392:	2800      	cmp	r0, #0
 c003394:	d044      	beq.n	c003420 <otfdec_config+0xc0>
    err = ARM_DRIVER_ERROR;
 c003396:	f04f 34ff 	mov.w	r4, #4294967295
  BOOT_LOG_INF("otfdec key %x, %x, %x, %x, %x, %x, %x, %x,",
 c00339a:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
 c00339e:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
 c0033a2:	9004      	str	r0, [sp, #16]
 c0033a4:	f89d 0032 	ldrb.w	r0, [sp, #50]	; 0x32
 c0033a8:	f89d 202d 	ldrb.w	r2, [sp, #45]	; 0x2d
 c0033ac:	9003      	str	r0, [sp, #12]
 c0033ae:	f89d 0031 	ldrb.w	r0, [sp, #49]	; 0x31
 c0033b2:	f89d 102c 	ldrb.w	r1, [sp, #44]	; 0x2c
 c0033b6:	9002      	str	r0, [sp, #8]
 c0033b8:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
 c0033bc:	9001      	str	r0, [sp, #4]
 c0033be:	f89d 002f 	ldrb.w	r0, [sp, #47]	; 0x2f
 c0033c2:	9000      	str	r0, [sp, #0]
 c0033c4:	482c      	ldr	r0, [pc, #176]	; (c003478 <otfdec_config+0x118>)
 c0033c6:	f00a ff11 	bl	c00e1ec <iprintf>
  BOOT_LOG_INF("otfdec key %x, %x, %x, %x, %x, %x, %x, %x,\r\n",
 c0033ca:	f89d 003b 	ldrb.w	r0, [sp, #59]	; 0x3b
 c0033ce:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 c0033d2:	9004      	str	r0, [sp, #16]
 c0033d4:	f89d 003a 	ldrb.w	r0, [sp, #58]	; 0x3a
 c0033d8:	f89d 2035 	ldrb.w	r2, [sp, #53]	; 0x35
 c0033dc:	9003      	str	r0, [sp, #12]
 c0033de:	f89d 0039 	ldrb.w	r0, [sp, #57]	; 0x39
 c0033e2:	f89d 1034 	ldrb.w	r1, [sp, #52]	; 0x34
 c0033e6:	9002      	str	r0, [sp, #8]
 c0033e8:	f89d 0038 	ldrb.w	r0, [sp, #56]	; 0x38
 c0033ec:	9001      	str	r0, [sp, #4]
 c0033ee:	f89d 0037 	ldrb.w	r0, [sp, #55]	; 0x37
 c0033f2:	9000      	str	r0, [sp, #0]
 c0033f4:	4821      	ldr	r0, [pc, #132]	; (c00347c <otfdec_config+0x11c>)
 c0033f6:	f00a fef9 	bl	c00e1ec <iprintf>
  if (err == ARM_DRIVER_OK)
 c0033fa:	b9fc      	cbnz	r4, c00343c <otfdec_config+0xdc>
 c0033fc:	ab0f      	add	r3, sp, #60	; 0x3c
    for (i = 0; i < OTFDEC_KEY_SIZE; i++)
 c0033fe:	4620      	mov	r0, r4
 c003400:	461a      	mov	r2, r3
      key_swapped[i] = key[OTFDEC_KEY_SIZE - 1 - i];
 c003402:	f813 1d01 	ldrb.w	r1, [r3, #-1]!
 c003406:	5411      	strb	r1, [r2, r0]
    for (i = 0; i < OTFDEC_KEY_SIZE; i++)
 c003408:	3001      	adds	r0, #1
 c00340a:	2810      	cmp	r0, #16
 c00340c:	d1f9      	bne.n	c003402 <otfdec_config+0xa2>
      && (HAL_OTFDEC_RegionSetKey(&OtfdecHandle, OTFDEC_REGION1,
 c00340e:	2100      	movs	r1, #0
 c003410:	4628      	mov	r0, r5
 c003412:	f005 f9bb 	bl	c00878c <HAL_OTFDEC_RegionSetKey>
 c003416:	1c01      	adds	r1, r0, #0
 c003418:	bf18      	it	ne
 c00341a:	2101      	movne	r1, #1
 c00341c:	4249      	negs	r1, r1
 c00341e:	e00f      	b.n	c003440 <otfdec_config+0xe0>
      && (HAL_OTFDEC_RegionSetMode(&OtfdecHandle, OTFDEC_REGION1,
 c003420:	2220      	movs	r2, #32
 c003422:	4628      	mov	r0, r5
 c003424:	f005 f932 	bl	c00868c <HAL_OTFDEC_RegionSetMode>
 c003428:	2800      	cmp	r0, #0
 c00342a:	d1b4      	bne.n	c003396 <otfdec_config+0x36>
      && (otfdec_read_key(key) != 0))
 c00342c:	a80b      	add	r0, sp, #44	; 0x2c
 c00342e:	f7ff ff89 	bl	c003344 <otfdec_read_key>
 c003432:	3000      	adds	r0, #0
 c003434:	bf18      	it	ne
 c003436:	2001      	movne	r0, #1
 c003438:	4244      	negs	r4, r0
 c00343a:	e7ae      	b.n	c00339a <otfdec_config+0x3a>
 c00343c:	f04f 31ff 	mov.w	r1, #4294967295
  OtfdecConfig.Nonce[0]     = 0x0;
 c003440:	2300      	movs	r3, #0
  OtfdecConfig.EndAddress   = NS_CODE_START + NS_CODE_SIZE;
 c003442:	480f      	ldr	r0, [pc, #60]	; (c003480 <otfdec_config+0x120>)
 c003444:	4a0f      	ldr	r2, [pc, #60]	; (c003484 <otfdec_config+0x124>)
  OtfdecConfig.Nonce[1]     = 0x0;
 c003446:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
  OtfdecConfig.EndAddress   = NS_CODE_START + NS_CODE_SIZE;
 c00344a:	e9cd 0215 	strd	r0, r2, [sp, #84]	; 0x54
  OtfdecConfig.Version      = 0x0;
 c00344e:	f8ad 305c 	strh.w	r3, [sp, #92]	; 0x5c
  if ((err == ARM_DRIVER_OK)
 c003452:	b951      	cbnz	r1, c00346a <otfdec_config+0x10a>
      && (HAL_OTFDEC_RegionConfig(&OtfdecHandle, OTFDEC_REGION1, &OtfdecConfig,
 c003454:	2302      	movs	r3, #2
 c003456:	aa13      	add	r2, sp, #76	; 0x4c
 c003458:	4628      	mov	r0, r5
 c00345a:	f005 f92a 	bl	c0086b2 <HAL_OTFDEC_RegionConfig>
 c00345e:	3000      	adds	r0, #0
 c003460:	bf18      	it	ne
 c003462:	2001      	movne	r0, #1
 c003464:	4240      	negs	r0, r0
}
 c003466:	b019      	add	sp, #100	; 0x64
 c003468:	bd30      	pop	{r4, r5, pc}
 c00346a:	f04f 30ff 	mov.w	r0, #4294967295
  return err;
 c00346e:	e7fa      	b.n	c003466 <otfdec_config+0x106>
 c003470:	50021000 	.word	0x50021000
 c003474:	520c5000 	.word	0x520c5000
 c003478:	0c00f955 	.word	0x0c00f955
 c00347c:	0c00f988 	.word	0x0c00f988
 c003480:	90000400 	.word	0x90000400
 c003484:	900fe000 	.word	0x900fe000

0c003488 <HAL_InitTick>:
  uint32_t ticks = SystemCoreClock ;
 c003488:	4b04      	ldr	r3, [pc, #16]	; (c00349c <HAL_InitTick+0x14>)
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c00348a:	2000      	movs	r0, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 c00348c:	681a      	ldr	r2, [r3, #0]
 c00348e:	4b04      	ldr	r3, [pc, #16]	; (c0034a0 <HAL_InitTick+0x18>)
 c003490:	3a01      	subs	r2, #1
 c003492:	605a      	str	r2, [r3, #4]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c003494:	2205      	movs	r2, #5
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 c003496:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 c003498:	601a      	str	r2, [r3, #0]
}
 c00349a:	4770      	bx	lr
 c00349c:	300300a0 	.word	0x300300a0
 c0034a0:	e000e010 	.word	0xe000e010

0c0034a4 <HAL_GetTick>:
{
 c0034a4:	b530      	push	{r4, r5, lr}
  if (t2 <= t1)
 c0034a6:	4910      	ldr	r1, [pc, #64]	; (c0034e8 <HAL_GetTick+0x44>)
  t2 =  SysTick->VAL;
 c0034a8:	4c10      	ldr	r4, [pc, #64]	; (c0034ec <HAL_GetTick+0x48>)
 c0034aa:	4a11      	ldr	r2, [pc, #68]	; (c0034f0 <HAL_GetTick+0x4c>)
 c0034ac:	68a0      	ldr	r0, [r4, #8]
  if (t2 <= t1)
 c0034ae:	680b      	ldr	r3, [r1, #0]
 c0034b0:	6815      	ldr	r5, [r2, #0]
 c0034b2:	4283      	cmp	r3, r0
    tdelta += t1 + SysTick->LOAD - t2;
 c0034b4:	bf38      	it	cc
 c0034b6:	6864      	ldrcc	r4, [r4, #4]
 c0034b8:	442b      	add	r3, r5
 c0034ba:	bf38      	it	cc
 c0034bc:	191b      	addcc	r3, r3, r4
  if (tdelta > (SystemCoreClock / (1000U)))
 c0034be:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    tdelta += t1 + SysTick->LOAD - t2;
 c0034c2:	1a1b      	subs	r3, r3, r0
 c0034c4:	6013      	str	r3, [r2, #0]
  if (tdelta > (SystemCoreClock / (1000U)))
 c0034c6:	4b0b      	ldr	r3, [pc, #44]	; (c0034f4 <HAL_GetTick+0x50>)
 c0034c8:	681b      	ldr	r3, [r3, #0]
 c0034ca:	fbb3 f3f4 	udiv	r3, r3, r4
 c0034ce:	6814      	ldr	r4, [r2, #0]
 c0034d0:	42a3      	cmp	r3, r4
 c0034d2:	4b09      	ldr	r3, [pc, #36]	; (c0034f8 <HAL_GetTick+0x54>)
 c0034d4:	d204      	bcs.n	c0034e0 <HAL_GetTick+0x3c>
    tdelta = 0U;
 c0034d6:	2500      	movs	r5, #0
 c0034d8:	681c      	ldr	r4, [r3, #0]
 c0034da:	6015      	str	r5, [r2, #0]
    m_uTick ++;
 c0034dc:	3401      	adds	r4, #1
 c0034de:	601c      	str	r4, [r3, #0]
  t1 = t2;
 c0034e0:	6008      	str	r0, [r1, #0]
}
 c0034e2:	6818      	ldr	r0, [r3, #0]
 c0034e4:	bd30      	pop	{r4, r5, pc}
 c0034e6:	bf00      	nop
 c0034e8:	3003017c 	.word	0x3003017c
 c0034ec:	e000e010 	.word	0xe000e010
 c0034f0:	30030180 	.word	0x30030180
 c0034f4:	300300a0 	.word	0x300300a0
 c0034f8:	30030178 	.word	0x30030178

0c0034fc <boot_platform_noimage>:
{
 c0034fc:	b500      	push	{lr}
  if (OSPI_FLASH_DEV_NAME.Uninitialize() != ARM_DRIVER_OK)
 c0034fe:	4b37      	ldr	r3, [pc, #220]	; (c0035dc <boot_platform_noimage+0xe0>)
{
 c003500:	b089      	sub	sp, #36	; 0x24
  if (OSPI_FLASH_DEV_NAME.Uninitialize() != ARM_DRIVER_OK)
 c003502:	68db      	ldr	r3, [r3, #12]
 c003504:	4798      	blx	r3
 c003506:	b120      	cbz	r0, c003512 <boot_platform_noimage+0x16>
	BOOT_LOG_ERR("Error while initializing ospi Flash Interface");
 c003508:	4835      	ldr	r0, [pc, #212]	; (c0035e0 <boot_platform_noimage+0xe4>)
 c00350a:	f00a fee3 	bl	c00e2d4 <puts>
    Error_Handler();
 c00350e:	f00e fa07 	bl	c011920 <Error_Handler>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 c003512:	4b34      	ldr	r3, [pc, #208]	; (c0035e4 <boot_platform_noimage+0xe8>)
 c003514:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003516:	f042 0201 	orr.w	r2, r2, #1
 c00351a:	64da      	str	r2, [r3, #76]	; 0x4c
 c00351c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00351e:	f002 0201 	and.w	r2, r2, #1
 c003522:	9200      	str	r2, [sp, #0]
 c003524:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 c003526:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003528:	f042 0202 	orr.w	r2, r2, #2
 c00352c:	64da      	str	r2, [r3, #76]	; 0x4c
 c00352e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003530:	f002 0202 	and.w	r2, r2, #2
 c003534:	9201      	str	r2, [sp, #4]
 c003536:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 c003538:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00353a:	f042 0204 	orr.w	r2, r2, #4
 c00353e:	64da      	str	r2, [r3, #76]	; 0x4c
 c003540:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003542:	f002 0204 	and.w	r2, r2, #4
 c003546:	9202      	str	r2, [sp, #8]
 c003548:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 c00354a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00354c:	f042 0208 	orr.w	r2, r2, #8
 c003550:	64da      	str	r2, [r3, #76]	; 0x4c
 c003552:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003554:	f002 0208 	and.w	r2, r2, #8
 c003558:	9203      	str	r2, [sp, #12]
 c00355a:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 c00355c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00355e:	f042 0210 	orr.w	r2, r2, #16
 c003562:	64da      	str	r2, [r3, #76]	; 0x4c
 c003564:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003566:	f002 0210 	and.w	r2, r2, #16
 c00356a:	9204      	str	r2, [sp, #16]
 c00356c:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 c00356e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003570:	f042 0220 	orr.w	r2, r2, #32
 c003574:	64da      	str	r2, [r3, #76]	; 0x4c
 c003576:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003578:	f002 0220 	and.w	r2, r2, #32
 c00357c:	9205      	str	r2, [sp, #20]
 c00357e:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 c003580:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003582:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 c003586:	64da      	str	r2, [r3, #76]	; 0x4c
 c003588:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00358a:	f002 0240 	and.w	r2, r2, #64	; 0x40
 c00358e:	9206      	str	r2, [sp, #24]
 c003590:	9a06      	ldr	r2, [sp, #24]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c003592:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003594:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c003598:	64da      	str	r2, [r3, #76]	; 0x4c
 c00359a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  GPIOA_S->SECCFGR = 0x0;
 c00359c:	4a12      	ldr	r2, [pc, #72]	; (c0035e8 <boot_platform_noimage+0xec>)
  __HAL_RCC_GPIOH_CLK_ENABLE();
 c00359e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 c0035a2:	9307      	str	r3, [sp, #28]
 c0035a4:	9b07      	ldr	r3, [sp, #28]
  GPIOA_S->SECCFGR = 0x0;
 c0035a6:	2300      	movs	r3, #0
 c0035a8:	6313      	str	r3, [r2, #48]	; 0x30
  GPIOB_S->SECCFGR = 0x0;
 c0035aa:	f8c2 3430 	str.w	r3, [r2, #1072]	; 0x430
  GPIOC_S->SECCFGR = 0x0;
 c0035ae:	f8c2 3830 	str.w	r3, [r2, #2096]	; 0x830
  GPIOD_S->SECCFGR = 0x0;
 c0035b2:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOB_S->SECCFGR = 0x0;
 c0035b6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOE_S->SECCFGR = 0x0;
 c0035ba:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOC_S->SECCFGR = 0x0;
 c0035be:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOF_S->SECCFGR = 0x0;
 c0035c2:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOD_S->SECCFGR = 0x0;
 c0035c6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOG_S->SECCFGR = 0x0;
 c0035ca:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  GPIOE_S->SECCFGR = 0x0;
 c0035ce:	f502 6280 	add.w	r2, r2, #1024	; 0x400
  GPIOH_S->SECCFGR = 0x0;
 c0035d2:	f8c2 3c30 	str.w	r3, [r2, #3120]	; 0xc30
  execute_loader();
 c0035d6:	f00e f96e 	bl	c0118b6 <execute_loader>
 c0035da:	bf00      	nop
 c0035dc:	0c00fb18 	.word	0x0c00fb18
 c0035e0:	0c00f920 	.word	0x0c00f920
 c0035e4:	50021000 	.word	0x50021000
 c0035e8:	52020000 	.word	0x52020000

0c0035ec <icache_init>:
{
 c0035ec:	b508      	push	{r3, lr}
  if (HAL_ICACHE_Enable() != HAL_OK)
 c0035ee:	f004 fcdb 	bl	c007fa8 <HAL_ICACHE_Enable>
 c0035f2:	b118      	cbz	r0, c0035fc <icache_init+0x10>
}
 c0035f4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 c0035f8:	f00e b992 	b.w	c011920 <Error_Handler>
}
 c0035fc:	bd08      	pop	{r3, pc}
	...

0c003600 <boot_platform_init>:
{
 c003600:	b570      	push	{r4, r5, r6, lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 c003602:	4c3b      	ldr	r4, [pc, #236]	; (c0036f0 <boot_platform_init+0xf0>)
{
 c003604:	b088      	sub	sp, #32
  HAL_Init();
 c003606:	f002 ff54 	bl	c0064b2 <HAL_Init>
  stdio_init();
 c00360a:	f00a fcbf 	bl	c00df8c <stdio_init>
  icache_init();
 c00360e:	f7ff ffed 	bl	c0035ec <icache_init>
  TFM_LL_SECU_ApplyRunTimeProtections();
 c003612:	f001 fb2b 	bl	c004c6c <TFM_LL_SECU_ApplyRunTimeProtections>
  TFM_LL_SECU_CheckStaticProtections();
 c003616:	f001 fcb5 	bl	c004f84 <TFM_LL_SECU_CheckStaticProtections>
  __HAL_RCC_PWR_CLK_ENABLE();
 c00361a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c00361c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c003620:	65a3      	str	r3, [r4, #88]	; 0x58
 c003622:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c003624:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c003628:	9301      	str	r3, [sp, #4]
 c00362a:	9b01      	ldr	r3, [sp, #4]
  HAL_PWREx_EnableSRAM2ContentRetention();
 c00362c:	f005 face 	bl	c008bcc <HAL_PWREx_EnableSRAM2ContentRetention>
  __HAL_RCC_RTC_DISABLE();
 c003630:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
  RTCHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
 c003634:	227f      	movs	r2, #127	; 0x7f
  __HAL_RCC_RTC_DISABLE();
 c003636:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 c00363a:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
  RTCHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
 c00363e:	2300      	movs	r3, #0
  RTCHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
 c003640:	482c      	ldr	r0, [pc, #176]	; (c0036f4 <boot_platform_init+0xf4>)
  RTCHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
 c003642:	e9c0 3201 	strd	r3, r2, [r0, #4]
  RTCHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
 c003646:	22ff      	movs	r2, #255	; 0xff
  RTCHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
 c003648:	e9c0 2303 	strd	r2, r3, [r0, #12]
  RTCHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
 c00364c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 c003650:	61c2      	str	r2, [r0, #28]
  RTCHandle.Instance            = RTC;
 c003652:	4a29      	ldr	r2, [pc, #164]	; (c0036f8 <boot_platform_init+0xf8>)
  RTCHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 c003654:	6183      	str	r3, [r0, #24]
  RTCHandle.Instance            = RTC;
 c003656:	6002      	str	r2, [r0, #0]
  RTCHandle.State = HAL_RTC_STATE_RESET;
 c003658:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25
  if (HAL_RTC_Init(&RTCHandle) != HAL_OK)
 c00365c:	f006 fb86 	bl	c009d6c <HAL_RTC_Init>
 c003660:	b108      	cbz	r0, c003666 <boot_platform_init+0x66>
    Error_Handler();
 c003662:	f00e f95d 	bl	c011920 <Error_Handler>
{
 c003666:	2400      	movs	r4, #0
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, BL2_RTC_CLEANUP_VALUE);
 c003668:	4e24      	ldr	r6, [pc, #144]	; (c0036fc <boot_platform_init+0xfc>)
 c00366a:	4d22      	ldr	r5, [pc, #136]	; (c0036f4 <boot_platform_init+0xf4>)
 c00366c:	08a1      	lsrs	r1, r4, #2
 c00366e:	4632      	mov	r2, r6
 c003670:	4628      	mov	r0, r5
  for (i = 0; i < BL2_RTC_SHARED_DATA_SIZE ; i += 4)
 c003672:	3404      	adds	r4, #4
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, BL2_RTC_CLEANUP_VALUE);
 c003674:	f006 fbc2 	bl	c009dfc <HAL_RTCEx_BKUPWrite>
  for (i = 0; i < BL2_RTC_SHARED_DATA_SIZE ; i += 4)
 c003678:	2c20      	cmp	r4, #32
 c00367a:	d1f7      	bne.n	c00366c <boot_platform_init+0x6c>
  TFM_LL_SECU_ApplyRunTimeProtections();
 c00367c:	f001 faf6 	bl	c004c6c <TFM_LL_SECU_ApplyRunTimeProtections>
  TFM_LL_SECU_CheckStaticProtections();
 c003680:	f001 fc80 	bl	c004f84 <TFM_LL_SECU_CheckStaticProtections>
  if (FLASH_DEV_NAME.Initialize(NULL) != ARM_DRIVER_OK)
 c003684:	4b1e      	ldr	r3, [pc, #120]	; (c003700 <boot_platform_init+0x100>)
 c003686:	2000      	movs	r0, #0
 c003688:	689b      	ldr	r3, [r3, #8]
 c00368a:	4798      	blx	r3
 c00368c:	b120      	cbz	r0, c003698 <boot_platform_init+0x98>
    BOOT_LOG_ERR("Error while initializing Flash Interface");
 c00368e:	481d      	ldr	r0, [pc, #116]	; (c003704 <boot_platform_init+0x104>)
 c003690:	f00a fe20 	bl	c00e2d4 <puts>
    Error_Handler();
 c003694:	f00e f944 	bl	c011920 <Error_Handler>
  if (OSPI_FLASH_DEV_NAME.Initialize(NULL) != ARM_DRIVER_OK)
 c003698:	4b1b      	ldr	r3, [pc, #108]	; (c003708 <boot_platform_init+0x108>)
 c00369a:	2000      	movs	r0, #0
 c00369c:	689b      	ldr	r3, [r3, #8]
 c00369e:	4798      	blx	r3
 c0036a0:	b120      	cbz	r0, c0036ac <boot_platform_init+0xac>
    BOOT_LOG_ERR("Error while initializing ospi Flash Interface");
 c0036a2:	481a      	ldr	r0, [pc, #104]	; (c00370c <boot_platform_init+0x10c>)
 c0036a4:	f00a fe16 	bl	c00e2d4 <puts>
    Error_Handler();
 c0036a8:	f00e f93a 	bl	c011920 <Error_Handler>
  BUTTON_CLK_ENABLE;
 c0036ac:	4b10      	ldr	r3, [pc, #64]	; (c0036f0 <boot_platform_init+0xf0>)
  GPIO_Init.Mode      = 0;
 c0036ae:	2400      	movs	r4, #0
  BUTTON_CLK_ENABLE;
 c0036b0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  GPIO_Init.Mode      = 0;
 c0036b2:	f44f 5500 	mov.w	r5, #8192	; 0x2000
  BUTTON_CLK_ENABLE;
 c0036b6:	f042 0204 	orr.w	r2, r2, #4
 c0036ba:	64da      	str	r2, [r3, #76]	; 0x4c
 c0036bc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  HAL_GPIO_Init(BUTTON_PORT, &GPIO_Init);
 c0036be:	a903      	add	r1, sp, #12
  BUTTON_CLK_ENABLE;
 c0036c0:	f003 0304 	and.w	r3, r3, #4
 c0036c4:	9302      	str	r3, [sp, #8]
 c0036c6:	9b02      	ldr	r3, [sp, #8]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 c0036c8:	2302      	movs	r3, #2
  HAL_GPIO_Init(BUTTON_PORT, &GPIO_Init);
 c0036ca:	4811      	ldr	r0, [pc, #68]	; (c003710 <boot_platform_init+0x110>)
  GPIO_Init.Pull      = GPIO_NOPULL;
 c0036cc:	e9cd 4305 	strd	r4, r3, [sp, #20]
  GPIO_Init.Mode      = 0;
 c0036d0:	e9cd 5403 	strd	r5, r4, [sp, #12]
  GPIO_Init.Alternate = 0;
 c0036d4:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(BUTTON_PORT, &GPIO_Init);
 c0036d6:	f004 f82d 	bl	c007734 <HAL_GPIO_Init>
  if (HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN) == GPIO_PIN_SET)
 c0036da:	4629      	mov	r1, r5
 c0036dc:	480c      	ldr	r0, [pc, #48]	; (c003710 <boot_platform_init+0x110>)
 c0036de:	f004 f97f 	bl	c0079e0 <HAL_GPIO_ReadPin>
 c0036e2:	2801      	cmp	r0, #1
 c0036e4:	d101      	bne.n	c0036ea <boot_platform_init+0xea>
    boot_platform_noimage();
 c0036e6:	f7ff ff09 	bl	c0034fc <boot_platform_noimage>
}
 c0036ea:	4620      	mov	r0, r4
 c0036ec:	b008      	add	sp, #32
 c0036ee:	bd70      	pop	{r4, r5, r6, pc}
 c0036f0:	50021000 	.word	0x50021000
 c0036f4:	3003e3f8 	.word	0x3003e3f8
 c0036f8:	50002800 	.word	0x50002800
 c0036fc:	dadabeef 	.word	0xdadabeef
 c003700:	0c00fad0 	.word	0x0c00fad0
 c003704:	0c00f8f0 	.word	0x0c00f8f0
 c003708:	0c00fb18 	.word	0x0c00fb18
 c00370c:	0c00f920 	.word	0x0c00f920
 c003710:	52020800 	.word	0x52020800

0c003714 <USART_GetVersion>:
  0  /* Reserved */
};

static ARM_DRIVER_VERSION USART_GetVersion(void)
{
  return DriverVersion;
 c003714:	4b03      	ldr	r3, [pc, #12]	; (c003724 <USART_GetVersion+0x10>)
{
 c003716:	b082      	sub	sp, #8
  return DriverVersion;
 c003718:	6818      	ldr	r0, [r3, #0]
 c00371a:	b283      	uxth	r3, r0
}
 c00371c:	f363 000f 	bfi	r0, r3, #0, #16
 c003720:	b002      	add	sp, #8
 c003722:	4770      	bx	lr
 c003724:	0c00fa76 	.word	0x0c00fa76

0c003728 <USART_GetCapabilities>:

static ARM_USART_CAPABILITIES USART_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c003728:	2001      	movs	r0, #1
 c00372a:	4770      	bx	lr

0c00372c <USART0_Uninitialize>:

static int32_t USART0_Uninitialize(void)
{
  /* Nothing to be done */
  return ARM_DRIVER_OK;
}
 c00372c:	2000      	movs	r0, #0
 c00372e:	4770      	bx	lr

0c003730 <USART0_PowerControl>:

static int32_t USART0_PowerControl(ARM_POWER_STATE state)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c003730:	f06f 0003 	mvn.w	r0, #3
 c003734:	4770      	bx	lr

0c003736 <USART0_Transfer>:
  ARG_UNUSED(data_out);
  ARG_UNUSED(data_in);
  ARG_UNUSED(num);

  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c003736:	f06f 0003 	mvn.w	r0, #3
 c00373a:	4770      	bx	lr

0c00373c <USART0_GetTxCount>:

static uint32_t USART0_GetTxCount(void)
{
  return (uint32_t)ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c00373c:	f06f 0003 	mvn.w	r0, #3
 c003740:	4770      	bx	lr

0c003742 <USART0_Control>:
  return (uint32_t)ARM_DRIVER_ERROR_UNSUPPORTED;
}
static int32_t USART0_Control(uint32_t control, uint32_t arg)
{
  return ARM_DRIVER_OK;
}
 c003742:	2000      	movs	r0, #0
 c003744:	4770      	bx	lr

0c003746 <USART0_GetStatus>:

static ARM_USART_STATUS USART0_GetStatus(void)
{
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c003746:	2300      	movs	r3, #0
{
 c003748:	b082      	sub	sp, #8
  ARM_USART_STATUS status = {0, 0, 0, 0, 0, 0, 0, 0};
 c00374a:	9301      	str	r3, [sp, #4]
  return status;
 c00374c:	9801      	ldr	r0, [sp, #4]
}
 c00374e:	b002      	add	sp, #8
 c003750:	4770      	bx	lr

0c003752 <USART0_GetModemStatus>:
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}

static ARM_USART_MODEM_STATUS USART0_GetModemStatus(void)
{
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c003752:	2300      	movs	r3, #0
{
 c003754:	b082      	sub	sp, #8
  ARM_USART_MODEM_STATUS modem_status = {0, 0, 0, 0, 0};
 c003756:	9301      	str	r3, [sp, #4]
  return modem_status;
 c003758:	9801      	ldr	r0, [sp, #4]
}
 c00375a:	b002      	add	sp, #8
 c00375c:	4770      	bx	lr
	...

0c003760 <USART0_Receive>:
{
 c003760:	b510      	push	{r4, lr}
 c003762:	460c      	mov	r4, r1
  if ((data == NULL) || (num == 0U))
 c003764:	4601      	mov	r1, r0
 c003766:	b130      	cbz	r0, c003776 <USART0_Receive+0x16>
 c003768:	b12c      	cbz	r4, c003776 <USART0_Receive+0x16>
  HAL_UART_Receive_IT(&uart_device, data, num);
 c00376a:	b2a2      	uxth	r2, r4
 c00376c:	4803      	ldr	r0, [pc, #12]	; (c00377c <USART0_Receive+0x1c>)
 c00376e:	f007 f82f 	bl	c00a7d0 <HAL_UART_Receive_IT>
  return num;
 c003772:	4620      	mov	r0, r4
}
 c003774:	bd10      	pop	{r4, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c003776:	f06f 0004 	mvn.w	r0, #4
 c00377a:	e7fb      	b.n	c003774 <USART0_Receive+0x14>
 c00377c:	30030188 	.word	0x30030188

0c003780 <USART0_Send>:
{
 c003780:	b508      	push	{r3, lr}
  if ((data == NULL) || (num == 0U))
 c003782:	b148      	cbz	r0, c003798 <USART0_Send+0x18>
 c003784:	b141      	cbz	r1, c003798 <USART0_Send+0x18>
  HAL_UART_Transmit(&uart_device, (uint8_t *) data, num,  1000);
 c003786:	b28a      	uxth	r2, r1
 c003788:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 c00378c:	4601      	mov	r1, r0
 c00378e:	4804      	ldr	r0, [pc, #16]	; (c0037a0 <USART0_Send+0x20>)
 c003790:	f006 fefa 	bl	c00a588 <HAL_UART_Transmit>
  return ARM_DRIVER_OK;
 c003794:	2000      	movs	r0, #0
}
 c003796:	bd08      	pop	{r3, pc}
    return ARM_DRIVER_ERROR_PARAMETER;
 c003798:	f06f 0004 	mvn.w	r0, #4
 c00379c:	e7fb      	b.n	c003796 <USART0_Send+0x16>
 c00379e:	bf00      	nop
 c0037a0:	30030188 	.word	0x30030188

0c0037a4 <USART0_Initialize>:
  COM_TX_GPIO_CLK_ENABLE();
 c0037a4:	4b27      	ldr	r3, [pc, #156]	; (c003844 <USART0_Initialize+0xa0>)
{
 c0037a6:	b530      	push	{r4, r5, lr}
  COM_TX_GPIO_CLK_ENABLE();
 c0037a8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 c0037aa:	b089      	sub	sp, #36	; 0x24
  COM_TX_GPIO_CLK_ENABLE();
 c0037ac:	f042 0201 	orr.w	r2, r2, #1
 c0037b0:	64da      	str	r2, [r3, #76]	; 0x4c
 c0037b2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  GPIO_Init.Alternate = COM_TX_AF;
 c0037b4:	2507      	movs	r5, #7
  COM_TX_GPIO_CLK_ENABLE();
 c0037b6:	f002 0201 	and.w	r2, r2, #1
 c0037ba:	9200      	str	r2, [sp, #0]
 c0037bc:	9a00      	ldr	r2, [sp, #0]
  COM_RX_GPIO_CLK_ENABLE();
 c0037be:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c0037c0:	4c21      	ldr	r4, [pc, #132]	; (c003848 <USART0_Initialize+0xa4>)
  COM_RX_GPIO_CLK_ENABLE();
 c0037c2:	f042 0201 	orr.w	r2, r2, #1
 c0037c6:	64da      	str	r2, [r3, #76]	; 0x4c
 c0037c8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c0037ca:	a903      	add	r1, sp, #12
  COM_RX_GPIO_CLK_ENABLE();
 c0037cc:	f002 0201 	and.w	r2, r2, #1
 c0037d0:	9201      	str	r2, [sp, #4]
 c0037d2:	9a01      	ldr	r2, [sp, #4]
  COM_CLK_ENABLE();
 c0037d4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c0037d6:	4620      	mov	r0, r4
  COM_CLK_ENABLE();
 c0037d8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 c0037dc:	661a      	str	r2, [r3, #96]	; 0x60
 c0037de:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c0037e0:	f44f 7200 	mov.w	r2, #512	; 0x200
  COM_CLK_ENABLE();
 c0037e4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 c0037e8:	9302      	str	r3, [sp, #8]
 c0037ea:	9b02      	ldr	r3, [sp, #8]
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
 c0037ec:	2302      	movs	r3, #2
 c0037ee:	e9cd 2303 	strd	r2, r3, [sp, #12]
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
 c0037f2:	9306      	str	r3, [sp, #24]
  GPIO_Init.Pull      = GPIO_PULLUP;
 c0037f4:	2301      	movs	r3, #1
  GPIO_Init.Alternate = COM_TX_AF;
 c0037f6:	9507      	str	r5, [sp, #28]
  GPIO_Init.Pull      = GPIO_PULLUP;
 c0037f8:	9305      	str	r3, [sp, #20]
  HAL_GPIO_Init(COM_TX_GPIO_PORT, &GPIO_Init);
 c0037fa:	f003 ff9b 	bl	c007734 <HAL_GPIO_Init>
  GPIO_Init.Pin       = COM_RX_PIN;
 c0037fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
  HAL_GPIO_Init(COM_RX_GPIO_PORT, &GPIO_Init);
 c003802:	a903      	add	r1, sp, #12
 c003804:	4620      	mov	r0, r4
  GPIO_Init.Pin       = COM_RX_PIN;
 c003806:	9303      	str	r3, [sp, #12]
  GPIO_Init.Alternate = COM_RX_AF;
 c003808:	9507      	str	r5, [sp, #28]
  HAL_GPIO_Init(COM_RX_GPIO_PORT, &GPIO_Init);
 c00380a:	f003 ff93 	bl	c007734 <HAL_GPIO_Init>
  uart_device.Init.BaudRate       = 115200;
 c00380e:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  uart_device.Instance = COM_INSTANCE;
 c003812:	480e      	ldr	r0, [pc, #56]	; (c00384c <USART0_Initialize+0xa8>)
  uart_device.Init.BaudRate       = 115200;
 c003814:	490e      	ldr	r1, [pc, #56]	; (c003850 <USART0_Initialize+0xac>)
  uart_device.Init.Mode           = UART_MODE_TX_RX;
 c003816:	220c      	movs	r2, #12
  uart_device.Init.BaudRate       = 115200;
 c003818:	e9c0 1300 	strd	r1, r3, [r0]
  uart_device.Init.WordLength     = UART_WORDLENGTH_8B;
 c00381c:	2300      	movs	r3, #0
  uart_device.Init.HwFlowCtl      = UART_HWCONTROL_NONE;
 c00381e:	e9c0 2305 	strd	r2, r3, [r0, #20]
  uart_device.Init.OverSampling   = UART_OVERSAMPLING_8;
 c003822:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  uart_device.Init.StopBits       = UART_STOPBITS_1;
 c003826:	e9c0 3302 	strd	r3, r3, [r0, #8]
  uart_device.Init.Parity         = UART_PARITY_NONE;
 c00382a:	6103      	str	r3, [r0, #16]
  uart_device.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 c00382c:	e9c0 2307 	strd	r2, r3, [r0, #28]
  uart_device.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 c003830:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&uart_device) != HAL_OK)
 c003832:	f006 ff39 	bl	c00a6a8 <HAL_UART_Init>
 c003836:	3000      	adds	r0, #0
 c003838:	bf18      	it	ne
 c00383a:	2001      	movne	r0, #1
}
 c00383c:	4240      	negs	r0, r0
 c00383e:	b009      	add	sp, #36	; 0x24
 c003840:	bd30      	pop	{r4, r5, pc}
 c003842:	bf00      	nop
 c003844:	50021000 	.word	0x50021000
 c003848:	52020000 	.word	0x52020000
 c00384c:	30030188 	.word	0x30030188
 c003850:	50013800 	.word	0x50013800

0c003854 <USART0_SetModemControl>:
 c003854:	f06f 0003 	mvn.w	r0, #3
 c003858:	4770      	bx	lr

0c00385a <USART0_GetRxCount>:
 c00385a:	f06f 0003 	mvn.w	r0, #3
 c00385e:	4770      	bx	lr

0c003860 <Flash_GetVersion>:
static ARM_FLASH_STATUS ARM_FLASH0_STATUS = {0, 0, 0};

#if !defined(LOCAL_LOADER_CONFIG)
static ARM_DRIVER_VERSION Flash_GetVersion(void)
{
  return DriverVersion;
 c003860:	4b03      	ldr	r3, [pc, #12]	; (c003870 <Flash_GetVersion+0x10>)
{
 c003862:	b082      	sub	sp, #8
  return DriverVersion;
 c003864:	6818      	ldr	r0, [r3, #0]
 c003866:	b283      	uxth	r3, r0
}
 c003868:	f363 000f 	bfi	r0, r3, #0, #16
 c00386c:	b002      	add	sp, #8
 c00386e:	4770      	bx	lr
 c003870:	0c00facc 	.word	0x0c00facc

0c003874 <Flash_GetCapabilities>:

static ARM_FLASH_CAPABILITIES Flash_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c003874:	200c      	movs	r0, #12
 c003876:	4770      	bx	lr

0c003878 <Flash_Uninitialize>:
}
#if !defined(LOCAL_LOADER_CONFIG)
static int32_t Flash_Uninitialize(void)
{
  return ARM_DRIVER_OK;
}
 c003878:	2000      	movs	r0, #0
 c00387a:	4770      	bx	lr

0c00387c <Flash_PowerControl>:

static int32_t Flash_PowerControl(ARM_POWER_STATE state)
{
  switch (state)
 c00387c:	2801      	cmp	r0, #1
 c00387e:	d905      	bls.n	c00388c <Flash_PowerControl+0x10>
 c003880:	2802      	cmp	r0, #2
      return ARM_DRIVER_OK;
    case ARM_POWER_OFF:
    case ARM_POWER_LOW:
      return ARM_DRIVER_ERROR_UNSUPPORTED;
    default:
      return ARM_DRIVER_ERROR_PARAMETER;
 c003882:	bf0c      	ite	eq
 c003884:	2000      	moveq	r0, #0
 c003886:	f06f 0004 	mvnne.w	r0, #4
 c00388a:	4770      	bx	lr
      return ARM_DRIVER_ERROR_UNSUPPORTED;
 c00388c:	f06f 0003 	mvn.w	r0, #3
  }
}
 c003890:	4770      	bx	lr

0c003892 <Flash_EraseChip>:
}
#if !defined(LOCAL_LOADER_CONFIG)
static int32_t Flash_EraseChip(void)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c003892:	f06f 0003 	mvn.w	r0, #3
 c003896:	4770      	bx	lr

0c003898 <Flash_GetStatus>:

static ARM_FLASH_STATUS Flash_GetStatus(void)
{
  return ARM_FLASH0_STATUS;
 c003898:	4b01      	ldr	r3, [pc, #4]	; (c0038a0 <Flash_GetStatus+0x8>)
 c00389a:	6818      	ldr	r0, [r3, #0]
}
 c00389c:	4770      	bx	lr
 c00389e:	bf00      	nop
 c0038a0:	30030218 	.word	0x30030218

0c0038a4 <Flash_GetInfo>:
#endif
static ARM_FLASH_INFO *Flash_GetInfo(void)
{
  return ARM_FLASH0_DEV.data;
}
 c0038a4:	4800      	ldr	r0, [pc, #0]	; (c0038a8 <Flash_GetInfo+0x4>)
 c0038a6:	4770      	bx	lr
 c0038a8:	0c00fab4 	.word	0x0c00fab4

0c0038ac <Flash_Initialize>:
{
 c0038ac:	b508      	push	{r3, lr}
  FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0038ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c0038b2:	f003 fc4d 	bl	c007150 <FLASH_WaitForLastOperation>
}
 c0038b6:	2000      	movs	r0, #0
 c0038b8:	bd08      	pop	{r3, pc}

0c0038ba <is_range_secure.isra.1>:
static bool is_range_secure(struct arm_flash_dev_t *flash_dev,
 c0038ba:	b530      	push	{r4, r5, lr}
  if (!vect->range)
 c0038bc:	6944      	ldr	r4, [r0, #20]
 c0038be:	b194      	cbz	r4, c0038e6 <is_range_secure.isra.1+0x2c>
  for (nb = 0; nb < vect->nb; nb++)
 c0038c0:	2300      	movs	r3, #0
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c0038c2:	3a01      	subs	r2, #1
  for (nb = 0; nb < vect->nb; nb++)
 c0038c4:	6900      	ldr	r0, [r0, #16]
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c0038c6:	440a      	add	r2, r1
  for (nb = 0; nb < vect->nb; nb++)
 c0038c8:	4283      	cmp	r3, r0
 c0038ca:	d101      	bne.n	c0038d0 <is_range_secure.isra.1+0x16>
  return false;
 c0038cc:	2000      	movs	r0, #0
}
 c0038ce:	bd30      	pop	{r4, r5, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c0038d0:	f854 5033 	ldr.w	r5, [r4, r3, lsl #3]
 c0038d4:	428d      	cmp	r5, r1
 c0038d6:	d804      	bhi.n	c0038e2 <is_range_secure.isra.1+0x28>
 c0038d8:	eb04 05c3 	add.w	r5, r4, r3, lsl #3
 c0038dc:	686d      	ldr	r5, [r5, #4]
 c0038de:	42aa      	cmp	r2, r5
 c0038e0:	d901      	bls.n	c0038e6 <is_range_secure.isra.1+0x2c>
  for (nb = 0; nb < vect->nb; nb++)
 c0038e2:	3301      	adds	r3, #1
 c0038e4:	e7f0      	b.n	c0038c8 <is_range_secure.isra.1+0xe>
    return true;
 c0038e6:	2001      	movs	r0, #1
 c0038e8:	e7f1      	b.n	c0038ce <is_range_secure.isra.1+0x14>
	...

0c0038ec <Flash_ProgramData>:
{
 c0038ec:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0038f0:	4c2f      	ldr	r4, [pc, #188]	; (c0039b0 <Flash_ProgramData+0xc4>)
{
 c0038f2:	4605      	mov	r5, r0
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0038f4:	6823      	ldr	r3, [r4, #0]
{
 c0038f6:	4617      	mov	r7, r2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c0038f8:	f36f 0341 	bfc	r3, #1, #1
{
 c0038fc:	4688      	mov	r8, r1
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c0038fe:	4601      	mov	r1, r0
 c003900:	482c      	ldr	r0, [pc, #176]	; (c0039b4 <Flash_ProgramData+0xc8>)
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003902:	6023      	str	r3, [r4, #0]
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c003904:	f7ff ffd9 	bl	c0038ba <is_range_secure.isra.1>
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c003908:	1e79      	subs	r1, r7, #1
    write_type = FLASH_TYPEPROGRAM_DOUBLEWORD_NS;
 c00390a:	2800      	cmp	r0, #0
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c00390c:	4429      	add	r1, r5
    write_type = FLASH_TYPEPROGRAM_DOUBLEWORD_NS;
 c00390e:	4e2a      	ldr	r6, [pc, #168]	; (c0039b8 <Flash_ProgramData+0xcc>)
 c003910:	bf1a      	itte	ne
 c003912:	f04f 6a40 	movne.w	sl, #201326592	; 0xc000000
 c003916:	2601      	movne	r6, #1
 c003918:	f04f 6a00 	moveq.w	sl, #134217728	; 0x8000000
  if ((!is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1)) ||
 c00391c:	f5b1 2f00 	cmp.w	r1, #524288	; 0x80000
 c003920:	d209      	bcs.n	c003936 <Flash_ProgramData+0x4a>
      (!is_write_aligned(&ARM_FLASH0_DEV, addr))     ||
 c003922:	ea45 0307 	orr.w	r3, r5, r7
 c003926:	f013 0307 	ands.w	r3, r3, #7
 c00392a:	d104      	bne.n	c003936 <Flash_ProgramData+0x4a>
  for (nb = 0; nb < vect->nb; nb++)
 c00392c:	4a21      	ldr	r2, [pc, #132]	; (c0039b4 <Flash_ProgramData+0xc8>)
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c00392e:	e9d2 c002 	ldrd	ip, r0, [r2, #8]
  for (nb = 0; nb < vect->nb; nb++)
 c003932:	4563      	cmp	r3, ip
 c003934:	d108      	bne.n	c003948 <Flash_ProgramData+0x5c>
    return ARM_DRIVER_ERROR_PARAMETER;
 c003936:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c00393a:	6823      	ldr	r3, [r4, #0]
 c00393c:	f043 0302 	orr.w	r3, r3, #2
 c003940:	6023      	str	r3, [r4, #0]
}
 c003942:	b002      	add	sp, #8
 c003944:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c003948:	f850 2033 	ldr.w	r2, [r0, r3, lsl #3]
 c00394c:	4295      	cmp	r5, r2
 c00394e:	d304      	bcc.n	c00395a <Flash_ProgramData+0x6e>
 c003950:	eb00 02c3 	add.w	r2, r0, r3, lsl #3
 c003954:	6852      	ldr	r2, [r2, #4]
 c003956:	4291      	cmp	r1, r2
 c003958:	d91f      	bls.n	c00399a <Flash_ProgramData+0xae>
  for (nb = 0; nb < vect->nb; nb++)
 c00395a:	3301      	adds	r3, #1
 c00395c:	e7e9      	b.n	c003932 <Flash_ProgramData+0x46>
  } while ((loop != cnt) && (err == HAL_OK));
 c00395e:	b988      	cbnz	r0, c003984 <Flash_ProgramData+0x98>
    memcpy(&dword, (void *)((uint32_t)data + loop), sizeof(dword));
 c003960:	466b      	mov	r3, sp
 c003962:	eb08 0209 	add.w	r2, r8, r9
 c003966:	6810      	ldr	r0, [r2, #0]
 c003968:	6851      	ldr	r1, [r2, #4]
 c00396a:	c303      	stmia	r3!, {r0, r1}
    err = HAL_FLASH_Program(write_type, (flash_base + addr), dword);
 c00396c:	eb0a 0109 	add.w	r1, sl, r9
 c003970:	e9dd 2300 	ldrd	r2, r3, [sp]
 c003974:	4630      	mov	r0, r6
 c003976:	f003 fc29 	bl	c0071cc <HAL_FLASH_Program>
    loop += sizeof(dword);
 c00397a:	f109 0908 	add.w	r9, r9, #8
  } while ((loop != cnt) && (err == HAL_OK));
 c00397e:	454f      	cmp	r7, r9
    err = HAL_FLASH_Program(write_type, (flash_base + addr), dword);
 c003980:	4605      	mov	r5, r0
  } while ((loop != cnt) && (err == HAL_OK));
 c003982:	d1ec      	bne.n	c00395e <Flash_ProgramData+0x72>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003984:	6823      	ldr	r3, [r4, #0]
 c003986:	f36f 0300 	bfc	r3, #0, #1
 c00398a:	6023      	str	r3, [r4, #0]
  HAL_FLASH_Lock();
 c00398c:	f003 fbb0 	bl	c0070f0 <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c003990:	1c28      	adds	r0, r5, #0
 c003992:	bf18      	it	ne
 c003994:	2001      	movne	r0, #1
 c003996:	4240      	negs	r0, r0
 c003998:	e7d3      	b.n	c003942 <Flash_ProgramData+0x56>
  HAL_FLASH_Unlock();
 c00399a:	f003 fb89 	bl	c0070b0 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c00399e:	6823      	ldr	r3, [r4, #0]
  uint32_t loop = 0;
 c0039a0:	f04f 0900 	mov.w	r9, #0
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c0039a4:	f043 0301 	orr.w	r3, r3, #1
 c0039a8:	6023      	str	r3, [r4, #0]
    err = HAL_FLASH_Program(write_type, (flash_base + addr), dword);
 c0039aa:	44aa      	add	sl, r5
 c0039ac:	e7d8      	b.n	c003960 <Flash_ProgramData+0x74>
 c0039ae:	bf00      	nop
 c0039b0:	30030218 	.word	0x30030218
 c0039b4:	30030008 	.word	0x30030008
 c0039b8:	80000001 	.word	0x80000001

0c0039bc <Flash_EraseSector>:
{
 c0039bc:	b530      	push	{r4, r5, lr}
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0039be:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
{
 c0039c2:	b087      	sub	sp, #28
 c0039c4:	4604      	mov	r4, r0
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0039c6:	d207      	bcs.n	c0039d8 <Flash_EraseSector+0x1c>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 c0039c8:	f3c0 030b 	ubfx	r3, r0, #0, #12
  if (!(is_range_valid(&ARM_FLASH0_DEV, addr)) ||
 c0039cc:	b923      	cbnz	r3, c0039d8 <Flash_EraseSector+0x1c>
  for (nb = 0; nb < vect->nb; nb++)
 c0039ce:	4a26      	ldr	r2, [pc, #152]	; (c003a68 <Flash_EraseSector+0xac>)
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c0039d0:	e9d2 1200 	ldrd	r1, r2, [r2]
  for (nb = 0; nb < vect->nb; nb++)
 c0039d4:	428b      	cmp	r3, r1
 c0039d6:	d108      	bne.n	c0039ea <Flash_EraseSector+0x2e>
    return ARM_DRIVER_ERROR_PARAMETER;
 c0039d8:	f06f 0004 	mvn.w	r0, #4
    ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c0039dc:	4a23      	ldr	r2, [pc, #140]	; (c003a6c <Flash_EraseSector+0xb0>)
 c0039de:	6813      	ldr	r3, [r2, #0]
 c0039e0:	f043 0302 	orr.w	r3, r3, #2
 c0039e4:	6013      	str	r3, [r2, #0]
}
 c0039e6:	b007      	add	sp, #28
 c0039e8:	bd30      	pop	{r4, r5, pc}
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c0039ea:	f852 0033 	ldr.w	r0, [r2, r3, lsl #3]
 c0039ee:	4284      	cmp	r4, r0
 c0039f0:	d304      	bcc.n	c0039fc <Flash_EraseSector+0x40>
 c0039f2:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
 c0039f6:	6840      	ldr	r0, [r0, #4]
 c0039f8:	4284      	cmp	r4, r0
 c0039fa:	d92b      	bls.n	c003a54 <Flash_EraseSector+0x98>
  for (nb = 0; nb < vect->nb; nb++)
 c0039fc:	3301      	adds	r3, #1
 c0039fe:	e7e9      	b.n	c0039d4 <Flash_EraseSector+0x18>
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES;
 c003a00:	2302      	movs	r3, #2
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c003a02:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES_NS;
 c003a06:	9302      	str	r3, [sp, #8]
  return ((param >= (FLASH_TOTAL_SIZE / 2)) ? 2 : 1);
 c003a08:	bf2c      	ite	cs
 c003a0a:	2302      	movcs	r3, #2
 c003a0c:	2301      	movcc	r3, #1
  EraseInit.Banks = bank_number(&ARM_FLASH0_DEV, addr);
 c003a0e:	9303      	str	r3, [sp, #12]
  EraseInit.NbPages = 2;
 c003a10:	2302      	movs	r3, #2
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a12:	4d16      	ldr	r5, [pc, #88]	; (c003a6c <Flash_EraseSector+0xb0>)
  uint32_t page = param / flash_dev->data->page_size ;
 c003a14:	0ae4      	lsrs	r4, r4, #11
  EraseInit.NbPages = 2;
 c003a16:	9305      	str	r3, [sp, #20]
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a18:	682b      	ldr	r3, [r5, #0]
  page = ((page > (flash_dev->data->sector_count))) ? page - ((flash_dev->data->sector_count)) : page;
 c003a1a:	2c80      	cmp	r4, #128	; 0x80
 c003a1c:	bf88      	it	hi
 c003a1e:	3c80      	subhi	r4, #128	; 0x80
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a20:	f36f 0341 	bfc	r3, #1, #1
  EraseInit.Page = page_number(&ARM_FLASH0_DEV, addr);
 c003a24:	9404      	str	r4, [sp, #16]
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a26:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Unlock();
 c003a28:	f003 fb42 	bl	c0070b0 <HAL_FLASH_Unlock>
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003a2c:	682b      	ldr	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c003a2e:	a901      	add	r1, sp, #4
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003a30:	f043 0301 	orr.w	r3, r3, #1
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c003a34:	a802      	add	r0, sp, #8
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003a36:	602b      	str	r3, [r5, #0]
  err = HAL_FLASHEx_Erase(&EraseInit, &pageError);
 c003a38:	f003 fe26 	bl	c007688 <HAL_FLASHEx_Erase>
 c003a3c:	4604      	mov	r4, r0
  ARM_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003a3e:	682b      	ldr	r3, [r5, #0]
 c003a40:	f36f 0300 	bfc	r3, #0, #1
 c003a44:	602b      	str	r3, [r5, #0]
  HAL_FLASH_Lock();
 c003a46:	f003 fb53 	bl	c0070f0 <HAL_FLASH_Lock>
  return (err == HAL_OK) ? ARM_DRIVER_OK : ARM_DRIVER_ERROR;
 c003a4a:	1c20      	adds	r0, r4, #0
 c003a4c:	bf18      	it	ne
 c003a4e:	2001      	movne	r0, #1
 c003a50:	4240      	negs	r0, r0
 c003a52:	e7c8      	b.n	c0039e6 <Flash_EraseSector+0x2a>
  if (is_range_secure(&ARM_FLASH0_DEV, addr, 4))
 c003a54:	2204      	movs	r2, #4
 c003a56:	4621      	mov	r1, r4
 c003a58:	4803      	ldr	r0, [pc, #12]	; (c003a68 <Flash_EraseSector+0xac>)
 c003a5a:	f7ff ff2e 	bl	c0038ba <is_range_secure.isra.1>
 c003a5e:	2800      	cmp	r0, #0
 c003a60:	d1ce      	bne.n	c003a00 <Flash_EraseSector+0x44>
    EraseInit.TypeErase = FLASH_TYPEERASE_PAGES_NS;
 c003a62:	4b03      	ldr	r3, [pc, #12]	; (c003a70 <Flash_EraseSector+0xb4>)
 c003a64:	e7cd      	b.n	c003a02 <Flash_EraseSector+0x46>
 c003a66:	bf00      	nop
 c003a68:	30030008 	.word	0x30030008
 c003a6c:	30030218 	.word	0x30030218
 c003a70:	80000002 	.word	0x80000002

0c003a74 <Flash_ReadData>:
{
 c003a74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a76:	4b1c      	ldr	r3, [pc, #112]	; (c003ae8 <Flash_ReadData+0x74>)
{
 c003a78:	460e      	mov	r6, r1
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a7a:	6819      	ldr	r1, [r3, #0]
{
 c003a7c:	4605      	mov	r5, r0
  ARM_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003a7e:	f36f 0141 	bfc	r1, #1, #1
 c003a82:	6019      	str	r1, [r3, #0]
  is_valid = is_range_valid(&ARM_FLASH0_DEV, addr + cnt - 1);
 c003a84:	1e51      	subs	r1, r2, #1
 c003a86:	4401      	add	r1, r0
  if (is_valid != true)
 c003a88:	f5b1 2f00 	cmp.w	r1, #524288	; 0x80000
{
 c003a8c:	4617      	mov	r7, r2
  if (is_valid != true)
 c003a8e:	d30f      	bcc.n	c003ab0 <Flash_ReadData+0x3c>
    if (ARM_FLASH0_DEV.dev->read_error)
 c003a90:	4916      	ldr	r1, [pc, #88]	; (c003aec <Flash_ReadData+0x78>)
 c003a92:	698c      	ldr	r4, [r1, #24]
 c003a94:	b134      	cbz	r4, c003aa4 <Flash_ReadData+0x30>
      return ARM_DRIVER_ERROR_PARAMETER;
 c003a96:	f06f 0004 	mvn.w	r0, #4
      ARM_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c003a9a:	681a      	ldr	r2, [r3, #0]
 c003a9c:	f042 0202 	orr.w	r2, r2, #2
 c003aa0:	601a      	str	r2, [r3, #0]
}
 c003aa2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    memset(data, 0xff, cnt);
 c003aa4:	21ff      	movs	r1, #255	; 0xff
 c003aa6:	4630      	mov	r0, r6
 c003aa8:	f00a faef 	bl	c00e08a <memset>
    return ARM_DRIVER_OK;
 c003aac:	4620      	mov	r0, r4
 c003aae:	e7f8      	b.n	c003aa2 <Flash_ReadData+0x2e>
  DoubleECC_Error_Counter = 0U;
 c003ab0:	2300      	movs	r3, #0
 c003ab2:	4c0f      	ldr	r4, [pc, #60]	; (c003af0 <Flash_ReadData+0x7c>)
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c003ab4:	4601      	mov	r1, r0
 c003ab6:	480d      	ldr	r0, [pc, #52]	; (c003aec <Flash_ReadData+0x78>)
  DoubleECC_Error_Counter = 0U;
 c003ab8:	6023      	str	r3, [r4, #0]
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c003aba:	f7ff fefe 	bl	c0038ba <is_range_secure.isra.1>
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c003abe:	463a      	mov	r2, r7
  if (is_range_secure(&ARM_FLASH0_DEV, addr, cnt))
 c003ac0:	b170      	cbz	r0, c003ae0 <Flash_ReadData+0x6c>
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE), cnt);
 c003ac2:	f105 6140 	add.w	r1, r5, #201326592	; 0xc000000
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c003ac6:	4630      	mov	r0, r6
 c003ac8:	f00a fabb 	bl	c00e042 <memcpy>
  if (DoubleECC_Error_Counter == 0U)
 c003acc:	6823      	ldr	r3, [r4, #0]
    ret = ARM_DRIVER_OK;
 c003ace:	2b00      	cmp	r3, #0
  DoubleECC_Error_Counter = 0U;
 c003ad0:	f04f 0300 	mov.w	r3, #0
    ret = ARM_DRIVER_OK;
 c003ad4:	bf14      	ite	ne
 c003ad6:	f06f 0005 	mvnne.w	r0, #5
 c003ada:	2000      	moveq	r0, #0
  DoubleECC_Error_Counter = 0U;
 c003adc:	6023      	str	r3, [r4, #0]
 c003ade:	e7e0      	b.n	c003aa2 <Flash_ReadData+0x2e>
    memcpy(data, (void *)((uint32_t)addr + FLASH_BASE_NS), cnt);
 c003ae0:	f105 6100 	add.w	r1, r5, #134217728	; 0x8000000
 c003ae4:	e7ef      	b.n	c003ac6 <Flash_ReadData+0x52>
 c003ae6:	bf00      	nop
 c003ae8:	30030218 	.word	0x30030218
 c003aec:	30030008 	.word	0x30030008
 c003af0:	3003021c 	.word	0x3003021c

0c003af4 <NMI_Handler>:
void NMI_Handler(void)
{
  uint32_t *p_sp;
  uint32_t lr;
  uint16_t opcode_msb;
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_ECCD))
 c003af4:	4b17      	ldr	r3, [pc, #92]	; (c003b54 <NMI_Handler+0x60>)
 c003af6:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c003af8:	f002 4220 	and.w	r2, r2, #2684354560	; 0xa0000000
 c003afc:	f1b2 4f20 	cmp.w	r2, #2684354560	; 0xa0000000
 c003b00:	d127      	bne.n	c003b52 <NMI_Handler+0x5e>
  {
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_ECCD);
 c003b02:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c003b04:	f042 4220 	orr.w	r2, r2, #2684354560	; 0xa0000000
 c003b08:	631a      	str	r2, [r3, #48]	; 0x30
    /* Memorize error to ignore the read value */
    DoubleECC_Error_Counter++;
 c003b0a:	4a13      	ldr	r2, [pc, #76]	; (c003b58 <NMI_Handler+0x64>)
 c003b0c:	6813      	ldr	r3, [r2, #0]
 c003b0e:	3301      	adds	r3, #1
 c003b10:	6013      	str	r3, [r2, #0]
  __ASM volatile("MOV %0, LR" : "=r"(result));
 c003b12:	4673      	mov	r3, lr

    lr = __get_LR();

    /* Check EXC_RETURN value in LR to know which SP was used prior entering exception */
    if (((lr) & (0xFU)) == 0xDU)
 c003b14:	f003 030f 	and.w	r3, r3, #15
 c003b18:	2b0d      	cmp	r3, #13
 c003b1a:	d114      	bne.n	c003b46 <NMI_Handler+0x52>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 c003b1c:	f3ef 8209 	mrs	r2, PSP
      /* interrupted code was using Main Stack Pointer */
      p_sp = (uint32_t *)__get_MSP();
    }

    /* Test caller mode T bit from CPSR in stack */
    if ((*(p_sp + 7U) & (1U << xPSR_T_Pos)) != 0U)
 c003b20:	e9d2 3106 	ldrd	r3, r1, [r2, #24]
 c003b24:	01c9      	lsls	r1, r1, #7
 c003b26:	d50c      	bpl.n	c003b42 <NMI_Handler+0x4e>
         Test PC in stack.
         If bits [15:11] of the halfword being decoded take any of the following values,
         the halfword is the first halfword of a 32-bit instruction: 0b11101, 0b11110, 0b11111.
         Otherwise, the halfword is a 16-bit instruction.
      */
      opcode_msb = (*(uint16_t *)(*(p_sp + 6) & 0xFFFFFFFEU) & 0xF800U);
 c003b28:	f023 0101 	bic.w	r1, r3, #1
 c003b2c:	8809      	ldrh	r1, [r1, #0]
 c003b2e:	f401 4078 	and.w	r0, r1, #63488	; 0xf800
      if ((opcode_msb == 0xE800U) || (opcode_msb == 0xF000U) || (opcode_msb == 0xF800U))
 c003b32:	f401 4168 	and.w	r1, r1, #59392	; 0xe800
 c003b36:	f5b1 4f68 	cmp.w	r1, #59392	; 0xe800
 c003b3a:	d002      	beq.n	c003b42 <NMI_Handler+0x4e>
 c003b3c:	f5b0 4f70 	cmp.w	r0, #61440	; 0xf000
 c003b40:	d104      	bne.n	c003b4c <NMI_Handler+0x58>
      }
    }
    else
    {
      /* ARM mode execute next instruction PC +4 */
      *(p_sp + 6U) += 4U;
 c003b42:	3304      	adds	r3, #4
 c003b44:	e003      	b.n	c003b4e <NMI_Handler+0x5a>
  __ASM volatile ("MRS %0, msp" : "=r" (result) );
 c003b46:	f3ef 8208 	mrs	r2, MSP
 c003b4a:	e7e9      	b.n	c003b20 <NMI_Handler+0x2c>
        *(p_sp + 6U) += 2U;
 c003b4c:	3302      	adds	r3, #2
      *(p_sp + 6U) += 4U;
 c003b4e:	6193      	str	r3, [r2, #24]
  else
  {
    /* This exception occurs for another reason than flash double ECC errors */
    while (1U);
  }
}
 c003b50:	4770      	bx	lr
 c003b52:	e7fe      	b.n	c003b52 <NMI_Handler+0x5e>
 c003b54:	50022000 	.word	0x50022000
 c003b58:	3003021c 	.word	0x3003021c

0c003b5c <Ospi_Flash_GetVersion>:
/* Flash Status */
static ARM_FLASH_STATUS ARM_OSPI_FLASH0_STATUS = {0, 0, 0};

static ARM_DRIVER_VERSION Ospi_Flash_GetVersion(void)
{
  return DriverVersion;
 c003b5c:	4b03      	ldr	r3, [pc, #12]	; (c003b6c <Ospi_Flash_GetVersion+0x10>)
{
 c003b5e:	b082      	sub	sp, #8
  return DriverVersion;
 c003b60:	6818      	ldr	r0, [r3, #0]
 c003b62:	b283      	uxth	r3, r0
}
 c003b64:	f363 000f 	bfi	r0, r3, #0, #16
 c003b68:	b002      	add	sp, #8
 c003b6a:	4770      	bx	lr
 c003b6c:	0c00fb14 	.word	0x0c00fb14

0c003b70 <Ospi_Flash_GetCapabilities>:

static ARM_FLASH_CAPABILITIES Ospi_Flash_GetCapabilities(void)
{
  return DriverCapabilities;
}
 c003b70:	200a      	movs	r0, #10
 c003b72:	4770      	bx	lr

0c003b74 <Ospi_Flash_PowerControl>:
  }
}

static int32_t Ospi_Flash_PowerControl(ARM_POWER_STATE state)
{
  switch (state)
 c003b74:	2801      	cmp	r0, #1
 c003b76:	d905      	bls.n	c003b84 <Ospi_Flash_PowerControl+0x10>
 c003b78:	2802      	cmp	r0, #2
      return ARM_DRIVER_OK;
    case ARM_POWER_OFF:
    case ARM_POWER_LOW:
      return ARM_DRIVER_ERROR_UNSUPPORTED;
    default:
      return ARM_DRIVER_ERROR_PARAMETER;
 c003b7a:	bf0c      	ite	eq
 c003b7c:	2000      	moveq	r0, #0
 c003b7e:	f06f 0004 	mvnne.w	r0, #4
 c003b82:	4770      	bx	lr
      return ARM_DRIVER_ERROR_UNSUPPORTED;
 c003b84:	f06f 0003 	mvn.w	r0, #3
  }
}
 c003b88:	4770      	bx	lr

0c003b8a <Ospi_Flash_EraseChip>:
}

static int32_t Ospi_Flash_EraseChip(void)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 c003b8a:	f06f 0003 	mvn.w	r0, #3
 c003b8e:	4770      	bx	lr

0c003b90 <Ospi_Flash_GetStatus>:

static ARM_FLASH_STATUS Ospi_Flash_GetStatus(void)
{
  return ARM_OSPI_FLASH0_STATUS;
 c003b90:	4b01      	ldr	r3, [pc, #4]	; (c003b98 <Ospi_Flash_GetStatus+0x8>)
 c003b92:	6818      	ldr	r0, [r3, #0]
}
 c003b94:	4770      	bx	lr
 c003b96:	bf00      	nop
 c003b98:	30030220 	.word	0x30030220

0c003b9c <Ospi_Flash_GetInfo>:

static ARM_FLASH_INFO *Ospi_Flash_GetInfo(void)
{
  return ARM_OSPI_FLASH0_DEV.data;
}
 c003b9c:	4800      	ldr	r0, [pc, #0]	; (c003ba0 <Ospi_Flash_GetInfo+0x4>)
 c003b9e:	4770      	bx	lr
 c003ba0:	0c00fafc 	.word	0x0c00fafc

0c003ba4 <Ospi_Flash_ReadData>:
{
 c003ba4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c003ba8:	4616      	mov	r6, r2
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003baa:	4b35      	ldr	r3, [pc, #212]	; (c003c80 <Ospi_Flash_ReadData+0xdc>)
 c003bac:	1e77      	subs	r7, r6, #1
 c003bae:	681a      	ldr	r2, [r3, #0]
  if (!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1))
 c003bb0:	eb07 0900 	add.w	r9, r7, r0
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003bb4:	f36f 0241 	bfc	r2, #1, #1
  if (!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1))
 c003bb8:	f1b9 6f80 	cmp.w	r9, #67108864	; 0x4000000
{
 c003bbc:	4605      	mov	r5, r0
 c003bbe:	460c      	mov	r4, r1
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003bc0:	601a      	str	r2, [r3, #0]
 c003bc2:	4698      	mov	r8, r3
  if (!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1))
 c003bc4:	d308      	bcc.n	c003bd8 <Ospi_Flash_ReadData+0x34>
    return ARM_DRIVER_ERROR_PARAMETER;
 c003bc6:	f06f 0004 	mvn.w	r0, #4
    ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c003bca:	681a      	ldr	r2, [r3, #0]
 c003bcc:	f042 0202 	orr.w	r2, r2, #2
 c003bd0:	601a      	str	r2, [r3, #0]
}
 c003bd2:	b003      	add	sp, #12
 c003bd4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003bd8:	681b      	ldr	r3, [r3, #0]
 c003bda:	f043 0301 	orr.w	r3, r3, #1
 c003bde:	f8c8 3000 	str.w	r3, [r8]
  while (BSP_OSPI_NOR_GetStatus(0) !=  BSP_ERROR_NONE)
 c003be2:	2000      	movs	r0, #0
 c003be4:	f002 f9e0 	bl	c005fa8 <BSP_OSPI_NOR_GetStatus>
 c003be8:	2800      	cmp	r0, #0
 c003bea:	d1fa      	bne.n	c003be2 <Ospi_Flash_ReadData+0x3e>
  if (addr % 2)
 c003bec:	07e9      	lsls	r1, r5, #31
 c003bee:	d530      	bpl.n	c003c52 <Ospi_Flash_ReadData+0xae>
    err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr - 1, 2);
 c003bf0:	2302      	movs	r3, #2
 c003bf2:	1e6a      	subs	r2, r5, #1
 c003bf4:	a901      	add	r1, sp, #4
 c003bf6:	f002 f93b 	bl	c005e70 <BSP_OSPI_NOR_Read>
    *(uint8_t*)data = data_tmp[1];
 c003bfa:	f89d 2005 	ldrb.w	r2, [sp, #5]
    if (cnt > 1)
 c003bfe:	2e01      	cmp	r6, #1
    err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr - 1, 2);
 c003c00:	4603      	mov	r3, r0
    *(uint8_t*)data = data_tmp[1];
 c003c02:	7022      	strb	r2, [r4, #0]
    if (cnt > 1)
 c003c04:	d91a      	bls.n	c003c3c <Ospi_Flash_ReadData+0x98>
      if (cnt % 2)
 c003c06:	07f2      	lsls	r2, r6, #31
 c003c08:	d507      	bpl.n	c003c1a <Ospi_Flash_ReadData+0x76>
        if (err == BSP_ERROR_NONE)
 c003c0a:	b9b8      	cbnz	r0, c003c3c <Ospi_Flash_ReadData+0x98>
          err = BSP_OSPI_NOR_Read(0, (uint8_t *)data + 1, (addr + 1), cnt - 1);
 c003c0c:	463b      	mov	r3, r7
 c003c0e:	1c6a      	adds	r2, r5, #1
 c003c10:	1c61      	adds	r1, r4, #1
      err = BSP_OSPI_NOR_Read(0, (uint8_t *)data, addr, cnt);
 c003c12:	f002 f92d 	bl	c005e70 <BSP_OSPI_NOR_Read>
 c003c16:	4603      	mov	r3, r0
 c003c18:	e010      	b.n	c003c3c <Ospi_Flash_ReadData+0x98>
        if (err == BSP_ERROR_NONE)
 c003c1a:	b978      	cbnz	r0, c003c3c <Ospi_Flash_ReadData+0x98>
          err = BSP_OSPI_NOR_Read(0, (uint8_t *)data + 1, (addr + 1), cnt - 2);
 c003c1c:	1eb3      	subs	r3, r6, #2
 c003c1e:	1c6a      	adds	r2, r5, #1
 c003c20:	1c61      	adds	r1, r4, #1
 c003c22:	f002 f925 	bl	c005e70 <BSP_OSPI_NOR_Read>
        if (err == BSP_ERROR_NONE)
 c003c26:	4603      	mov	r3, r0
 c003c28:	b940      	cbnz	r0, c003c3c <Ospi_Flash_ReadData+0x98>
          err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr + cnt - 1, 2);
 c003c2a:	2302      	movs	r3, #2
 c003c2c:	464a      	mov	r2, r9
 c003c2e:	a901      	add	r1, sp, #4
        err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr + cnt - 1, 2);
 c003c30:	f002 f91e 	bl	c005e70 <BSP_OSPI_NOR_Read>
 c003c34:	4603      	mov	r3, r0
        *((uint8_t*)data + cnt -1) = data_tmp[0];
 c003c36:	f89d 2004 	ldrb.w	r2, [sp, #4]
 c003c3a:	55e2      	strb	r2, [r4, r7]
  if (err != BSP_ERROR_NONE)
 c003c3c:	1c18      	adds	r0, r3, #0
 c003c3e:	bf18      	it	ne
 c003c40:	2001      	movne	r0, #1
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003c42:	f8d8 2000 	ldr.w	r2, [r8]
  if (err != BSP_ERROR_NONE)
 c003c46:	4240      	negs	r0, r0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003c48:	f36f 0200 	bfc	r2, #0, #1
 c003c4c:	f8c8 2000 	str.w	r2, [r8]
 c003c50:	e7bf      	b.n	c003bd2 <Ospi_Flash_ReadData+0x2e>
    if (cnt % 2)
 c003c52:	07f3      	lsls	r3, r6, #31
 c003c54:	d50f      	bpl.n	c003c76 <Ospi_Flash_ReadData+0xd2>
      if (cnt > 1)
 c003c56:	2e01      	cmp	r6, #1
 c003c58:	d104      	bne.n	c003c64 <Ospi_Flash_ReadData+0xc0>
        err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr + cnt - 1, 2);
 c003c5a:	2302      	movs	r3, #2
 c003c5c:	464a      	mov	r2, r9
 c003c5e:	a901      	add	r1, sp, #4
 c003c60:	2000      	movs	r0, #0
 c003c62:	e7e5      	b.n	c003c30 <Ospi_Flash_ReadData+0x8c>
        err = BSP_OSPI_NOR_Read(0, (uint8_t *)data, addr, cnt - 1);
 c003c64:	463b      	mov	r3, r7
 c003c66:	462a      	mov	r2, r5
 c003c68:	4621      	mov	r1, r4
 c003c6a:	f002 f901 	bl	c005e70 <BSP_OSPI_NOR_Read>
      if (err == BSP_ERROR_NONE)
 c003c6e:	4603      	mov	r3, r0
 c003c70:	2800      	cmp	r0, #0
 c003c72:	d0f2      	beq.n	c003c5a <Ospi_Flash_ReadData+0xb6>
 c003c74:	e7e2      	b.n	c003c3c <Ospi_Flash_ReadData+0x98>
      err = BSP_OSPI_NOR_Read(0, (uint8_t *)data, addr, cnt);
 c003c76:	4633      	mov	r3, r6
 c003c78:	462a      	mov	r2, r5
 c003c7a:	4621      	mov	r1, r4
 c003c7c:	e7c9      	b.n	c003c12 <Ospi_Flash_ReadData+0x6e>
 c003c7e:	bf00      	nop
 c003c80:	30030220 	.word	0x30030220

0c003c84 <Ospi_Flash_Uninitialize>:
{
 c003c84:	b508      	push	{r3, lr}
  if (BSP_OSPI_NOR_DeInit(0) != BSP_ERROR_NONE)
 c003c86:	2000      	movs	r0, #0
 c003c88:	f002 f9f6 	bl	c006078 <BSP_OSPI_NOR_DeInit>
 c003c8c:	2800      	cmp	r0, #0
}
 c003c8e:	bf18      	it	ne
 c003c90:	f06f 0005 	mvnne.w	r0, #5
 c003c94:	bd08      	pop	{r3, pc}

0c003c96 <Ospi_Flash_Initialize>:
  flash.InterfaceMode = BSP_OSPI_NOR_OPI_MODE;
 c003c96:	2301      	movs	r3, #1
{
 c003c98:	b507      	push	{r0, r1, r2, lr}
  if (BSP_OSPI_NOR_Init(0, &flash) != BSP_ERROR_NONE)
 c003c9a:	2000      	movs	r0, #0
 c003c9c:	a901      	add	r1, sp, #4
  flash.InterfaceMode = BSP_OSPI_NOR_OPI_MODE;
 c003c9e:	f88d 3004 	strb.w	r3, [sp, #4]
  flash.TransferRate  = BSP_OSPI_NOR_DTR_TRANSFER;
 c003ca2:	f88d 3005 	strb.w	r3, [sp, #5]
  if (BSP_OSPI_NOR_Init(0, &flash) != BSP_ERROR_NONE)
 c003ca6:	f002 fabb 	bl	c006220 <BSP_OSPI_NOR_Init>
 c003caa:	2800      	cmp	r0, #0
}
 c003cac:	bf18      	it	ne
 c003cae:	f06f 0005 	mvnne.w	r0, #5
 c003cb2:	b003      	add	sp, #12
 c003cb4:	f85d fb04 	ldr.w	pc, [sp], #4

0c003cb8 <Ospi_Flash_EraseSector>:
{
 c003cb8:	b538      	push	{r3, r4, r5, lr}
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003cba:	4c1a      	ldr	r4, [pc, #104]	; (c003d24 <Ospi_Flash_EraseSector+0x6c>)
  if (!(is_range_valid(&ARM_OSPI_FLASH0_DEV, addr)) ||
 c003cbc:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003cc0:	6823      	ldr	r3, [r4, #0]
{
 c003cc2:	4601      	mov	r1, r0
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003cc4:	f36f 0341 	bfc	r3, #1, #1
 c003cc8:	6023      	str	r3, [r4, #0]
  if (!(is_range_valid(&ARM_OSPI_FLASH0_DEV, addr)) ||
 c003cca:	d207      	bcs.n	c003cdc <Ospi_Flash_EraseSector+0x24>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 c003ccc:	f3c0 030b 	ubfx	r3, r0, #0, #12
  if (!(is_range_valid(&ARM_OSPI_FLASH0_DEV, addr)) ||
 c003cd0:	b923      	cbnz	r3, c003cdc <Ospi_Flash_EraseSector+0x24>
  for (nb = 0; nb < vect->nb; nb++)
 c003cd2:	4a15      	ldr	r2, [pc, #84]	; (c003d28 <Ospi_Flash_EraseSector+0x70>)
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c003cd4:	e9d2 0200 	ldrd	r0, r2, [r2]
  for (nb = 0; nb < vect->nb; nb++)
 c003cd8:	4283      	cmp	r3, r0
 c003cda:	d106      	bne.n	c003cea <Ospi_Flash_EraseSector+0x32>
    return ARM_DRIVER_ERROR_PARAMETER;
 c003cdc:	f06f 0004 	mvn.w	r0, #4
    ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c003ce0:	6823      	ldr	r3, [r4, #0]
 c003ce2:	f043 0302 	orr.w	r3, r3, #2
 c003ce6:	6023      	str	r3, [r4, #0]
}
 c003ce8:	bd38      	pop	{r3, r4, r5, pc}
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 c003cea:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
 c003cee:	42a9      	cmp	r1, r5
 c003cf0:	d304      	bcc.n	c003cfc <Ospi_Flash_EraseSector+0x44>
 c003cf2:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 c003cf6:	686d      	ldr	r5, [r5, #4]
 c003cf8:	42a9      	cmp	r1, r5
 c003cfa:	d901      	bls.n	c003d00 <Ospi_Flash_EraseSector+0x48>
  for (nb = 0; nb < vect->nb; nb++)
 c003cfc:	3301      	adds	r3, #1
 c003cfe:	e7eb      	b.n	c003cd8 <Ospi_Flash_EraseSector+0x20>
    err = BSP_OSPI_NOR_Erase_Block(0, addr, MX25LM51245G_ERASE_4K);
 c003d00:	2200      	movs	r2, #0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003d02:	6823      	ldr	r3, [r4, #0]
    err = BSP_OSPI_NOR_Erase_Block(0, addr, MX25LM51245G_ERASE_4K);
 c003d04:	4610      	mov	r0, r2
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003d06:	f043 0301 	orr.w	r3, r3, #1
 c003d0a:	6023      	str	r3, [r4, #0]
    err = BSP_OSPI_NOR_Erase_Block(0, addr, MX25LM51245G_ERASE_4K);
 c003d0c:	f002 f924 	bl	c005f58 <BSP_OSPI_NOR_Erase_Block>
  if (err != BSP_ERROR_NONE)
 c003d10:	3000      	adds	r0, #0
 c003d12:	bf18      	it	ne
 c003d14:	2001      	movne	r0, #1
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003d16:	6823      	ldr	r3, [r4, #0]
  if (err != BSP_ERROR_NONE)
 c003d18:	4240      	negs	r0, r0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003d1a:	f36f 0300 	bfc	r3, #0, #1
 c003d1e:	6023      	str	r3, [r4, #0]
 c003d20:	e7e2      	b.n	c003ce8 <Ospi_Flash_EraseSector+0x30>
 c003d22:	bf00      	nop
 c003d24:	30030220 	.word	0x30030220
 c003d28:	3003007c 	.word	0x3003007c

0c003d2c <Ospi_Flash_ProgramData>:
{
 c003d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c003d2e:	4613      	mov	r3, r2
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003d30:	4c1b      	ldr	r4, [pc, #108]	; (c003da0 <Ospi_Flash_ProgramData+0x74>)
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 c003d32:	1e5e      	subs	r6, r3, #1
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003d34:	6822      	ldr	r2, [r4, #0]
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 c003d36:	4406      	add	r6, r0
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003d38:	f36f 0241 	bfc	r2, #1, #1
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 c003d3c:	f1b6 6f80 	cmp.w	r6, #67108864	; 0x4000000
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 c003d40:	6022      	str	r2, [r4, #0]
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 c003d42:	d209      	bcs.n	c003d58 <Ospi_Flash_ProgramData+0x2c>
      (!is_write_aligned(&ARM_OSPI_FLASH0_DEV, addr))     ||
 c003d44:	ea40 0503 	orr.w	r5, r0, r3
 c003d48:	f015 0501 	ands.w	r5, r5, #1
 c003d4c:	d104      	bne.n	c003d58 <Ospi_Flash_ProgramData+0x2c>
  for (nb = 0; nb < vect->nb; nb++)
 c003d4e:	4a15      	ldr	r2, [pc, #84]	; (c003da4 <Ospi_Flash_ProgramData+0x78>)
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c003d50:	e9d2 c202 	ldrd	ip, r2, [r2, #8]
  for (nb = 0; nb < vect->nb; nb++)
 c003d54:	4565      	cmp	r5, ip
 c003d56:	d106      	bne.n	c003d66 <Ospi_Flash_ProgramData+0x3a>
    return ARM_DRIVER_ERROR_PARAMETER;
 c003d58:	f06f 0004 	mvn.w	r0, #4
    ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 c003d5c:	6823      	ldr	r3, [r4, #0]
 c003d5e:	f043 0302 	orr.w	r3, r3, #2
 c003d62:	6023      	str	r3, [r4, #0]
}
 c003d64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 c003d66:	f852 7035 	ldr.w	r7, [r2, r5, lsl #3]
 c003d6a:	42b8      	cmp	r0, r7
 c003d6c:	d304      	bcc.n	c003d78 <Ospi_Flash_ProgramData+0x4c>
 c003d6e:	eb02 07c5 	add.w	r7, r2, r5, lsl #3
 c003d72:	687f      	ldr	r7, [r7, #4]
 c003d74:	42be      	cmp	r6, r7
 c003d76:	d901      	bls.n	c003d7c <Ospi_Flash_ProgramData+0x50>
  for (nb = 0; nb < vect->nb; nb++)
 c003d78:	3501      	adds	r5, #1
 c003d7a:	e7eb      	b.n	c003d54 <Ospi_Flash_ProgramData+0x28>
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003d7c:	6822      	ldr	r2, [r4, #0]
 c003d7e:	f042 0201 	orr.w	r2, r2, #1
 c003d82:	6022      	str	r2, [r4, #0]
  err = BSP_OSPI_NOR_Write(0, (uint8_t *) data, addr, cnt);
 c003d84:	4602      	mov	r2, r0
 c003d86:	2000      	movs	r0, #0
 c003d88:	f002 f892 	bl	c005eb0 <BSP_OSPI_NOR_Write>
  if (err != BSP_ERROR_NONE)
 c003d8c:	3000      	adds	r0, #0
 c003d8e:	bf18      	it	ne
 c003d90:	2001      	movne	r0, #1
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003d92:	6823      	ldr	r3, [r4, #0]
  if (err != BSP_ERROR_NONE)
 c003d94:	4240      	negs	r0, r0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 c003d96:	f36f 0300 	bfc	r3, #0, #1
 c003d9a:	6023      	str	r3, [r4, #0]
 c003d9c:	e7e2      	b.n	c003d64 <Ospi_Flash_ProgramData+0x38>
 c003d9e:	bf00      	nop
 c003da0:	30030220 	.word	0x30030220
 c003da4:	3003007c 	.word	0x3003007c

0c003da8 <Ospi_Flash_Config_Exe>:
  * @brief This function configures the ospi flash in execution mode.
  * @note
  * @retval execution_status
  */
int32_t Ospi_Flash_Config_Exe(void)
{
 c003da8:	b508      	push	{r3, lr}

#ifdef DEBUG_OSPI_FLASH_ACCESS
  printf("memory mapped ospi\r\n");
#endif /*  DEBUG_OSPI_FLASH_ACCESS */

  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 c003daa:	4a08      	ldr	r2, [pc, #32]	; (c003dcc <Ospi_Flash_Config_Exe+0x24>)
 c003dac:	6813      	ldr	r3, [r2, #0]
 c003dae:	f043 0301 	orr.w	r3, r3, #1
 c003db2:	6013      	str	r3, [r2, #0]

  /* ensure previous operation is finished (erase/write) : GetStatus()
     such verification is done (inside BSP driver) at the beginning of erase or write operation  but
     not for read operation ==> in order to maximise BSP driver execution timing efficiency */
  while (BSP_OSPI_NOR_GetStatus(0) !=  BSP_ERROR_NONE)
 c003db4:	2000      	movs	r0, #0
 c003db6:	f002 f8f7 	bl	c005fa8 <BSP_OSPI_NOR_GetStatus>
 c003dba:	2800      	cmp	r0, #0
 c003dbc:	d1fa      	bne.n	c003db4 <Ospi_Flash_Config_Exe+0xc>
  {
  }

  /* Enable memory map mode */
  err = BSP_OSPI_NOR_EnableMemoryMappedMode(0);
 c003dbe:	f002 f923 	bl	c006008 <BSP_OSPI_NOR_EnableMemoryMappedMode>

  if (err != BSP_ERROR_NONE)
 c003dc2:	3000      	adds	r0, #0
 c003dc4:	bf18      	it	ne
 c003dc6:	2001      	movne	r0, #1
#endif /* DEBUG_OSPI_FLASH_ACCESS */
    return ARM_DRIVER_ERROR;
  }

  return ARM_DRIVER_OK;
}
 c003dc8:	4240      	negs	r0, r0
 c003dca:	bd08      	pop	{r3, pc}
 c003dcc:	30030220 	.word	0x30030220

0c003dd0 <mbedtls_hardware_poll>:
}


/*  interface for mbed-crypto */
int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, size_t *olen)
{
 c003dd0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c003dd4:	460d      	mov	r5, r1
 c003dd6:	4616      	mov	r6, r2
 c003dd8:	4698      	mov	r8, r3
__STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
 c003dda:	4b37      	ldr	r3, [pc, #220]	; (c003eb8 <mbedtls_hardware_poll+0xe8>)
 c003ddc:	461f      	mov	r7, r3
 c003dde:	e8d3 2f4f 	ldrexb	r2, [r3]
    newValue = __LDREXB(valuePtr) + delta;
 c003de2:	3201      	adds	r2, #1
 c003de4:	b2d2      	uxtb	r2, r2
 */
__STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
 c003de6:	e8c3 2f41 	strexb	r1, r2, [r3]
  } while (__STREXB(newValue, valuePtr));
 c003dea:	2900      	cmp	r1, #0
 c003dec:	d1f7      	bne.n	c003dde <mbedtls_hardware_poll+0xe>
  if (atomic_incr_u8(&users, 1) > 1)
 c003dee:	2a01      	cmp	r2, #1
 c003df0:	d901      	bls.n	c003df6 <mbedtls_hardware_poll+0x26>
    Error_Handler();
 c003df2:	f00d fd95 	bl	c011920 <Error_Handler>
  handle.Instance = RNG;
 c003df6:	4c31      	ldr	r4, [pc, #196]	; (c003ebc <mbedtls_hardware_poll+0xec>)
  handle.State = HAL_RNG_STATE_RESET;
 c003df8:	f04f 0900 	mov.w	r9, #0
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c003dfc:	46a2      	mov	sl, r4
  __HAL_RCC_RNG_CONFIG(RCC_RNGCLKSOURCE_MSI);
 c003dfe:	4b30      	ldr	r3, [pc, #192]	; (c003ec0 <mbedtls_hardware_poll+0xf0>)
  HAL_RNG_Init(&handle);
 c003e00:	4620      	mov	r0, r4
  __HAL_RCC_RNG_CONFIG(RCC_RNGCLKSOURCE_MSI);
 c003e02:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 c003e06:	f042 6240 	orr.w	r2, r2, #201326592	; 0xc000000
 c003e0a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __HAL_RCC_RNG_CLK_ENABLE();
 c003e0e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c003e10:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 c003e14:	64da      	str	r2, [r3, #76]	; 0x4c
 c003e16:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  handle.Lock = HAL_UNLOCKED;
 c003e18:	f884 9008 	strb.w	r9, [r4, #8]
  __HAL_RCC_RNG_CLK_ENABLE();
 c003e1c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 c003e20:	9301      	str	r3, [sp, #4]
 c003e22:	9b01      	ldr	r3, [sp, #4]
  handle.Instance = RNG;
 c003e24:	4b27      	ldr	r3, [pc, #156]	; (c003ec4 <mbedtls_hardware_poll+0xf4>)
  handle.State = HAL_RNG_STATE_RESET;
 c003e26:	f884 9009 	strb.w	r9, [r4, #9]
  handle.Instance = RNG;
 c003e2a:	6023      	str	r3, [r4, #0]
  HAL_RNG_Init(&handle);
 c003e2c:	f005 fe14 	bl	c009a58 <HAL_RNG_Init>
  HAL_RNG_GenerateRandomNumber(&handle, &dummy);
 c003e30:	4669      	mov	r1, sp
 c003e32:	4620      	mov	r0, r4
 c003e34:	f005 fef1 	bl	c009c1a <HAL_RNG_GenerateRandomNumber>
  *output_length = 0;
 c003e38:	f8c8 9000 	str.w	r9, [r8]
  while ((*output_length < length) && (ret == 0))
 c003e3c:	f8d8 3000 	ldr.w	r3, [r8]
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c003e40:	46ab      	mov	fp, r5
  while ((*output_length < length) && (ret == 0))
 c003e42:	429e      	cmp	r6, r3
 c003e44:	d904      	bls.n	c003e50 <mbedtls_hardware_poll+0x80>
    if (HAL_RNG_GenerateRandomNumber(&handle, (uint32_t *)random) != HAL_OK)
 c003e46:	4669      	mov	r1, sp
 c003e48:	4650      	mov	r0, sl
 c003e4a:	f005 fee6 	bl	c009c1a <HAL_RNG_GenerateRandomNumber>
 c003e4e:	b1d8      	cbz	r0, c003e88 <mbedtls_hardware_poll+0xb8>
  if ((__HAL_RNG_GET_FLAG(&handle, (RNG_FLAG_CECS | RNG_FLAG_SECS))) != 0)
 c003e50:	6823      	ldr	r3, [r4, #0]
  HAL_RNG_DeInit(&handle);
 c003e52:	481a      	ldr	r0, [pc, #104]	; (c003ebc <mbedtls_hardware_poll+0xec>)
  if ((__HAL_RNG_GET_FLAG(&handle, (RNG_FLAG_CECS | RNG_FLAG_SECS))) != 0)
 c003e54:	685b      	ldr	r3, [r3, #4]
 c003e56:	f003 0306 	and.w	r3, r3, #6
 c003e5a:	2b06      	cmp	r3, #6
    *output_length = 0;
 c003e5c:	bf04      	itt	eq
 c003e5e:	2300      	moveq	r3, #0
 c003e60:	f8c8 3000 	streq.w	r3, [r8]
  HAL_RNG_DeInit(&handle);
 c003e64:	f005 fe5b 	bl	c009b1e <HAL_RNG_DeInit>
  __HAL_RCC_RNG_CLK_DISABLE();
 c003e68:	4a15      	ldr	r2, [pc, #84]	; (c003ec0 <mbedtls_hardware_poll+0xf0>)
 c003e6a:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c003e6c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 c003e70:	64d3      	str	r3, [r2, #76]	; 0x4c
  users = 0;
 c003e72:	2300      	movs	r3, #0
 c003e74:	703b      	strb	r3, [r7, #0]
  RNG_Init();
  RNG_GetBytes(output, len, olen);
  RNG_DeInit();
  if (*olen != len)
 c003e76:	f8d8 0000 	ldr.w	r0, [r8]
  {
    return -1;
  }
  return 0;
}
 c003e7a:	1b80      	subs	r0, r0, r6
 c003e7c:	bf18      	it	ne
 c003e7e:	f04f 30ff 	movne.w	r0, #4294967295
 c003e82:	b003      	add	sp, #12
 c003e84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c003e88:	1d29      	adds	r1, r5, #4
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c003e8a:	f8d8 3000 	ldr.w	r3, [r8]
 c003e8e:	429e      	cmp	r6, r3
 c003e90:	d9d4      	bls.n	c003e3c <mbedtls_hardware_poll+0x6c>
 c003e92:	eba5 030b 	sub.w	r3, r5, fp
        *output++ = random[i];
 c003e96:	aa02      	add	r2, sp, #8
 c003e98:	4413      	add	r3, r2
 c003e9a:	f813 2c08 	ldrb.w	r2, [r3, #-8]
        random[i] = 0;
 c003e9e:	f803 9c08 	strb.w	r9, [r3, #-8]
        *output++ = random[i];
 c003ea2:	f805 2b01 	strb.w	r2, [r5], #1
        *output_length += 1;
 c003ea6:	f8d8 2000 	ldr.w	r2, [r8]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c003eaa:	428d      	cmp	r5, r1
        *output_length += 1;
 c003eac:	f102 0201 	add.w	r2, r2, #1
 c003eb0:	f8c8 2000 	str.w	r2, [r8]
      for (uint8_t i = 0; (i < 4) && (*output_length < length) ; i++)
 c003eb4:	d1e9      	bne.n	c003e8a <mbedtls_hardware_poll+0xba>
 c003eb6:	e7c1      	b.n	c003e3c <mbedtls_hardware_poll+0x6c>
 c003eb8:	30030238 	.word	0x30030238
 c003ebc:	30030224 	.word	0x30030224
 c003ec0:	50021000 	.word	0x50021000
 c003ec4:	520c0800 	.word	0x520c0800

0c003ec8 <mgf_mask>:
 * \param slen      length of the source buffer
 * \param md_ctx    message digest context to use
 */
static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
                      size_t slen, mbedtls_md_context_t *md_ctx )
{
 c003ec8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c003ecc:	b08d      	sub	sp, #52	; 0x34
    unsigned char *p;
    unsigned int hlen;
    size_t i, use_len;
    int ret = 0;

    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c003ece:	ae04      	add	r6, sp, #16
{
 c003ed0:	4607      	mov	r7, r0
 c003ed2:	460c      	mov	r4, r1
 c003ed4:	4691      	mov	r9, r2
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c003ed6:	2100      	movs	r1, #0
 c003ed8:	2220      	movs	r2, #32
 c003eda:	4630      	mov	r0, r6
{
 c003edc:	9301      	str	r3, [sp, #4]
 c003ede:	9d16      	ldr	r5, [sp, #88]	; 0x58
    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
 c003ee0:	f00a f8d3 	bl	c00e08a <memset>
    memset( counter, 0, 4 );
 c003ee4:	2300      	movs	r3, #0
 c003ee6:	f10d 0830 	add.w	r8, sp, #48	; 0x30

    hlen = mbedtls_md_get_size( md_ctx->md_info );
 c003eea:	6828      	ldr	r0, [r5, #0]
    memset( counter, 0, 4 );
 c003eec:	f848 3d24 	str.w	r3, [r8, #-36]!
    hlen = mbedtls_md_get_size( md_ctx->md_info );
 c003ef0:	f007 fe2c 	bl	c00bb4c <mbedtls_md_get_size>
 c003ef4:	4682      	mov	sl, r0

    /* Generate and apply dbMask */
    p = dst;

    while( dlen > 0 )
 c003ef6:	b954      	cbnz	r4, c003f0e <mgf_mask+0x46>
        counter[3]++;

        dlen -= use_len;
    }

exit:
 c003ef8:	4623      	mov	r3, r4
    mbedtls_platform_zeroize( mask, sizeof( mask ) );
 c003efa:	4630      	mov	r0, r6
 c003efc:	2120      	movs	r1, #32
 c003efe:	9301      	str	r3, [sp, #4]
 c003f00:	f007 fff0 	bl	c00bee4 <mbedtls_platform_zeroize>

    return( ret );
}
 c003f04:	9b01      	ldr	r3, [sp, #4]
 c003f06:	4618      	mov	r0, r3
 c003f08:	b00d      	add	sp, #52	; 0x34
 c003f0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c003f0e:	4554      	cmp	r4, sl
        if( ( ret = mbedtls_md_starts( md_ctx ) ) != 0 )
 c003f10:	4628      	mov	r0, r5
 c003f12:	46a3      	mov	fp, r4
 c003f14:	bf28      	it	cs
 c003f16:	46d3      	movcs	fp, sl
 c003f18:	f007 fdea 	bl	c00baf0 <mbedtls_md_starts>
 c003f1c:	4603      	mov	r3, r0
 c003f1e:	2800      	cmp	r0, #0
 c003f20:	d1eb      	bne.n	c003efa <mgf_mask+0x32>
        if( ( ret = mbedtls_md_update( md_ctx, src, slen ) ) != 0 )
 c003f22:	9a01      	ldr	r2, [sp, #4]
 c003f24:	4649      	mov	r1, r9
 c003f26:	4628      	mov	r0, r5
 c003f28:	f007 fdec 	bl	c00bb04 <mbedtls_md_update>
 c003f2c:	4603      	mov	r3, r0
 c003f2e:	2800      	cmp	r0, #0
 c003f30:	d1e3      	bne.n	c003efa <mgf_mask+0x32>
        if( ( ret = mbedtls_md_update( md_ctx, counter, 4 ) ) != 0 )
 c003f32:	2204      	movs	r2, #4
 c003f34:	4641      	mov	r1, r8
 c003f36:	4628      	mov	r0, r5
 c003f38:	f007 fde4 	bl	c00bb04 <mbedtls_md_update>
 c003f3c:	4603      	mov	r3, r0
 c003f3e:	2800      	cmp	r0, #0
 c003f40:	d1db      	bne.n	c003efa <mgf_mask+0x32>
        if( ( ret = mbedtls_md_finish( md_ctx, mask ) ) != 0 )
 c003f42:	4631      	mov	r1, r6
 c003f44:	4628      	mov	r0, r5
 c003f46:	f007 fde7 	bl	c00bb18 <mbedtls_md_finish>
 c003f4a:	4603      	mov	r3, r0
 c003f4c:	2800      	cmp	r0, #0
 c003f4e:	d1d4      	bne.n	c003efa <mgf_mask+0x32>
 c003f50:	463a      	mov	r2, r7
        for( i = 0; i < use_len; ++i )
 c003f52:	455b      	cmp	r3, fp
 c003f54:	d107      	bne.n	c003f66 <mgf_mask+0x9e>
        counter[3]++;
 c003f56:	f89d 200f 	ldrb.w	r2, [sp, #15]
 c003f5a:	441f      	add	r7, r3
 c003f5c:	3201      	adds	r2, #1
 c003f5e:	f88d 200f 	strb.w	r2, [sp, #15]
        dlen -= use_len;
 c003f62:	1ae4      	subs	r4, r4, r3
 c003f64:	e7c7      	b.n	c003ef6 <mgf_mask+0x2e>
            *p++ ^= mask[i];
 c003f66:	f812 1b01 	ldrb.w	r1, [r2], #1
 c003f6a:	5cf0      	ldrb	r0, [r6, r3]
        for( i = 0; i < use_len; ++i )
 c003f6c:	3301      	adds	r3, #1
            *p++ ^= mask[i];
 c003f6e:	4041      	eors	r1, r0
 c003f70:	f802 1c01 	strb.w	r1, [r2, #-1]
 c003f74:	e7ed      	b.n	c003f52 <mgf_mask+0x8a>
	...

0c003f78 <rsa_check_context.isra.0>:
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c003f78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c003f7a:	f100 0508 	add.w	r5, r0, #8
 c003f7e:	6847      	ldr	r7, [r0, #4]
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c003f80:	4604      	mov	r4, r0
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c003f82:	4628      	mov	r0, r5
static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
 c003f84:	460e      	mov	r6, r1
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c003f86:	f006 feb9 	bl	c00acfc <mbedtls_mpi_size>
 c003f8a:	4287      	cmp	r7, r0
 c003f8c:	d001      	beq.n	c003f92 <rsa_check_context.isra.0+0x1a>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c003f8e:	4827      	ldr	r0, [pc, #156]	; (c00402c <rsa_check_context.isra.0+0xb4>)
}
 c003f90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
 c003f92:	6863      	ldr	r3, [r4, #4]
 c003f94:	f5b3 7fc0 	cmp.w	r3, #384	; 0x180
 c003f98:	d8f9      	bhi.n	c003f8e <rsa_check_context.isra.0+0x16>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c003f9a:	2100      	movs	r1, #0
 c003f9c:	4628      	mov	r0, r5
 c003f9e:	f007 f814 	bl	c00afca <mbedtls_mpi_cmp_int>
 c003fa2:	2800      	cmp	r0, #0
 c003fa4:	ddf3      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
 c003fa6:	2100      	movs	r1, #0
 c003fa8:	4628      	mov	r0, r5
 c003faa:	f006 fe5c 	bl	c00ac66 <mbedtls_mpi_get_bit>
    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
 c003fae:	2800      	cmp	r0, #0
 c003fb0:	d0ed      	beq.n	c003f8e <rsa_check_context.isra.0+0x16>
    if( is_priv &&
 c003fb2:	b9f6      	cbnz	r6, c003ff2 <rsa_check_context.isra.0+0x7a>
    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
 c003fb4:	2100      	movs	r1, #0
 c003fb6:	f104 0014 	add.w	r0, r4, #20
 c003fba:	f007 f806 	bl	c00afca <mbedtls_mpi_cmp_int>
 c003fbe:	2800      	cmp	r0, #0
 c003fc0:	dde5      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
    if( is_priv &&
 c003fc2:	b1a6      	cbz	r6, c003fee <rsa_check_context.isra.0+0x76>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c003fc4:	2100      	movs	r1, #0
 c003fc6:	f104 0044 	add.w	r0, r4, #68	; 0x44
 c003fca:	f006 fffe 	bl	c00afca <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c003fce:	2800      	cmp	r0, #0
 c003fd0:	dddd      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
 c003fd2:	2100      	movs	r1, #0
 c003fd4:	f104 0050 	add.w	r0, r4, #80	; 0x50
 c003fd8:	f006 fff7 	bl	c00afca <mbedtls_mpi_cmp_int>
        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
 c003fdc:	2800      	cmp	r0, #0
 c003fde:	ddd6      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
 c003fe0:	2100      	movs	r1, #0
 c003fe2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c003fe6:	f006 fff0 	bl	c00afca <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c003fea:	2800      	cmp	r0, #0
 c003fec:	ddcf      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
    return( 0 );
 c003fee:	2000      	movs	r0, #0
 c003ff0:	e7ce      	b.n	c003f90 <rsa_check_context.isra.0+0x18>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c003ff2:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 c003ff6:	2100      	movs	r1, #0
 c003ff8:	4628      	mov	r0, r5
 c003ffa:	f006 ffe6 	bl	c00afca <mbedtls_mpi_cmp_int>
    if( is_priv &&
 c003ffe:	2800      	cmp	r0, #0
 c004000:	ddc5      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c004002:	2100      	movs	r1, #0
 c004004:	4628      	mov	r0, r5
 c004006:	f006 fe2e 	bl	c00ac66 <mbedtls_mpi_get_bit>
        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
 c00400a:	2800      	cmp	r0, #0
 c00400c:	d0bf      	beq.n	c003f8e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c00400e:	f104 0538 	add.w	r5, r4, #56	; 0x38
 c004012:	2100      	movs	r1, #0
 c004014:	4628      	mov	r0, r5
 c004016:	f006 ffd8 	bl	c00afca <mbedtls_mpi_cmp_int>
          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
 c00401a:	2800      	cmp	r0, #0
 c00401c:	ddb7      	ble.n	c003f8e <rsa_check_context.isra.0+0x16>
          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
 c00401e:	2100      	movs	r1, #0
 c004020:	4628      	mov	r0, r5
 c004022:	f006 fe20 	bl	c00ac66 <mbedtls_mpi_get_bit>
          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
 c004026:	2800      	cmp	r0, #0
 c004028:	d1c4      	bne.n	c003fb4 <rsa_check_context.isra.0+0x3c>
 c00402a:	e7b0      	b.n	c003f8e <rsa_check_context.isra.0+0x16>
 c00402c:	ffffbf80 	.word	0xffffbf80

0c004030 <mbedtls_rsa_import>:
{
 c004030:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c004034:	4604      	mov	r4, r0
 c004036:	e9dd 7608 	ldrd	r7, r6, [sp, #32]
 c00403a:	4691      	mov	r9, r2
 c00403c:	4698      	mov	r8, r3
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c00403e:	460d      	mov	r5, r1
 c004040:	b979      	cbnz	r1, c004062 <mbedtls_rsa_import+0x32>
 c004042:	f1b9 0f00 	cmp.w	r9, #0
 c004046:	d115      	bne.n	c004074 <mbedtls_rsa_import+0x44>
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c004048:	f1b8 0f00 	cmp.w	r8, #0
 c00404c:	d11a      	bne.n	c004084 <mbedtls_rsa_import+0x54>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c00404e:	bb0f      	cbnz	r7, c004094 <mbedtls_rsa_import+0x64>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c004050:	bb46      	cbnz	r6, c0040a4 <mbedtls_rsa_import+0x74>
    if( N != NULL )
 c004052:	b37d      	cbz	r5, c0040b4 <mbedtls_rsa_import+0x84>
        ctx->len = mbedtls_mpi_size( &ctx->N );
 c004054:	f104 0008 	add.w	r0, r4, #8
 c004058:	f006 fe50 	bl	c00acfc <mbedtls_mpi_size>
 c00405c:	6060      	str	r0, [r4, #4]
    return( 0 );
 c00405e:	2000      	movs	r0, #0
 c004060:	e006      	b.n	c004070 <mbedtls_rsa_import+0x40>
    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
 c004062:	3008      	adds	r0, #8
 c004064:	f006 fdb7 	bl	c00abd6 <mbedtls_mpi_copy>
 c004068:	2800      	cmp	r0, #0
 c00406a:	d0ea      	beq.n	c004042 <mbedtls_rsa_import+0x12>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
 c00406c:	f5a0 4081 	sub.w	r0, r0, #16512	; 0x4080
}
 c004070:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
 c004074:	4649      	mov	r1, r9
 c004076:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 c00407a:	f006 fdac 	bl	c00abd6 <mbedtls_mpi_copy>
 c00407e:	2800      	cmp	r0, #0
 c004080:	d0e2      	beq.n	c004048 <mbedtls_rsa_import+0x18>
 c004082:	e7f3      	b.n	c00406c <mbedtls_rsa_import+0x3c>
        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
 c004084:	4641      	mov	r1, r8
 c004086:	f104 0038 	add.w	r0, r4, #56	; 0x38
 c00408a:	f006 fda4 	bl	c00abd6 <mbedtls_mpi_copy>
 c00408e:	2800      	cmp	r0, #0
 c004090:	d0dd      	beq.n	c00404e <mbedtls_rsa_import+0x1e>
 c004092:	e7eb      	b.n	c00406c <mbedtls_rsa_import+0x3c>
        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
 c004094:	4639      	mov	r1, r7
 c004096:	f104 0020 	add.w	r0, r4, #32
 c00409a:	f006 fd9c 	bl	c00abd6 <mbedtls_mpi_copy>
 c00409e:	2800      	cmp	r0, #0
 c0040a0:	d0d6      	beq.n	c004050 <mbedtls_rsa_import+0x20>
 c0040a2:	e7e3      	b.n	c00406c <mbedtls_rsa_import+0x3c>
        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
 c0040a4:	4631      	mov	r1, r6
 c0040a6:	f104 0014 	add.w	r0, r4, #20
 c0040aa:	f006 fd94 	bl	c00abd6 <mbedtls_mpi_copy>
 c0040ae:	2800      	cmp	r0, #0
 c0040b0:	d0cf      	beq.n	c004052 <mbedtls_rsa_import+0x22>
 c0040b2:	e7db      	b.n	c00406c <mbedtls_rsa_import+0x3c>
    return( 0 );
 c0040b4:	4628      	mov	r0, r5
 c0040b6:	e7db      	b.n	c004070 <mbedtls_rsa_import+0x40>

0c0040b8 <mbedtls_rsa_init>:
{
 c0040b8:	b538      	push	{r3, r4, r5, lr}
 c0040ba:	460d      	mov	r5, r1
 c0040bc:	4614      	mov	r4, r2
    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
 c0040be:	2100      	movs	r1, #0
 c0040c0:	22a4      	movs	r2, #164	; 0xa4
 c0040c2:	f009 ffe2 	bl	c00e08a <memset>
    ctx->hash_id = hash_id;
 c0040c6:	e9c0 5429 	strd	r5, r4, [r0, #164]	; 0xa4
}
 c0040ca:	bd38      	pop	{r3, r4, r5, pc}

0c0040cc <mbedtls_rsa_check_pubkey>:
{
 c0040cc:	b570      	push	{r4, r5, r6, lr}
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c0040ce:	2100      	movs	r1, #0
{
 c0040d0:	4604      	mov	r4, r0
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
 c0040d2:	f7ff ff51 	bl	c003f78 <rsa_check_context.isra.0>
 c0040d6:	4605      	mov	r5, r0
 c0040d8:	b9b8      	cbnz	r0, c00410a <mbedtls_rsa_check_pubkey+0x3e>
    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
 c0040da:	f104 0608 	add.w	r6, r4, #8
 c0040de:	4630      	mov	r0, r6
 c0040e0:	f006 fdec 	bl	c00acbc <mbedtls_mpi_bitlen>
 c0040e4:	287f      	cmp	r0, #127	; 0x7f
 c0040e6:	d910      	bls.n	c00410a <mbedtls_rsa_check_pubkey+0x3e>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c0040e8:	3414      	adds	r4, #20
 c0040ea:	4629      	mov	r1, r5
 c0040ec:	4620      	mov	r0, r4
 c0040ee:	f006 fdba 	bl	c00ac66 <mbedtls_mpi_get_bit>
 c0040f2:	b150      	cbz	r0, c00410a <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c0040f4:	4620      	mov	r0, r4
 c0040f6:	f006 fde1 	bl	c00acbc <mbedtls_mpi_bitlen>
    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
 c0040fa:	2801      	cmp	r0, #1
 c0040fc:	d905      	bls.n	c00410a <mbedtls_rsa_check_pubkey+0x3e>
        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
 c0040fe:	4631      	mov	r1, r6
 c004100:	4620      	mov	r0, r4
 c004102:	f006 ff22 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
 c004106:	2800      	cmp	r0, #0
 c004108:	db00      	blt.n	c00410c <mbedtls_rsa_check_pubkey+0x40>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c00410a:	4d01      	ldr	r5, [pc, #4]	; (c004110 <mbedtls_rsa_check_pubkey+0x44>)
}
 c00410c:	4628      	mov	r0, r5
 c00410e:	bd70      	pop	{r4, r5, r6, pc}
 c004110:	ffffbe00 	.word	0xffffbe00

0c004114 <mbedtls_rsa_check_privkey>:
{
 c004114:	b5f0      	push	{r4, r5, r6, r7, lr}
 c004116:	b085      	sub	sp, #20
 c004118:	4604      	mov	r4, r0
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 c00411a:	f7ff ffd7 	bl	c0040cc <mbedtls_rsa_check_pubkey>
 c00411e:	b110      	cbz	r0, c004126 <mbedtls_rsa_check_privkey+0x12>
        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
 c004120:	4816      	ldr	r0, [pc, #88]	; (c00417c <mbedtls_rsa_check_privkey+0x68>)
}
 c004122:	b005      	add	sp, #20
 c004124:	bdf0      	pop	{r4, r5, r6, r7, pc}
        rsa_check_context( ctx, 1 /* private */, 1 /* blinding */ ) != 0 )
 c004126:	2101      	movs	r1, #1
 c004128:	4620      	mov	r0, r4
 c00412a:	f7ff ff25 	bl	c003f78 <rsa_check_context.isra.0>
    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
 c00412e:	2800      	cmp	r0, #0
 c004130:	d1f6      	bne.n	c004120 <mbedtls_rsa_check_privkey+0xc>
    if( mbedtls_rsa_validate_params( &ctx->N, &ctx->P, &ctx->Q,
 c004132:	f104 0314 	add.w	r3, r4, #20
 c004136:	f104 052c 	add.w	r5, r4, #44	; 0x2c
 c00413a:	f104 0638 	add.w	r6, r4, #56	; 0x38
 c00413e:	f104 0720 	add.w	r7, r4, #32
 c004142:	e9cd 0001 	strd	r0, r0, [sp, #4]
 c004146:	9300      	str	r3, [sp, #0]
 c004148:	4632      	mov	r2, r6
 c00414a:	463b      	mov	r3, r7
 c00414c:	4629      	mov	r1, r5
 c00414e:	f104 0008 	add.w	r0, r4, #8
 c004152:	f007 ff55 	bl	c00c000 <mbedtls_rsa_validate_params>
 c004156:	2800      	cmp	r0, #0
 c004158:	d1e2      	bne.n	c004120 <mbedtls_rsa_check_privkey+0xc>
    else if( mbedtls_rsa_validate_crt( &ctx->P, &ctx->Q, &ctx->D,
 c00415a:	f104 035c 	add.w	r3, r4, #92	; 0x5c
 c00415e:	9301      	str	r3, [sp, #4]
 c004160:	f104 0350 	add.w	r3, r4, #80	; 0x50
 c004164:	9300      	str	r3, [sp, #0]
 c004166:	463a      	mov	r2, r7
 c004168:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c00416c:	4631      	mov	r1, r6
 c00416e:	4628      	mov	r0, r5
 c004170:	f007 fec0 	bl	c00bef4 <mbedtls_rsa_validate_crt>
 c004174:	2800      	cmp	r0, #0
 c004176:	d0d4      	beq.n	c004122 <mbedtls_rsa_check_privkey+0xe>
 c004178:	e7d2      	b.n	c004120 <mbedtls_rsa_check_privkey+0xc>
 c00417a:	bf00      	nop
 c00417c:	ffffbe00 	.word	0xffffbe00

0c004180 <mbedtls_rsa_public>:
{
 c004180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c004184:	468b      	mov	fp, r1
 c004186:	b08f      	sub	sp, #60	; 0x3c
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c004188:	2100      	movs	r1, #0
{
 c00418a:	4607      	mov	r7, r0
 c00418c:	9201      	str	r2, [sp, #4]
    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
 c00418e:	f7ff fef3 	bl	c003f78 <rsa_check_context.isra.0>
 c004192:	2800      	cmp	r0, #0
 c004194:	f040 809c 	bne.w	c0042d0 <mbedtls_rsa_public+0x150>
    mbedtls_mpi_init( &T );
 c004198:	a803      	add	r0, sp, #12
 c00419a:	f006 fcde 	bl	c00ab5a <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c00419e:	687a      	ldr	r2, [r7, #4]
 c0041a0:	4659      	mov	r1, fp
 c0041a2:	a803      	add	r0, sp, #12
 c0041a4:	f006 fdb0 	bl	c00ad08 <mbedtls_mpi_read_binary>
 c0041a8:	4604      	mov	r4, r0
 c0041aa:	2800      	cmp	r0, #0
 c0041ac:	f040 8081 	bne.w	c0042b2 <mbedtls_rsa_public+0x132>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c0041b0:	f107 0908 	add.w	r9, r7, #8
 c0041b4:	4649      	mov	r1, r9
 c0041b6:	a803      	add	r0, sp, #12
 c0041b8:	f006 fec7 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c0041bc:	2800      	cmp	r0, #0
 c0041be:	f280 8084 	bge.w	c0042ca <mbedtls_rsa_public+0x14a>
    PKA_ModExpInTypeDef in = {0};
 c0041c2:	2214      	movs	r2, #20
 c0041c4:	4621      	mov	r1, r4
    MBEDTLS_MPI_CHK( rsa_pka_modexp( &ctx->E, &ctx->N, input, output ) );
 c0041c6:	3714      	adds	r7, #20
    PKA_ModExpInTypeDef in = {0};
 c0041c8:	a809      	add	r0, sp, #36	; 0x24
    PKA_HandleTypeDef hpka = {0};
 c0041ca:	e9cd 4406 	strd	r4, r4, [sp, #24]
 c0041ce:	9408      	str	r4, [sp, #32]
    PKA_ModExpInTypeDef in = {0};
 c0041d0:	f009 ff5b 	bl	c00e08a <memset>
    elen = mbedtls_mpi_size( exponent );
 c0041d4:	4638      	mov	r0, r7
 c0041d6:	f006 fd91 	bl	c00acfc <mbedtls_mpi_size>
    if (elen < 4)
 c0041da:	2803      	cmp	r0, #3
      elen = 4;
 c0041dc:	bf92      	itee	ls
 c0041de:	2604      	movls	r6, #4
        elen_padding = (elen % 4);
 c0041e0:	f000 0603 	andhi.w	r6, r0, #3
        elen += elen_padding;
 c0041e4:	1836      	addhi	r6, r6, r0
    e_binary = mbedtls_calloc( 1, elen );
 c0041e6:	4631      	mov	r1, r6
 c0041e8:	2001      	movs	r0, #1
 c0041ea:	f007 fe65 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( e_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c0041ee:	4680      	mov	r8, r0
 c0041f0:	b918      	cbnz	r0, c0041fa <mbedtls_rsa_public+0x7a>
    uint8_t *n_binary = NULL;
 c0041f2:	2500      	movs	r5, #0
    MBEDTLS_MPI_CHK( ( HAL_PKA_ModExp( &hpka, &in, ST_PKA_TIMEOUT ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c0041f4:	f06f 046f 	mvn.w	r4, #111	; 0x6f
 c0041f8:	e03b      	b.n	c004272 <mbedtls_rsa_public+0xf2>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( exponent, e_binary, elen ) );
 c0041fa:	4601      	mov	r1, r0
 c0041fc:	4632      	mov	r2, r6
 c0041fe:	4638      	mov	r0, r7
 c004200:	f006 fdba 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c004204:	4604      	mov	r4, r0
 c004206:	2800      	cmp	r0, #0
 c004208:	d15d      	bne.n	c0042c6 <mbedtls_rsa_public+0x146>
    nlen = mbedtls_mpi_size( modulus );
 c00420a:	4648      	mov	r0, r9
 c00420c:	f006 fd76 	bl	c00acfc <mbedtls_mpi_size>
    n_binary = mbedtls_calloc( 1, nlen );
 c004210:	4601      	mov	r1, r0
    nlen = mbedtls_mpi_size( modulus );
 c004212:	4682      	mov	sl, r0
    n_binary = mbedtls_calloc( 1, nlen );
 c004214:	2001      	movs	r0, #1
 c004216:	f007 fe4f 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( n_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c00421a:	4605      	mov	r5, r0
 c00421c:	2800      	cmp	r0, #0
 c00421e:	d0e8      	beq.n	c0041f2 <mbedtls_rsa_public+0x72>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( modulus, n_binary, nlen ) );
 c004220:	4601      	mov	r1, r0
 c004222:	4652      	mov	r2, sl
 c004224:	4648      	mov	r0, r9
 c004226:	f006 fda7 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c00422a:	4604      	mov	r4, r0
 c00422c:	bb08      	cbnz	r0, c004272 <mbedtls_rsa_public+0xf2>
    in.OpSize  = nlen;           /* modulus length */
 c00422e:	e9cd 6a09 	strd	r6, sl, [sp, #36]	; 0x24
    __HAL_RCC_PKA_CLK_ENABLE();
 c004232:	4b28      	ldr	r3, [pc, #160]	; (c0042d4 <mbedtls_rsa_public+0x154>)
    in.pExp    = e_binary;       /* Exponent */
 c004234:	e9cd 8b0b 	strd	r8, fp, [sp, #44]	; 0x2c
    __HAL_RCC_PKA_CLK_ENABLE();
 c004238:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    in.pMod    = n_binary;       /* modulus */
 c00423a:	950d      	str	r5, [sp, #52]	; 0x34
    __HAL_RCC_PKA_CLK_ENABLE();
 c00423c:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 c004240:	64da      	str	r2, [r3, #76]	; 0x4c
 c004242:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c004244:	a806      	add	r0, sp, #24
    __HAL_RCC_PKA_CLK_ENABLE();
 c004246:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 c00424a:	9302      	str	r3, [sp, #8]
 c00424c:	9b02      	ldr	r3, [sp, #8]
    hpka.Instance = PKA;
 c00424e:	4b22      	ldr	r3, [pc, #136]	; (c0042d8 <mbedtls_rsa_public+0x158>)
 c004250:	9306      	str	r3, [sp, #24]
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c004252:	f004 fad0 	bl	c0087f6 <HAL_PKA_Init>
 c004256:	2800      	cmp	r0, #0
 c004258:	d1cc      	bne.n	c0041f4 <mbedtls_rsa_public+0x74>
    MBEDTLS_MPI_CHK( ( HAL_PKA_ModExp( &hpka, &in, ST_PKA_TIMEOUT ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c00425a:	f241 3288 	movw	r2, #5000	; 0x1388
 c00425e:	a909      	add	r1, sp, #36	; 0x24
 c004260:	a806      	add	r0, sp, #24
 c004262:	f004 fc29 	bl	c008ab8 <HAL_PKA_ModExp>
 c004266:	2800      	cmp	r0, #0
 c004268:	d1c4      	bne.n	c0041f4 <mbedtls_rsa_public+0x74>
    HAL_PKA_ModExp_GetResult( &hpka, (uint8_t *)output );
 c00426a:	9901      	ldr	r1, [sp, #4]
 c00426c:	a806      	add	r0, sp, #24
 c00426e:	f004 fb61 	bl	c008934 <HAL_PKA_ModExp_GetResult>
    HAL_PKA_DeInit( &hpka );
 c004272:	a806      	add	r0, sp, #24
 c004274:	f004 fae8 	bl	c008848 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c004278:	4a16      	ldr	r2, [pc, #88]	; (c0042d4 <mbedtls_rsa_public+0x154>)
 c00427a:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c00427c:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 c004280:	64d3      	str	r3, [r2, #76]	; 0x4c
    if (e_binary != NULL)
 c004282:	f1b8 0f00 	cmp.w	r8, #0
 c004286:	d009      	beq.n	c00429c <mbedtls_rsa_public+0x11c>
        mbedtls_platform_zeroize( e_binary, mbedtls_mpi_size( exponent ) );
 c004288:	4638      	mov	r0, r7
 c00428a:	f006 fd37 	bl	c00acfc <mbedtls_mpi_size>
 c00428e:	4601      	mov	r1, r0
 c004290:	4640      	mov	r0, r8
 c004292:	f007 fe27 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( e_binary );
 c004296:	4640      	mov	r0, r8
 c004298:	f007 fe14 	bl	c00bec4 <mbedtls_free>
    if (n_binary != NULL)
 c00429c:	b14d      	cbz	r5, c0042b2 <mbedtls_rsa_public+0x132>
        mbedtls_platform_zeroize( n_binary, mbedtls_mpi_size( modulus ) );
 c00429e:	4648      	mov	r0, r9
 c0042a0:	f006 fd2c 	bl	c00acfc <mbedtls_mpi_size>
 c0042a4:	4601      	mov	r1, r0
 c0042a6:	4628      	mov	r0, r5
 c0042a8:	f007 fe1c 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( n_binary );
 c0042ac:	4628      	mov	r0, r5
 c0042ae:	f007 fe09 	bl	c00bec4 <mbedtls_free>
    mbedtls_mpi_free( &T );
 c0042b2:	a803      	add	r0, sp, #12
 c0042b4:	f006 fc57 	bl	c00ab66 <mbedtls_mpi_free>
    if( ret != 0 )
 c0042b8:	b10c      	cbz	r4, c0042be <mbedtls_rsa_public+0x13e>
        return( MBEDTLS_ERR_RSA_PUBLIC_FAILED + ret );
 c0042ba:	f5a4 4485 	sub.w	r4, r4, #17024	; 0x4280
}
 c0042be:	4620      	mov	r0, r4
 c0042c0:	b00f      	add	sp, #60	; 0x3c
 c0042c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t *n_binary = NULL;
 c0042c6:	2500      	movs	r5, #0
 c0042c8:	e7d3      	b.n	c004272 <mbedtls_rsa_public+0xf2>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c0042ca:	f06f 0403 	mvn.w	r4, #3
 c0042ce:	e7f0      	b.n	c0042b2 <mbedtls_rsa_public+0x132>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c0042d0:	4c02      	ldr	r4, [pc, #8]	; (c0042dc <mbedtls_rsa_public+0x15c>)
 c0042d2:	e7f4      	b.n	c0042be <mbedtls_rsa_public+0x13e>
 c0042d4:	50021000 	.word	0x50021000
 c0042d8:	520c2000 	.word	0x520c2000
 c0042dc:	ffffbf80 	.word	0xffffbf80

0c0042e0 <mbedtls_rsa_private>:
{
 c0042e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( rsa_check_context( ctx, 1             /* private key checks */,
 c0042e4:	2101      	movs	r1, #1
{
 c0042e6:	b0ab      	sub	sp, #172	; 0xac
 c0042e8:	4605      	mov	r5, r0
 c0042ea:	9304      	str	r3, [sp, #16]
    if( rsa_check_context( ctx, 1             /* private key checks */,
 c0042ec:	f7ff fe44 	bl	c003f78 <rsa_check_context.isra.0>
 c0042f0:	4606      	mov	r6, r0
 c0042f2:	2800      	cmp	r0, #0
 c0042f4:	f040 8149 	bne.w	c00458a <mbedtls_rsa_private+0x2aa>
    mbedtls_mpi_init( &T );
 c0042f8:	a808      	add	r0, sp, #32
 c0042fa:	f006 fc2e 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &P1 );
 c0042fe:	a80b      	add	r0, sp, #44	; 0x2c
 c004300:	f006 fc2b 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &Q1 );
 c004304:	a80e      	add	r0, sp, #56	; 0x38
 c004306:	f006 fc28 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &R );
 c00430a:	a811      	add	r0, sp, #68	; 0x44
 c00430c:	f006 fc25 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &TP ); mbedtls_mpi_init( &TQ );
 c004310:	a814      	add	r0, sp, #80	; 0x50
 c004312:	f006 fc22 	bl	c00ab5a <mbedtls_mpi_init>
 c004316:	a817      	add	r0, sp, #92	; 0x5c
 c004318:	f006 fc1f 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &I );
 c00431c:	a81a      	add	r0, sp, #104	; 0x68
 c00431e:	f006 fc1c 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &C );
 c004322:	a81d      	add	r0, sp, #116	; 0x74
 c004324:	f006 fc19 	bl	c00ab5a <mbedtls_mpi_init>
    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
 c004328:	686a      	ldr	r2, [r5, #4]
 c00432a:	9904      	ldr	r1, [sp, #16]
 c00432c:	a808      	add	r0, sp, #32
 c00432e:	f006 fceb 	bl	c00ad08 <mbedtls_mpi_read_binary>
 c004332:	4604      	mov	r4, r0
 c004334:	2800      	cmp	r0, #0
 c004336:	f040 80ea 	bne.w	c00450e <mbedtls_rsa_private+0x22e>
    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
 c00433a:	f105 0108 	add.w	r1, r5, #8
 c00433e:	a808      	add	r0, sp, #32
 c004340:	f006 fe03 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c004344:	2800      	cmp	r0, #0
 c004346:	f280 811d 	bge.w	c004584 <mbedtls_rsa_private+0x2a4>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &I, &T ) );
 c00434a:	a908      	add	r1, sp, #32
 c00434c:	a81a      	add	r0, sp, #104	; 0x68
 c00434e:	f006 fc42 	bl	c00abd6 <mbedtls_mpi_copy>
 c004352:	4604      	mov	r4, r0
 c004354:	2800      	cmp	r0, #0
 c004356:	f040 80da 	bne.w	c00450e <mbedtls_rsa_private+0x22e>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c00435a:	686b      	ldr	r3, [r5, #4]
    PKA_RSACRTExpInTypeDef in = {0};
 c00435c:	4601      	mov	r1, r0
 c00435e:	221c      	movs	r2, #28
    PKA_HandleTypeDef hpka = {0};
 c004360:	e9cd 0020 	strd	r0, r0, [sp, #128]	; 0x80
 c004364:	9022      	str	r0, [sp, #136]	; 0x88
    mbedtls_mpi *DP = &ctx->DP;
 c004366:	f105 0744 	add.w	r7, r5, #68	; 0x44
    PKA_RSACRTExpInTypeDef in = {0};
 c00436a:	a823      	add	r0, sp, #140	; 0x8c
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c00436c:	9305      	str	r3, [sp, #20]
    PKA_RSACRTExpInTypeDef in = {0};
 c00436e:	f009 fe8c 	bl	c00e08a <memset>
    dplen = mbedtls_mpi_size( dp );
 c004372:	4638      	mov	r0, r7
 c004374:	f006 fcc2 	bl	c00acfc <mbedtls_mpi_size>
    dp_binary = mbedtls_calloc( 1, dplen );
 c004378:	4601      	mov	r1, r0
    dplen = mbedtls_mpi_size( dp );
 c00437a:	4683      	mov	fp, r0
    dp_binary = mbedtls_calloc( 1, dplen );
 c00437c:	2001      	movs	r0, #1
 c00437e:	f007 fd9b 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( dp_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c004382:	4681      	mov	r9, r0
 c004384:	2800      	cmp	r0, #0
 c004386:	f000 80e1 	beq.w	c00454c <mbedtls_rsa_private+0x26c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( dp, dp_binary, dplen ) );
 c00438a:	4601      	mov	r1, r0
 c00438c:	465a      	mov	r2, fp
 c00438e:	4638      	mov	r0, r7
 c004390:	f006 fcf2 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c004394:	4604      	mov	r4, r0
 c004396:	2800      	cmp	r0, #0
 c004398:	f040 80df 	bne.w	c00455a <mbedtls_rsa_private+0x27a>
    mbedtls_mpi *DQ = &ctx->DQ;
 c00439c:	f105 0450 	add.w	r4, r5, #80	; 0x50
    dqlen = mbedtls_mpi_size( dq );
 c0043a0:	4620      	mov	r0, r4
 c0043a2:	f006 fcab 	bl	c00acfc <mbedtls_mpi_size>
    dq_binary = mbedtls_calloc( 1, dqlen );
 c0043a6:	4601      	mov	r1, r0
    dqlen = mbedtls_mpi_size( dq );
 c0043a8:	4682      	mov	sl, r0
    dq_binary = mbedtls_calloc( 1, dqlen );
 c0043aa:	2001      	movs	r0, #1
 c0043ac:	f007 fd84 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( dq_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c0043b0:	4680      	mov	r8, r0
 c0043b2:	2800      	cmp	r0, #0
 c0043b4:	f000 80d5 	beq.w	c004562 <mbedtls_rsa_private+0x282>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( dq, dq_binary, dqlen ) );
 c0043b8:	4601      	mov	r1, r0
 c0043ba:	4652      	mov	r2, sl
 c0043bc:	4620      	mov	r0, r4
 c0043be:	f006 fcdb 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c0043c2:	4604      	mov	r4, r0
 c0043c4:	2800      	cmp	r0, #0
 c0043c6:	f040 80d0 	bne.w	c00456a <mbedtls_rsa_private+0x28a>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c0043ca:	f105 042c 	add.w	r4, r5, #44	; 0x2c
    plen = mbedtls_mpi_size( p );
 c0043ce:	4620      	mov	r0, r4
 c0043d0:	f006 fc94 	bl	c00acfc <mbedtls_mpi_size>
 c0043d4:	9001      	str	r0, [sp, #4]
    p_binary = mbedtls_calloc( 1, plen );
 c0043d6:	4601      	mov	r1, r0
 c0043d8:	2001      	movs	r0, #1
 c0043da:	f007 fd6d 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( p_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c0043de:	4607      	mov	r7, r0
 c0043e0:	2800      	cmp	r0, #0
 c0043e2:	f000 80c5 	beq.w	c004570 <mbedtls_rsa_private+0x290>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( p, p_binary, plen ) );
 c0043e6:	4601      	mov	r1, r0
 c0043e8:	9a01      	ldr	r2, [sp, #4]
 c0043ea:	4620      	mov	r0, r4
 c0043ec:	f006 fcc4 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c0043f0:	4604      	mov	r4, r0
 c0043f2:	2800      	cmp	r0, #0
 c0043f4:	f040 80bf 	bne.w	c004576 <mbedtls_rsa_private+0x296>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c0043f8:	f105 0438 	add.w	r4, r5, #56	; 0x38
    qlen = mbedtls_mpi_size( q );
 c0043fc:	4620      	mov	r0, r4
 c0043fe:	f006 fc7d 	bl	c00acfc <mbedtls_mpi_size>
 c004402:	9002      	str	r0, [sp, #8]
    q_binary = mbedtls_calloc( 1, qlen );
 c004404:	4601      	mov	r1, r0
 c004406:	2001      	movs	r0, #1
 c004408:	f007 fd56 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( q_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c00440c:	4606      	mov	r6, r0
 c00440e:	2800      	cmp	r0, #0
 c004410:	f000 80b4 	beq.w	c00457c <mbedtls_rsa_private+0x29c>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( q, q_binary, qlen ) );
 c004414:	4601      	mov	r1, r0
 c004416:	9a02      	ldr	r2, [sp, #8]
 c004418:	4620      	mov	r0, r4
 c00441a:	f006 fcad 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c00441e:	4604      	mov	r4, r0
 c004420:	2800      	cmp	r0, #0
 c004422:	f040 80ad 	bne.w	c004580 <mbedtls_rsa_private+0x2a0>
    MBEDTLS_MPI_CHK( rsa_crt_pka_modexp( DP, DQ, &ctx->P, &ctx->Q, &ctx->QP, input, ctx->len, output) );
 c004426:	f105 045c 	add.w	r4, r5, #92	; 0x5c
    qplen = mbedtls_mpi_size( qp );
 c00442a:	4620      	mov	r0, r4
 c00442c:	f006 fc66 	bl	c00acfc <mbedtls_mpi_size>
 c004430:	9003      	str	r0, [sp, #12]
    qp_binary = mbedtls_calloc( 1, qplen );
 c004432:	4601      	mov	r1, r0
 c004434:	2001      	movs	r0, #1
 c004436:	f007 fd3f 	bl	c00beb8 <mbedtls_calloc>
    MBEDTLS_MPI_CHK( ( qp_binary == NULL ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c00443a:	4605      	mov	r5, r0
 c00443c:	2800      	cmp	r0, #0
 c00443e:	f000 8089 	beq.w	c004554 <mbedtls_rsa_private+0x274>
    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( qp, qp_binary, qplen ) );
 c004442:	4601      	mov	r1, r0
 c004444:	9a03      	ldr	r2, [sp, #12]
 c004446:	4620      	mov	r0, r4
 c004448:	f006 fc96 	bl	c00ad78 <mbedtls_mpi_write_binary>
 c00444c:	4604      	mov	r4, r0
 c00444e:	bb50      	cbnz	r0, c0044a6 <mbedtls_rsa_private+0x1c6>
    in.size    = input_len;
 c004450:	9b05      	ldr	r3, [sp, #20]
    in.pOpQinv = qp_binary;
 c004452:	e9cd 8525 	strd	r8, r5, [sp, #148]	; 0x94
    in.pOpDp   = dp_binary;
 c004456:	e9cd 3923 	strd	r3, r9, [sp, #140]	; 0x8c
    in.popA    = input;
 c00445a:	9b04      	ldr	r3, [sp, #16]
    in.pPrimeQ = q_binary;
 c00445c:	e9cd 7627 	strd	r7, r6, [sp, #156]	; 0x9c
    in.popA    = input;
 c004460:	9329      	str	r3, [sp, #164]	; 0xa4
    __HAL_RCC_PKA_CLK_ENABLE();
 c004462:	4b4b      	ldr	r3, [pc, #300]	; (c004590 <mbedtls_rsa_private+0x2b0>)
 c004464:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c004466:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 c00446a:	64da      	str	r2, [r3, #76]	; 0x4c
 c00446c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    hpka.Instance = PKA;
 c00446e:	4a49      	ldr	r2, [pc, #292]	; (c004594 <mbedtls_rsa_private+0x2b4>)
    __HAL_RCC_PKA_CLK_ENABLE();
 c004470:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 c004474:	9307      	str	r3, [sp, #28]
 c004476:	9b07      	ldr	r3, [sp, #28]
    hpka.Instance = PKA;
 c004478:	ab2a      	add	r3, sp, #168	; 0xa8
 c00447a:	f843 2d28 	str.w	r2, [r3, #-40]!
    MBEDTLS_MPI_CHK( ( HAL_PKA_Init( &hpka ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c00447e:	4618      	mov	r0, r3
 c004480:	9304      	str	r3, [sp, #16]
 c004482:	f004 f9b8 	bl	c0087f6 <HAL_PKA_Init>
 c004486:	2800      	cmp	r0, #0
 c004488:	d164      	bne.n	c004554 <mbedtls_rsa_private+0x274>
    MBEDTLS_MPI_CHK( ( HAL_PKA_RSACRTExp( &hpka, &in, ST_PKA_TIMEOUT ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c00448a:	9b04      	ldr	r3, [sp, #16]
 c00448c:	f241 3288 	movw	r2, #5000	; 0x1388
 c004490:	a923      	add	r1, sp, #140	; 0x8c
 c004492:	4618      	mov	r0, r3
 c004494:	f004 fb73 	bl	c008b7e <HAL_PKA_RSACRTExp>
 c004498:	2800      	cmp	r0, #0
 c00449a:	d15b      	bne.n	c004554 <mbedtls_rsa_private+0x274>
    HAL_PKA_ModExp_GetResult( &hpka, (uint8_t *)output );
 c00449c:	9b04      	ldr	r3, [sp, #16]
 c00449e:	9934      	ldr	r1, [sp, #208]	; 0xd0
 c0044a0:	4618      	mov	r0, r3
 c0044a2:	f004 fa47 	bl	c008934 <HAL_PKA_ModExp_GetResult>
    HAL_PKA_DeInit( &hpka );
 c0044a6:	a820      	add	r0, sp, #128	; 0x80
 c0044a8:	f004 f9ce 	bl	c008848 <HAL_PKA_DeInit>
    __HAL_RCC_PKA_CLK_DISABLE();
 c0044ac:	4a38      	ldr	r2, [pc, #224]	; (c004590 <mbedtls_rsa_private+0x2b0>)
 c0044ae:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c0044b0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 c0044b4:	64d3      	str	r3, [r2, #76]	; 0x4c
    if (dp_binary != NULL)
 c0044b6:	f1b9 0f00 	cmp.w	r9, #0
 c0044ba:	d006      	beq.n	c0044ca <mbedtls_rsa_private+0x1ea>
        mbedtls_platform_zeroize( dp_binary, dplen );
 c0044bc:	4648      	mov	r0, r9
 c0044be:	4659      	mov	r1, fp
 c0044c0:	f007 fd10 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( dp_binary );
 c0044c4:	4648      	mov	r0, r9
 c0044c6:	f007 fcfd 	bl	c00bec4 <mbedtls_free>
    if (dq_binary != NULL)
 c0044ca:	f1b8 0f00 	cmp.w	r8, #0
 c0044ce:	d006      	beq.n	c0044de <mbedtls_rsa_private+0x1fe>
        mbedtls_platform_zeroize( dq_binary, dqlen );
 c0044d0:	4640      	mov	r0, r8
 c0044d2:	4651      	mov	r1, sl
 c0044d4:	f007 fd06 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( dq_binary );
 c0044d8:	4640      	mov	r0, r8
 c0044da:	f007 fcf3 	bl	c00bec4 <mbedtls_free>
    if (p_binary != NULL)
 c0044de:	b137      	cbz	r7, c0044ee <mbedtls_rsa_private+0x20e>
        mbedtls_platform_zeroize( p_binary, plen );
 c0044e0:	4638      	mov	r0, r7
 c0044e2:	9901      	ldr	r1, [sp, #4]
 c0044e4:	f007 fcfe 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( p_binary );
 c0044e8:	4638      	mov	r0, r7
 c0044ea:	f007 fceb 	bl	c00bec4 <mbedtls_free>
    if (q_binary != NULL)
 c0044ee:	b136      	cbz	r6, c0044fe <mbedtls_rsa_private+0x21e>
        mbedtls_platform_zeroize( q_binary, qlen );
 c0044f0:	4630      	mov	r0, r6
 c0044f2:	9902      	ldr	r1, [sp, #8]
 c0044f4:	f007 fcf6 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( q_binary );
 c0044f8:	4630      	mov	r0, r6
 c0044fa:	f007 fce3 	bl	c00bec4 <mbedtls_free>
    if (qp_binary != NULL)
 c0044fe:	b135      	cbz	r5, c00450e <mbedtls_rsa_private+0x22e>
        mbedtls_platform_zeroize( qp_binary, qplen );
 c004500:	4628      	mov	r0, r5
 c004502:	9903      	ldr	r1, [sp, #12]
 c004504:	f007 fcee 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( qp_binary );
 c004508:	4628      	mov	r0, r5
 c00450a:	f007 fcdb 	bl	c00bec4 <mbedtls_free>
    mbedtls_mpi_free( &P1 );
 c00450e:	a80b      	add	r0, sp, #44	; 0x2c
 c004510:	f006 fb29 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &Q1 );
 c004514:	a80e      	add	r0, sp, #56	; 0x38
 c004516:	f006 fb26 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &R );
 c00451a:	a811      	add	r0, sp, #68	; 0x44
 c00451c:	f006 fb23 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T );
 c004520:	a808      	add	r0, sp, #32
 c004522:	f006 fb20 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &TP ); mbedtls_mpi_free( &TQ );
 c004526:	a814      	add	r0, sp, #80	; 0x50
 c004528:	f006 fb1d 	bl	c00ab66 <mbedtls_mpi_free>
 c00452c:	a817      	add	r0, sp, #92	; 0x5c
 c00452e:	f006 fb1a 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &C );
 c004532:	a81d      	add	r0, sp, #116	; 0x74
 c004534:	f006 fb17 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &I );
 c004538:	a81a      	add	r0, sp, #104	; 0x68
 c00453a:	f006 fb14 	bl	c00ab66 <mbedtls_mpi_free>
    if( ret != 0 )
 c00453e:	b10c      	cbz	r4, c004544 <mbedtls_rsa_private+0x264>
        return( MBEDTLS_ERR_RSA_PRIVATE_FAILED + ret );
 c004540:	f5a4 4486 	sub.w	r4, r4, #17152	; 0x4300
}
 c004544:	4620      	mov	r0, r4
 c004546:	b02b      	add	sp, #172	; 0xac
 c004548:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    uint8_t *qp_binary = NULL;
 c00454c:	4605      	mov	r5, r0
    uint8_t *q_binary = NULL;
 c00454e:	4606      	mov	r6, r0
    uint8_t *p_binary = NULL;
 c004550:	4607      	mov	r7, r0
    uint8_t *dq_binary = NULL;
 c004552:	4680      	mov	r8, r0
    MBEDTLS_MPI_CHK( ( HAL_PKA_RSACRTExp( &hpka, &in, ST_PKA_TIMEOUT ) != HAL_OK ) ? MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED : 0 );
 c004554:	f06f 046f 	mvn.w	r4, #111	; 0x6f
 c004558:	e7a5      	b.n	c0044a6 <mbedtls_rsa_private+0x1c6>
    uint8_t *qp_binary = NULL;
 c00455a:	4635      	mov	r5, r6
    uint8_t *p_binary = NULL;
 c00455c:	4637      	mov	r7, r6
    uint8_t *dq_binary = NULL;
 c00455e:	46b0      	mov	r8, r6
 c004560:	e7a1      	b.n	c0044a6 <mbedtls_rsa_private+0x1c6>
    uint8_t *qp_binary = NULL;
 c004562:	4605      	mov	r5, r0
    uint8_t *q_binary = NULL;
 c004564:	4606      	mov	r6, r0
    uint8_t *p_binary = NULL;
 c004566:	4607      	mov	r7, r0
 c004568:	e7f4      	b.n	c004554 <mbedtls_rsa_private+0x274>
    uint8_t *qp_binary = NULL;
 c00456a:	4635      	mov	r5, r6
    uint8_t *p_binary = NULL;
 c00456c:	4637      	mov	r7, r6
 c00456e:	e79a      	b.n	c0044a6 <mbedtls_rsa_private+0x1c6>
    uint8_t *qp_binary = NULL;
 c004570:	4605      	mov	r5, r0
    uint8_t *q_binary = NULL;
 c004572:	4606      	mov	r6, r0
 c004574:	e7ee      	b.n	c004554 <mbedtls_rsa_private+0x274>
    uint8_t *qp_binary = NULL;
 c004576:	2500      	movs	r5, #0
    uint8_t *q_binary = NULL;
 c004578:	462e      	mov	r6, r5
 c00457a:	e794      	b.n	c0044a6 <mbedtls_rsa_private+0x1c6>
    uint8_t *qp_binary = NULL;
 c00457c:	4605      	mov	r5, r0
 c00457e:	e7e9      	b.n	c004554 <mbedtls_rsa_private+0x274>
 c004580:	2500      	movs	r5, #0
 c004582:	e790      	b.n	c0044a6 <mbedtls_rsa_private+0x1c6>
        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
 c004584:	f06f 0403 	mvn.w	r4, #3
 c004588:	e7c1      	b.n	c00450e <mbedtls_rsa_private+0x22e>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c00458a:	4c03      	ldr	r4, [pc, #12]	; (c004598 <mbedtls_rsa_private+0x2b8>)
 c00458c:	e7da      	b.n	c004544 <mbedtls_rsa_private+0x264>
 c00458e:	bf00      	nop
 c004590:	50021000 	.word	0x50021000
 c004594:	520c2000 	.word	0x520c2000
 c004598:	ffffbf80 	.word	0xffffbf80

0c00459c <mbedtls_rsa_rsaes_oaep_decrypt>:
                            const unsigned char *label, size_t label_len,
                            size_t *olen,
                            const unsigned char *input,
                            unsigned char *output,
                            size_t output_max_len )
{
 c00459c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    RSA_VALIDATE_RET( olen != NULL );

    /*
     * Parameters sanity checks
     */
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c0045a0:	2b01      	cmp	r3, #1
{
 c0045a2:	b0f1      	sub	sp, #452	; 0x1c4
 c0045a4:	4607      	mov	r7, r0
 c0045a6:	468a      	mov	sl, r1
 c0045a8:	9203      	str	r2, [sp, #12]
 c0045aa:	469b      	mov	fp, r3
    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
 c0045ac:	d109      	bne.n	c0045c2 <mbedtls_rsa_rsaes_oaep_decrypt+0x26>
 c0045ae:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 c0045b2:	2b01      	cmp	r3, #1
 c0045b4:	d005      	beq.n	c0045c2 <mbedtls_rsa_rsaes_oaep_decrypt+0x26>
        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
 c0045b6:	f8df a16c 	ldr.w	sl, [pc, #364]	; c004724 <mbedtls_rsa_rsaes_oaep_decrypt+0x188>
cleanup:
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );

    return( ret );
}
 c0045ba:	4650      	mov	r0, sl
 c0045bc:	b071      	add	sp, #452	; 0x1c4
 c0045be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ilen = ctx->len;
 c0045c2:	687c      	ldr	r4, [r7, #4]
    if( ilen < 16 || ilen > sizeof( buf ) )
 c0045c4:	f1a4 0310 	sub.w	r3, r4, #16
 c0045c8:	f5b3 7fb8 	cmp.w	r3, #368	; 0x170
 c0045cc:	d8f3      	bhi.n	c0045b6 <mbedtls_rsa_rsaes_oaep_decrypt+0x1a>
    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
 c0045ce:	f897 00a8 	ldrb.w	r0, [r7, #168]	; 0xa8
 c0045d2:	f007 fa3f 	bl	c00ba54 <mbedtls_md_info_from_type>
    if( md_info == NULL )
 c0045d6:	9002      	str	r0, [sp, #8]
 c0045d8:	2800      	cmp	r0, #0
 c0045da:	d0ec      	beq.n	c0045b6 <mbedtls_rsa_rsaes_oaep_decrypt+0x1a>
    hlen = mbedtls_md_get_size( md_info );
 c0045dc:	f007 fab6 	bl	c00bb4c <mbedtls_md_get_size>
    if( 2 * hlen + 2 > ilen )
 c0045e0:	f100 0801 	add.w	r8, r0, #1
 c0045e4:	ea4f 0648 	mov.w	r6, r8, lsl #1
 c0045e8:	42a6      	cmp	r6, r4
    hlen = mbedtls_md_get_size( md_info );
 c0045ea:	4605      	mov	r5, r0
    if( 2 * hlen + 2 > ilen )
 c0045ec:	d8e3      	bhi.n	c0045b6 <mbedtls_rsa_rsaes_oaep_decrypt+0x1a>
 c0045ee:	f10d 0940 	add.w	r9, sp, #64	; 0x40
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c0045f2:	f1bb 0f00 	cmp.w	fp, #0
 c0045f6:	d11f      	bne.n	c004638 <mbedtls_rsa_rsaes_oaep_decrypt+0x9c>
 c0045f8:	464a      	mov	r2, r9
 c0045fa:	997d      	ldr	r1, [sp, #500]	; 0x1f4
 c0045fc:	4638      	mov	r0, r7
 c0045fe:	f7ff fdbf 	bl	c004180 <mbedtls_rsa_public>
 c004602:	4682      	mov	sl, r0
    if( ret != 0 )
 c004604:	b968      	cbnz	r0, c004622 <mbedtls_rsa_rsaes_oaep_decrypt+0x86>
    mbedtls_md_init( &md_ctx );
 c004606:	af05      	add	r7, sp, #20
 c004608:	4638      	mov	r0, r7
 c00460a:	f007 fa31 	bl	c00ba70 <mbedtls_md_init>
    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
 c00460e:	4652      	mov	r2, sl
 c004610:	9902      	ldr	r1, [sp, #8]
 c004612:	4638      	mov	r0, r7
 c004614:	f007 fa4c 	bl	c00bab0 <mbedtls_md_setup>
 c004618:	4682      	mov	sl, r0
 c00461a:	b1b0      	cbz	r0, c00464a <mbedtls_rsa_rsaes_oaep_decrypt+0xae>
        mbedtls_md_free( &md_ctx );
 c00461c:	4638      	mov	r0, r7
        mbedtls_md_free( &md_ctx );
 c00461e:	f007 fa2c 	bl	c00ba7a <mbedtls_md_free>
    mbedtls_platform_zeroize( buf, sizeof( buf ) );
 c004622:	a810      	add	r0, sp, #64	; 0x40
 c004624:	f44f 71c0 	mov.w	r1, #384	; 0x180
 c004628:	f007 fc5c 	bl	c00bee4 <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );
 c00462c:	2120      	movs	r1, #32
 c00462e:	eb0d 0001 	add.w	r0, sp, r1
 c004632:	f007 fc57 	bl	c00bee4 <mbedtls_platform_zeroize>
    return( ret );
 c004636:	e7c0      	b.n	c0045ba <mbedtls_rsa_rsaes_oaep_decrypt+0x1e>
          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
 c004638:	f8cd 9000 	str.w	r9, [sp]
 c00463c:	9b7d      	ldr	r3, [sp, #500]	; 0x1f4
 c00463e:	9a03      	ldr	r2, [sp, #12]
 c004640:	4651      	mov	r1, sl
 c004642:	4638      	mov	r0, r7
 c004644:	f7ff fe4c 	bl	c0042e0 <mbedtls_rsa_private>
 c004648:	e7db      	b.n	c004602 <mbedtls_rsa_rsaes_oaep_decrypt+0x66>
    if( ( ret = mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
 c00464a:	f104 3bff 	add.w	fp, r4, #4294967295
 c00464e:	44c8      	add	r8, r9
 c004650:	ebab 0b05 	sub.w	fp, fp, r5
 c004654:	9700      	str	r7, [sp, #0]
 c004656:	465b      	mov	r3, fp
 c004658:	4642      	mov	r2, r8
 c00465a:	4629      	mov	r1, r5
 c00465c:	f10d 0041 	add.w	r0, sp, #65	; 0x41
 c004660:	f7ff fc32 	bl	c003ec8 <mgf_mask>
 c004664:	4682      	mov	sl, r0
 c004666:	b948      	cbnz	r0, c00467c <mbedtls_rsa_rsaes_oaep_decrypt+0xe0>
                          &md_ctx ) ) != 0 ||
 c004668:	9700      	str	r7, [sp, #0]
 c00466a:	462b      	mov	r3, r5
 c00466c:	f10d 0241 	add.w	r2, sp, #65	; 0x41
 c004670:	4659      	mov	r1, fp
 c004672:	4640      	mov	r0, r8
 c004674:	f7ff fc28 	bl	c003ec8 <mgf_mask>
 c004678:	4682      	mov	sl, r0
 c00467a:	b108      	cbz	r0, c004680 <mbedtls_rsa_rsaes_oaep_decrypt+0xe4>
        mbedtls_md_free( &md_ctx );
 c00467c:	a805      	add	r0, sp, #20
 c00467e:	e7ce      	b.n	c00461e <mbedtls_rsa_rsaes_oaep_decrypt+0x82>
    mbedtls_md_free( &md_ctx );
 c004680:	4638      	mov	r0, r7
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 c004682:	af08      	add	r7, sp, #32
    mbedtls_md_free( &md_ctx );
 c004684:	f007 f9f9 	bl	c00ba7a <mbedtls_md_free>
    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
 c004688:	463b      	mov	r3, r7
 c00468a:	9a7b      	ldr	r2, [sp, #492]	; 0x1ec
 c00468c:	997a      	ldr	r1, [sp, #488]	; 0x1e8
 c00468e:	9802      	ldr	r0, [sp, #8]
 c004690:	f007 fa4c 	bl	c00bb2c <mbedtls_md>
 c004694:	4682      	mov	sl, r0
 c004696:	2800      	cmp	r0, #0
 c004698:	d1c3      	bne.n	c004622 <mbedtls_rsa_rsaes_oaep_decrypt+0x86>
    p += hlen; /* Skip seed */
 c00469a:	f10d 0341 	add.w	r3, sp, #65	; 0x41
    bad |= *p++; /* First byte must be 0 */
 c00469e:	f899 2000 	ldrb.w	r2, [r9]
    p += hlen; /* Skip seed */
 c0046a2:	1959      	adds	r1, r3, r5
    for( i = 0; i < hlen; i++ )
 c0046a4:	42a8      	cmp	r0, r5
 c0046a6:	fa4f fc82 	sxtb.w	ip, r2
 c0046aa:	d31f      	bcc.n	c0046ec <mbedtls_rsa_rsaes_oaep_decrypt+0x150>
    pad_done = 0;
 c0046ac:	2200      	movs	r2, #0
 c0046ae:	440d      	add	r5, r1
 c0046b0:	462f      	mov	r7, r5
    pad_len = 0;
 c0046b2:	4611      	mov	r1, r2
    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
 c0046b4:	1ba6      	subs	r6, r4, r6
 c0046b6:	442e      	add	r6, r5
 c0046b8:	42be      	cmp	r6, r7
 c0046ba:	d121      	bne.n	c004700 <mbedtls_rsa_rsaes_oaep_decrypt+0x164>
    bad |= *p++ ^ 0x01;
 c0046bc:	5c6a      	ldrb	r2, [r5, r1]
 c0046be:	f082 0201 	eor.w	r2, r2, #1
 c0046c2:	ea4c 0202 	orr.w	r2, ip, r2
    if( bad != 0 )
 c0046c6:	f012 0fff 	tst.w	r2, #255	; 0xff
 c0046ca:	d124      	bne.n	c004716 <mbedtls_rsa_rsaes_oaep_decrypt+0x17a>
    bad |= *p++ ^ 0x01;
 c0046cc:	3101      	adds	r1, #1
 c0046ce:	4429      	add	r1, r5
    if( ilen - ( p - buf ) > output_max_len )
 c0046d0:	aa10      	add	r2, sp, #64	; 0x40
 c0046d2:	1a8a      	subs	r2, r1, r2
 c0046d4:	987f      	ldr	r0, [sp, #508]	; 0x1fc
 c0046d6:	1aa2      	subs	r2, r4, r2
 c0046d8:	4282      	cmp	r2, r0
 c0046da:	d81f      	bhi.n	c00471c <mbedtls_rsa_rsaes_oaep_decrypt+0x180>
    *olen = ilen - (p - buf);
 c0046dc:	987c      	ldr	r0, [sp, #496]	; 0x1f0
 c0046de:	6002      	str	r2, [r0, #0]
    if( *olen != 0 )
 c0046e0:	2a00      	cmp	r2, #0
 c0046e2:	d09e      	beq.n	c004622 <mbedtls_rsa_rsaes_oaep_decrypt+0x86>
        memcpy( output, p, *olen );
 c0046e4:	987e      	ldr	r0, [sp, #504]	; 0x1f8
 c0046e6:	f009 fcac 	bl	c00e042 <memcpy>
 c0046ea:	e79a      	b.n	c004622 <mbedtls_rsa_rsaes_oaep_decrypt+0x86>
        bad |= lhash[i] ^ *p++;
 c0046ec:	5c3a      	ldrb	r2, [r7, r0]
 c0046ee:	f811 e000 	ldrb.w	lr, [r1, r0]
    for( i = 0; i < hlen; i++ )
 c0046f2:	3001      	adds	r0, #1
        bad |= lhash[i] ^ *p++;
 c0046f4:	ea82 020e 	eor.w	r2, r2, lr
 c0046f8:	ea4c 0202 	orr.w	r2, ip, r2
 c0046fc:	b2d2      	uxtb	r2, r2
 c0046fe:	e7d1      	b.n	c0046a4 <mbedtls_rsa_rsaes_oaep_decrypt+0x108>
        pad_done |= p[i];
 c004700:	f817 0b01 	ldrb.w	r0, [r7], #1
 c004704:	4302      	orrs	r2, r0
        pad_len += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
 c004706:	4250      	negs	r0, r2
 c004708:	4310      	orrs	r0, r2
 c00470a:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 c00470e:	f080 0001 	eor.w	r0, r0, #1
 c004712:	4401      	add	r1, r0
 c004714:	e7d0      	b.n	c0046b8 <mbedtls_rsa_rsaes_oaep_decrypt+0x11c>
        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
 c004716:	f8df a010 	ldr.w	sl, [pc, #16]	; c004728 <mbedtls_rsa_rsaes_oaep_decrypt+0x18c>
 c00471a:	e782      	b.n	c004622 <mbedtls_rsa_rsaes_oaep_decrypt+0x86>
        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
 c00471c:	f8df a00c 	ldr.w	sl, [pc, #12]	; c00472c <mbedtls_rsa_rsaes_oaep_decrypt+0x190>
 c004720:	e77f      	b.n	c004622 <mbedtls_rsa_rsaes_oaep_decrypt+0x86>
 c004722:	bf00      	nop
 c004724:	ffffbf80 	.word	0xffffbf80
 c004728:	ffffbf00 	.word	0xffffbf00
 c00472c:	ffffbc00 	.word	0xffffbc00

0c004730 <mbedtls_rsa_free>:

/*
 * Free the components of an RSA key
 */
void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
{
 c004730:	b510      	push	{r4, lr}
    if( ctx == NULL )
 c004732:	4604      	mov	r4, r0
 c004734:	b3a0      	cbz	r0, c0047a0 <mbedtls_rsa_free+0x70>
        return;

    mbedtls_mpi_free( &ctx->Vi );
 c004736:	308c      	adds	r0, #140	; 0x8c
 c004738:	f006 fa15 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Vf );
 c00473c:	f104 0098 	add.w	r0, r4, #152	; 0x98
 c004740:	f006 fa11 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RN );
 c004744:	f104 0068 	add.w	r0, r4, #104	; 0x68
 c004748:	f006 fa0d 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->D  );
 c00474c:	f104 0020 	add.w	r0, r4, #32
 c004750:	f006 fa09 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->Q  );
 c004754:	f104 0038 	add.w	r0, r4, #56	; 0x38
 c004758:	f006 fa05 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->P  );
 c00475c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 c004760:	f006 fa01 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->E  );
 c004764:	f104 0014 	add.w	r0, r4, #20
 c004768:	f006 f9fd 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->N  );
 c00476c:	f104 0008 	add.w	r0, r4, #8
 c004770:	f006 f9f9 	bl	c00ab66 <mbedtls_mpi_free>

#if !defined(MBEDTLS_RSA_NO_CRT)
    mbedtls_mpi_free( &ctx->RQ );
 c004774:	f104 0080 	add.w	r0, r4, #128	; 0x80
 c004778:	f006 f9f5 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->RP );
 c00477c:	f104 0074 	add.w	r0, r4, #116	; 0x74
 c004780:	f006 f9f1 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->QP );
 c004784:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c004788:	f006 f9ed 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DQ );
 c00478c:	f104 0050 	add.w	r0, r4, #80	; 0x50
 c004790:	f006 f9e9 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &ctx->DP );
 c004794:	f104 0044 	add.w	r0, r4, #68	; 0x44
#endif /* MBEDTLS_RSA_NO_CRT */

#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_free( &ctx->mutex );
#endif
}
 c004798:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_mpi_free( &ctx->DP );
 c00479c:	f006 b9e3 	b.w	c00ab66 <mbedtls_mpi_free>
}
 c0047a0:	bd10      	pop	{r4, pc}
	...

0c0047a4 <mbedtls_sha256_init>:
static void mbedtls_zeroize(void *v, size_t n)
{
    volatile unsigned char *p = (unsigned char *)v;
    while (n--)
    {
        *p++ = 0;
 c0047a4:	2200      	movs	r2, #0
    }
}

void mbedtls_sha256_init(mbedtls_sha256_context *ctx)
{
 c0047a6:	b082      	sub	sp, #8
 c0047a8:	f500 73b8 	add.w	r3, r0, #368	; 0x170
    while (n--)
 c0047ac:	4298      	cmp	r0, r3
 c0047ae:	d10b      	bne.n	c0047c8 <mbedtls_sha256_init+0x24>
    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));

    /* Enable HASH clock */
    __HAL_RCC_HASH_CLK_ENABLE();
 c0047b0:	4b07      	ldr	r3, [pc, #28]	; (c0047d0 <mbedtls_sha256_init+0x2c>)
 c0047b2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0047b4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 c0047b8:	64da      	str	r2, [r3, #76]	; 0x4c
 c0047ba:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c0047bc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 c0047c0:	9301      	str	r3, [sp, #4]
 c0047c2:	9b01      	ldr	r3, [sp, #4]
}
 c0047c4:	b002      	add	sp, #8
 c0047c6:	4770      	bx	lr
        *p++ = 0;
 c0047c8:	7002      	strb	r2, [r0, #0]
 c0047ca:	3001      	adds	r0, #1
 c0047cc:	e7ee      	b.n	c0047ac <mbedtls_sha256_init+0x8>
 c0047ce:	bf00      	nop
 c0047d0:	50021000 	.word	0x50021000

0c0047d4 <mbedtls_sha256_free>:

void mbedtls_sha256_free(mbedtls_sha256_context *ctx)
{
    if (ctx == NULL)
 c0047d4:	b120      	cbz	r0, c0047e0 <mbedtls_sha256_free+0xc>
        *p++ = 0;
 c0047d6:	2200      	movs	r2, #0
 c0047d8:	f500 73b8 	add.w	r3, r0, #368	; 0x170
    while (n--)
 c0047dc:	4298      	cmp	r0, r3
 c0047de:	d100      	bne.n	c0047e2 <mbedtls_sha256_free+0xe>
    {
        return;
    }
    mbedtls_zeroize(ctx, sizeof(mbedtls_sha256_context));
}
 c0047e0:	4770      	bx	lr
        *p++ = 0;
 c0047e2:	7002      	strb	r2, [r0, #0]
 c0047e4:	3001      	adds	r0, #1
 c0047e6:	e7f9      	b.n	c0047dc <mbedtls_sha256_free+0x8>

0c0047e8 <mbedtls_sha256_clone>:

void mbedtls_sha256_clone(mbedtls_sha256_context *dst,
                          const mbedtls_sha256_context *src)
{
 c0047e8:	b508      	push	{r3, lr}
    *dst = *src;
 c0047ea:	f44f 72b8 	mov.w	r2, #368	; 0x170
 c0047ee:	f009 fc28 	bl	c00e042 <memcpy>
}
 c0047f2:	bd08      	pop	{r3, pc}

0c0047f4 <mbedtls_sha256_starts_ret>:

int mbedtls_sha256_starts_ret(mbedtls_sha256_context *ctx, int is224)
{
 c0047f4:	b570      	push	{r4, r5, r6, lr}
    /* HASH Configuration */
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0047f6:	1d05      	adds	r5, r0, #4
{
 c0047f8:	4604      	mov	r4, r0
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0047fa:	4628      	mov	r0, r5
{
 c0047fc:	460e      	mov	r6, r1
    if (HAL_HASH_DeInit(&ctx->hhash) != HAL_OK)
 c0047fe:	f003 fabc 	bl	c007d7a <HAL_HASH_DeInit>
 c004802:	b110      	cbz	r0, c00480a <mbedtls_sha256_starts_ret+0x16>
    {
        return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c004804:	f06f 006f 	mvn.w	r0, #111	; 0x6f
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    return 0;
}
 c004808:	bd70      	pop	{r4, r5, r6, pc}
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c00480a:	2320      	movs	r3, #32
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c00480c:	4628      	mov	r0, r5
    ctx->hhash.Init.DataType = HASH_DATATYPE_8B;
 c00480e:	6063      	str	r3, [r4, #4]
    if (HAL_HASH_Init(&ctx->hhash) != HAL_OK)
 c004810:	f003 fa82 	bl	c007d18 <HAL_HASH_Init>
 c004814:	2800      	cmp	r0, #0
 c004816:	d1f5      	bne.n	c004804 <mbedtls_sha256_starts_ret+0x10>
    ctx->is224 = is224;
 c004818:	6026      	str	r6, [r4, #0]
    return 0;
 c00481a:	e7f5      	b.n	c004808 <mbedtls_sha256_starts_ret+0x14>

0c00481c <mbedtls_internal_sha256_process>:

int mbedtls_internal_sha256_process( mbedtls_sha256_context *ctx, const unsigned char data[ST_SHA256_BLOCK_SIZE] )
{
 c00481c:	b508      	push	{r3, lr}
 c00481e:	4603      	mov	r3, r0
#ifdef ST_HW_CONTEXT_SAVING
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    if (ctx->is224 == 0) {
 c004820:	681b      	ldr	r3, [r3, #0]
 c004822:	3004      	adds	r0, #4
        if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
 c004824:	2240      	movs	r2, #64	; 0x40
    if (ctx->is224 == 0) {
 c004826:	b93b      	cbnz	r3, c004838 <mbedtls_internal_sha256_process+0x1c>
        if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
 c004828:	f003 fbb6 	bl	c007f98 <HAL_HASHEx_SHA256_Accmlt>
 c00482c:	b110      	cbz	r0, c004834 <mbedtls_internal_sha256_process+0x18>
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c00482e:	f06f 006f 	mvn.w	r0, #111	; 0x6f
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    return 0;
}
 c004832:	bd08      	pop	{r3, pc}
    return 0;
 c004834:	2000      	movs	r0, #0
 c004836:	e7fc      	b.n	c004832 <mbedtls_internal_sha256_process+0x16>
        if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *) data, ST_SHA256_BLOCK_SIZE) != 0) {
 c004838:	f003 fb9c 	bl	c007f74 <HAL_HASHEx_SHA224_Accmlt>
 c00483c:	e7f6      	b.n	c00482c <mbedtls_internal_sha256_process+0x10>

0c00483e <mbedtls_sha256_update_ret>:

int mbedtls_sha256_update_ret(mbedtls_sha256_context *ctx, const unsigned char *input, size_t ilen)
{
 c00483e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c004842:	4605      	mov	r5, r0
#ifdef ST_HW_CONTEXT_SAVING
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    if (currentlen < (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len))
 c004844:	f890 0088 	ldrb.w	r0, [r0, #136]	; 0x88
 c004848:	f105 0748 	add.w	r7, r5, #72	; 0x48
 c00484c:	f1c0 0340 	rsb	r3, r0, #64	; 0x40
 c004850:	4293      	cmp	r3, r2
{
 c004852:	4688      	mov	r8, r1
 c004854:	4616      	mov	r6, r2
 c004856:	4438      	add	r0, r7
    if (currentlen < (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len))
 c004858:	d908      	bls.n	c00486c <mbedtls_sha256_update_ret+0x2e>
    {
        /* only store input data in context buffer */
        memcpy(ctx->sbuf + ctx->sbuf_len, input, currentlen);
 c00485a:	f009 fbf2 	bl	c00e042 <memcpy>
        ctx->sbuf_len += currentlen;
 c00485e:	f895 1088 	ldrb.w	r1, [r5, #136]	; 0x88
 c004862:	440e      	add	r6, r1
 c004864:	f885 6088 	strb.w	r6, [r5, #136]	; 0x88

#ifdef ST_HW_CONTEXT_SAVING
    /* save hw context */
    HAL_HASH_ContextSaving(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */
    return 0;
 c004868:	2000      	movs	r0, #0
 c00486a:	e032      	b.n	c0048d2 <mbedtls_sha256_update_ret+0x94>
        memcpy(ctx->sbuf + ctx->sbuf_len, input, (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len));
 c00486c:	461a      	mov	r2, r3
 c00486e:	f009 fbe8 	bl	c00e042 <memcpy>
        currentlen -= (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len);
 c004872:	f895 2088 	ldrb.w	r2, [r5, #136]	; 0x88
        if (ctx->is224 == 0)
 c004876:	682b      	ldr	r3, [r5, #0]
        currentlen -= (ST_SHA256_BLOCK_SIZE - ctx->sbuf_len);
 c004878:	4432      	add	r2, r6
 c00487a:	f105 0904 	add.w	r9, r5, #4
 c00487e:	f1a2 0440 	sub.w	r4, r2, #64	; 0x40
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c004882:	4639      	mov	r1, r7
 c004884:	2240      	movs	r2, #64	; 0x40
 c004886:	4648      	mov	r0, r9
        if (ctx->is224 == 0)
 c004888:	b983      	cbnz	r3, c0048ac <mbedtls_sha256_update_ret+0x6e>
            if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c00488a:	f003 fb85 	bl	c007f98 <HAL_HASHEx_SHA256_Accmlt>
 c00488e:	b9f0      	cbnz	r0, c0048ce <mbedtls_sha256_update_ret+0x90>
        if (iter != 0)
 c004890:	2c3f      	cmp	r4, #63	; 0x3f
 c004892:	d80e      	bhi.n	c0048b2 <mbedtls_sha256_update_ret+0x74>
        ctx->sbuf_len = currentlen % ST_SHA256_BLOCK_SIZE;
 c004894:	f004 023f 	and.w	r2, r4, #63	; 0x3f
 c004898:	f885 2088 	strb.w	r2, [r5, #136]	; 0x88
        if (ctx->sbuf_len != 0)
 c00489c:	2a00      	cmp	r2, #0
 c00489e:	d0e3      	beq.n	c004868 <mbedtls_sha256_update_ret+0x2a>
            memcpy(ctx->sbuf, input + ilen - ctx->sbuf_len, ctx->sbuf_len);
 c0048a0:	1ab1      	subs	r1, r6, r2
 c0048a2:	4441      	add	r1, r8
 c0048a4:	4638      	mov	r0, r7
 c0048a6:	f009 fbcc 	bl	c00e042 <memcpy>
 c0048aa:	e7dd      	b.n	c004868 <mbedtls_sha256_update_ret+0x2a>
            if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(ctx->sbuf), ST_SHA256_BLOCK_SIZE) != 0)
 c0048ac:	f003 fb62 	bl	c007f74 <HAL_HASHEx_SHA224_Accmlt>
 c0048b0:	e7ed      	b.n	c00488e <mbedtls_sha256_update_ret+0x50>
 c0048b2:	f895 1088 	ldrb.w	r1, [r5, #136]	; 0x88
            if (ctx->is224 == 0)
 c0048b6:	682b      	ldr	r3, [r5, #0]
 c0048b8:	f1c1 0140 	rsb	r1, r1, #64	; 0x40
 c0048bc:	4441      	add	r1, r8
 c0048be:	f024 023f 	bic.w	r2, r4, #63	; 0x3f
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0048c2:	4648      	mov	r0, r9
            if (ctx->is224 == 0)
 c0048c4:	b93b      	cbnz	r3, c0048d6 <mbedtls_sha256_update_ret+0x98>
                if (HAL_HASHEx_SHA256_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0048c6:	f003 fb67 	bl	c007f98 <HAL_HASHEx_SHA256_Accmlt>
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0048ca:	2800      	cmp	r0, #0
 c0048cc:	d0e2      	beq.n	c004894 <mbedtls_sha256_update_ret+0x56>
                return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c0048ce:	f06f 006f 	mvn.w	r0, #111	; 0x6f
}
 c0048d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (HAL_HASHEx_SHA224_Accmlt(&ctx->hhash, (uint8_t *)(input + ST_SHA256_BLOCK_SIZE - ctx->sbuf_len), (iter * ST_SHA256_BLOCK_SIZE)) != 0)
 c0048d6:	f003 fb4d 	bl	c007f74 <HAL_HASHEx_SHA224_Accmlt>
 c0048da:	e7f6      	b.n	c0048ca <mbedtls_sha256_update_ret+0x8c>

0c0048dc <mbedtls_sha256_finish_ret>:

int mbedtls_sha256_finish_ret(mbedtls_sha256_context *ctx, unsigned char output[32])
{
 c0048dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c0048de:	4604      	mov	r4, r0
 c0048e0:	2503      	movs	r5, #3
    /* restore hw context */
    HAL_HASH_ContextRestoring(&ctx->hhash, ctx->ctx_save_regs);
#endif /* ST_HW_CONTEXT_SAVING */

    /* Last accumulation for pending bytes in sbuf_len, then trig processing and get digest */
    if (ctx->is224 == 0)
 c0048e2:	6826      	ldr	r6, [r4, #0]
{
 c0048e4:	460b      	mov	r3, r1
 c0048e6:	3004      	adds	r0, #4
 c0048e8:	f104 0148 	add.w	r1, r4, #72	; 0x48
 c0048ec:	f894 2088 	ldrb.w	r2, [r4, #136]	; 0x88
    {
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c0048f0:	9500      	str	r5, [sp, #0]
    if (ctx->is224 == 0)
 c0048f2:	b956      	cbnz	r6, c00490a <mbedtls_sha256_finish_ret+0x2e>
        if (HAL_HASHEx_SHA256_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c0048f4:	f003 fb56 	bl	c007fa4 <HAL_HASHEx_SHA256_Accmlt_End>
 c0048f8:	b920      	cbnz	r0, c004904 <mbedtls_sha256_finish_ret+0x28>
        {
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
        }
    }

    ctx->sbuf_len = 0;
 c0048fa:	2000      	movs	r0, #0
 c0048fc:	f884 0088 	strb.w	r0, [r4, #136]	; 0x88

    return 0;
}
 c004900:	b002      	add	sp, #8
 c004902:	bd70      	pop	{r4, r5, r6, pc}
            return MBEDTLS_ERR_PLATFORM_HW_ACCEL_FAILED;
 c004904:	f06f 006f 	mvn.w	r0, #111	; 0x6f
 c004908:	e7fa      	b.n	c004900 <mbedtls_sha256_finish_ret+0x24>
        if (HAL_HASHEx_SHA224_Accmlt_End(&ctx->hhash, ctx->sbuf, ctx->sbuf_len, output, ST_SHA256_TIMEOUT) != 0)
 c00490a:	f003 fb37 	bl	c007f7c <HAL_HASHEx_SHA224_Accmlt_End>
 c00490e:	e7f3      	b.n	c0048f8 <mbedtls_sha256_finish_ret+0x1c>

0c004910 <HAL_RTC_MspInit>:
     - Enable the power clock using __HAL_RCC_PWR_CLK_ENABLE()
     - Enable write access using HAL_PWR_EnableBkUpAccess() function before to
       configure the RTC clock source (to be done once after reset).
     - Configure the needed RTC clock source */

  __HAL_RCC_PWR_CLK_ENABLE();
 c004910:	4b23      	ldr	r3, [pc, #140]	; (c0049a0 <HAL_RTC_MspInit+0x90>)
{
 c004912:	b500      	push	{lr}
  __HAL_RCC_PWR_CLK_ENABLE();
 c004914:	6d9a      	ldr	r2, [r3, #88]	; 0x58
{
 c004916:	b0bb      	sub	sp, #236	; 0xec
  __HAL_RCC_PWR_CLK_ENABLE();
 c004918:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c00491c:	659a      	str	r2, [r3, #88]	; 0x58
 c00491e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c004920:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c004924:	9301      	str	r3, [sp, #4]
 c004926:	9b01      	ldr	r3, [sp, #4]
  
  HAL_PWR_EnableBkUpAccess();
 c004928:	f004 f936 	bl	c008b98 <HAL_PWR_EnableBkUpAccess>

  /* If the system has resumed from STANDBY mode, no need to reconfigure all clocks */
  if (__HAL_PWR_GET_FLAG(PWR_FLAG_SB) == RESET)
 c00492c:	4b1d      	ldr	r3, [pc, #116]	; (c0049a4 <HAL_RTC_MspInit+0x94>)
 c00492e:	691b      	ldr	r3, [r3, #16]
 c004930:	f413 7380 	ands.w	r3, r3, #256	; 0x100
 c004934:	d11e      	bne.n	c004974 <HAL_RTC_MspInit+0x64>
  {

#ifdef RTC_CLOCK_SOURCE_LSE
    RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_LSE;
 c004936:	220c      	movs	r2, #12
 c004938:	9203      	str	r2, [sp, #12]
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    RCC_OscInitStruct.LSEState = RCC_LSE_ON_RTC_ONLY;
 c00493a:	2201      	movs	r2, #1
    RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 c00493c:	a803      	add	r0, sp, #12
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 c00493e:	930e      	str	r3, [sp, #56]	; 0x38
    RCC_OscInitStruct.LSEState = RCC_LSE_ON_RTC_ONLY;
 c004940:	9205      	str	r2, [sp, #20]
    RCC_OscInitStruct.LSIState = RCC_LSI_OFF;
 c004942:	9308      	str	r3, [sp, #32]
    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 c004944:	f004 f9e6 	bl	c008d14 <HAL_RCC_OscConfig>
 c004948:	b108      	cbz	r0, c00494e <HAL_RTC_MspInit+0x3e>
    {
      Error_Handler();
 c00494a:	f00c ffe9 	bl	c011920 <Error_Handler>
    }

    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 c00494e:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 c004952:	9315      	str	r3, [sp, #84]	; 0x54
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 c004954:	f44f 7380 	mov.w	r3, #256	; 0x100
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 c004958:	a815      	add	r0, sp, #84	; 0x54
    PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 c00495a:	9339      	str	r3, [sp, #228]	; 0xe4
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 c00495c:	f004 fe22 	bl	c0095a4 <HAL_RCCEx_PeriphCLKConfig>
 c004960:	b108      	cbz	r0, c004966 <HAL_RTC_MspInit+0x56>
    {
      Error_Handler();
 c004962:	f00c ffdd 	bl	c011920 <Error_Handler>
#else
#error Please select the RTC Clock source inside the main.h file
#endif /*RTC_CLOCK_SOURCE_LSE*/

    /* Enable RTC Clock */
    __HAL_RCC_RTC_ENABLE();
 c004966:	4a0e      	ldr	r2, [pc, #56]	; (c0049a0 <HAL_RTC_MspInit+0x90>)
 c004968:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 c00496c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 c004970:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  } /* if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET) */

  /* Enable RTC APB clock  */
  __HAL_RCC_RTCAPB_CLK_ENABLE();

  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c004974:	2104      	movs	r1, #4
  __HAL_RCC_RTCAPB_CLK_ENABLE();
 c004976:	4b0a      	ldr	r3, [pc, #40]	; (c0049a0 <HAL_RTC_MspInit+0x90>)
  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c004978:	4608      	mov	r0, r1
  __HAL_RCC_RTCAPB_CLK_ENABLE();
 c00497a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c00497c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 c004980:	659a      	str	r2, [r3, #88]	; 0x58
 c004982:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c004984:	2200      	movs	r2, #0
  __HAL_RCC_RTCAPB_CLK_ENABLE();
 c004986:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 c00498a:	9302      	str	r3, [sp, #8]
 c00498c:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(TAMP_IRQn, 0x4, 0);
 c00498e:	f001 fdc5 	bl	c00651c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TAMP_IRQn);
 c004992:	2004      	movs	r0, #4
 c004994:	f001 fdf6 	bl	c006584 <HAL_NVIC_EnableIRQ>
}
 c004998:	b03b      	add	sp, #236	; 0xec
 c00499a:	f85d fb04 	ldr.w	pc, [sp], #4
 c00499e:	bf00      	nop
 c0049a0:	50021000 	.word	0x50021000
 c0049a4:	50007000 	.word	0x50007000

0c0049a8 <SystemInit>:
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0049a8:	4a22      	ldr	r2, [pc, #136]	; (c004a34 <SystemInit+0x8c>)

  /* Enable voltage range 0 mode for frequency above 80 Mhz */
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
  tmp = RCC->APB1ENR1;
  UNUSED(tmp);
  PWR->CR1 &= ~PWR_CR1_VOS;  /* voltage range 0 */
 c0049aa:	4923      	ldr	r1, [pc, #140]	; (c004a38 <SystemInit+0x90>)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0049ac:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
{
 c0049b0:	b082      	sub	sp, #8
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 c0049b2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 c0049b6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
 c0049ba:	4b20      	ldr	r3, [pc, #128]	; (c004a3c <SystemInit+0x94>)
 c0049bc:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0049be:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c0049c2:	659a      	str	r2, [r3, #88]	; 0x58
  tmp = RCC->APB1ENR1;
 c0049c4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0049c6:	9201      	str	r2, [sp, #4]
  UNUSED(tmp);
 c0049c8:	9a01      	ldr	r2, [sp, #4]
  PWR->CR1 &= ~PWR_CR1_VOS;  /* voltage range 0 */
 c0049ca:	680a      	ldr	r2, [r1, #0]
 c0049cc:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 c0049d0:	600a      	str	r2, [r1, #0]

  /* Set Flash latency prior to system clock change */
  FLASH->ACR = 5U;
 c0049d2:	2105      	movs	r1, #5
 c0049d4:	4a1a      	ldr	r2, [pc, #104]	; (c004a40 <SystemInit+0x98>)
 c0049d6:	6011      	str	r1, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY) != 5U)
 c0049d8:	6811      	ldr	r1, [r2, #0]
 c0049da:	f001 010f 	and.w	r1, r1, #15
 c0049de:	2905      	cmp	r1, #5
 c0049e0:	d1fa      	bne.n	c0049d8 <SystemInit+0x30>
  {
  }

  /* Configure and enable the main PLL */
  /* PLLSRC=MSI, PLLM=1, PLLN=55, PLLR=2, PLLREN=1 */
  RCC->PLLCFGR = RCC_PLLCFGR_PLLSRC_0 | (55 << RCC_PLLCFGR_PLLN_Pos) | RCC_PLLCFGR_PLLREN;
 c0049e2:	4a18      	ldr	r2, [pc, #96]	; (c004a44 <SystemInit+0x9c>)
 c0049e4:	60da      	str	r2, [r3, #12]
  RCC->CR |= RCC_CR_PLLON;
 c0049e6:	681a      	ldr	r2, [r3, #0]
 c0049e8:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 c0049ec:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_PLLRDY) != RCC_CR_PLLRDY)
 c0049ee:	4b13      	ldr	r3, [pc, #76]	; (c004a3c <SystemInit+0x94>)
 c0049f0:	461a      	mov	r2, r3
 c0049f2:	6819      	ldr	r1, [r3, #0]
 c0049f4:	0189      	lsls	r1, r1, #6
 c0049f6:	d5fc      	bpl.n	c0049f2 <SystemInit+0x4a>
  {
  }

  /* Sysclk activation on the main PLL */
  /* Intermediate AHB prescaler 2 when target frequency clock is higher than 80 MHz */
  RCC->CFGR = RCC_CFGR_HPRE_3 | RCC_CFGR_SW;
 c0049f8:	2183      	movs	r1, #131	; 0x83
 c0049fa:	6099      	str	r1, [r3, #8]
  /* Wait till the main PLL is used as system clock source */
  while ((RCC->CFGR & RCC_CFGR_SW) != RCC_CFGR_SW)
 c0049fc:	6893      	ldr	r3, [r2, #8]
 c0049fe:	f003 0303 	and.w	r3, r3, #3
 c004a02:	2b03      	cmp	r3, #3
 c004a04:	d1fa      	bne.n	c0049fc <SystemInit+0x54>
  {
  }

  /* Insure 1µs transition state at intermediate medium speed clock based on DWT*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 c004a06:	4a10      	ldr	r2, [pc, #64]	; (c004a48 <SystemInit+0xa0>)
 c004a08:	68d3      	ldr	r3, [r2, #12]
 c004a0a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 c004a0e:	60d3      	str	r3, [r2, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 c004a10:	4b0e      	ldr	r3, [pc, #56]	; (c004a4c <SystemInit+0xa4>)
 c004a12:	681a      	ldr	r2, [r3, #0]
 c004a14:	f042 0201 	orr.w	r2, r2, #1
 c004a18:	601a      	str	r2, [r3, #0]
  DWT->CYCCNT = 0;
 c004a1a:	2200      	movs	r2, #0
 c004a1c:	605a      	str	r2, [r3, #4]
  while(DWT->CYCCNT < 100);
 c004a1e:	685a      	ldr	r2, [r3, #4]
 c004a20:	2a63      	cmp	r2, #99	; 0x63
 c004a22:	d9fc      	bls.n	c004a1e <SystemInit+0x76>

  /* AHB prescaler 1 */
  RCC->CFGR &= ~RCC_CFGR_HPRE_3;
 c004a24:	4a05      	ldr	r2, [pc, #20]	; (c004a3c <SystemInit+0x94>)
 c004a26:	6893      	ldr	r3, [r2, #8]
 c004a28:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c004a2c:	6093      	str	r3, [r2, #8]
}
 c004a2e:	b002      	add	sp, #8
 c004a30:	4770      	bx	lr
 c004a32:	bf00      	nop
 c004a34:	e000ed00 	.word	0xe000ed00
 c004a38:	50007000 	.word	0x50007000
 c004a3c:	50021000 	.word	0x50021000
 c004a40:	50022000 	.word	0x50022000
 c004a44:	01003701 	.word	0x01003701
 c004a48:	e000edf0 	.word	0xe000edf0
 c004a4c:	e0001000 	.word	0xe0001000

0c004a50 <SystemCoreClockUpdate>:
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c004a50:	4a23      	ldr	r2, [pc, #140]	; (c004ae0 <SystemCoreClockUpdate+0x90>)
  msirange = MSIRangeTable[msirange];
 c004a52:	4924      	ldr	r1, [pc, #144]	; (c004ae4 <SystemCoreClockUpdate+0x94>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c004a54:	6813      	ldr	r3, [r2, #0]
{
 c004a56:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 c004a58:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c004a5a:	bf54      	ite	pl
 c004a5c:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c004a60:	6813      	ldrmi	r3, [r2, #0]
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c004a62:	6890      	ldr	r0, [r2, #8]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 c004a64:	bf58      	it	pl
 c004a66:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c004a6a:	f000 000c 	and.w	r0, r0, #12
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 c004a6e:	bf48      	it	mi
 c004a70:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c004a74:	2808      	cmp	r0, #8
  msirange = MSIRangeTable[msirange];
 c004a76:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 c004a7a:	491b      	ldr	r1, [pc, #108]	; (c004ae8 <SystemCoreClockUpdate+0x98>)
  switch (RCC->CFGR & RCC_CFGR_SWS)
 c004a7c:	d003      	beq.n	c004a86 <SystemCoreClockUpdate+0x36>
 c004a7e:	280c      	cmp	r0, #12
 c004a80:	d00d      	beq.n	c004a9e <SystemCoreClockUpdate+0x4e>
 c004a82:	2804      	cmp	r0, #4
 c004a84:	d129      	bne.n	c004ada <SystemCoreClockUpdate+0x8a>
      SystemCoreClock = HSI_VALUE;
 c004a86:	4b19      	ldr	r3, [pc, #100]	; (c004aec <SystemCoreClockUpdate+0x9c>)
      SystemCoreClock = pllvco/pllr;
 c004a88:	600b      	str	r3, [r1, #0]
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 c004a8a:	4b15      	ldr	r3, [pc, #84]	; (c004ae0 <SystemCoreClockUpdate+0x90>)
 c004a8c:	4a18      	ldr	r2, [pc, #96]	; (c004af0 <SystemCoreClockUpdate+0xa0>)
 c004a8e:	689b      	ldr	r3, [r3, #8]
 c004a90:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c004a94:	5cd2      	ldrb	r2, [r2, r3]
  SystemCoreClock >>= tmp;
 c004a96:	680b      	ldr	r3, [r1, #0]
 c004a98:	40d3      	lsrs	r3, r2
 c004a9a:	600b      	str	r3, [r1, #0]
}
 c004a9c:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c004a9e:	68d0      	ldr	r0, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c004aa0:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c004aa2:	f000 0203 	and.w	r2, r0, #3
      switch (pllsource)
 c004aa6:	3a02      	subs	r2, #2
 c004aa8:	2a01      	cmp	r2, #1
          pllvco = (HSE_VALUE / pllm);
 c004aaa:	bf98      	it	ls
 c004aac:	4a0f      	ldrls	r2, [pc, #60]	; (c004aec <SystemCoreClockUpdate+0x9c>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 c004aae:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c004ab2:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
 c004ab6:	bf94      	ite	ls
 c004ab8:	fbb2 f3f3 	udivls	r3, r2, r3
          pllvco = (msirange / pllm);
 c004abc:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c004ac0:	4a07      	ldr	r2, [pc, #28]	; (c004ae0 <SystemCoreClockUpdate+0x90>)
 c004ac2:	68d0      	ldr	r0, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c004ac4:	68d2      	ldr	r2, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 c004ac6:	f3c0 2006 	ubfx	r0, r0, #8, #7
 c004aca:	4343      	muls	r3, r0
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 c004acc:	f3c2 6241 	ubfx	r2, r2, #25, #2
 c004ad0:	3201      	adds	r2, #1
 c004ad2:	0052      	lsls	r2, r2, #1
      SystemCoreClock = pllvco/pllr;
 c004ad4:	fbb3 f3f2 	udiv	r3, r3, r2
 c004ad8:	e7d6      	b.n	c004a88 <SystemCoreClockUpdate+0x38>
      SystemCoreClock = msirange;
 c004ada:	600c      	str	r4, [r1, #0]
      break;
 c004adc:	e7d5      	b.n	c004a8a <SystemCoreClockUpdate+0x3a>
 c004ade:	bf00      	nop
 c004ae0:	50021000 	.word	0x50021000
 c004ae4:	0c00fb5c 	.word	0x0c00fb5c
 c004ae8:	300300a0 	.word	0x300300a0
 c004aec:	00f42400 	.word	0x00f42400
 c004af0:	0c00fb44 	.word	0x0c00fb44

0c004af4 <TFM_BL2_CopySharedData>:
  /*  default value */
  enum tfm_security_lifecycle_t lifecycle = TFM_SLC_SECURED;
  /* if 1 for TFM regression test */
  uint8_t boot_seed[BOOT_SEED_SIZE];
  uint8_t implementation_id[IMPLEMENTATION_ID_MAX_SIZE];
  size_t len = sizeof(boot_seed);
 c004af4:	2220      	movs	r2, #32
  enum tfm_security_lifecycle_t lifecycle = TFM_SLC_SECURED;
 c004af6:	f44f 5340 	mov.w	r3, #12288	; 0x3000
{
 c004afa:	b570      	push	{r4, r5, r6, lr}
 c004afc:	b0f4      	sub	sp, #464	; 0x1d0
  enum tfm_security_lifecycle_t lifecycle = TFM_SLC_SECURED;
 c004afe:	f8ad 301a 	strh.w	r3, [sp, #26]
  mbedtls_hardware_poll(NULL, boot_seed, sizeof(boot_seed), &len);
 c004b02:	eb0d 0102 	add.w	r1, sp, r2
 c004b06:	ab07      	add	r3, sp, #28
 c004b08:	2000      	movs	r0, #0
  size_t len = sizeof(boot_seed);
 c004b0a:	9207      	str	r2, [sp, #28]
  mbedtls_hardware_poll(NULL, boot_seed, sizeof(boot_seed), &len);
 c004b0c:	f7ff f960 	bl	c003dd0 <mbedtls_hardware_poll>
  if (len != sizeof(boot_seed))
 c004b10:	9b07      	ldr	r3, [sp, #28]
 c004b12:	2b20      	cmp	r3, #32
 c004b14:	d004      	beq.n	c004b20 <TFM_BL2_CopySharedData+0x2c>
  {
    BOOT_LOG_ERR("BL2 BOOT SEED generation Failed !!");
 c004b16:	4847      	ldr	r0, [pc, #284]	; (c004c34 <TFM_BL2_CopySharedData+0x140>)
 c004b18:	f009 fbdc 	bl	c00e2d4 <puts>
    Error_Handler();
 c004b1c:	f00c ff00 	bl	c011920 <Error_Handler>
  }
#ifndef TFM_HUK_RANDOM_GENERATION
  enum shared_memory_err_t res;
  res = boot_add_data_to_shared_area(TLV_MAJOR_SST,
 c004b20:	4b45      	ldr	r3, [pc, #276]	; (c004c38 <TFM_BL2_CopySharedData+0x144>)
 c004b22:	2220      	movs	r2, #32
 c004b24:	f644 0155 	movw	r1, #18517	; 0x4855
 c004b28:	2002      	movs	r0, #2
 c004b2a:	f008 ffb7 	bl	c00da9c <boot_add_data_to_shared_area>
                                     TLV_MINOR_CORE_HUK,
                                     sizeof(huk_value) - 1,
                                     (const uint8_t *)huk_value);
  if (res)
 c004b2e:	b120      	cbz	r0, c004b3a <TFM_BL2_CopySharedData+0x46>
  {
    BOOT_LOG_ERR("BL2 HUK set BL2 SHARED DATA Failed !!");
 c004b30:	4842      	ldr	r0, [pc, #264]	; (c004c3c <TFM_BL2_CopySharedData+0x148>)
 c004b32:	f009 fbcf 	bl	c00e2d4 <puts>
    Error_Handler();;
 c004b36:	f00c fef3 	bl	c011920 <Error_Handler>
  }
  BOOT_LOG_INF("BL2 HUK %s set to BL2 SHARED DATA", huk_value);
 c004b3a:	493f      	ldr	r1, [pc, #252]	; (c004c38 <TFM_BL2_CopySharedData+0x144>)
 c004b3c:	4840      	ldr	r0, [pc, #256]	; (c004c40 <TFM_BL2_CopySharedData+0x14c>)
 c004b3e:	f009 fb55 	bl	c00e1ec <iprintf>

#endif /*TFM_HUK_RANDOM_GENERATION*/
  /* Add BOOT SEED to the shared data */
  boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c004b42:	ab08      	add	r3, sp, #32
 c004b44:	2220      	movs	r2, #32
 c004b46:	2100      	movs	r1, #0
 c004b48:	2001      	movs	r0, #1
 c004b4a:	f008 ffa7 	bl	c00da9c <boot_add_data_to_shared_area>
                               TLV_MINOR_IAS_BOOT_SEED,
                               sizeof(boot_seed),
                               (const uint8_t *)boot_seed);
  /* Add Hardocded Lifecycle value */
  boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c004b4e:	2202      	movs	r2, #2
 c004b50:	f10d 031a 	add.w	r3, sp, #26
 c004b54:	4611      	mov	r1, r2
 c004b56:	2001      	movs	r0, #1
 c004b58:	f008 ffa0 	bl	c00da9c <boot_add_data_to_shared_area>
                               TLV_MINOR_IAS_SLC,
                               sizeof(lifecycle),
                               (const uint8_t *)&lifecycle);

  /* add Attest key material in BL2 shared data */
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c004b5c:	4b39      	ldr	r3, [pc, #228]	; (c004c44 <TFM_BL2_CopySharedData+0x150>)
 c004b5e:	2220      	movs	r2, #32
 c004b60:	f644 3158 	movw	r1, #19288	; 0x4b58
 c004b64:	2000      	movs	r0, #0
 c004b66:	f008 ff99 	bl	c00da9c <boot_add_data_to_shared_area>
                               TLV_MINOR_CORE_IAS_PUB_KEY_X,
                               sizeof(initial_attestation_public_x_key),
                               (const uint8_t *)&initial_attestation_public_x_key);
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c004b6a:	4b37      	ldr	r3, [pc, #220]	; (c004c48 <TFM_BL2_CopySharedData+0x154>)
 c004b6c:	2220      	movs	r2, #32
 c004b6e:	f644 3159 	movw	r1, #19289	; 0x4b59
 c004b72:	2000      	movs	r0, #0
 c004b74:	f008 ff92 	bl	c00da9c <boot_add_data_to_shared_area>
  */

static void ComputeImplementationId(uint8_t *hash_result)
{
  bootutil_sha256_context sha256_ctx;
  BOOT_LOG_INF("Code %x %x", (uint32_t)CODE_START
 c004b78:	4c34      	ldr	r4, [pc, #208]	; (c004c4c <TFM_BL2_CopySharedData+0x158>)
 c004b7a:	4d35      	ldr	r5, [pc, #212]	; (c004c50 <TFM_BL2_CopySharedData+0x15c>)
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c004b7c:	4b35      	ldr	r3, [pc, #212]	; (c004c54 <TFM_BL2_CopySharedData+0x160>)
 c004b7e:	2220      	movs	r2, #32
 c004b80:	f644 3148 	movw	r1, #19272	; 0x4b48
 c004b84:	2000      	movs	r0, #0
 c004b86:	f008 ff89 	bl	c00da9c <boot_add_data_to_shared_area>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c004b8a:	4b33      	ldr	r3, [pc, #204]	; (c004c58 <TFM_BL2_CopySharedData+0x164>)
 c004b8c:	2201      	movs	r2, #1
 c004b8e:	f644 3154 	movw	r1, #19284	; 0x4b54
 c004b92:	2000      	movs	r0, #0
 c004b94:	f008 ff82 	bl	c00da9c <boot_add_data_to_shared_area>
  BOOT_LOG_INF("Code %x %x", (uint32_t)CODE_START
 c004b98:	462a      	mov	r2, r5
 c004b9a:	4621      	mov	r1, r4
 c004b9c:	482f      	ldr	r0, [pc, #188]	; (c004c5c <TFM_BL2_CopySharedData+0x168>)
 c004b9e:	f009 fb25 	bl	c00e1ec <iprintf>
#ifdef MCUBOOT_USE_MBED_TLS
typedef mbedtls_sha256_context bootutil_sha256_context;

static inline void bootutil_sha256_init(bootutil_sha256_context *ctx)
{
    mbedtls_sha256_init(ctx);
 c004ba2:	a818      	add	r0, sp, #96	; 0x60
 c004ba4:	f7ff fdfe 	bl	c0047a4 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c004ba8:	2100      	movs	r1, #0
 c004baa:	a818      	add	r0, sp, #96	; 0x60
 c004bac:	f7ff fe22 	bl	c0047f4 <mbedtls_sha256_starts_ret>

static inline void bootutil_sha256_update(bootutil_sha256_context *ctx,
                                          const void *data,
                                          uint32_t data_len)
{
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c004bb0:	1b2a      	subs	r2, r5, r4
 c004bb2:	4621      	mov	r1, r4
  for (i = 0; i < sizeof(initial_attestation_private_key); i += 4)
 c004bb4:	2400      	movs	r4, #0
 c004bb6:	a818      	add	r0, sp, #96	; 0x60
 c004bb8:	f7ff fe41 	bl	c00483e <mbedtls_sha256_update_ret>
}

static inline void bootutil_sha256_finish(bootutil_sha256_context *ctx,
                                          uint8_t *output)
{
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c004bbc:	a910      	add	r1, sp, #64	; 0x40
 c004bbe:	a818      	add	r0, sp, #96	; 0x60
 c004bc0:	f7ff fe8c 	bl	c0048dc <mbedtls_sha256_finish_ret>
  bootutil_sha256_update(&sha256_ctx,
                         CODE_START,
                         (uint32_t)CODE_LIMIT - (uint32_t)CODE_START);

  bootutil_sha256_finish(&sha256_ctx, hash_result);
  BOOT_LOG_INF("hash TFM_SBSFU_Boot  %x%x%x%x .. %x%x%x%x",
 c004bc4:	f89d 005f 	ldrb.w	r0, [sp, #95]	; 0x5f
 c004bc8:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
 c004bcc:	9004      	str	r0, [sp, #16]
 c004bce:	f89d 005e 	ldrb.w	r0, [sp, #94]	; 0x5e
 c004bd2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
 c004bd6:	9003      	str	r0, [sp, #12]
 c004bd8:	f89d 005d 	ldrb.w	r0, [sp, #93]	; 0x5d
 c004bdc:	f89d 1040 	ldrb.w	r1, [sp, #64]	; 0x40
 c004be0:	9002      	str	r0, [sp, #8]
 c004be2:	f89d 005c 	ldrb.w	r0, [sp, #92]	; 0x5c
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c004be6:	4e14      	ldr	r6, [pc, #80]	; (c004c38 <TFM_BL2_CopySharedData+0x144>)
  BOOT_LOG_INF("hash TFM_SBSFU_Boot  %x%x%x%x .. %x%x%x%x",
 c004be8:	9001      	str	r0, [sp, #4]
 c004bea:	f89d 0043 	ldrb.w	r0, [sp, #67]	; 0x43
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c004bee:	4d1c      	ldr	r5, [pc, #112]	; (c004c60 <TFM_BL2_CopySharedData+0x16c>)
  BOOT_LOG_INF("hash TFM_SBSFU_Boot  %x%x%x%x .. %x%x%x%x",
 c004bf0:	9000      	str	r0, [sp, #0]
 c004bf2:	481c      	ldr	r0, [pc, #112]	; (c004c64 <TFM_BL2_CopySharedData+0x170>)
 c004bf4:	f009 fafa 	bl	c00e1ec <iprintf>
  boot_add_data_to_shared_area(TLV_MAJOR_CORE,
 c004bf8:	ab10      	add	r3, sp, #64	; 0x40
 c004bfa:	2220      	movs	r2, #32
 c004bfc:	f644 11cd 	movw	r1, #18893	; 0x49cd
 c004c00:	2000      	movs	r0, #0
 c004c02:	f008 ff4b 	bl	c00da9c <boot_add_data_to_shared_area>
  MODIFY_REG(TAMP->SMCR, TAMP_SMCR_BKPRWDPROT, BL2_RTC_SHARED_DATA_SIZE>>2);
 c004c06:	4a18      	ldr	r2, [pc, #96]	; (c004c68 <TFM_BL2_CopySharedData+0x174>)
 c004c08:	6a13      	ldr	r3, [r2, #32]
 c004c0a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 c004c0e:	f043 0308 	orr.w	r3, r3, #8
 c004c12:	6213      	str	r3, [r2, #32]
  TAMP->PRIVCR |= TAMP_PRIVCR_BKPRWPRIV;
 c004c14:	6a53      	ldr	r3, [r2, #36]	; 0x24
 c004c16:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 c004c1a:	6253      	str	r3, [r2, #36]	; 0x24
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c004c1c:	1933      	adds	r3, r6, r4
 c004c1e:	08a1      	lsrs	r1, r4, #2
 c004c20:	f8d3 2082 	ldr.w	r2, [r3, #130]	; 0x82
 c004c24:	4628      	mov	r0, r5
  for (i = 0; i < sizeof(initial_attestation_private_key); i += 4)
 c004c26:	3404      	adds	r4, #4
    HAL_RTCEx_BKUPWrite(&RTCHandle, i / 4, *((uint32_t *)(&initial_attestation_private_key[i])));
 c004c28:	f005 f8e8 	bl	c009dfc <HAL_RTCEx_BKUPWrite>
  for (i = 0; i < sizeof(initial_attestation_private_key); i += 4)
 c004c2c:	2c20      	cmp	r4, #32
 c004c2e:	d1f5      	bne.n	c004c1c <TFM_BL2_CopySharedData+0x128>
}
 c004c30:	b074      	add	sp, #464	; 0x1d0
 c004c32:	bd70      	pop	{r4, r5, r6, pc}
 c004c34:	0c00fb9c 	.word	0x0c00fb9c
 c004c38:	0c002000 	.word	0x0c002000
 c004c3c:	0c00fbc6 	.word	0x0c00fbc6
 c004c40:	0c00fbf3 	.word	0x0c00fbf3
 c004c44:	0c002021 	.word	0x0c002021
 c004c48:	0c002041 	.word	0x0c002041
 c004c4c:	0c002900 	.word	0x0c002900
 c004c50:	0c011bf6 	.word	0x0c011bf6
 c004c54:	0c002061 	.word	0x0c002061
 c004c58:	0c002081 	.word	0x0c002081
 c004c5c:	0c00fc1d 	.word	0x0c00fc1d
 c004c60:	3003e3f8 	.word	0x3003e3f8
 c004c64:	0c00fc30 	.word	0x0c00fc30
 c004c68:	50003400 	.word	0x50003400

0c004c6c <TFM_LL_SECU_ApplyRunTimeProtections>:
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c004c6c:	f06f 0201 	mvn.w	r2, #1
 c004c70:	4bb7      	ldr	r3, [pc, #732]	; (c004f50 <TFM_LL_SECU_ApplyRunTimeProtections+0x2e4>)
{
 c004c72:	b510      	push	{r4, lr}
  GTZC_MPCBB1_S->VCTR[0] = 0xfffffffe;
 c004c74:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  __HAL_RCC_GTZC_CLK_ENABLE();
 c004c78:	f5a3 338e 	sub.w	r3, r3, #72704	; 0x11c00
 c004c7c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
{
 c004c7e:	b09e      	sub	sp, #120	; 0x78
  __HAL_RCC_GTZC_CLK_ENABLE();
 c004c80:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 c004c84:	649a      	str	r2, [r3, #72]	; 0x48
 c004c86:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  MPCWM_ConfigTypeDef MPCWM1_NonSecureArea1_Desc = {0};
 c004c88:	2100      	movs	r1, #0
  __HAL_RCC_GTZC_CLK_ENABLE();
 c004c8a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 c004c8e:	9302      	str	r3, [sp, #8]
  MPCWM_ConfigTypeDef MPCWM1_NonSecureArea1_Desc = {0};
 c004c90:	2210      	movs	r2, #16
 c004c92:	a803      	add	r0, sp, #12
  __HAL_RCC_GTZC_CLK_ENABLE();
 c004c94:	9b02      	ldr	r3, [sp, #8]
  MPCWM_ConfigTypeDef MPCWM1_NonSecureArea1_Desc = {0};
 c004c96:	f009 f9f8 	bl	c00e08a <memset>
  MPCWM1_NonSecureArea1_Desc.Length = OSPI_FLASH_TOTAL_SIZE;
 c004c9a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  if (HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes(OCTOSPI1_BASE, &MPCWM1_NonSecureArea1_Desc) != HAL_OK)
 c004c9e:	a903      	add	r1, sp, #12
 c004ca0:	f04f 4010 	mov.w	r0, #2415919104	; 0x90000000
  MPCWM1_NonSecureArea1_Desc.Length = OSPI_FLASH_TOTAL_SIZE;
 c004ca4:	9305      	str	r3, [sp, #20]
  if (HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes(OCTOSPI1_BASE, &MPCWM1_NonSecureArea1_Desc) != HAL_OK)
 c004ca6:	f002 fea1 	bl	c0079ec <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes>
 c004caa:	b108      	cbz	r0, c004cb0 <TFM_LL_SECU_ApplyRunTimeProtections+0x44>
    Error_Handler();
 c004cac:	f00c fe38 	bl	c011920 <Error_Handler>
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c004cb0:	4ba8      	ldr	r3, [pc, #672]	; (c004f54 <TFM_LL_SECU_ApplyRunTimeProtections+0x2e8>)
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c004cb2:	4aa9      	ldr	r2, [pc, #676]	; (c004f58 <TFM_LL_SECU_ApplyRunTimeProtections+0x2ec>)
  struct mpu_armv8m_dev_t dev_mpu_s = { MPU_BASE };
 c004cb4:	9300      	str	r3, [sp, #0]
  struct mpu_armv8m_dev_t dev_mpu_ns = { MPU_BASE_NS};
 c004cb6:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
 c004cba:	9301      	str	r3, [sp, #4]
  region_cfg.region_base = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET ;
 c004cbc:	2300      	movs	r3, #0
 c004cbe:	e9cd 3203 	strd	r3, r2, [sp, #12]
  region_cfg.region_limit = FLASH_BASE_S + S_IMAGE_PRIMARY_PARTITION_OFFSET + FLASH_S_PARTITION_SIZE - 1;
 c004cc2:	f502 320f 	add.w	r2, r2, #146432	; 0x23c00
 c004cc6:	f202 32ff 	addw	r2, r2, #1023	; 0x3ff
 c004cca:	9205      	str	r2, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004ccc:	2401      	movs	r4, #1
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004cce:	2203      	movs	r2, #3
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004cd0:	a903      	add	r1, sp, #12
 c004cd2:	4668      	mov	r0, sp
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004cd4:	9206      	str	r2, [sp, #24]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004cd6:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004cda:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004cde:	f88d 401c 	strb.w	r4, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004ce2:	f00c fda7 	bl	c011834 <mpu_armv8m_region_enable>
 c004ce6:	b108      	cbz	r0, c004cec <TFM_LL_SECU_ApplyRunTimeProtections+0x80>
    Error_Handler();
 c004ce8:	f00c fe1a 	bl	c011920 <Error_Handler>
  region_cfg.region_limit = OSPI_FLASH_BASE_ADDRESS + OSPI_FLASH_TOTAL_SIZE - 1;
 c004cec:	f04f 4010 	mov.w	r0, #2415919104	; 0x90000000
 c004cf0:	f06f 43d8 	mvn.w	r3, #1811939328	; 0x6c000000
 c004cf4:	e9cd 0304 	strd	r0, r3, [sp, #16]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c004cf8:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004cfa:	a903      	add	r1, sp, #12
 c004cfc:	4668      	mov	r0, sp
  region_cfg.region_nr = 1;
 c004cfe:	9403      	str	r4, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c004d00:	9306      	str	r3, [sp, #24]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004d02:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004d06:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004d0a:	f88d 401c 	strb.w	r4, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d0e:	f00c fd91 	bl	c011834 <mpu_armv8m_region_enable>
 c004d12:	b108      	cbz	r0, c004d18 <TFM_LL_SECU_ApplyRunTimeProtections+0xac>
    Error_Handler();
 c004d14:	f00c fe04 	bl	c011920 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_S;
 c004d18:	2102      	movs	r1, #2
 c004d1a:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
 c004d1e:	e9cd 1303 	strd	r1, r3, [sp, #12]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_BL2_OFFSET - 1;
 c004d22:	f503 5323 	add.w	r3, r3, #10432	; 0x28c0
 c004d26:	333f      	adds	r3, #63	; 0x3f
 c004d28:	9305      	str	r3, [sp, #20]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004d2a:	2300      	movs	r3, #0
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004d2c:	2403      	movs	r4, #3
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004d2e:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004d32:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004d36:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d38:	a903      	add	r1, sp, #12
 c004d3a:	4668      	mov	r0, sp
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004d3c:	9406      	str	r4, [sp, #24]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004d3e:	f88d 301c 	strb.w	r3, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d42:	f00c fd77 	bl	c011834 <mpu_armv8m_region_enable>
 c004d46:	b108      	cbz	r0, c004d4c <TFM_LL_SECU_ApplyRunTimeProtections+0xe0>
    Error_Handler();
 c004d48:	f00c fdea 	bl	c011920 <Error_Handler>
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_BL2_NOHDP_OFFSET + FLASH_AREA_BL2_NOHDP_SIZE;
 c004d4c:	4b83      	ldr	r3, [pc, #524]	; (c004f5c <TFM_LL_SECU_ApplyRunTimeProtections+0x2f0>)
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d4e:	a903      	add	r1, sp, #12
  region_cfg.region_base = FLASH_BASE_S + FLASH_AREA_BL2_NOHDP_OFFSET + FLASH_AREA_BL2_NOHDP_SIZE;
 c004d50:	9304      	str	r3, [sp, #16]
  region_cfg.region_limit = FLASH_BASE_S + FLASH_AREA_0_OFFSET - 1;
 c004d52:	f503 439f 	add.w	r3, r3, #20352	; 0x4f80
 c004d56:	337f      	adds	r3, #127	; 0x7f
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004d58:	e9cd 3405 	strd	r3, r4, [sp, #20]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004d5c:	2300      	movs	r3, #0
 c004d5e:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004d62:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004d66:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d68:	4668      	mov	r0, sp
  region_cfg.region_nr = 3;
 c004d6a:	9403      	str	r4, [sp, #12]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004d6c:	f88d 301c 	strb.w	r3, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d70:	f00c fd60 	bl	c011834 <mpu_armv8m_region_enable>
 c004d74:	b108      	cbz	r0, c004d7a <TFM_LL_SECU_ApplyRunTimeProtections+0x10e>
    Error_Handler();
 c004d76:	f00c fdd3 	bl	c011920 <Error_Handler>
  region_cfg.region_base = SRAM1_BASE_S ;
 c004d7a:	f04f 5340 	mov.w	r3, #805306368	; 0x30000000
 c004d7e:	2204      	movs	r2, #4
 c004d80:	e9cd 2303 	strd	r2, r3, [sp, #12]
  region_cfg.region_limit = SRAM1_BASE_S + TOTAL_RAM_SIZE - 1;
 c004d84:	f503 337e 	add.w	r3, r3, #260096	; 0x3f800
 c004d88:	f203 33ff 	addw	r3, r3, #1023	; 0x3ff
 c004d8c:	9305      	str	r3, [sp, #20]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c004d8e:	2302      	movs	r3, #2
 c004d90:	9306      	str	r3, [sp, #24]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004d92:	2300      	movs	r3, #0
 c004d94:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004d98:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004d9c:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004d9e:	a903      	add	r1, sp, #12
 c004da0:	4668      	mov	r0, sp
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004da2:	f88d 301c 	strb.w	r3, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004da6:	f00c fd45 	bl	c011834 <mpu_armv8m_region_enable>
 c004daa:	b108      	cbz	r0, c004db0 <TFM_LL_SECU_ApplyRunTimeProtections+0x144>
    Error_Handler();
 c004dac:	f00c fdb8 	bl	c011920 <Error_Handler>
  region_cfg.region_base = PERIPH_BASE_S;
 c004db0:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 c004db4:	f04f 0c05 	mov.w	ip, #5
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c004db8:	f06f 4e20 	mvn.w	lr, #2684354560	; 0xa0000000
  region_cfg.region_base = PERIPH_BASE_S;
 c004dbc:	e9cd c303 	strd	ip, r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c004dc0:	2300      	movs	r3, #0
 c004dc2:	e9cd e305 	strd	lr, r3, [sp, #20]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004dc6:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004dca:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004dce:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004dd0:	a903      	add	r1, sp, #12
 c004dd2:	4668      	mov	r0, sp
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004dd4:	f88d 301c 	strb.w	r3, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_s, &region_cfg) != MPU_ARMV8M_OK)
 c004dd8:	f00c fd2c 	bl	c011834 <mpu_armv8m_region_enable>
 c004ddc:	b108      	cbz	r0, c004de2 <TFM_LL_SECU_ApplyRunTimeProtections+0x176>
    Error_Handler();
 c004dde:	f00c fd9f 	bl	c011920 <Error_Handler>
  mpu_armv8m_enable(&dev_mpu_s, PRIVILEGED_DEFAULT_ENABLE,
 c004de2:	2201      	movs	r2, #1
 c004de4:	4668      	mov	r0, sp
 c004de6:	4611      	mov	r1, r2
 c004de8:	f00c fd0a 	bl	c011800 <mpu_armv8m_enable>
  region_cfg.region_base = OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_1_OFFSET;
 c004dec:	2300      	movs	r3, #0
 c004dee:	f04f 4210 	mov.w	r2, #2415919104	; 0x90000000
 c004df2:	e9cd 3203 	strd	r3, r2, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004df6:	2203      	movs	r2, #3
 c004df8:	4c59      	ldr	r4, [pc, #356]	; (c004f60 <TFM_LL_SECU_ApplyRunTimeProtections+0x2f4>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004dfa:	a903      	add	r1, sp, #12
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004dfc:	e9cd 4205 	strd	r4, r2, [sp, #20]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e00:	2401      	movs	r4, #1
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e02:	a801      	add	r0, sp, #4
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004e04:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004e08:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e0c:	f88d 401c 	strb.w	r4, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e10:	f00c fd10 	bl	c011834 <mpu_armv8m_region_enable>
 c004e14:	b108      	cbz	r0, c004e1a <TFM_LL_SECU_ApplyRunTimeProtections+0x1ae>
    Error_Handler();
 c004e16:	f00c fd83 	bl	c011920 <Error_Handler>
  region_cfg.region_limit = OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_3_OFFSET + FLASH_AREA_3_SIZE - 1;
 c004e1a:	4852      	ldr	r0, [pc, #328]	; (c004f64 <TFM_LL_SECU_ApplyRunTimeProtections+0x2f8>)
 c004e1c:	4b52      	ldr	r3, [pc, #328]	; (c004f68 <TFM_LL_SECU_ApplyRunTimeProtections+0x2fc>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e1e:	a903      	add	r1, sp, #12
  region_cfg.region_limit = OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_3_OFFSET + FLASH_AREA_3_SIZE - 1;
 c004e20:	e9cd 0304 	strd	r0, r3, [sp, #16]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATANOCACHE_IDX;
 c004e24:	2303      	movs	r3, #3
 c004e26:	9306      	str	r3, [sp, #24]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004e28:	2300      	movs	r3, #0
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e2a:	a801      	add	r0, sp, #4
  region_cfg.region_nr = 1;
 c004e2c:	9403      	str	r4, [sp, #12]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004e2e:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004e32:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e36:	f88d 401c 	strb.w	r4, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e3a:	f00c fcfb 	bl	c011834 <mpu_armv8m_region_enable>
 c004e3e:	b108      	cbz	r0, c004e44 <TFM_LL_SECU_ApplyRunTimeProtections+0x1d8>
    Error_Handler();
 c004e40:	f00c fd6e 	bl	c011920 <Error_Handler>
  region_cfg.region_base = SRAM1_BASE_NS + (~MPU_RBAR_BASE_Msk) + 1;
 c004e44:	2302      	movs	r3, #2
 c004e46:	4a49      	ldr	r2, [pc, #292]	; (c004f6c <TFM_LL_SECU_ApplyRunTimeProtections+0x300>)
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e48:	a903      	add	r1, sp, #12
  region_cfg.region_base = SRAM1_BASE_NS + (~MPU_RBAR_BASE_Msk) + 1;
 c004e4a:	e9cd 3203 	strd	r3, r2, [sp, #12]
  region_cfg.region_limit = SRAM1_BASE_NS + TOTAL_RAM_SIZE - 1;
 c004e4e:	f502 327e 	add.w	r2, r2, #260096	; 0x3f800
 c004e52:	f202 32df 	addw	r2, r2, #991	; 0x3df
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
 c004e56:	e9cd 2305 	strd	r2, r3, [sp, #20]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004e5a:	2300      	movs	r3, #0
 c004e5c:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004e60:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e64:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e66:	a801      	add	r0, sp, #4
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e68:	f88d 301c 	strb.w	r3, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e6c:	f00c fce2 	bl	c011834 <mpu_armv8m_region_enable>
 c004e70:	b108      	cbz	r0, c004e76 <TFM_LL_SECU_ApplyRunTimeProtections+0x20a>
    Error_Handler();
 c004e72:	f00c fd55 	bl	c011920 <Error_Handler>
  region_cfg.region_base = PERIPH_BASE_NS;
 c004e76:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 c004e7a:	2203      	movs	r2, #3
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c004e7c:	f06f 4130 	mvn.w	r1, #2952790016	; 0xb0000000
  region_cfg.region_base = PERIPH_BASE_NS;
 c004e80:	e9cd 2303 	strd	r2, r3, [sp, #12]
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DEVICE_IDX;
 c004e84:	2300      	movs	r3, #0
 c004e86:	e9cd 1305 	strd	r1, r3, [sp, #20]
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
 c004e8a:	f88d 301d 	strb.w	r3, [sp, #29]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
 c004e8e:	f88d 301e 	strb.w	r3, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e92:	2301      	movs	r3, #1
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e94:	a903      	add	r1, sp, #12
 c004e96:	a801      	add	r0, sp, #4
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_NEVER;
 c004e98:	f88d 301c 	strb.w	r3, [sp, #28]
  if (mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg) != MPU_ARMV8M_OK)
 c004e9c:	f00c fcca 	bl	c011834 <mpu_armv8m_region_enable>
 c004ea0:	b108      	cbz	r0, c004ea6 <TFM_LL_SECU_ApplyRunTimeProtections+0x23a>
    Error_Handler();
 c004ea2:	f00c fd3d 	bl	c011920 <Error_Handler>
  mpu_armv8m_enable(&dev_mpu_ns, PRIVILEGED_DEFAULT_ENABLE,
 c004ea6:	2201      	movs	r2, #1
 c004ea8:	a801      	add	r0, sp, #4
 c004eaa:	4611      	mov	r1, r2
 c004eac:	f00c fca8 	bl	c011800 <mpu_armv8m_enable>
    SAU->CTRL &= ~(SAU_CTRL_ENABLE_Msk);
 c004eb0:	4b2f      	ldr	r3, [pc, #188]	; (c004f70 <TFM_LL_SECU_ApplyRunTimeProtections+0x304>)
 c004eb2:	681a      	ldr	r2, [r3, #0]
 c004eb4:	f022 0201 	bic.w	r2, r2, #1
 c004eb8:	601a      	str	r2, [r3, #0]
  SAU->RNR  = 0;
 c004eba:	2200      	movs	r2, #0
 c004ebc:	609a      	str	r2, [r3, #8]
  SAU->RBAR = (SRAM1_BASE_NS & SAU_RBAR_BADDR_Msk);
 c004ebe:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 c004ec2:	60da      	str	r2, [r3, #12]
  SAU->RLAR = ((SRAM1_BASE_NS + NS_NO_INIT_DATA_SIZE - 1) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c004ec4:	32e1      	adds	r2, #225	; 0xe1
 c004ec6:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 1;
 c004ec8:	2201      	movs	r2, #1
 c004eca:	609a      	str	r2, [r3, #8]
  SAU->RBAR = ((uint32_t)FLASH_NS & SAU_RBAR_BADDR_Msk);
 c004ecc:	4a29      	ldr	r2, [pc, #164]	; (c004f74 <TFM_LL_SECU_ApplyRunTimeProtections+0x308>)
 c004ece:	60da      	str	r2, [r3, #12]
  SAU->RLAR = (((uint32_t)FLASH_NS + 0xffff) & SAU_RLAR_LADDR_Msk) | SAU_RLAR_ENABLE_Msk;
 c004ed0:	f502 427f 	add.w	r2, r2, #65280	; 0xff00
 c004ed4:	32e1      	adds	r2, #225	; 0xe1
 c004ed6:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 2;
 c004ed8:	2202      	movs	r2, #2
 c004eda:	609a      	str	r2, [r3, #8]
  SAU->RBAR = ((uint32_t)OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_1_OFFSET) & SAU_RBAR_BADDR_Msk;
 c004edc:	f04f 4210 	mov.w	r2, #2415919104	; 0x90000000
 c004ee0:	60da      	str	r2, [r3, #12]
  SAU->RLAR = (((uint32_t)OSPI_FLASH_BASE_ADDRESS + FLASH_AREA_3_OFFSET
 c004ee2:	f502 1208 	add.w	r2, r2, #2228224	; 0x220000
 c004ee6:	f502 527f 	add.w	r2, r2, #16320	; 0x3fc0
 c004eea:	3221      	adds	r2, #33	; 0x21
 c004eec:	611a      	str	r2, [r3, #16]
  SAU->RNR  = 3;
 c004eee:	2203      	movs	r2, #3
 c004ef0:	609a      	str	r2, [r3, #8]
  SAU->RBAR = LOADER_NS_ROM_ALIAS(FLASH_AREA_LOADER_OFFSET) & SAU_RBAR_BADDR_Msk;
 c004ef2:	4a21      	ldr	r2, [pc, #132]	; (c004f78 <TFM_LL_SECU_ApplyRunTimeProtections+0x30c>)
 c004ef4:	60da      	str	r2, [r3, #12]
  SAU->RLAR = LOADER_NS_ROM_ALIAS(FLASH_TOTAL_SIZE-1) & SAU_RBAR_BADDR_Msk;
 c004ef6:	f502 42bf 	add.w	r2, r2, #24448	; 0x5f80
 c004efa:	3260      	adds	r2, #96	; 0x60
 c004efc:	611a      	str	r2, [r3, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 c004efe:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c004f02:	f3bf 8f6f 	isb	sy
    SAU->CTRL |=  (SAU_CTRL_ENABLE_Msk);
 c004f06:	681a      	ldr	r2, [r3, #0]
    if (HAL_GTZC_MPCBB_GetConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c004f08:	a903      	add	r1, sp, #12
 c004f0a:	f042 0201 	orr.w	r2, r2, #1
 c004f0e:	601a      	str	r2, [r3, #0]
    __HAL_RCC_GTZC_CLK_ENABLE();
 c004f10:	4b1a      	ldr	r3, [pc, #104]	; (c004f7c <TFM_LL_SECU_ApplyRunTimeProtections+0x310>)
    if (HAL_GTZC_MPCBB_GetConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c004f12:	481b      	ldr	r0, [pc, #108]	; (c004f80 <TFM_LL_SECU_ApplyRunTimeProtections+0x314>)
    __HAL_RCC_GTZC_CLK_ENABLE();
 c004f14:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 c004f16:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 c004f1a:	649a      	str	r2, [r3, #72]	; 0x48
 c004f1c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 c004f1e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 c004f22:	9301      	str	r3, [sp, #4]
 c004f24:	9b01      	ldr	r3, [sp, #4]
    if (HAL_GTZC_MPCBB_GetConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c004f26:	f002 fde9 	bl	c007afc <HAL_GTZC_MPCBB_GetConfigMem>
 c004f2a:	b108      	cbz	r0, c004f30 <TFM_LL_SECU_ApplyRunTimeProtections+0x2c4>
      Error_Handler();
 c004f2c:	f00c fcf8 	bl	c011920 <Error_Handler>
    MPCBB_desc.AttributeConfig.MPCBB_LockConfig_array[0] |= 0x00000080;
 c004f30:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c004f32:	a903      	add	r1, sp, #12
    MPCBB_desc.AttributeConfig.MPCBB_LockConfig_array[0] |= 0x00000080;
 c004f34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c004f38:	4811      	ldr	r0, [pc, #68]	; (c004f80 <TFM_LL_SECU_ApplyRunTimeProtections+0x314>)
    MPCBB_desc.AttributeConfig.MPCBB_LockConfig_array[0] |= 0x00000080;
 c004f3a:	931d      	str	r3, [sp, #116]	; 0x74
    if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_desc) != HAL_OK)
 c004f3c:	f002 fd9e 	bl	c007a7c <HAL_GTZC_MPCBB_ConfigMem>
 c004f40:	b108      	cbz	r0, c004f46 <TFM_LL_SECU_ApplyRunTimeProtections+0x2da>
      Error_Handler();
 c004f42:	f00c fced 	bl	c011920 <Error_Handler>
  HAL_FLASHEx_ConfigPrivMode(FLASH_PRIV_DENIED);
 c004f46:	2001      	movs	r0, #1
 c004f48:	f002 fb5e 	bl	c007608 <HAL_FLASHEx_ConfigPrivMode>
}
 c004f4c:	b01e      	add	sp, #120	; 0x78
 c004f4e:	bd10      	pop	{r4, pc}
 c004f50:	50032c00 	.word	0x50032c00
 c004f54:	e000ed90 	.word	0xe000ed90
 c004f58:	0c017000 	.word	0x0c017000
 c004f5c:	0c012000 	.word	0x0c012000
 c004f60:	900fffff 	.word	0x900fffff
 c004f64:	90100000 	.word	0x90100000
 c004f68:	90223fff 	.word	0x90223fff
 c004f6c:	20000020 	.word	0x20000020
 c004f70:	e000edd0 	.word	0xe000edd0
 c004f74:	40022000 	.word	0x40022000
 c004f78:	0807a000 	.word	0x0807a000
 c004f7c:	50021000 	.word	0x50021000
 c004f80:	30030000 	.word	0x30030000

0c004f84 <TFM_LL_SECU_CheckStaticProtections>:
{
 c004f84:	b573      	push	{r0, r1, r4, r5, r6, lr}
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c004f86:	2301      	movs	r3, #1
  flash_option_bytes_bank1.BootAddrConfig = OB_BOOTADDR_SEC0;
 c004f88:	2604      	movs	r6, #4
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c004f8a:	4ca9      	ldr	r4, [pc, #676]	; (c005230 <TFM_LL_SECU_CheckStaticProtections+0x2ac>)
  flash_option_bytes_bank2.WRPArea = OB_WRPAREA_BANK2_AREAA;
 c004f8c:	4da9      	ldr	r5, [pc, #676]	; (c005234 <TFM_LL_SECU_CheckStaticProtections+0x2b0>)
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);
 c004f8e:	4620      	mov	r0, r4
  flash_option_bytes_bank1.WRPArea = OB_WRPAREA_BANK1_AREAA;
 c004f90:	6063      	str	r3, [r4, #4]
  flash_option_bytes_bank1.WMSecConfig = OB_WMSEC_AREA1;
 c004f92:	61e3      	str	r3, [r4, #28]
  flash_option_bytes_bank1.BootAddrConfig = OB_BOOTADDR_SEC0;
 c004f94:	6326      	str	r6, [r4, #48]	; 0x30
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank1);
 c004f96:	f002 fab3 	bl	c007500 <HAL_FLASHEx_OBGetConfig>
  flash_option_bytes_bank2.WMSecConfig = OB_WMSEC_AREA2;
 c004f9a:	2302      	movs	r3, #2
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank2);
 c004f9c:	4628      	mov	r0, r5
  flash_option_bytes_bank2.WMSecConfig = OB_WMSEC_AREA2;
 c004f9e:	61eb      	str	r3, [r5, #28]
  flash_option_bytes_bank2.WRPArea = OB_WRPAREA_BANK2_AREAA;
 c004fa0:	606e      	str	r6, [r5, #4]
  HAL_FLASHEx_OBGetConfig(&flash_option_bytes_bank2);
 c004fa2:	f002 faad 	bl	c007500 <HAL_FLASHEx_OBGetConfig>
  flash_option_bytes_bank1.OptionType = 0;
 c004fa6:	2300      	movs	r3, #0
 c004fa8:	6023      	str	r3, [r4, #0]
  flash_option_bytes_bank2.WRPArea = 0;
 c004faa:	e9c5 3300 	strd	r3, r3, [r5]
  flash_option_bytes_bank1.WRPArea = 0;
 c004fae:	6063      	str	r3, [r4, #4]
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_TZEN) != FLASH_OPTR_TZEN)
 c004fb0:	69a3      	ldr	r3, [r4, #24]
 c004fb2:	2b00      	cmp	r3, #0
 c004fb4:	db04      	blt.n	c004fc0 <TFM_LL_SECU_CheckStaticProtections+0x3c>
    BOOT_LOG_ERR("Unexpected value for TZEN value");
 c004fb6:	48a0      	ldr	r0, [pc, #640]	; (c005238 <TFM_LL_SECU_CheckStaticProtections+0x2b4>)
 c004fb8:	f009 f98c 	bl	c00e2d4 <puts>
    Error_Handler();
 c004fbc:	f00c fcb0 	bl	c011920 <Error_Handler>
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_DBANK) != FLASH_OPTR_DBANK)
 c004fc0:	69a3      	ldr	r3, [r4, #24]
 c004fc2:	025e      	lsls	r6, r3, #9
 c004fc4:	d404      	bmi.n	c004fd0 <TFM_LL_SECU_CheckStaticProtections+0x4c>
    BOOT_LOG_ERR("Unexpected value for dual bank configuration");
 c004fc6:	489d      	ldr	r0, [pc, #628]	; (c00523c <TFM_LL_SECU_CheckStaticProtections+0x2b8>)
 c004fc8:	f009 f984 	bl	c00e2d4 <puts>
    Error_Handler();
 c004fcc:	f00c fca8 	bl	c011920 <Error_Handler>
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_SWAP_BANK) != 0)
 c004fd0:	69a3      	ldr	r3, [r4, #24]
 c004fd2:	02d8      	lsls	r0, r3, #11
 c004fd4:	d504      	bpl.n	c004fe0 <TFM_LL_SECU_CheckStaticProtections+0x5c>
    BOOT_LOG_ERR("Unexpected value for swap bank configuration");
 c004fd6:	489a      	ldr	r0, [pc, #616]	; (c005240 <TFM_LL_SECU_CheckStaticProtections+0x2bc>)
 c004fd8:	f009 f97c 	bl	c00e2d4 <puts>
    Error_Handler();
 c004fdc:	f00c fca0 	bl	c011920 <Error_Handler>
  if (flash_option_bytes_bank1.BootAddr != SBSFU_BOOT_VTOR_ADDR)
 c004fe0:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c004fe2:	4b98      	ldr	r3, [pc, #608]	; (c005244 <TFM_LL_SECU_CheckStaticProtections+0x2c0>)
 c004fe4:	4299      	cmp	r1, r3
 c004fe6:	d007      	beq.n	c004ff8 <TFM_LL_SECU_CheckStaticProtections+0x74>
    BOOT_LOG_INF("BootAddr 0x%x", flash_option_bytes_bank1.BootAddr);
 c004fe8:	4897      	ldr	r0, [pc, #604]	; (c005248 <TFM_LL_SECU_CheckStaticProtections+0x2c4>)
 c004fea:	f009 f8ff 	bl	c00e1ec <iprintf>
    BOOT_LOG_ERR("Unexpected value for SEC BOOT Address");
 c004fee:	4897      	ldr	r0, [pc, #604]	; (c00524c <TFM_LL_SECU_CheckStaticProtections+0x2c8>)
 c004ff0:	f009 f970 	bl	c00e2d4 <puts>
    Error_Handler();
 c004ff4:	f00c fc94 	bl	c011920 <Error_Handler>
 c004ff8:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
  if ((start != flash_option_bytes_bank1.WMSecStartPage)
 c004ffc:	b90b      	cbnz	r3, c005002 <TFM_LL_SECU_CheckStaticProtections+0x7e>
      || (end != flash_option_bytes_bank1.WMSecEndPage))
 c004ffe:	2a75      	cmp	r2, #117	; 0x75
 c005000:	d014      	beq.n	c00502c <TFM_LL_SECU_CheckStaticProtections+0xa8>
    BOOT_LOG_INF("BANK 1 secure flash [%d, %d] : OB [%d, %d]",
 c005002:	2100      	movs	r1, #0
 c005004:	9200      	str	r2, [sp, #0]
 c005006:	4892      	ldr	r0, [pc, #584]	; (c005250 <TFM_LL_SECU_CheckStaticProtections+0x2cc>)
 c005008:	2275      	movs	r2, #117	; 0x75
 c00500a:	f009 f8ef 	bl	c00e1ec <iprintf>
    BOOT_LOG_ERR("Unexpected value for secure flash protection: set wmsec1");
 c00500e:	4891      	ldr	r0, [pc, #580]	; (c005254 <TFM_LL_SECU_CheckStaticProtections+0x2d0>)
 c005010:	f009 f960 	bl	c00e2d4 <puts>
    flash_option_bytes_bank1.WMSecEndPage = end;
 c005014:	2375      	movs	r3, #117	; 0x75
 c005016:	2100      	movs	r1, #0
 c005018:	e9c4 1308 	strd	r1, r3, [r4, #32]
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WMSEC;
 c00501c:	6823      	ldr	r3, [r4, #0]
 c00501e:	f043 0310 	orr.w	r3, r3, #16
 c005022:	6023      	str	r3, [r4, #0]
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_AREA1 | OB_WMSEC_SECURE_AREA_CONFIG;
 c005024:	69e3      	ldr	r3, [r4, #28]
 c005026:	f043 0311 	orr.w	r3, r3, #17
 c00502a:	61e3      	str	r3, [r4, #28]
  else if (flash_option_bytes_bank2.WMSecEndPage >= flash_option_bytes_bank2.WMSecStartPage)
 c00502c:	e9d5 3208 	ldrd	r3, r2, [r5, #32]
 c005030:	429a      	cmp	r2, r3
 c005032:	d30f      	bcc.n	c005054 <TFM_LL_SECU_CheckStaticProtections+0xd0>
    BOOT_LOG_INF("BANK 2 secure flash [%d, %d] : OB [%d, %d]", 127, 0, flash_option_bytes_bank2.WMSecStartPage,
 c005034:	9200      	str	r2, [sp, #0]
 c005036:	217f      	movs	r1, #127	; 0x7f
 c005038:	2200      	movs	r2, #0
 c00503a:	4887      	ldr	r0, [pc, #540]	; (c005258 <TFM_LL_SECU_CheckStaticProtections+0x2d4>)
 c00503c:	f009 f8d6 	bl	c00e1ec <iprintf>
    flash_option_bytes_bank2.WMSecEndPage = 0;
 c005040:	2300      	movs	r3, #0
 c005042:	227f      	movs	r2, #127	; 0x7f
 c005044:	e9c5 2308 	strd	r2, r3, [r5, #32]
    flash_option_bytes_bank2.OptionType = OPTIONBYTE_WMSEC;
 c005048:	2310      	movs	r3, #16
 c00504a:	602b      	str	r3, [r5, #0]
    flash_option_bytes_bank2.WMSecConfig |= OB_WMSEC_AREA2 | OB_WMSEC_SECURE_AREA_CONFIG ;
 c00504c:	69eb      	ldr	r3, [r5, #28]
 c00504e:	f043 0312 	orr.w	r3, r3, #18
 c005052:	61eb      	str	r3, [r5, #28]
  if ((flash_option_bytes_bank1.WRPStartOffset > flash_option_bytes_bank1.WRPEndOffset)
 c005054:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 c005058:	4293      	cmp	r3, r2
 c00505a:	d803      	bhi.n	c005064 <TFM_LL_SECU_CheckStaticProtections+0xe0>
      || (start != flash_option_bytes_bank1.WRPStartOffset)
 c00505c:	2b04      	cmp	r3, #4
 c00505e:	d101      	bne.n	c005064 <TFM_LL_SECU_CheckStaticProtections+0xe0>
      || (end != flash_option_bytes_bank1.WRPEndOffset))
 c005060:	2a23      	cmp	r2, #35	; 0x23
 c005062:	d015      	beq.n	c005090 <TFM_LL_SECU_CheckStaticProtections+0x10c>
    BOOT_LOG_INF("BANK 1 flash write protection [%d, %d] : OB [%d, %d]", start, end,
 c005064:	9200      	str	r2, [sp, #0]
 c005066:	2104      	movs	r1, #4
 c005068:	2223      	movs	r2, #35	; 0x23
 c00506a:	487c      	ldr	r0, [pc, #496]	; (c00525c <TFM_LL_SECU_CheckStaticProtections+0x2d8>)
 c00506c:	f009 f8be 	bl	c00e1ec <iprintf>
    flash_option_bytes_bank1.WRPEndOffset = end;
 c005070:	f04f 0e04 	mov.w	lr, #4
 c005074:	2323      	movs	r3, #35	; 0x23
 c005076:	e9c4 e302 	strd	lr, r3, [r4, #8]
    flash_option_bytes_bank1.WRPArea |= OB_WRPAREA_BANK1_AREAA;
 c00507a:	6863      	ldr	r3, [r4, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp1");
 c00507c:	4878      	ldr	r0, [pc, #480]	; (c005260 <TFM_LL_SECU_CheckStaticProtections+0x2dc>)
    flash_option_bytes_bank1.WRPArea |= OB_WRPAREA_BANK1_AREAA;
 c00507e:	f043 0301 	orr.w	r3, r3, #1
 c005082:	6063      	str	r3, [r4, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp1");
 c005084:	f009 f926 	bl	c00e2d4 <puts>
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WRP;
 c005088:	6823      	ldr	r3, [r4, #0]
 c00508a:	f043 0301 	orr.w	r3, r3, #1
 c00508e:	6023      	str	r3, [r4, #0]
  if ((flash_option_bytes_bank2.WRPStartOffset > flash_option_bytes_bank2.WRPEndOffset)
 c005090:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 c005094:	4293      	cmp	r3, r2
 c005096:	d803      	bhi.n	c0050a0 <TFM_LL_SECU_CheckStaticProtections+0x11c>
      || (start != flash_option_bytes_bank2.WRPStartOffset)
 c005098:	2b74      	cmp	r3, #116	; 0x74
 c00509a:	d101      	bne.n	c0050a0 <TFM_LL_SECU_CheckStaticProtections+0x11c>
      || (end != flash_option_bytes_bank2.WRPEndOffset))
 c00509c:	2a7f      	cmp	r2, #127	; 0x7f
 c00509e:	d015      	beq.n	c0050cc <TFM_LL_SECU_CheckStaticProtections+0x148>
    BOOT_LOG_INF("BANK 2 flash write protection [%d, %d] : OB [%d, %d]", start, end,
 c0050a0:	9200      	str	r2, [sp, #0]
 c0050a2:	2174      	movs	r1, #116	; 0x74
 c0050a4:	227f      	movs	r2, #127	; 0x7f
 c0050a6:	486f      	ldr	r0, [pc, #444]	; (c005264 <TFM_LL_SECU_CheckStaticProtections+0x2e0>)
 c0050a8:	f009 f8a0 	bl	c00e1ec <iprintf>
    flash_option_bytes_bank2.WRPEndOffset = end;
 c0050ac:	f04f 0c74 	mov.w	ip, #116	; 0x74
 c0050b0:	237f      	movs	r3, #127	; 0x7f
 c0050b2:	e9c5 c302 	strd	ip, r3, [r5, #8]
    flash_option_bytes_bank2.WRPArea |= OB_WRPAREA_BANK2_AREAA;
 c0050b6:	686b      	ldr	r3, [r5, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp2");
 c0050b8:	486b      	ldr	r0, [pc, #428]	; (c005268 <TFM_LL_SECU_CheckStaticProtections+0x2e4>)
    flash_option_bytes_bank2.WRPArea |= OB_WRPAREA_BANK2_AREAA;
 c0050ba:	f043 0304 	orr.w	r3, r3, #4
 c0050be:	606b      	str	r3, [r5, #4]
    BOOT_LOG_ERR("Unexpected value for write protection : set wrp2");
 c0050c0:	f009 f908 	bl	c00e2d4 <puts>
    flash_option_bytes_bank2.OptionType |= OPTIONBYTE_WRP;
 c0050c4:	682b      	ldr	r3, [r5, #0]
 c0050c6:	f043 0301 	orr.w	r3, r3, #1
 c0050ca:	602b      	str	r3, [r5, #0]
    (flash_option_bytes_bank1.WMSecStartPage > flash_option_bytes_bank1.WMHDPEndPage)
 c0050cc:	6a23      	ldr	r3, [r4, #32]
 c0050ce:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  if (
 c0050d0:	4293      	cmp	r3, r2
 c0050d2:	d805      	bhi.n	c0050e0 <TFM_LL_SECU_CheckStaticProtections+0x15c>
    || (start < flash_option_bytes_bank1.WMSecStartPage)
 c0050d4:	b923      	cbnz	r3, c0050e0 <TFM_LL_SECU_CheckStaticProtections+0x15c>
    || (end > flash_option_bytes_bank1.WMHDPEndPage)
 c0050d6:	2a21      	cmp	r2, #33	; 0x21
 c0050d8:	d902      	bls.n	c0050e0 <TFM_LL_SECU_CheckStaticProtections+0x15c>
    || (flash_option_bytes_bank1.WMSecConfig & OB_WMSEC_HDP_AREA_DISABLE))
 c0050da:	69e1      	ldr	r1, [r4, #28]
 c0050dc:	05ce      	lsls	r6, r1, #23
 c0050de:	d516      	bpl.n	c00510e <TFM_LL_SECU_CheckStaticProtections+0x18a>
    BOOT_LOG_INF("BANK 1 secure user flash [%d, %d] : OB [%d, %d]",
 c0050e0:	9200      	str	r2, [sp, #0]
 c0050e2:	2100      	movs	r1, #0
 c0050e4:	2222      	movs	r2, #34	; 0x22
 c0050e6:	4861      	ldr	r0, [pc, #388]	; (c00526c <TFM_LL_SECU_CheckStaticProtections+0x2e8>)
 c0050e8:	f009 f880 	bl	c00e1ec <iprintf>
    BOOT_LOG_ERR("Unexpected value for secure user flash protection : set hdp1");
 c0050ec:	4860      	ldr	r0, [pc, #384]	; (c005270 <TFM_LL_SECU_CheckStaticProtections+0x2ec>)
 c0050ee:	f009 f8f1 	bl	c00e2d4 <puts>
    flash_option_bytes_bank1.WMSecStartPage = start;
 c0050f2:	2300      	movs	r3, #0
 c0050f4:	6223      	str	r3, [r4, #32]
    flash_option_bytes_bank1.WMHDPEndPage = end;
 c0050f6:	2322      	movs	r3, #34	; 0x22
 c0050f8:	62a3      	str	r3, [r4, #40]	; 0x28
    flash_option_bytes_bank1.OptionType |= OPTIONBYTE_WMSEC;
 c0050fa:	6823      	ldr	r3, [r4, #0]
 c0050fc:	f043 0310 	orr.w	r3, r3, #16
 c005100:	6023      	str	r3, [r4, #0]
    flash_option_bytes_bank1.WMSecConfig &= ~OB_WMSEC_HDP_AREA_DISABLE;
 c005102:	69e3      	ldr	r3, [r4, #28]
 c005104:	f423 7380 	bic.w	r3, r3, #256	; 0x100
    flash_option_bytes_bank1.WMSecConfig |= OB_WMSEC_AREA1;
 c005108:	f043 03a1 	orr.w	r3, r3, #161	; 0xa1
 c00510c:	61e3      	str	r3, [r4, #28]
  if ((flash_option_bytes_bank1.USERConfig & FLASH_OPTR_SRAM2_RST) != 0)
 c00510e:	69a3      	ldr	r3, [r4, #24]
 c005110:	0199      	lsls	r1, r3, #6
 c005112:	d504      	bpl.n	c00511e <TFM_LL_SECU_CheckStaticProtections+0x19a>
    BOOT_LOG_ERR("Unexpected value for SRAM2 ERASE at Reset");
 c005114:	4857      	ldr	r0, [pc, #348]	; (c005274 <TFM_LL_SECU_CheckStaticProtections+0x2f0>)
 c005116:	f009 f8dd 	bl	c00e2d4 <puts>
    Error_Handler();
 c00511a:	f00c fc01 	bl	c011920 <Error_Handler>
  if ((flash_option_bytes_bank1.OptionType != 0) || (flash_option_bytes_bank2.OptionType != 0))
 c00511e:	6823      	ldr	r3, [r4, #0]
 c005120:	b913      	cbnz	r3, c005128 <TFM_LL_SECU_CheckStaticProtections+0x1a4>
 c005122:	682b      	ldr	r3, [r5, #0]
 c005124:	2b00      	cmp	r3, #0
 c005126:	d045      	beq.n	c0051b4 <TFM_LL_SECU_CheckStaticProtections+0x230>
    HAL_FLASH_Unlock();
 c005128:	f001 ffc2 	bl	c0070b0 <HAL_FLASH_Unlock>
    HAL_FLASH_OB_Unlock();
 c00512c:	f001 fff4 	bl	c007118 <HAL_FLASH_OB_Unlock>
    if ((flash_option_bytes_bank1.OptionType & OPTIONBYTE_RDP) != 0)
 c005130:	6823      	ldr	r3, [r4, #0]
 c005132:	079a      	lsls	r2, r3, #30
 c005134:	d504      	bpl.n	c005140 <TFM_LL_SECU_CheckStaticProtections+0x1bc>
      BOOT_LOG_ERR("Unexpected value for OB RDP to program");
 c005136:	4850      	ldr	r0, [pc, #320]	; (c005278 <TFM_LL_SECU_CheckStaticProtections+0x2f4>)
 c005138:	f009 f8cc 	bl	c00e2d4 <puts>
      Error_Handler();
 c00513c:	f00c fbf0 	bl	c011920 <Error_Handler>
    if ((flash_option_bytes_bank2.OptionType & OPTIONBYTE_RDP) != 0)
 c005140:	682b      	ldr	r3, [r5, #0]
 c005142:	079b      	lsls	r3, r3, #30
 c005144:	d504      	bpl.n	c005150 <TFM_LL_SECU_CheckStaticProtections+0x1cc>
      BOOT_LOG_ERR("Unexpected value for OB RDP to program");
 c005146:	484c      	ldr	r0, [pc, #304]	; (c005278 <TFM_LL_SECU_CheckStaticProtections+0x2f4>)
 c005148:	f009 f8c4 	bl	c00e2d4 <puts>
      Error_Handler();
 c00514c:	f00c fbe8 	bl	c011920 <Error_Handler>
    if ((flash_option_bytes_bank2.WRPArea & ~OB_WRPAREA_BANK2_AREAA) != 0)
 c005150:	686b      	ldr	r3, [r5, #4]
 c005152:	f033 0304 	bics.w	r3, r3, #4
 c005156:	d004      	beq.n	c005162 <TFM_LL_SECU_CheckStaticProtections+0x1de>
      BOOT_LOG_ERR("Unexpected value for bank 2 OB WRP AREA to program");
 c005158:	4848      	ldr	r0, [pc, #288]	; (c00527c <TFM_LL_SECU_CheckStaticProtections+0x2f8>)
 c00515a:	f009 f8bb 	bl	c00e2d4 <puts>
      Error_Handler();
 c00515e:	f00c fbdf 	bl	c011920 <Error_Handler>
    if ((flash_option_bytes_bank1.WRPArea & ~OB_WRPAREA_BANK1_AREAA) != 0)
 c005162:	6863      	ldr	r3, [r4, #4]
 c005164:	f033 0301 	bics.w	r3, r3, #1
 c005168:	d004      	beq.n	c005174 <TFM_LL_SECU_CheckStaticProtections+0x1f0>
      BOOT_LOG_ERR("Unexpected value for bank 1 OB WRP AREA to program");
 c00516a:	4845      	ldr	r0, [pc, #276]	; (c005280 <TFM_LL_SECU_CheckStaticProtections+0x2fc>)
 c00516c:	f009 f8b2 	bl	c00e2d4 <puts>
      Error_Handler();
 c005170:	f00c fbd6 	bl	c011920 <Error_Handler>
    if ((flash_option_bytes_bank1.OptionType) != 0)
 c005174:	6823      	ldr	r3, [r4, #0]
 c005176:	b143      	cbz	r3, c00518a <TFM_LL_SECU_CheckStaticProtections+0x206>
      ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank1);
 c005178:	482d      	ldr	r0, [pc, #180]	; (c005230 <TFM_LL_SECU_CheckStaticProtections+0x2ac>)
 c00517a:	f002 f88f 	bl	c00729c <HAL_FLASHEx_OBProgram>
      if (ret != HAL_OK)
 c00517e:	b120      	cbz	r0, c00518a <TFM_LL_SECU_CheckStaticProtections+0x206>
        BOOT_LOG_ERR("Error while setting OB Bank1 config");
 c005180:	4840      	ldr	r0, [pc, #256]	; (c005284 <TFM_LL_SECU_CheckStaticProtections+0x300>)
 c005182:	f009 f8a7 	bl	c00e2d4 <puts>
        Error_Handler();
 c005186:	f00c fbcb 	bl	c011920 <Error_Handler>
    if ((flash_option_bytes_bank2.OptionType) != 0)
 c00518a:	682b      	ldr	r3, [r5, #0]
 c00518c:	b143      	cbz	r3, c0051a0 <TFM_LL_SECU_CheckStaticProtections+0x21c>
      ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank2);
 c00518e:	4829      	ldr	r0, [pc, #164]	; (c005234 <TFM_LL_SECU_CheckStaticProtections+0x2b0>)
 c005190:	f002 f884 	bl	c00729c <HAL_FLASHEx_OBProgram>
      if (ret != HAL_OK)
 c005194:	b120      	cbz	r0, c0051a0 <TFM_LL_SECU_CheckStaticProtections+0x21c>
        BOOT_LOG_ERR("Error while setting OB Bank1 config");
 c005196:	483b      	ldr	r0, [pc, #236]	; (c005284 <TFM_LL_SECU_CheckStaticProtections+0x300>)
 c005198:	f009 f89c 	bl	c00e2d4 <puts>
        Error_Handler();
 c00519c:	f00c fbc0 	bl	c011920 <Error_Handler>
    ret = HAL_FLASH_OB_Launch();
 c0051a0:	f001 ffcc 	bl	c00713c <HAL_FLASH_OB_Launch>
    if (ret != HAL_OK)
 c0051a4:	b120      	cbz	r0, c0051b0 <TFM_LL_SECU_CheckStaticProtections+0x22c>
      BOOT_LOG_ERR("Error while execution OB_Launch");
 c0051a6:	4838      	ldr	r0, [pc, #224]	; (c005288 <TFM_LL_SECU_CheckStaticProtections+0x304>)
 c0051a8:	f009 f894 	bl	c00e2d4 <puts>
      Error_Handler();
 c0051ac:	f00c fbb8 	bl	c011920 <Error_Handler>
    HAL_NVIC_SystemReset();
 c0051b0:	f001 f9f6 	bl	c0065a0 <HAL_NVIC_SystemReset>
  if (flash_option_bytes_bank1.BootLock != TFM_OB_BOOT_LOCK)
 c0051b4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 c0051b6:	b139      	cbz	r1, c0051c8 <TFM_LL_SECU_CheckStaticProtections+0x244>
    BOOT_LOG_INF("BootLock 0x%x", flash_option_bytes_bank1.BootLock);
 c0051b8:	4834      	ldr	r0, [pc, #208]	; (c00528c <TFM_LL_SECU_CheckStaticProtections+0x308>)
 c0051ba:	f009 f817 	bl	c00e1ec <iprintf>
    BOOT_LOG_ERR("Unexpected value for SEC BOOT LOCK");
 c0051be:	4834      	ldr	r0, [pc, #208]	; (c005290 <TFM_LL_SECU_CheckStaticProtections+0x30c>)
 c0051c0:	f009 f888 	bl	c00e2d4 <puts>
    Error_Handler();
 c0051c4:	f00c fbac 	bl	c011920 <Error_Handler>
  if (flash_option_bytes_bank1.RDPLevel != TFM_OB_RDP_LEVEL_VALUE)
 c0051c8:	6921      	ldr	r1, [r4, #16]
 c0051ca:	29bb      	cmp	r1, #187	; 0xbb
 c0051cc:	d02d      	beq.n	c00522a <TFM_LL_SECU_CheckStaticProtections+0x2a6>
    BOOT_LOG_INF("RDPLevel 0x%x (0x%x)", flash_option_bytes_bank1.RDPLevel, TFM_OB_RDP_LEVEL_VALUE);
 c0051ce:	22bb      	movs	r2, #187	; 0xbb
 c0051d0:	4830      	ldr	r0, [pc, #192]	; (c005294 <TFM_LL_SECU_CheckStaticProtections+0x310>)
 c0051d2:	f009 f80b 	bl	c00e1ec <iprintf>
    BOOT_LOG_ERR("Unexpected value for RDP level");
 c0051d6:	4830      	ldr	r0, [pc, #192]	; (c005298 <TFM_LL_SECU_CheckStaticProtections+0x314>)
 c0051d8:	f009 f87c 	bl	c00e2d4 <puts>
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c0051dc:	2302      	movs	r3, #2
  flash_option_bytes_bank.RDPLevel = rdplevel;
 c0051de:	21bb      	movs	r1, #187	; 0xbb
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c0051e0:	4c2e      	ldr	r4, [pc, #184]	; (c00529c <TFM_LL_SECU_CheckStaticProtections+0x318>)
  BOOT_LOG_INF("Programming RDP to %x", rdplevel);
 c0051e2:	482f      	ldr	r0, [pc, #188]	; (c0052a0 <TFM_LL_SECU_CheckStaticProtections+0x31c>)
  flash_option_bytes_bank.OptionType = OPTIONBYTE_RDP;
 c0051e4:	6023      	str	r3, [r4, #0]
  flash_option_bytes_bank.RDPLevel = rdplevel;
 c0051e6:	6121      	str	r1, [r4, #16]
  BOOT_LOG_INF("Programming RDP to %x", rdplevel);
 c0051e8:	f009 f800 	bl	c00e1ec <iprintf>
  BOOT_LOG_INF("Unplug/Plug jumper JP2 (IDD)");
 c0051ec:	482d      	ldr	r0, [pc, #180]	; (c0052a4 <TFM_LL_SECU_CheckStaticProtections+0x320>)
 c0051ee:	f009 f871 	bl	c00e2d4 <puts>
  HAL_FLASH_Unlock();
 c0051f2:	f001 ff5d 	bl	c0070b0 <HAL_FLASH_Unlock>
  HAL_FLASH_OB_Unlock();
 c0051f6:	f001 ff8f 	bl	c007118 <HAL_FLASH_OB_Unlock>
  ret = HAL_FLASHEx_OBProgram(&flash_option_bytes_bank);
 c0051fa:	4620      	mov	r0, r4
 c0051fc:	f002 f84e 	bl	c00729c <HAL_FLASHEx_OBProgram>
  if (ret != HAL_OK)
 c005200:	b120      	cbz	r0, c00520c <TFM_LL_SECU_CheckStaticProtections+0x288>
    BOOT_LOG_ERR("Error while setting RDP level");
 c005202:	4829      	ldr	r0, [pc, #164]	; (c0052a8 <TFM_LL_SECU_CheckStaticProtections+0x324>)
 c005204:	f009 f866 	bl	c00e2d4 <puts>
    Error_Handler();
 c005208:	f00c fb8a 	bl	c011920 <Error_Handler>
  ret = HAL_FLASH_OB_Launch();
 c00520c:	f001 ff96 	bl	c00713c <HAL_FLASH_OB_Launch>
  if (ret != HAL_OK)
 c005210:	b120      	cbz	r0, c00521c <TFM_LL_SECU_CheckStaticProtections+0x298>
    BOOT_LOG_ERR("Error while execution OB_Launch");
 c005212:	481d      	ldr	r0, [pc, #116]	; (c005288 <TFM_LL_SECU_CheckStaticProtections+0x304>)
 c005214:	f009 f85e 	bl	c00e2d4 <puts>
    Error_Handler();
 c005218:	f00c fb82 	bl	c011920 <Error_Handler>
  HAL_NVIC_SystemReset();
 c00521c:	f001 f9c0 	bl	c0065a0 <HAL_NVIC_SystemReset>
}
 c005220:	b002      	add	sp, #8
 c005222:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
 c005226:	f00c bb7b 	b.w	c011920 <Error_Handler>
}
 c00522a:	b002      	add	sp, #8
 c00522c:	bd70      	pop	{r4, r5, r6, pc}
 c00522e:	bf00      	nop
 c005230:	30030274 	.word	0x30030274
 c005234:	300302ac 	.word	0x300302ac
 c005238:	0c00fc62 	.word	0x0c00fc62
 c00523c:	0c00fc89 	.word	0x0c00fc89
 c005240:	0c00fcbd 	.word	0x0c00fcbd
 c005244:	0c002900 	.word	0x0c002900
 c005248:	0c00fcf1 	.word	0x0c00fcf1
 c00524c:	0c00fd07 	.word	0x0c00fd07
 c005250:	0c00fd34 	.word	0x0c00fd34
 c005254:	0c00fd67 	.word	0x0c00fd67
 c005258:	0c00fda7 	.word	0x0c00fda7
 c00525c:	0c00fdda 	.word	0x0c00fdda
 c005260:	0c00fe17 	.word	0x0c00fe17
 c005264:	0c00fe4f 	.word	0x0c00fe4f
 c005268:	0c00fe8c 	.word	0x0c00fe8c
 c00526c:	0c00fec4 	.word	0x0c00fec4
 c005270:	0c00fefc 	.word	0x0c00fefc
 c005274:	0c00ff40 	.word	0x0c00ff40
 c005278:	0c00ff71 	.word	0x0c00ff71
 c00527c:	0c00ff9f 	.word	0x0c00ff9f
 c005280:	0c00ffd9 	.word	0x0c00ffd9
 c005284:	0c010013 	.word	0x0c010013
 c005288:	0c01003e 	.word	0x0c01003e
 c00528c:	0c010065 	.word	0x0c010065
 c005290:	0c01007b 	.word	0x0c01007b
 c005294:	0c0100a5 	.word	0x0c0100a5
 c005298:	0c0100c2 	.word	0x0c0100c2
 c00529c:	3003023c 	.word	0x3003023c
 c0052a0:	0c0100e8 	.word	0x0c0100e8
 c0052a4:	0c010106 	.word	0x0c010106
 c0052a8:	0c01012a 	.word	0x0c01012a

0c0052ac <MX25LM51245G_GetFlashInfo>:
  */
int32_t MX25LM51245G_GetFlashInfo(MX25LM51245G_Info_t *pInfo)
{
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize              = MX25LM51245G_FLASH_SIZE;
  pInfo->EraseSectorSize        = MX25LM51245G_SECTOR_64K;
 c0052ac:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 c0052b0:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 c0052b4:	e9c0 2300 	strd	r2, r3, [r0]
  pInfo->EraseSectorsNumber     = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SECTOR_64K);
  pInfo->EraseSubSectorSize     = MX25LM51245G_SUBSECTOR_4K;
 c0052b8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 c0052bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 c0052c0:	e9c0 3202 	strd	r3, r2, [r0, #8]
  pInfo->EraseSubSectorNumber   = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SUBSECTOR_4K);
 c0052c4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  pInfo->EraseSubSector1Size    = MX25LM51245G_SUBSECTOR_4K;
  pInfo->EraseSubSector1Number  = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SUBSECTOR_4K);
  pInfo->ProgPageSize           = MX25LM51245G_PAGE_SIZE;
  pInfo->ProgPagesNumber        = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_PAGE_SIZE);
 c0052c8:	f44f 7180 	mov.w	r1, #256	; 0x100
  pInfo->EraseSubSector1Size    = MX25LM51245G_SUBSECTOR_4K;
 c0052cc:	e9c0 3204 	strd	r3, r2, [r0, #16]
  pInfo->EraseSubSector1Number  = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SUBSECTOR_4K);
 c0052d0:	6183      	str	r3, [r0, #24]
  pInfo->ProgPagesNumber        = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_PAGE_SIZE);
 c0052d2:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 c0052d6:	e9c0 1307 	strd	r1, r3, [r0, #28]

  return MX25LM51245G_OK;
};
 c0052da:	2000      	movs	r0, #0
 c0052dc:	4770      	bx	lr

0c0052de <MX25LM51245G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX25LM51245G_AutoPollingMemReady(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                         MX25LM51245G_Transfer_t Rate)
{
 c0052de:	b570      	push	{r4, r5, r6, lr}
 c0052e0:	460c      	mov	r4, r1
 c0052e2:	b09a      	sub	sp, #104	; 0x68
  OSPI_RegularCmdTypeDef  s_command = {0};
 c0052e4:	2100      	movs	r1, #0
{
 c0052e6:	4606      	mov	r6, r0
 c0052e8:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef  s_command = {0};
 c0052ea:	a806      	add	r0, sp, #24
 c0052ec:	2250      	movs	r2, #80	; 0x50
 c0052ee:	f008 fecc 	bl	c00e08a <memset>
  OSPI_AutoPollingTypeDef s_config = {0};
 c0052f2:	2214      	movs	r2, #20
 c0052f4:	2100      	movs	r1, #0
 c0052f6:	a801      	add	r0, sp, #4
 c0052f8:	f008 fec7 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c0052fc:	b92c      	cbnz	r4, c00530a <MX25LM51245G_AutoPollingMemReady+0x2c>
 c0052fe:	2d01      	cmp	r5, #1
 c005300:	d159      	bne.n	c0053b6 <MX25LM51245G_AutoPollingMemReady+0xd8>
  {
    return MX25LM51245G_ERROR;
 c005302:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005306:	b01a      	add	sp, #104	; 0x68
 c005308:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c00530a:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c00530c:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c00530e:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005310:	bf0c      	ite	eq
 c005312:	2308      	moveq	r3, #8
 c005314:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005316:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005318:	930b      	str	r3, [sp, #44]	; 0x2c
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c00531a:	bf0c      	ite	eq
 c00531c:	2300      	moveq	r3, #0
 c00531e:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005320:	930a      	str	r3, [sp, #40]	; 0x28
                                 : MX25LM51245G_OCTA_READ_STATUS_REG_CMD;
 c005322:	f240 53fa 	movw	r3, #1530	; 0x5fa
 c005326:	bf08      	it	eq
 c005328:	2305      	moveq	r3, #5
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c00532a:	9308      	str	r3, [sp, #32]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c00532c:	bf0c      	ite	eq
 c00532e:	2300      	moveq	r3, #0
 c005330:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005334:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c005336:	930d      	str	r3, [sp, #52]	; 0x34
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005338:	bf0c      	ite	eq
 c00533a:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c00533e:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005340:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005342:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005346:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005348:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c00534a:	bf0c      	ite	eq
 c00534c:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005350:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005354:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005356:	9314      	str	r3, [sp, #80]	; 0x50
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005358:	bf0c      	ite	eq
 c00535a:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 c00535e:	2300      	movne	r3, #0
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005360:	9316      	str	r3, [sp, #88]	; 0x58
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 c005362:	b11c      	cbz	r4, c00536c <MX25LM51245G_AutoPollingMemReady+0x8e>
 c005364:	2d01      	cmp	r5, #1
 c005366:	bf0c      	ite	eq
 c005368:	2405      	moveq	r4, #5
 c00536a:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 c00536c:	2d01      	cmp	r5, #1
 c00536e:	bf0c      	ite	eq
 c005370:	2302      	moveq	r3, #2
 c005372:	2301      	movne	r3, #1
 c005374:	9315      	str	r3, [sp, #84]	; 0x54
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c005376:	bf0c      	ite	eq
 c005378:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 c00537c:	2300      	movne	r3, #0
 c00537e:	9318      	str	r3, [sp, #96]	; 0x60
  s_config.Mask          = MX25LM51245G_SR_WIP;
 c005380:	2301      	movs	r3, #1
  s_config.AutomaticStop = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 c005382:	2110      	movs	r1, #16
  s_config.Mask          = MX25LM51245G_SR_WIP;
 c005384:	9302      	str	r3, [sp, #8]
  s_config.AutomaticStop = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 c005386:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c00538a:	f241 3288 	movw	r2, #5000	; 0x1388
  s_config.AutomaticStop = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 c00538e:	e9cd 3104 	strd	r3, r1, [sp, #16]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005392:	4630      	mov	r0, r6
 c005394:	a906      	add	r1, sp, #24
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 c005396:	9417      	str	r4, [sp, #92]	; 0x5c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005398:	f002 ffc0 	bl	c00831c <HAL_OSPI_Command>
 c00539c:	2800      	cmp	r0, #0
 c00539e:	d1b0      	bne.n	c005302 <MX25LM51245G_AutoPollingMemReady+0x24>
  if (HAL_OSPI_AutoPolling(Ctx, &s_config, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0053a0:	f241 3288 	movw	r2, #5000	; 0x1388
 c0053a4:	a901      	add	r1, sp, #4
 c0053a6:	4630      	mov	r0, r6
 c0053a8:	f003 f8a1 	bl	c0084ee <HAL_OSPI_AutoPolling>
 c0053ac:	3000      	adds	r0, #0
 c0053ae:	bf18      	it	ne
 c0053b0:	2001      	movne	r0, #1
 c0053b2:	4240      	negs	r0, r0
 c0053b4:	e7a7      	b.n	c005306 <MX25LM51245G_AutoPollingMemReady+0x28>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c0053b6:	2301      	movs	r3, #1
 c0053b8:	e7a8      	b.n	c00530c <MX25LM51245G_AutoPollingMemReady+0x2e>

0c0053ba <MX25LM51245G_ReadSTR>:
  * @param  Size Size of data to read
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_ReadSTR(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                             MX25LM51245G_AddressSize_t AddressSize, uint8_t *pData, uint32_t ReadAddr, uint32_t Size)
{
 c0053ba:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0053bc:	460c      	mov	r4, r1
 c0053be:	b095      	sub	sp, #84	; 0x54
 c0053c0:	4606      	mov	r6, r0
 c0053c2:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c0053c4:	2100      	movs	r1, #0
 c0053c6:	2250      	movs	r2, #80	; 0x50
 c0053c8:	4668      	mov	r0, sp
{
 c0053ca:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c0053cc:	f008 fe5d 	bl	c00e08a <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 c0053d0:	2c01      	cmp	r4, #1
 c0053d2:	d105      	bne.n	c0053e0 <MX25LM51245G_ReadSTR+0x26>
 c0053d4:	2d00      	cmp	r5, #0
 c0053d6:	d143      	bne.n	c005460 <MX25LM51245G_ReadSTR+0xa6>
  {
    return MX25LM51245G_ERROR;
 c0053d8:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c0053dc:	b015      	add	sp, #84	; 0x54
 c0053de:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c0053e0:	2c00      	cmp	r4, #0
 c0053e2:	bf0c      	ite	eq
 c0053e4:	2301      	moveq	r3, #1
 c0053e6:	2304      	movne	r3, #4
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c0053e8:	2c00      	cmp	r4, #0
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c0053ea:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c0053ec:	bf0c      	ite	eq
 c0053ee:	2300      	moveq	r3, #0
 c0053f0:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c0053f2:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_READ_CMD;
 c0053f4:	d136      	bne.n	c005464 <MX25LM51245G_ReadSTR+0xaa>
 c0053f6:	2d00      	cmp	r5, #0
 c0053f8:	bf0c      	ite	eq
 c0053fa:	230b      	moveq	r3, #11
 c0053fc:	230c      	movne	r3, #12
                                 : HAL_OSPI_ADDRESS_8_LINES;
 c0053fe:	2c00      	cmp	r4, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005400:	9302      	str	r3, [sp, #8]
                                 : HAL_OSPI_ADDRESS_8_LINES;
 c005402:	bf0c      	ite	eq
 c005404:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c005408:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c00540c:	2d00      	cmp	r5, #0
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE)
 c00540e:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c005410:	bf0c      	ite	eq
 c005412:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 c005416:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 c00541a:	9308      	str	r3, [sp, #32]
  s_command.Address            = ReadAddr;
 c00541c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c00541e:	2c00      	cmp	r4, #0
  s_command.Address            = ReadAddr;
 c005420:	9306      	str	r3, [sp, #24]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005422:	bf0c      	ite	eq
 c005424:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005428:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 c00542c:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
 c00542e:	bf0c      	ite	eq
 c005430:	2308      	moveq	r3, #8
 c005432:	2306      	movne	r3, #6
 c005434:	9311      	str	r3, [sp, #68]	; 0x44
  s_command.NbData             = Size;
 c005436:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005438:	f241 3288 	movw	r2, #5000	; 0x1388
 c00543c:	4669      	mov	r1, sp
 c00543e:	4630      	mov	r0, r6
  s_command.NbData             = Size;
 c005440:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005442:	f002 ff6b 	bl	c00831c <HAL_OSPI_Command>
 c005446:	2800      	cmp	r0, #0
 c005448:	d1c6      	bne.n	c0053d8 <MX25LM51245G_ReadSTR+0x1e>
  if (HAL_OSPI_Receive(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c00544a:	f241 3288 	movw	r2, #5000	; 0x1388
 c00544e:	4639      	mov	r1, r7
 c005450:	4630      	mov	r0, r6
 c005452:	f002 fff6 	bl	c008442 <HAL_OSPI_Receive>
 c005456:	3000      	adds	r0, #0
 c005458:	bf18      	it	ne
 c00545a:	2001      	movne	r0, #1
 c00545c:	4240      	negs	r0, r0
 c00545e:	e7bd      	b.n	c0053dc <MX25LM51245G_ReadSTR+0x22>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005460:	2304      	movs	r3, #4
 c005462:	e7c1      	b.n	c0053e8 <MX25LM51245G_ReadSTR+0x2e>
                                 : MX25LM51245G_OCTA_READ_CMD;
 c005464:	f64e 4313 	movw	r3, #60435	; 0xec13
 c005468:	e7c9      	b.n	c0053fe <MX25LM51245G_ReadSTR+0x44>

0c00546a <MX25LM51245G_ReadDTR>:
  * @param  Size Size of data to read
  * @note   Only OPI mode support DTR transfer rate
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_ReadDTR(OSPI_HandleTypeDef *Ctx, uint8_t *pData, uint32_t ReadAddr, uint32_t Size)
{
 c00546a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00546c:	b095      	sub	sp, #84	; 0x54
 c00546e:	4604      	mov	r4, r0
 c005470:	4617      	mov	r7, r2
 c005472:	460d      	mov	r5, r1
  OSPI_RegularCmdTypeDef s_command = {0};
 c005474:	2250      	movs	r2, #80	; 0x50
 c005476:	2100      	movs	r1, #0
 c005478:	4668      	mov	r0, sp
{
 c00547a:	461e      	mov	r6, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c00547c:	f008 fe05 	bl	c00e08a <memset>
#if defined (OCTOSPI_CR_MSEL)
  s_command.FlashSelect        = HAL_OSPI_FLASH_SELECT_IO_7_0;
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 c005480:	2304      	movs	r3, #4
  s_command.InstructionDtrMode = HAL_OSPI_INSTRUCTION_DTR_ENABLE;
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 c005482:	2108      	movs	r1, #8
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 c005484:	9303      	str	r3, [sp, #12]
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 c005486:	2310      	movs	r3, #16
 c005488:	e9cd 3104 	strd	r3, r1, [sp, #16]
  s_command.Instruction        = MX25LM51245G_OCTA_READ_DTR_CMD;
 c00548c:	f64e 6311 	movw	r3, #60945	; 0xee11
 c005490:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 c005492:	f44f 6380 	mov.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = HAL_OSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005496:	f44f 6e00 	mov.w	lr, #2048	; 0x800
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 c00549a:	9307      	str	r3, [sp, #28]
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c00549c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 c0054a0:	e9cd 3e08 	strd	r3, lr, [sp, #32]
  s_command.Address            = ReadAddr;
  s_command.AlternateBytesMode = HAL_OSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 c0054a4:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  s_command.DataDtrMode        = HAL_OSPI_DATA_DTR_ENABLE;
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
 c0054a8:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 c0054ac:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
 c0054ae:	2306      	movs	r3, #6
 c0054b0:	e9cd 1310 	strd	r1, r3, [sp, #64]	; 0x40
  s_command.NbData             = Size;
  s_command.DQSMode            = HAL_OSPI_DQS_ENABLE;
 c0054b4:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0054b8:	f241 3288 	movw	r2, #5000	; 0x1388
 c0054bc:	4669      	mov	r1, sp
 c0054be:	4620      	mov	r0, r4
  s_command.Address            = ReadAddr;
 c0054c0:	9706      	str	r7, [sp, #24]
  s_command.NbData             = Size;
 c0054c2:	960f      	str	r6, [sp, #60]	; 0x3c
  s_command.DQSMode            = HAL_OSPI_DQS_ENABLE;
 c0054c4:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0054c6:	f002 ff29 	bl	c00831c <HAL_OSPI_Command>
 c0054ca:	b958      	cbnz	r0, c0054e4 <MX25LM51245G_ReadDTR+0x7a>
  {
    return MX25LM51245G_ERROR;
  }

  /* Reception of the data */
  if (HAL_OSPI_Receive(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0054cc:	f241 3288 	movw	r2, #5000	; 0x1388
 c0054d0:	4629      	mov	r1, r5
 c0054d2:	4620      	mov	r0, r4
 c0054d4:	f002 ffb5 	bl	c008442 <HAL_OSPI_Receive>
 c0054d8:	3000      	adds	r0, #0
 c0054da:	bf18      	it	ne
 c0054dc:	2001      	movne	r0, #1
 c0054de:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c0054e0:	b015      	add	sp, #84	; 0x54
 c0054e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return MX25LM51245G_ERROR;
 c0054e4:	f04f 30ff 	mov.w	r0, #4294967295
 c0054e8:	e7fa      	b.n	c0054e0 <MX25LM51245G_ReadDTR+0x76>

0c0054ea <MX25LM51245G_PageProgram>:
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_PageProgram(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                 MX25LM51245G_AddressSize_t AddressSize, uint8_t *pData, uint32_t WriteAddr,
                                 uint32_t Size)
{
 c0054ea:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0054ec:	460c      	mov	r4, r1
 c0054ee:	b095      	sub	sp, #84	; 0x54
 c0054f0:	4606      	mov	r6, r0
 c0054f2:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c0054f4:	2100      	movs	r1, #0
 c0054f6:	2250      	movs	r2, #80	; 0x50
 c0054f8:	4668      	mov	r0, sp
{
 c0054fa:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c0054fc:	f008 fdc5 	bl	c00e08a <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 c005500:	2c01      	cmp	r4, #1
 c005502:	d105      	bne.n	c005510 <MX25LM51245G_PageProgram+0x26>
 c005504:	2d00      	cmp	r5, #0
 c005506:	d13f      	bne.n	c005588 <MX25LM51245G_PageProgram+0x9e>
  {
    return MX25LM51245G_ERROR;
 c005508:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c00550c:	b015      	add	sp, #84	; 0x54
 c00550e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005510:	2c00      	cmp	r4, #0
 c005512:	bf0c      	ite	eq
 c005514:	2301      	moveq	r3, #1
 c005516:	2304      	movne	r3, #4
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005518:	2c00      	cmp	r4, #0
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c00551a:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c00551c:	bf0c      	ite	eq
 c00551e:	2300      	moveq	r3, #0
 c005520:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005522:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c005524:	d132      	bne.n	c00558c <MX25LM51245G_PageProgram+0xa2>
 c005526:	2d00      	cmp	r5, #0
 c005528:	bf0c      	ite	eq
 c00552a:	2302      	moveq	r3, #2
 c00552c:	2312      	movne	r3, #18
                                 : HAL_OSPI_ADDRESS_8_LINES;
 c00552e:	2c00      	cmp	r4, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005530:	9302      	str	r3, [sp, #8]
                                 : HAL_OSPI_ADDRESS_8_LINES;
 c005532:	bf0c      	ite	eq
 c005534:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c005538:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c00553c:	2d00      	cmp	r5, #0
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE)
 c00553e:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c005540:	bf0c      	ite	eq
 c005542:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 c005546:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 c00554a:	9308      	str	r3, [sp, #32]
  s_command.Address            = WriteAddr;
 c00554c:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c00554e:	2c00      	cmp	r4, #0
  s_command.Address            = WriteAddr;
 c005550:	9306      	str	r3, [sp, #24]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005552:	bf0c      	ite	eq
 c005554:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005558:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 c00555c:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.NbData             = Size;
 c00555e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005560:	f241 3288 	movw	r2, #5000	; 0x1388
 c005564:	4669      	mov	r1, sp
 c005566:	4630      	mov	r0, r6
  s_command.NbData             = Size;
 c005568:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c00556a:	f002 fed7 	bl	c00831c <HAL_OSPI_Command>
 c00556e:	2800      	cmp	r0, #0
 c005570:	d1ca      	bne.n	c005508 <MX25LM51245G_PageProgram+0x1e>
  if (HAL_OSPI_Transmit(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005572:	f241 3288 	movw	r2, #5000	; 0x1388
 c005576:	4639      	mov	r1, r7
 c005578:	4630      	mov	r0, r6
 c00557a:	f002 ff1e 	bl	c0083ba <HAL_OSPI_Transmit>
 c00557e:	3000      	adds	r0, #0
 c005580:	bf18      	it	ne
 c005582:	2001      	movne	r0, #1
 c005584:	4240      	negs	r0, r0
 c005586:	e7c1      	b.n	c00550c <MX25LM51245G_PageProgram+0x22>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005588:	2304      	movs	r3, #4
 c00558a:	e7c5      	b.n	c005518 <MX25LM51245G_PageProgram+0x2e>
                                 : MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c00558c:	f241 23ed 	movw	r3, #4845	; 0x12ed
 c005590:	e7cd      	b.n	c00552e <MX25LM51245G_PageProgram+0x44>

0c005592 <MX25LM51245G_PageProgramDTR>:
  * @param  Size Size of data to write. Range 1 ~ MX25LM51245G_PAGE_SIZE
  * @note   Only OPI mode support DTR transfer rate
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_PageProgramDTR(OSPI_HandleTypeDef *Ctx, uint8_t *pData, uint32_t WriteAddr, uint32_t Size)
{
 c005592:	b5f0      	push	{r4, r5, r6, r7, lr}
 c005594:	b095      	sub	sp, #84	; 0x54
 c005596:	4604      	mov	r4, r0
 c005598:	4617      	mov	r7, r2
 c00559a:	460d      	mov	r5, r1
  OSPI_RegularCmdTypeDef s_command = {0};
 c00559c:	2250      	movs	r2, #80	; 0x50
 c00559e:	2100      	movs	r1, #0
 c0055a0:	4668      	mov	r0, sp
{
 c0055a2:	461e      	mov	r6, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c0055a4:	f008 fd71 	bl	c00e08a <memset>
#if defined (OCTOSPI_CR_MSEL)
  s_command.FlashSelect        = HAL_OSPI_FLASH_SELECT_IO_7_0;
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 c0055a8:	2304      	movs	r3, #4
  s_command.InstructionDtrMode = HAL_OSPI_INSTRUCTION_DTR_ENABLE;
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 c0055aa:	2108      	movs	r1, #8
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 c0055ac:	9303      	str	r3, [sp, #12]
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 c0055ae:	2310      	movs	r3, #16
 c0055b0:	e9cd 3104 	strd	r3, r1, [sp, #16]
  s_command.Instruction        = MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c0055b4:	f241 23ed 	movw	r3, #4845	; 0x12ed
 c0055b8:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 c0055ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = HAL_OSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c0055be:	f44f 6e00 	mov.w	lr, #2048	; 0x800
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 c0055c2:	9307      	str	r3, [sp, #28]
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c0055c4:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 c0055c8:	e9cd 3e08 	strd	r3, lr, [sp, #32]
  s_command.Address            = WriteAddr;
  s_command.AlternateBytesMode = HAL_OSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 c0055cc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 c0055d0:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DataDtrMode        = HAL_OSPI_DATA_DTR_ENABLE;
 c0055d2:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  s_command.NbData             = Size;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Configure the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0055d6:	f241 3288 	movw	r2, #5000	; 0x1388
 c0055da:	4669      	mov	r1, sp
 c0055dc:	4620      	mov	r0, r4
  s_command.Address            = WriteAddr;
 c0055de:	9706      	str	r7, [sp, #24]
  s_command.NbData             = Size;
 c0055e0:	e9cd 630f 	strd	r6, r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0055e4:	f002 fe9a 	bl	c00831c <HAL_OSPI_Command>
 c0055e8:	b958      	cbnz	r0, c005602 <MX25LM51245G_PageProgramDTR+0x70>
  {
    return MX25LM51245G_ERROR;
  }

  /* Transmission of the data */
  if (HAL_OSPI_Transmit(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0055ea:	f241 3288 	movw	r2, #5000	; 0x1388
 c0055ee:	4629      	mov	r1, r5
 c0055f0:	4620      	mov	r0, r4
 c0055f2:	f002 fee2 	bl	c0083ba <HAL_OSPI_Transmit>
 c0055f6:	3000      	adds	r0, #0
 c0055f8:	bf18      	it	ne
 c0055fa:	2001      	movne	r0, #1
 c0055fc:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c0055fe:	b015      	add	sp, #84	; 0x54
 c005600:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return MX25LM51245G_ERROR;
 c005602:	f04f 30ff 	mov.w	r0, #4294967295
 c005606:	e7fa      	b.n	c0055fe <MX25LM51245G_PageProgramDTR+0x6c>

0c005608 <MX25LM51245G_BlockErase>:
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_BlockErase(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate,
                                MX25LM51245G_AddressSize_t AddressSize, uint32_t BlockAddress,
                                MX25LM51245G_Erase_t BlockSize)
{
 c005608:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00560c:	460d      	mov	r5, r1
 c00560e:	b094      	sub	sp, #80	; 0x50
 c005610:	4680      	mov	r8, r0
 c005612:	4616      	mov	r6, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c005614:	2100      	movs	r1, #0
 c005616:	2250      	movs	r2, #80	; 0x50
 c005618:	4668      	mov	r0, sp
{
 c00561a:	461c      	mov	r4, r3
 c00561c:	f89d 706c 	ldrb.w	r7, [sp, #108]	; 0x6c
  OSPI_RegularCmdTypeDef s_command = {0};
 c005620:	f008 fd33 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005624:	2d00      	cmp	r5, #0
 c005626:	d138      	bne.n	c00569a <MX25LM51245G_BlockErase+0x92>
 c005628:	2e01      	cmp	r6, #1
 c00562a:	d047      	beq.n	c0056bc <MX25LM51245G_BlockErase+0xb4>
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif  /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_1_LINE
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c00562c:	2301      	movs	r3, #1
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c00562e:	2e01      	cmp	r6, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005630:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005632:	bf0c      	ite	eq
 c005634:	2308      	moveq	r3, #8
 c005636:	2300      	movne	r3, #0
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_8_BITS
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005638:	2d00      	cmp	r5, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c00563a:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c00563c:	bf0c      	ite	eq
 c00563e:	2300      	moveq	r3, #0
 c005640:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005642:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005644:	bf0c      	ite	eq
 c005646:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c00564a:	f44f 6380 	movne.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_ADDRESS_DTR_ENABLE
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c00564e:	2e01      	cmp	r6, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005650:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005652:	bf0c      	ite	eq
 c005654:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c005658:	2300      	movne	r3, #0
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
                                 ? HAL_OSPI_ADDRESS_24_BITS
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c00565a:	2c00      	cmp	r4, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 c00565c:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c00565e:	bf0c      	ite	eq
 c005660:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 c005664:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 c005668:	9308      	str	r3, [sp, #32]
  s_command.Address            = BlockAddress;
 c00566a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  s_command.DataMode           = HAL_OSPI_DATA_NONE;
  s_command.DummyCycles        = 0U;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  switch (Mode)
 c00566c:	2d01      	cmp	r5, #1
  s_command.Address            = BlockAddress;
 c00566e:	9306      	str	r3, [sp, #24]
  switch (Mode)
 c005670:	d118      	bne.n	c0056a4 <MX25LM51245G_BlockErase+0x9c>
  {
    case MX25LM51245G_OPI_MODE :
      if (BlockSize == MX25LM51245G_ERASE_64K)
 c005672:	2f01      	cmp	r7, #1
      {
        s_command.Instruction = MX25LM51245G_OCTA_SECTOR_ERASE_64K_CMD;
 c005674:	bf0c      	ite	eq
 c005676:	f64d 4323 	movweq	r3, #56355	; 0xdc23
      }
      else
      {
        s_command.Instruction = MX25LM51245G_OCTA_SUBSECTOR_ERASE_4K_CMD;
 c00567a:	f242 13de 	movwne	r3, #8670	; 0x21de
      }
      break;
  }

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c00567e:	f241 3288 	movw	r2, #5000	; 0x1388
 c005682:	4669      	mov	r1, sp
 c005684:	4640      	mov	r0, r8
        s_command.Instruction = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 c005686:	9302      	str	r3, [sp, #8]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005688:	f002 fe48 	bl	c00831c <HAL_OSPI_Command>
 c00568c:	3000      	adds	r0, #0
 c00568e:	bf18      	it	ne
 c005690:	2001      	movne	r0, #1
 c005692:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005694:	b014      	add	sp, #80	; 0x50
 c005696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 c00569a:	2d01      	cmp	r5, #1
 c00569c:	d100      	bne.n	c0056a0 <MX25LM51245G_BlockErase+0x98>
 c00569e:	b16c      	cbz	r4, c0056bc <MX25LM51245G_BlockErase+0xb4>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c0056a0:	2304      	movs	r3, #4
 c0056a2:	e7c4      	b.n	c00562e <MX25LM51245G_BlockErase+0x26>
      if (BlockSize == MX25LM51245G_ERASE_64K)
 c0056a4:	2f01      	cmp	r7, #1
 c0056a6:	d104      	bne.n	c0056b2 <MX25LM51245G_BlockErase+0xaa>
                                : MX25LM51245G_4_BYTE_SECTOR_ERASE_64K_CMD;
 c0056a8:	2c00      	cmp	r4, #0
 c0056aa:	bf0c      	ite	eq
 c0056ac:	23d8      	moveq	r3, #216	; 0xd8
 c0056ae:	23dc      	movne	r3, #220	; 0xdc
 c0056b0:	e7e5      	b.n	c00567e <MX25LM51245G_BlockErase+0x76>
                                : MX25LM51245G_4_BYTE_SUBSECTOR_ERASE_4K_CMD;
 c0056b2:	2c00      	cmp	r4, #0
 c0056b4:	bf0c      	ite	eq
 c0056b6:	2320      	moveq	r3, #32
 c0056b8:	2321      	movne	r3, #33	; 0x21
 c0056ba:	e7e0      	b.n	c00567e <MX25LM51245G_BlockErase+0x76>
    return MX25LM51245G_ERROR;
 c0056bc:	f04f 30ff 	mov.w	r0, #4294967295
 c0056c0:	e7e8      	b.n	c005694 <MX25LM51245G_BlockErase+0x8c>

0c0056c2 <MX25LM51245G_EnableSTRMemoryMappedMode>:
  * @param  AddressSize Address size
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_EnableSTRMemoryMappedMode(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                               MX25LM51245G_AddressSize_t AddressSize)
{
 c0056c2:	b570      	push	{r4, r5, r6, lr}
 c0056c4:	b096      	sub	sp, #88	; 0x58
 c0056c6:	460c      	mov	r4, r1
 c0056c8:	4606      	mov	r6, r0
 c0056ca:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef      s_command = {0};
 c0056cc:	2100      	movs	r1, #0
 c0056ce:	2250      	movs	r2, #80	; 0x50
 c0056d0:	a802      	add	r0, sp, #8
 c0056d2:	f008 fcda 	bl	c00e08a <memset>
  OSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
 c0056d6:	2300      	movs	r3, #0

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 c0056d8:	2c01      	cmp	r4, #1
  OSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
 c0056da:	e9cd 3300 	strd	r3, r3, [sp]
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 c0056de:	d104      	bne.n	c0056ea <MX25LM51245G_EnableSTRMemoryMappedMode+0x28>
 c0056e0:	b91d      	cbnz	r5, c0056ea <MX25LM51245G_EnableSTRMemoryMappedMode+0x28>
  {
    return MX25LM51245G_ERROR;
 c0056e2:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c0056e6:	b016      	add	sp, #88	; 0x58
 c0056e8:	bd70      	pop	{r4, r5, r6, pc}
  s_command.OperationType      = HAL_OSPI_OPTYPE_READ_CFG;
 c0056ea:	2301      	movs	r3, #1
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c0056ec:	2c00      	cmp	r4, #0
  s_command.OperationType      = HAL_OSPI_OPTYPE_READ_CFG;
 c0056ee:	9302      	str	r3, [sp, #8]
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c0056f0:	bf18      	it	ne
 c0056f2:	2304      	movne	r3, #4
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c0056f4:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c0056f6:	bf0c      	ite	eq
 c0056f8:	2300      	moveq	r3, #0
 c0056fa:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c0056fc:	9306      	str	r3, [sp, #24]
                                 : MX25LM51245G_OCTA_READ_CMD;
 c0056fe:	d140      	bne.n	c005782 <MX25LM51245G_EnableSTRMemoryMappedMode+0xc0>
 c005700:	2d00      	cmp	r5, #0
 c005702:	bf0c      	ite	eq
 c005704:	230b      	moveq	r3, #11
 c005706:	230c      	movne	r3, #12
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005708:	2c00      	cmp	r4, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c00570a:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c00570c:	bf0c      	ite	eq
 c00570e:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c005712:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c005716:	2d00      	cmp	r5, #0
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005718:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_ADDRESS_32_BITS;
 c00571a:	bf0c      	ite	eq
 c00571c:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 c005720:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005724:	2c00      	cmp	r4, #0
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 c005726:	930a      	str	r3, [sp, #40]	; 0x28
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005728:	bf0c      	ite	eq
 c00572a:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c00572e:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 c005732:	9310      	str	r3, [sp, #64]	; 0x40
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
 c005734:	bf0c      	ite	eq
 c005736:	2308      	moveq	r3, #8
 c005738:	2306      	movne	r3, #6
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c00573a:	f241 3288 	movw	r2, #5000	; 0x1388
 c00573e:	a902      	add	r1, sp, #8
 c005740:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
 c005742:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005744:	f002 fdea 	bl	c00831c <HAL_OSPI_Command>
 c005748:	2800      	cmp	r0, #0
 c00574a:	d1ca      	bne.n	c0056e2 <MX25LM51245G_EnableSTRMemoryMappedMode+0x20>
  s_command.OperationType      = HAL_OSPI_OPTYPE_WRITE_CFG;
 c00574c:	2302      	movs	r3, #2
 c00574e:	9302      	str	r3, [sp, #8]
                                 : MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c005750:	b9d4      	cbnz	r4, c005788 <MX25LM51245G_EnableSTRMemoryMappedMode+0xc6>
 c005752:	2d00      	cmp	r5, #0
 c005754:	bf18      	it	ne
 c005756:	2312      	movne	r3, #18
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005758:	9304      	str	r3, [sp, #16]
  s_command.DummyCycles        = 0U;
 c00575a:	2300      	movs	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c00575c:	f241 3288 	movw	r2, #5000	; 0x1388
 c005760:	a902      	add	r1, sp, #8
 c005762:	4630      	mov	r0, r6
  s_command.DummyCycles        = 0U;
 c005764:	9313      	str	r3, [sp, #76]	; 0x4c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005766:	f002 fdd9 	bl	c00831c <HAL_OSPI_Command>
 c00576a:	2800      	cmp	r0, #0
 c00576c:	d1b9      	bne.n	c0056e2 <MX25LM51245G_EnableSTRMemoryMappedMode+0x20>
  s_mem_mapped_cfg.TimeOutActivation = HAL_OSPI_TIMEOUT_COUNTER_DISABLE;
 c00576e:	9000      	str	r0, [sp, #0]
  if (HAL_OSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
 c005770:	4669      	mov	r1, sp
 c005772:	4630      	mov	r0, r6
 c005774:	f002 ff0d 	bl	c008592 <HAL_OSPI_MemoryMapped>
 c005778:	3000      	adds	r0, #0
 c00577a:	bf18      	it	ne
 c00577c:	2001      	movne	r0, #1
 c00577e:	4240      	negs	r0, r0
 c005780:	e7b1      	b.n	c0056e6 <MX25LM51245G_EnableSTRMemoryMappedMode+0x24>
                                 : MX25LM51245G_OCTA_READ_CMD;
 c005782:	f64e 4313 	movw	r3, #60435	; 0xec13
 c005786:	e7bf      	b.n	c005708 <MX25LM51245G_EnableSTRMemoryMappedMode+0x46>
                                 : MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c005788:	f241 23ed 	movw	r3, #4845	; 0x12ed
 c00578c:	e7e4      	b.n	c005758 <MX25LM51245G_EnableSTRMemoryMappedMode+0x96>

0c00578e <MX25LM51245G_EnableDTRMemoryMappedMode>:
  * @param  AddressSize Address size
  * @note   Only OPI mode support DTR transfer rate
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_EnableDTRMemoryMappedMode(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode)
{
 c00578e:	b510      	push	{r4, lr}
 c005790:	b096      	sub	sp, #88	; 0x58
 c005792:	4604      	mov	r4, r0
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Mode);

  OSPI_RegularCmdTypeDef      s_command = {0};
 c005794:	224c      	movs	r2, #76	; 0x4c
 c005796:	2100      	movs	r1, #0
 c005798:	a803      	add	r0, sp, #12
 c00579a:	f008 fc76 	bl	c00e08a <memset>
  OSPI_MemoryMappedTypeDef s_mem_mapped_cfg = {0};
 c00579e:	2300      	movs	r3, #0
 c0057a0:	e9cd 3300 	strd	r3, r3, [sp]

  /* Initialize the read command */
  s_command.OperationType      = HAL_OSPI_OPTYPE_READ_CFG;
 c0057a4:	2301      	movs	r3, #1
 c0057a6:	9302      	str	r3, [sp, #8]
#if defined (OCTOSPI_CR_MSEL)
  s_command.FlashSelect        = HAL_OSPI_FLASH_SELECT_IO_7_0;
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif  /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 c0057a8:	2304      	movs	r3, #4
  s_command.InstructionDtrMode = HAL_OSPI_INSTRUCTION_DTR_ENABLE;
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 c0057aa:	f04f 0c08 	mov.w	ip, #8
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 c0057ae:	9305      	str	r3, [sp, #20]
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 c0057b0:	2310      	movs	r3, #16
 c0057b2:	e9cd 3c06 	strd	r3, ip, [sp, #24]
  s_command.Instruction        = MX25LM51245G_OCTA_READ_DTR_CMD;
 c0057b6:	f64e 6311 	movw	r3, #60945	; 0xee11
 c0057ba:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 c0057bc:	f44f 6380 	mov.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = HAL_OSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c0057c0:	f44f 6100 	mov.w	r1, #2048	; 0x800
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 c0057c4:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c0057c6:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 c0057ca:	e9cd 310a 	strd	r3, r1, [sp, #40]	; 0x28
  s_command.AlternateBytesMode = HAL_OSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 c0057ce:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  s_command.DataDtrMode        = HAL_OSPI_DATA_DTR_ENABLE;
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
 c0057d2:	f04f 6c00 	mov.w	ip, #134217728	; 0x8000000
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 c0057d6:	9310      	str	r3, [sp, #64]	; 0x40
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
 c0057d8:	2306      	movs	r3, #6
 c0057da:	e9cd c312 	strd	ip, r3, [sp, #72]	; 0x48
  s_command.DQSMode            = HAL_OSPI_DQS_ENABLE;
 c0057de:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0057e2:	f241 3288 	movw	r2, #5000	; 0x1388
 c0057e6:	a902      	add	r1, sp, #8
 c0057e8:	4620      	mov	r0, r4
  s_command.DQSMode            = HAL_OSPI_DQS_ENABLE;
 c0057ea:	9314      	str	r3, [sp, #80]	; 0x50
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0057ec:	f002 fd96 	bl	c00831c <HAL_OSPI_Command>
 c0057f0:	b118      	cbz	r0, c0057fa <MX25LM51245G_EnableDTRMemoryMappedMode+0x6c>
  {
    return MX25LM51245G_ERROR;
 c0057f2:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c0057f6:	b016      	add	sp, #88	; 0x58
 c0057f8:	bd10      	pop	{r4, pc}
  s_command.OperationType = HAL_OSPI_OPTYPE_WRITE_CFG;
 c0057fa:	2302      	movs	r3, #2
 c0057fc:	9302      	str	r3, [sp, #8]
  s_command.Instruction   = MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c0057fe:	f241 23ed 	movw	r3, #4845	; 0x12ed
  s_command.DQSMode       = HAL_OSPI_DQS_DISABLE;
 c005802:	e9cd 0013 	strd	r0, r0, [sp, #76]	; 0x4c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005806:	f241 3288 	movw	r2, #5000	; 0x1388
 c00580a:	a902      	add	r1, sp, #8
 c00580c:	4620      	mov	r0, r4
  s_command.Instruction   = MX25LM51245G_OCTA_PAGE_PROG_CMD;
 c00580e:	9304      	str	r3, [sp, #16]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005810:	f002 fd84 	bl	c00831c <HAL_OSPI_Command>
 c005814:	2800      	cmp	r0, #0
 c005816:	d1ec      	bne.n	c0057f2 <MX25LM51245G_EnableDTRMemoryMappedMode+0x64>
  s_mem_mapped_cfg.TimeOutActivation = HAL_OSPI_TIMEOUT_COUNTER_DISABLE;
 c005818:	9000      	str	r0, [sp, #0]
  if (HAL_OSPI_MemoryMapped(Ctx, &s_mem_mapped_cfg) != HAL_OK)
 c00581a:	4669      	mov	r1, sp
 c00581c:	4620      	mov	r0, r4
 c00581e:	f002 feb8 	bl	c008592 <HAL_OSPI_MemoryMapped>
 c005822:	3000      	adds	r0, #0
 c005824:	bf18      	it	ne
 c005826:	2001      	movne	r0, #1
 c005828:	4240      	negs	r0, r0
 c00582a:	e7e4      	b.n	c0057f6 <MX25LM51245G_EnableDTRMemoryMappedMode+0x68>

0c00582c <MX25LM51245G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25LM51245G_WriteEnable(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate)
{
 c00582c:	b570      	push	{r4, r5, r6, lr}
 c00582e:	460c      	mov	r4, r1
 c005830:	b09a      	sub	sp, #104	; 0x68
  OSPI_RegularCmdTypeDef     s_command = {0};
 c005832:	2100      	movs	r1, #0
{
 c005834:	4606      	mov	r6, r0
 c005836:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef     s_command = {0};
 c005838:	a806      	add	r0, sp, #24
 c00583a:	2250      	movs	r2, #80	; 0x50
 c00583c:	f008 fc25 	bl	c00e08a <memset>
  OSPI_AutoPollingTypeDef s_config = {0};
 c005840:	2214      	movs	r2, #20
 c005842:	2100      	movs	r1, #0
 c005844:	a801      	add	r0, sp, #4
 c005846:	f008 fc20 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c00584a:	b92c      	cbnz	r4, c005858 <MX25LM51245G_WriteEnable+0x2c>
 c00584c:	2d01      	cmp	r5, #1
 c00584e:	d16a      	bne.n	c005926 <MX25LM51245G_WriteEnable+0xfa>
  {
    return MX25LM51245G_ERROR;
 c005850:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005854:	b01a      	add	sp, #104	; 0x68
 c005856:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005858:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c00585a:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c00585c:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c00585e:	bf0c      	ite	eq
 c005860:	2308      	moveq	r3, #8
 c005862:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005864:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005866:	930b      	str	r3, [sp, #44]	; 0x2c
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005868:	bf0c      	ite	eq
 c00586a:	2300      	moveq	r3, #0
 c00586c:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c00586e:	930a      	str	r3, [sp, #40]	; 0x28
                                 : MX25LM51245G_OCTA_WRITE_ENABLE_CMD;
 c005870:	f240 63f9 	movw	r3, #1785	; 0x6f9
 c005874:	bf08      	it	eq
 c005876:	2306      	moveq	r3, #6
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005878:	f241 3288 	movw	r2, #5000	; 0x1388
 c00587c:	a906      	add	r1, sp, #24
 c00587e:	4630      	mov	r0, r6
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005880:	9308      	str	r3, [sp, #32]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005882:	f002 fd4b 	bl	c00831c <HAL_OSPI_Command>
 c005886:	2800      	cmp	r0, #0
 c005888:	d1e2      	bne.n	c005850 <MX25LM51245G_WriteEnable+0x24>
                             : MX25LM51245G_OCTA_READ_STATUS_REG_CMD;
 c00588a:	2c00      	cmp	r4, #0
 c00588c:	f240 53fa 	movw	r3, #1530	; 0x5fa
 c005890:	bf08      	it	eq
 c005892:	2305      	moveq	r3, #5
  s_command.Instruction    = (Mode == MX25LM51245G_SPI_MODE)
 c005894:	9308      	str	r3, [sp, #32]
  s_command.AddressMode    = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c005896:	bf0c      	ite	eq
 c005898:	2300      	moveq	r3, #0
 c00589a:	f44f 6380 	movne.w	r3, #1024	; 0x400
                             : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c00589e:	2d01      	cmp	r5, #1
  s_command.AddressMode    = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c0058a0:	930d      	str	r3, [sp, #52]	; 0x34
                             : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c0058a2:	bf0c      	ite	eq
 c0058a4:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c0058a8:	2300      	movne	r3, #0
  s_command.AddressDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c0058aa:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.AddressSize    = HAL_OSPI_ADDRESS_32_BITS;
 c0058ac:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode       = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c0058b0:	2c00      	cmp	r4, #0
  s_command.AddressSize    = HAL_OSPI_ADDRESS_32_BITS;
 c0058b2:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DataMode       = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c0058b4:	bf0c      	ite	eq
 c0058b6:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c0058ba:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
  s_command.DataDtrMode    = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DATA_DTR_ENABLE : HAL_OSPI_DATA_DTR_DISABLE;
 c0058be:	2d01      	cmp	r5, #1
  s_command.DataMode       = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c0058c0:	9314      	str	r3, [sp, #80]	; 0x50
  s_command.DataDtrMode    = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DATA_DTR_ENABLE : HAL_OSPI_DATA_DTR_DISABLE;
 c0058c2:	bf0c      	ite	eq
 c0058c4:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 c0058c8:	2300      	movne	r3, #0
  s_command.Address        = 0U;
 c0058ca:	900c      	str	r0, [sp, #48]	; 0x30
  s_command.DataDtrMode    = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DATA_DTR_ENABLE : HAL_OSPI_DATA_DTR_DISABLE;
 c0058cc:	9316      	str	r3, [sp, #88]	; 0x58
                             : ((Rate == MX25LM51245G_DTR_TRANSFER)
 c0058ce:	b11c      	cbz	r4, c0058d8 <MX25LM51245G_WriteEnable+0xac>
 c0058d0:	2d01      	cmp	r5, #1
 c0058d2:	bf0c      	ite	eq
 c0058d4:	2405      	moveq	r4, #5
 c0058d6:	2404      	movne	r4, #4
  s_command.NbData         = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 c0058d8:	2d01      	cmp	r5, #1
 c0058da:	bf0c      	ite	eq
 c0058dc:	2302      	moveq	r3, #2
 c0058de:	2301      	movne	r3, #1
 c0058e0:	9315      	str	r3, [sp, #84]	; 0x54
  s_command.DQSMode        = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c0058e2:	bf0c      	ite	eq
 c0058e4:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 c0058e8:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0058ea:	f241 3288 	movw	r2, #5000	; 0x1388
 c0058ee:	a906      	add	r1, sp, #24
 c0058f0:	4630      	mov	r0, r6
  s_command.DummyCycles    = (Mode == MX25LM51245G_SPI_MODE)
 c0058f2:	9417      	str	r4, [sp, #92]	; 0x5c
  s_command.DQSMode        = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c0058f4:	9318      	str	r3, [sp, #96]	; 0x60
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0058f6:	f002 fd11 	bl	c00831c <HAL_OSPI_Command>
 c0058fa:	2800      	cmp	r0, #0
 c0058fc:	d1a8      	bne.n	c005850 <MX25LM51245G_WriteEnable+0x24>
  s_config.Match           = 2U;
 c0058fe:	2302      	movs	r3, #2
  s_config.AutomaticStop   = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 c005900:	2210      	movs	r2, #16
  s_config.Mask            = 2U;
 c005902:	e9cd 3301 	strd	r3, r3, [sp, #4]
  s_config.AutomaticStop   = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 c005906:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  s_config.MatchMode       = HAL_OSPI_MATCH_MODE_AND;
 c00590a:	9003      	str	r0, [sp, #12]
  s_config.AutomaticStop   = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 c00590c:	e9cd 3204 	strd	r3, r2, [sp, #16]
  if (HAL_OSPI_AutoPolling(Ctx, &s_config, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005910:	a901      	add	r1, sp, #4
 c005912:	f241 3288 	movw	r2, #5000	; 0x1388
 c005916:	4630      	mov	r0, r6
 c005918:	f002 fde9 	bl	c0084ee <HAL_OSPI_AutoPolling>
 c00591c:	3000      	adds	r0, #0
 c00591e:	bf18      	it	ne
 c005920:	2001      	movne	r0, #1
 c005922:	4240      	negs	r0, r0
 c005924:	e796      	b.n	c005854 <MX25LM51245G_WriteEnable+0x28>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005926:	2301      	movs	r3, #1
 c005928:	e797      	b.n	c00585a <MX25LM51245G_WriteEnable+0x2e>

0c00592a <MX25LM51245G_ReadStatusRegister>:
  * @param  Value Status register value pointer
  * @retval error status
  */
int32_t MX25LM51245G_ReadStatusRegister(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                        MX25LM51245G_Transfer_t Rate, uint8_t *Value)
{
 c00592a:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00592c:	460c      	mov	r4, r1
 c00592e:	b095      	sub	sp, #84	; 0x54
 c005930:	4606      	mov	r6, r0
 c005932:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c005934:	2100      	movs	r1, #0
 c005936:	2250      	movs	r2, #80	; 0x50
 c005938:	4668      	mov	r0, sp
{
 c00593a:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c00593c:	f008 fba5 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005940:	b92c      	cbnz	r4, c00594e <MX25LM51245G_ReadStatusRegister+0x24>
 c005942:	2d01      	cmp	r5, #1
 c005944:	d152      	bne.n	c0059ec <MX25LM51245G_ReadStatusRegister+0xc2>
  {
    return MX25LM51245G_ERROR;
 c005946:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c00594a:	b015      	add	sp, #84	; 0x54
 c00594c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c00594e:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005950:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005952:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005954:	bf0c      	ite	eq
 c005956:	2308      	moveq	r3, #8
 c005958:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c00595a:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c00595c:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c00595e:	bf0c      	ite	eq
 c005960:	2300      	moveq	r3, #0
 c005962:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005964:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_READ_STATUS_REG_CMD;
 c005966:	f240 53fa 	movw	r3, #1530	; 0x5fa
 c00596a:	bf08      	it	eq
 c00596c:	2305      	moveq	r3, #5
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c00596e:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c005970:	bf0c      	ite	eq
 c005972:	2300      	moveq	r3, #0
 c005974:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005978:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c00597a:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c00597c:	bf0c      	ite	eq
 c00597e:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c005982:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005984:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005986:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c00598a:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c00598c:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c00598e:	bf0c      	ite	eq
 c005990:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005994:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005998:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c00599a:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c00599c:	bf0c      	ite	eq
 c00599e:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 c0059a2:	2300      	movne	r3, #0
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 c0059a4:	9310      	str	r3, [sp, #64]	; 0x40
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 c0059a6:	b11c      	cbz	r4, c0059b0 <MX25LM51245G_ReadStatusRegister+0x86>
 c0059a8:	2d01      	cmp	r5, #1
 c0059aa:	bf0c      	ite	eq
 c0059ac:	2405      	moveq	r4, #5
 c0059ae:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 c0059b0:	2d01      	cmp	r5, #1
 c0059b2:	bf0c      	ite	eq
 c0059b4:	2302      	moveq	r3, #2
 c0059b6:	2301      	movne	r3, #1
 c0059b8:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c0059ba:	bf0c      	ite	eq
 c0059bc:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 c0059c0:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0059c2:	f241 3288 	movw	r2, #5000	; 0x1388
 c0059c6:	4669      	mov	r1, sp
 c0059c8:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 c0059ca:	9411      	str	r4, [sp, #68]	; 0x44
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c0059cc:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0059ce:	f002 fca5 	bl	c00831c <HAL_OSPI_Command>
 c0059d2:	2800      	cmp	r0, #0
 c0059d4:	d1b7      	bne.n	c005946 <MX25LM51245G_ReadStatusRegister+0x1c>
  if (HAL_OSPI_Receive(Ctx, Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c0059d6:	f241 3288 	movw	r2, #5000	; 0x1388
 c0059da:	4639      	mov	r1, r7
 c0059dc:	4630      	mov	r0, r6
 c0059de:	f002 fd30 	bl	c008442 <HAL_OSPI_Receive>
 c0059e2:	3000      	adds	r0, #0
 c0059e4:	bf18      	it	ne
 c0059e6:	2001      	movne	r0, #1
 c0059e8:	4240      	negs	r0, r0
 c0059ea:	e7ae      	b.n	c00594a <MX25LM51245G_ReadStatusRegister+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c0059ec:	2301      	movs	r3, #1
 c0059ee:	e7af      	b.n	c005950 <MX25LM51245G_ReadStatusRegister+0x26>

0c0059f0 <MX25LM51245G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX25LM51245G_WriteCfg2Register(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                       MX25LM51245G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
 c0059f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 c0059f2:	460d      	mov	r5, r1
 c0059f4:	b095      	sub	sp, #84	; 0x54
 c0059f6:	4606      	mov	r6, r0
 c0059f8:	4614      	mov	r4, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c0059fa:	2100      	movs	r1, #0
 c0059fc:	2250      	movs	r2, #80	; 0x50
 c0059fe:	4668      	mov	r0, sp
{
 c005a00:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c005a02:	f008 fb42 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005a06:	b92d      	cbnz	r5, c005a14 <MX25LM51245G_WriteCfg2Register+0x24>
 c005a08:	2c01      	cmp	r4, #1
 c005a0a:	d14a      	bne.n	c005aa2 <MX25LM51245G_WriteCfg2Register+0xb2>
  {
    return MX25LM51245G_ERROR;
 c005a0c:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005a10:	b015      	add	sp, #84	; 0x54
 c005a12:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005a14:	2204      	movs	r2, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005a16:	2c01      	cmp	r4, #1
 c005a18:	bf0c      	ite	eq
 c005a1a:	2308      	moveq	r3, #8
 c005a1c:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005a1e:	2d00      	cmp	r5, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005a20:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005a22:	bf0c      	ite	eq
 c005a24:	2300      	moveq	r3, #0
 c005a26:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005a28:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005a2a:	bf0c      	ite	eq
 c005a2c:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c005a30:	f44f 6380 	movne.w	r3, #1024	; 0x400
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005a34:	9203      	str	r2, [sp, #12]
                                 : MX25LM51245G_OCTA_WRITE_CFG_REG2_CMD;
 c005a36:	f247 228d 	movw	r2, #29325	; 0x728d
 c005a3a:	bf08      	it	eq
 c005a3c:	2272      	moveq	r2, #114	; 0x72
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005a3e:	2c01      	cmp	r4, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005a40:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005a42:	bf0c      	ite	eq
 c005a44:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c005a48:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005a4a:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005a4c:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005a50:	2d00      	cmp	r5, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005a52:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005a54:	bf0c      	ite	eq
 c005a56:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005a5a:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005a5e:	2c01      	cmp	r4, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005a60:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005a62:	bf0c      	ite	eq
 c005a64:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 c005a68:	2300      	movne	r3, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005a6a:	9202      	str	r2, [sp, #8]
  s_command.Address            = WriteAddr;
 c005a6c:	9706      	str	r7, [sp, #24]
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005a6e:	9310      	str	r3, [sp, #64]	; 0x40
  s_command.NbData             = (Mode == MX25LM51245G_SPI_MODE) ? 1U : ((Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U);
 c005a70:	b1cd      	cbz	r5, c005aa6 <MX25LM51245G_WriteCfg2Register+0xb6>
 c005a72:	2c01      	cmp	r4, #1
 c005a74:	bf14      	ite	ne
 c005a76:	2301      	movne	r3, #1
 c005a78:	2302      	moveq	r3, #2
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005a7a:	f241 3288 	movw	r2, #5000	; 0x1388
 c005a7e:	4669      	mov	r1, sp
 c005a80:	4630      	mov	r0, r6
  s_command.NbData             = (Mode == MX25LM51245G_SPI_MODE) ? 1U : ((Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U);
 c005a82:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005a84:	f002 fc4a 	bl	c00831c <HAL_OSPI_Command>
 c005a88:	2800      	cmp	r0, #0
 c005a8a:	d1bf      	bne.n	c005a0c <MX25LM51245G_WriteCfg2Register+0x1c>
  if (HAL_OSPI_Transmit(Ctx, &Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005a8c:	f241 3288 	movw	r2, #5000	; 0x1388
 c005a90:	a91a      	add	r1, sp, #104	; 0x68
 c005a92:	4630      	mov	r0, r6
 c005a94:	f002 fc91 	bl	c0083ba <HAL_OSPI_Transmit>
 c005a98:	3000      	adds	r0, #0
 c005a9a:	bf18      	it	ne
 c005a9c:	2001      	movne	r0, #1
 c005a9e:	4240      	negs	r0, r0
 c005aa0:	e7b6      	b.n	c005a10 <MX25LM51245G_WriteCfg2Register+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005aa2:	2201      	movs	r2, #1
 c005aa4:	e7b7      	b.n	c005a16 <MX25LM51245G_WriteCfg2Register+0x26>
  s_command.NbData             = (Mode == MX25LM51245G_SPI_MODE) ? 1U : ((Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U);
 c005aa6:	2301      	movs	r3, #1
 c005aa8:	e7e7      	b.n	c005a7a <MX25LM51245G_WriteCfg2Register+0x8a>

0c005aaa <MX25LM51245G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX25LM51245G_ReadCfg2Register(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                      MX25LM51245G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
 c005aaa:	b5f0      	push	{r4, r5, r6, r7, lr}
 c005aac:	460c      	mov	r4, r1
 c005aae:	b095      	sub	sp, #84	; 0x54
 c005ab0:	4606      	mov	r6, r0
 c005ab2:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c005ab4:	2100      	movs	r1, #0
 c005ab6:	2250      	movs	r2, #80	; 0x50
 c005ab8:	4668      	mov	r0, sp
{
 c005aba:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c005abc:	f008 fae5 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005ac0:	b92c      	cbnz	r4, c005ace <MX25LM51245G_ReadCfg2Register+0x24>
 c005ac2:	2d01      	cmp	r5, #1
 c005ac4:	d154      	bne.n	c005b70 <MX25LM51245G_ReadCfg2Register+0xc6>
  {
    return MX25LM51245G_ERROR;
 c005ac6:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005aca:	b015      	add	sp, #84	; 0x54
 c005acc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005ace:	2204      	movs	r2, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005ad0:	2d01      	cmp	r5, #1
 c005ad2:	bf0c      	ite	eq
 c005ad4:	2308      	moveq	r3, #8
 c005ad6:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005ad8:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005ada:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005adc:	bf0c      	ite	eq
 c005ade:	2300      	moveq	r3, #0
 c005ae0:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005ae2:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005ae4:	bf0c      	ite	eq
 c005ae6:	f44f 7380 	moveq.w	r3, #256	; 0x100
 c005aea:	f44f 6380 	movne.w	r3, #1024	; 0x400
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005aee:	9203      	str	r2, [sp, #12]
                                 : MX25LM51245G_OCTA_READ_CFG_REG2_CMD;
 c005af0:	f247 128e 	movw	r2, #29070	; 0x718e
 c005af4:	bf08      	it	eq
 c005af6:	2271      	moveq	r2, #113	; 0x71
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005af8:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 c005afa:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005afc:	bf0c      	ite	eq
 c005afe:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c005b02:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005b04:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005b06:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005b0a:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005b0c:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005b0e:	bf0c      	ite	eq
 c005b10:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005b14:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005b18:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005b1a:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005b1c:	bf0c      	ite	eq
 c005b1e:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 c005b22:	2300      	movne	r3, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005b24:	9202      	str	r2, [sp, #8]
  s_command.Address            = ReadAddr;
 c005b26:	9706      	str	r7, [sp, #24]
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005b28:	9310      	str	r3, [sp, #64]	; 0x40
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 c005b2a:	b11c      	cbz	r4, c005b34 <MX25LM51245G_ReadCfg2Register+0x8a>
 c005b2c:	2d01      	cmp	r5, #1
 c005b2e:	bf0c      	ite	eq
 c005b30:	2405      	moveq	r4, #5
 c005b32:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 c005b34:	2d01      	cmp	r5, #1
 c005b36:	bf0c      	ite	eq
 c005b38:	2302      	moveq	r3, #2
 c005b3a:	2301      	movne	r3, #1
 c005b3c:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c005b3e:	bf0c      	ite	eq
 c005b40:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 c005b44:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005b46:	f241 3288 	movw	r2, #5000	; 0x1388
 c005b4a:	4669      	mov	r1, sp
 c005b4c:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 c005b4e:	9411      	str	r4, [sp, #68]	; 0x44
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c005b50:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005b52:	f002 fbe3 	bl	c00831c <HAL_OSPI_Command>
 c005b56:	2800      	cmp	r0, #0
 c005b58:	d1b5      	bne.n	c005ac6 <MX25LM51245G_ReadCfg2Register+0x1c>
  if (HAL_OSPI_Receive(Ctx, Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005b5a:	f241 3288 	movw	r2, #5000	; 0x1388
 c005b5e:	991a      	ldr	r1, [sp, #104]	; 0x68
 c005b60:	4630      	mov	r0, r6
 c005b62:	f002 fc6e 	bl	c008442 <HAL_OSPI_Receive>
 c005b66:	3000      	adds	r0, #0
 c005b68:	bf18      	it	ne
 c005b6a:	2001      	movne	r0, #1
 c005b6c:	4240      	negs	r0, r0
 c005b6e:	e7ac      	b.n	c005aca <MX25LM51245G_ReadCfg2Register+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005b70:	2201      	movs	r2, #1
 c005b72:	e7ad      	b.n	c005ad0 <MX25LM51245G_ReadCfg2Register+0x26>

0c005b74 <MX25LM51245G_ReadSecurityRegister>:
  * @param  Value Security register value pointer
  * @retval error status
  */
int32_t MX25LM51245G_ReadSecurityRegister(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                          MX25LM51245G_Transfer_t Rate, uint8_t *Value)
{
 c005b74:	b5f0      	push	{r4, r5, r6, r7, lr}
 c005b76:	460c      	mov	r4, r1
 c005b78:	b095      	sub	sp, #84	; 0x54
 c005b7a:	4606      	mov	r6, r0
 c005b7c:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c005b7e:	2100      	movs	r1, #0
 c005b80:	2250      	movs	r2, #80	; 0x50
 c005b82:	4668      	mov	r0, sp
{
 c005b84:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 c005b86:	f008 fa80 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005b8a:	b92c      	cbnz	r4, c005b98 <MX25LM51245G_ReadSecurityRegister+0x24>
 c005b8c:	2d01      	cmp	r5, #1
 c005b8e:	d152      	bne.n	c005c36 <MX25LM51245G_ReadSecurityRegister+0xc2>
  {
    return MX25LM51245G_ERROR;
 c005b90:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005b94:	b015      	add	sp, #84	; 0x54
 c005b96:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005b98:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005b9a:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005b9c:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005b9e:	bf0c      	ite	eq
 c005ba0:	2308      	moveq	r3, #8
 c005ba2:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005ba4:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005ba6:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005ba8:	bf0c      	ite	eq
 c005baa:	2300      	moveq	r3, #0
 c005bac:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005bae:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_READ_SECURITY_REG_CMD;
 c005bb0:	f642 33d4 	movw	r3, #11220	; 0x2bd4
 c005bb4:	bf08      	it	eq
 c005bb6:	232b      	moveq	r3, #43	; 0x2b
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005bb8:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c005bba:	bf0c      	ite	eq
 c005bbc:	2300      	moveq	r3, #0
 c005bbe:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005bc2:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 c005bc4:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 c005bc6:	bf0c      	ite	eq
 c005bc8:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 c005bcc:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005bce:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005bd0:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005bd4:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 c005bd6:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005bd8:	bf0c      	ite	eq
 c005bda:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005bde:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005be2:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 c005be4:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 c005be6:	bf0c      	ite	eq
 c005be8:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 c005bec:	2300      	movne	r3, #0
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005bee:	9310      	str	r3, [sp, #64]	; 0x40
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 c005bf0:	b11c      	cbz	r4, c005bfa <MX25LM51245G_ReadSecurityRegister+0x86>
 c005bf2:	2d01      	cmp	r5, #1
 c005bf4:	bf0c      	ite	eq
 c005bf6:	2405      	moveq	r4, #5
 c005bf8:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 c005bfa:	2d01      	cmp	r5, #1
 c005bfc:	bf0c      	ite	eq
 c005bfe:	2302      	moveq	r3, #2
 c005c00:	2301      	movne	r3, #1
 c005c02:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c005c04:	bf0c      	ite	eq
 c005c06:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 c005c0a:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005c0c:	f241 3288 	movw	r2, #5000	; 0x1388
 c005c10:	4669      	mov	r1, sp
 c005c12:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 c005c14:	9411      	str	r4, [sp, #68]	; 0x44
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 c005c16:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005c18:	f002 fb80 	bl	c00831c <HAL_OSPI_Command>
 c005c1c:	2800      	cmp	r0, #0
 c005c1e:	d1b7      	bne.n	c005b90 <MX25LM51245G_ReadSecurityRegister+0x1c>
  if (HAL_OSPI_Receive(Ctx, Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005c20:	f241 3288 	movw	r2, #5000	; 0x1388
 c005c24:	4639      	mov	r1, r7
 c005c26:	4630      	mov	r0, r6
 c005c28:	f002 fc0b 	bl	c008442 <HAL_OSPI_Receive>
 c005c2c:	3000      	adds	r0, #0
 c005c2e:	bf18      	it	ne
 c005c30:	2001      	movne	r0, #1
 c005c32:	4240      	negs	r0, r0
 c005c34:	e7ae      	b.n	c005b94 <MX25LM51245G_ReadSecurityRegister+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005c36:	2301      	movs	r3, #1
 c005c38:	e7af      	b.n	c005b9a <MX25LM51245G_ReadSecurityRegister+0x26>

0c005c3a <MX25LM51245G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25LM51245G_ResetEnable(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate)
{
 c005c3a:	b570      	push	{r4, r5, r6, lr}
 c005c3c:	460c      	mov	r4, r1
 c005c3e:	b094      	sub	sp, #80	; 0x50
 c005c40:	4606      	mov	r6, r0
 c005c42:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c005c44:	2100      	movs	r1, #0
 c005c46:	2250      	movs	r2, #80	; 0x50
 c005c48:	4668      	mov	r0, sp
 c005c4a:	f008 fa1e 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005c4e:	b9f4      	cbnz	r4, c005c8e <MX25LM51245G_ResetEnable+0x54>
 c005c50:	2d01      	cmp	r5, #1
 c005c52:	d01e      	beq.n	c005c92 <MX25LM51245G_ResetEnable+0x58>
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_1_LINE
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005c54:	2301      	movs	r3, #1
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005c56:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005c58:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005c5a:	bf0c      	ite	eq
 c005c5c:	2308      	moveq	r3, #8
 c005c5e:	2300      	movne	r3, #0
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_8_BITS
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005c60:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005c62:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005c64:	bf0c      	ite	eq
 c005c66:	2300      	moveq	r3, #0
 c005c68:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005c6a:	9304      	str	r3, [sp, #16]
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
                                 ? MX25LM51245G_RESET_ENABLE_CMD
                                 : MX25LM51245G_OCTA_RESET_ENABLE_CMD;
 c005c6c:	f246 6399 	movw	r3, #26265	; 0x6699
 c005c70:	bf08      	it	eq
 c005c72:	2366      	moveq	r3, #102	; 0x66
  s_command.DummyCycles        = 0U;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005c74:	f241 3288 	movw	r2, #5000	; 0x1388
 c005c78:	4669      	mov	r1, sp
 c005c7a:	4630      	mov	r0, r6
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005c7c:	9302      	str	r3, [sp, #8]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005c7e:	f002 fb4d 	bl	c00831c <HAL_OSPI_Command>
 c005c82:	3000      	adds	r0, #0
 c005c84:	bf18      	it	ne
 c005c86:	2001      	movne	r0, #1
 c005c88:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005c8a:	b014      	add	sp, #80	; 0x50
 c005c8c:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005c8e:	2304      	movs	r3, #4
 c005c90:	e7e1      	b.n	c005c56 <MX25LM51245G_ResetEnable+0x1c>
    return MX25LM51245G_ERROR;
 c005c92:	f04f 30ff 	mov.w	r0, #4294967295
 c005c96:	e7f8      	b.n	c005c8a <MX25LM51245G_ResetEnable+0x50>

0c005c98 <MX25LM51245G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25LM51245G_ResetMemory(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate)
{
 c005c98:	b570      	push	{r4, r5, r6, lr}
 c005c9a:	460c      	mov	r4, r1
 c005c9c:	b094      	sub	sp, #80	; 0x50
 c005c9e:	4606      	mov	r6, r0
 c005ca0:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 c005ca2:	2100      	movs	r1, #0
 c005ca4:	2250      	movs	r2, #80	; 0x50
 c005ca6:	4668      	mov	r0, sp
 c005ca8:	f008 f9ef 	bl	c00e08a <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 c005cac:	b9f4      	cbnz	r4, c005cec <MX25LM51245G_ResetMemory+0x54>
 c005cae:	2d01      	cmp	r5, #1
 c005cb0:	d01e      	beq.n	c005cf0 <MX25LM51245G_ResetMemory+0x58>
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_1_LINE
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005cb2:	2301      	movs	r3, #1
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005cb4:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 c005cb6:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 c005cb8:	bf0c      	ite	eq
 c005cba:	2308      	moveq	r3, #8
 c005cbc:	2300      	movne	r3, #0
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_8_BITS
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005cbe:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 c005cc0:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 c005cc2:	bf0c      	ite	eq
 c005cc4:	2300      	moveq	r3, #0
 c005cc6:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 c005cc8:	9304      	str	r3, [sp, #16]
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
                                 ? MX25LM51245G_RESET_MEMORY_CMD
                                 : MX25LM51245G_OCTA_RESET_MEMORY_CMD;
 c005cca:	f649 1366 	movw	r3, #39270	; 0x9966
 c005cce:	bf08      	it	eq
 c005cd0:	2399      	moveq	r3, #153	; 0x99
  s_command.DummyCycles        = 0U;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005cd2:	f241 3288 	movw	r2, #5000	; 0x1388
 c005cd6:	4669      	mov	r1, sp
 c005cd8:	4630      	mov	r0, r6
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 c005cda:	9302      	str	r3, [sp, #8]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 c005cdc:	f002 fb1e 	bl	c00831c <HAL_OSPI_Command>
 c005ce0:	3000      	adds	r0, #0
 c005ce2:	bf18      	it	ne
 c005ce4:	2001      	movne	r0, #1
 c005ce6:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 c005ce8:	b014      	add	sp, #80	; 0x50
 c005cea:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 c005cec:	2304      	movs	r3, #4
 c005cee:	e7e1      	b.n	c005cb4 <MX25LM51245G_ResetMemory+0x1c>
    return MX25LM51245G_ERROR;
 c005cf0:	f04f 30ff 	mov.w	r0, #4294967295
 c005cf4:	e7f8      	b.n	c005ce8 <MX25LM51245G_ResetMemory+0x50>
	...

0c005cf8 <OSPI_NOR_EnterSOPIMode.constprop.4>:
/**
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  OSPI instance
  * @retval BSP status
  */
static int32_t OSPI_NOR_EnterSOPIMode(uint32_t Instance)
 c005cf8:	b530      	push	{r4, r5, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  /* Enable write operations */
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005cfa:	4c21      	ldr	r4, [pc, #132]	; (c005d80 <OSPI_NOR_EnterSOPIMode.constprop.4+0x88>)
static int32_t OSPI_NOR_EnterSOPIMode(uint32_t Instance)
 c005cfc:	b085      	sub	sp, #20
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005cfe:	78a2      	ldrb	r2, [r4, #2]
 c005d00:	7861      	ldrb	r1, [r4, #1]
 c005d02:	4820      	ldr	r0, [pc, #128]	; (c005d84 <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 c005d04:	f7ff fd92 	bl	c00582c <MX25LM51245G_WriteEnable>
 c005d08:	b118      	cbz	r0, c005d12 <OSPI_NOR_EnterSOPIMode.constprop.4+0x1a>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
 c005d0a:	f06f 0004 	mvn.w	r0, #4
    }
  }

  /* Return BSP status */
  return ret;
}
 c005d0e:	b005      	add	sp, #20
 c005d10:	bd30      	pop	{r4, r5, pc}
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG3_ADDR, MX25LM51245G_CR2_DC_6_CYCLES) != MX25LM51245G_OK)
 c005d12:	2307      	movs	r3, #7
 c005d14:	78a2      	ldrb	r2, [r4, #2]
 c005d16:	7861      	ldrb	r1, [r4, #1]
 c005d18:	481a      	ldr	r0, [pc, #104]	; (c005d84 <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 c005d1a:	9300      	str	r3, [sp, #0]
 c005d1c:	f44f 7340 	mov.w	r3, #768	; 0x300
 c005d20:	f7ff fe66 	bl	c0059f0 <MX25LM51245G_WriteCfg2Register>
 c005d24:	2800      	cmp	r0, #0
 c005d26:	d1f0      	bne.n	c005d0a <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005d28:	78a2      	ldrb	r2, [r4, #2]
 c005d2a:	7861      	ldrb	r1, [r4, #1]
 c005d2c:	4815      	ldr	r0, [pc, #84]	; (c005d84 <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 c005d2e:	f7ff fd7d 	bl	c00582c <MX25LM51245G_WriteEnable>
 c005d32:	4603      	mov	r3, r0
 c005d34:	2800      	cmp	r0, #0
 c005d36:	d1e8      	bne.n	c005d0a <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, MX25LM51245G_CR2_SOPI) != MX25LM51245G_OK)
 c005d38:	78a2      	ldrb	r2, [r4, #2]
 c005d3a:	7861      	ldrb	r1, [r4, #1]
 c005d3c:	2401      	movs	r4, #1
 c005d3e:	4811      	ldr	r0, [pc, #68]	; (c005d84 <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 c005d40:	9400      	str	r4, [sp, #0]
 c005d42:	f7ff fe55 	bl	c0059f0 <MX25LM51245G_WriteCfg2Register>
 c005d46:	4605      	mov	r5, r0
 c005d48:	2800      	cmp	r0, #0
 c005d4a:	d1de      	bne.n	c005d0a <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
    HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
 c005d4c:	2028      	movs	r0, #40	; 0x28
 c005d4e:	f000 fbc1 	bl	c0064d4 <HAL_Delay>
    if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 c005d52:	462a      	mov	r2, r5
 c005d54:	4621      	mov	r1, r4
 c005d56:	480b      	ldr	r0, [pc, #44]	; (c005d84 <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 c005d58:	f7ff fac1 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c005d5c:	4603      	mov	r3, r0
 c005d5e:	2800      	cmp	r0, #0
 c005d60:	d1d3      	bne.n	c005d0a <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
    else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
 c005d62:	aa03      	add	r2, sp, #12
 c005d64:	9200      	str	r2, [sp, #0]
 c005d66:	4621      	mov	r1, r4
 c005d68:	4602      	mov	r2, r0
 c005d6a:	4806      	ldr	r0, [pc, #24]	; (c005d84 <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 c005d6c:	f7ff fe9d 	bl	c005aaa <MX25LM51245G_ReadCfg2Register>
 c005d70:	2800      	cmp	r0, #0
 c005d72:	d1ca      	bne.n	c005d0a <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
    else if (reg[0] != MX25LM51245G_CR2_SOPI)
 c005d74:	f89d 300c 	ldrb.w	r3, [sp, #12]
 c005d78:	42a3      	cmp	r3, r4
 c005d7a:	d0c8      	beq.n	c005d0e <OSPI_NOR_EnterSOPIMode.constprop.4+0x16>
 c005d7c:	e7c5      	b.n	c005d0a <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
 c005d7e:	bf00      	nop
 c005d80:	300302e4 	.word	0x300302e4
 c005d84:	300302e8 	.word	0x300302e8

0c005d88 <OSPI_NOR_EnterDOPIMode.constprop.5>:
static int32_t OSPI_NOR_EnterDOPIMode(uint32_t Instance)
 c005d88:	b530      	push	{r4, r5, lr}
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005d8a:	4d27      	ldr	r5, [pc, #156]	; (c005e28 <OSPI_NOR_EnterDOPIMode.constprop.5+0xa0>)
 c005d8c:	4c27      	ldr	r4, [pc, #156]	; (c005e2c <OSPI_NOR_EnterDOPIMode.constprop.5+0xa4>)
static int32_t OSPI_NOR_EnterDOPIMode(uint32_t Instance)
 c005d8e:	b085      	sub	sp, #20
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005d90:	78aa      	ldrb	r2, [r5, #2]
 c005d92:	7869      	ldrb	r1, [r5, #1]
 c005d94:	4620      	mov	r0, r4
 c005d96:	f7ff fd49 	bl	c00582c <MX25LM51245G_WriteEnable>
 c005d9a:	b118      	cbz	r0, c005da4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x1c>
    ret = BSP_ERROR_COMPONENT_FAILURE;
 c005d9c:	f06f 0004 	mvn.w	r0, #4
}
 c005da0:	b005      	add	sp, #20
 c005da2:	bd30      	pop	{r4, r5, pc}
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG3_ADDR, MX25LM51245G_CR2_DC_6_CYCLES) != MX25LM51245G_OK)
 c005da4:	2307      	movs	r3, #7
 c005da6:	78aa      	ldrb	r2, [r5, #2]
 c005da8:	9300      	str	r3, [sp, #0]
 c005daa:	7869      	ldrb	r1, [r5, #1]
 c005dac:	f44f 7340 	mov.w	r3, #768	; 0x300
 c005db0:	4620      	mov	r0, r4
 c005db2:	f7ff fe1d 	bl	c0059f0 <MX25LM51245G_WriteCfg2Register>
 c005db6:	2800      	cmp	r0, #0
 c005db8:	d1f0      	bne.n	c005d9c <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005dba:	78aa      	ldrb	r2, [r5, #2]
 c005dbc:	7869      	ldrb	r1, [r5, #1]
 c005dbe:	4620      	mov	r0, r4
 c005dc0:	f7ff fd34 	bl	c00582c <MX25LM51245G_WriteEnable>
 c005dc4:	4603      	mov	r3, r0
 c005dc6:	2800      	cmp	r0, #0
 c005dc8:	d1e8      	bne.n	c005d9c <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, MX25LM51245G_CR2_DOPI) != MX25LM51245G_OK)
 c005dca:	2002      	movs	r0, #2
 c005dcc:	78aa      	ldrb	r2, [r5, #2]
 c005dce:	9000      	str	r0, [sp, #0]
 c005dd0:	7869      	ldrb	r1, [r5, #1]
 c005dd2:	4620      	mov	r0, r4
 c005dd4:	f7ff fe0c 	bl	c0059f0 <MX25LM51245G_WriteCfg2Register>
 c005dd8:	2800      	cmp	r0, #0
 c005dda:	d1df      	bne.n	c005d9c <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
    HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
 c005ddc:	2028      	movs	r0, #40	; 0x28
 c005dde:	f000 fb79 	bl	c0064d4 <HAL_Delay>
    hospi_nor[Instance].Init.MemoryType            = HAL_OSPI_MEMTYPE_MACRONIX;
 c005de2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 c005de6:	60e3      	str	r3, [r4, #12]
    hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 c005de8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 c005dec:	4620      	mov	r0, r4
    hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 c005dee:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 c005df0:	f002 fa10 	bl	c008214 <HAL_OSPI_Init>
 c005df4:	b9a8      	cbnz	r0, c005e22 <OSPI_NOR_EnterDOPIMode.constprop.5+0x9a>
    else if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
 c005df6:	2201      	movs	r2, #1
 c005df8:	4620      	mov	r0, r4
 c005dfa:	4611      	mov	r1, r2
 c005dfc:	f7ff fa6f 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c005e00:	4603      	mov	r3, r0
 c005e02:	2800      	cmp	r0, #0
 c005e04:	d1ca      	bne.n	c005d9c <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
    else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
 c005e06:	aa03      	add	r2, sp, #12
 c005e08:	9200      	str	r2, [sp, #0]
 c005e0a:	2201      	movs	r2, #1
 c005e0c:	4620      	mov	r0, r4
 c005e0e:	4611      	mov	r1, r2
 c005e10:	f7ff fe4b 	bl	c005aaa <MX25LM51245G_ReadCfg2Register>
 c005e14:	2800      	cmp	r0, #0
 c005e16:	d1c1      	bne.n	c005d9c <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
    else if (reg[0] != MX25LM51245G_CR2_DOPI)
 c005e18:	f89d 300c 	ldrb.w	r3, [sp, #12]
 c005e1c:	2b02      	cmp	r3, #2
 c005e1e:	d0bf      	beq.n	c005da0 <OSPI_NOR_EnterDOPIMode.constprop.5+0x18>
 c005e20:	e7bc      	b.n	c005d9c <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
      ret = BSP_ERROR_PERIPH_FAILURE;
 c005e22:	f06f 0003 	mvn.w	r0, #3
 c005e26:	e7bb      	b.n	c005da0 <OSPI_NOR_EnterDOPIMode.constprop.5+0x18>
 c005e28:	300302e4 	.word	0x300302e4
 c005e2c:	300302e8 	.word	0x300302e8

0c005e30 <MX_OSPI_NOR_Init>:
  hospi->Init.FifoThreshold      = 4;
 c005e30:	2304      	movs	r3, #4
 c005e32:	4a0e      	ldr	r2, [pc, #56]	; (c005e6c <MX_OSPI_NOR_Init+0x3c>)
 c005e34:	e9c0 2300 	strd	r2, r3, [r0]
  hospi->Init.DeviceSize         = Init->MemorySize; /* 512 MBits */
 c005e38:	680a      	ldr	r2, [r1, #0]
  hospi->Init.DualQuad           = HAL_OSPI_DUALQUAD_DISABLE;
 c005e3a:	2300      	movs	r3, #0
  hospi->Init.DeviceSize         = Init->MemorySize; /* 512 MBits */
 c005e3c:	6102      	str	r2, [r0, #16]
  hospi->Init.ChipSelectHighTime = 2;
 c005e3e:	2202      	movs	r2, #2
  hospi->Init.FreeRunningClock   = HAL_OSPI_FREERUNCLK_DISABLE;
 c005e40:	e9c0 2305 	strd	r2, r3, [r0, #20]
  hospi->Init.ClockPrescaler     = Init->ClockPrescaler;
 c005e44:	684a      	ldr	r2, [r1, #4]
  hospi->Init.DualQuad           = HAL_OSPI_DUALQUAD_DISABLE;
 c005e46:	6083      	str	r3, [r0, #8]
  hospi->Init.ClockPrescaler     = Init->ClockPrescaler;
 c005e48:	6242      	str	r2, [r0, #36]	; 0x24
  hospi->Init.SampleShifting     = Init->SampleShifting;
 c005e4a:	688a      	ldr	r2, [r1, #8]
  hospi->Init.WrapSize           = HAL_OSPI_WRAP_NOT_SUPPORTED;
 c005e4c:	e9c0 3307 	strd	r3, r3, [r0, #28]
  hospi->Init.SampleShifting     = Init->SampleShifting;
 c005e50:	6282      	str	r2, [r0, #40]	; 0x28
  if (Init->TransferRate == (uint32_t) BSP_OSPI_NOR_DTR_TRANSFER)
 c005e52:	68ca      	ldr	r2, [r1, #12]
  hospi->Init.ChipSelectBoundary = 0;
 c005e54:	6303      	str	r3, [r0, #48]	; 0x30
  if (Init->TransferRate == (uint32_t) BSP_OSPI_NOR_DTR_TRANSFER)
 c005e56:	2a01      	cmp	r2, #1
    hospi->Init.MemoryType            = HAL_OSPI_MEMTYPE_MACRONIX;
 c005e58:	bf03      	ittte	eq
 c005e5a:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 c005e5e:	60c3      	streq	r3, [r0, #12]
    hospi->Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 c005e60:	f04f 5380 	moveq.w	r3, #268435456	; 0x10000000
    hospi->Init.MemoryType            = HAL_OSPI_MEMTYPE_MICRON;
 c005e64:	60c3      	strne	r3, [r0, #12]
    hospi->Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
 c005e66:	62c3      	str	r3, [r0, #44]	; 0x2c
  return HAL_OSPI_Init(hospi);
 c005e68:	f002 b9d4 	b.w	c008214 <HAL_OSPI_Init>
 c005e6c:	54021000 	.word	0x54021000

0c005e70 <BSP_OSPI_NOR_Read>:
{
 c005e70:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c005e72:	460c      	mov	r4, r1
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c005e74:	b9a8      	cbnz	r0, c005ea2 <BSP_OSPI_NOR_Read+0x32>
    if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 c005e76:	480c      	ldr	r0, [pc, #48]	; (c005ea8 <BSP_OSPI_NOR_Read+0x38>)
 c005e78:	7887      	ldrb	r7, [r0, #2]
 c005e7a:	b977      	cbnz	r7, c005e9a <BSP_OSPI_NOR_Read+0x2a>
      if(MX25LM51245G_ReadSTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE, pData, ReadAddr, Size) != MX25LM51245G_OK)
 c005e7c:	7841      	ldrb	r1, [r0, #1]
 c005e7e:	e9cd 2300 	strd	r2, r3, [sp]
 c005e82:	480a      	ldr	r0, [pc, #40]	; (c005eac <BSP_OSPI_NOR_Read+0x3c>)
 c005e84:	4623      	mov	r3, r4
 c005e86:	2201      	movs	r2, #1
 c005e88:	f7ff fa97 	bl	c0053ba <MX25LM51245G_ReadSTR>
 c005e8c:	b118      	cbz	r0, c005e96 <BSP_OSPI_NOR_Read+0x26>
        ret = BSP_ERROR_COMPONENT_FAILURE;
 c005e8e:	f06f 0004 	mvn.w	r0, #4
}
 c005e92:	b003      	add	sp, #12
 c005e94:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = BSP_ERROR_NONE;
 c005e96:	2000      	movs	r0, #0
 c005e98:	e7fb      	b.n	c005e92 <BSP_OSPI_NOR_Read+0x22>
      if(MX25LM51245G_ReadDTR(&hospi_nor[Instance], pData, ReadAddr, Size) != MX25LM51245G_OK)
 c005e9a:	4804      	ldr	r0, [pc, #16]	; (c005eac <BSP_OSPI_NOR_Read+0x3c>)
 c005e9c:	f7ff fae5 	bl	c00546a <MX25LM51245G_ReadDTR>
 c005ea0:	e7f4      	b.n	c005e8c <BSP_OSPI_NOR_Read+0x1c>
    ret = BSP_ERROR_WRONG_PARAM;
 c005ea2:	f06f 0001 	mvn.w	r0, #1
  return ret;
 c005ea6:	e7f4      	b.n	c005e92 <BSP_OSPI_NOR_Read+0x22>
 c005ea8:	300302e4 	.word	0x300302e4
 c005eac:	300302e8 	.word	0x300302e8

0c005eb0 <BSP_OSPI_NOR_Write>:
{
 c005eb0:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 c005eb4:	4691      	mov	r9, r2
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c005eb6:	2800      	cmp	r0, #0
 c005eb8:	d144      	bne.n	c005f44 <BSP_OSPI_NOR_Write+0x94>
    current_size = MX25LM51245G_PAGE_SIZE - (WriteAddr % MX25LM51245G_PAGE_SIZE);
 c005eba:	b2d4      	uxtb	r4, r2
 c005ebc:	f5c4 7480 	rsb	r4, r4, #256	; 0x100
      if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005ec0:	4d23      	ldr	r5, [pc, #140]	; (c005f50 <BSP_OSPI_NOR_Write+0xa0>)
 c005ec2:	429c      	cmp	r4, r3
 c005ec4:	bf28      	it	cs
 c005ec6:	461c      	movcs	r4, r3
    data_addr = (uint32_t)pData;
 c005ec8:	460f      	mov	r7, r1
 c005eca:	46aa      	mov	sl, r5
      if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005ecc:	f8df 8084 	ldr.w	r8, [pc, #132]	; c005f54 <BSP_OSPI_NOR_Write+0xa4>
    end_addr = WriteAddr + Size;
 c005ed0:	18d6      	adds	r6, r2, r3
      if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005ed2:	78aa      	ldrb	r2, [r5, #2]
 c005ed4:	7869      	ldrb	r1, [r5, #1]
 c005ed6:	4640      	mov	r0, r8
 c005ed8:	f7ff fa01 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c005edc:	b120      	cbz	r0, c005ee8 <BSP_OSPI_NOR_Write+0x38>
    ret = BSP_ERROR_WRONG_PARAM;
 c005ede:	f06f 0004 	mvn.w	r0, #4
}
 c005ee2:	b002      	add	sp, #8
 c005ee4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005ee8:	78aa      	ldrb	r2, [r5, #2]
 c005eea:	7869      	ldrb	r1, [r5, #1]
 c005eec:	4640      	mov	r0, r8
 c005eee:	f7ff fc9d 	bl	c00582c <MX25LM51245G_WriteEnable>
 c005ef2:	2800      	cmp	r0, #0
 c005ef4:	d1f3      	bne.n	c005ede <BSP_OSPI_NOR_Write+0x2e>
        if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 c005ef6:	78ab      	ldrb	r3, [r5, #2]
 c005ef8:	b9eb      	cbnz	r3, c005f36 <BSP_OSPI_NOR_Write+0x86>
          if(MX25LM51245G_PageProgram(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE, (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
 c005efa:	7869      	ldrb	r1, [r5, #1]
 c005efc:	e9cd 9400 	strd	r9, r4, [sp]
 c005f00:	463b      	mov	r3, r7
 c005f02:	2201      	movs	r2, #1
 c005f04:	4640      	mov	r0, r8
 c005f06:	f7ff faf0 	bl	c0054ea <MX25LM51245G_PageProgram>
          if(MX25LM51245G_PageProgramDTR(&hospi_nor[Instance], (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
 c005f0a:	2800      	cmp	r0, #0
 c005f0c:	d1e7      	bne.n	c005ede <BSP_OSPI_NOR_Write+0x2e>
          if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005f0e:	f89a 2002 	ldrb.w	r2, [sl, #2]
 c005f12:	f89a 1001 	ldrb.w	r1, [sl, #1]
 c005f16:	4640      	mov	r0, r8
 c005f18:	f7ff f9e1 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c005f1c:	2800      	cmp	r0, #0
 c005f1e:	d1de      	bne.n	c005ede <BSP_OSPI_NOR_Write+0x2e>
            current_addr += current_size;
 c005f20:	44a1      	add	r9, r4
            current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
 c005f22:	f509 7380 	add.w	r3, r9, #256	; 0x100
 c005f26:	42b3      	cmp	r3, r6
            data_addr += current_size;
 c005f28:	4427      	add	r7, r4
            current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
 c005f2a:	d90e      	bls.n	c005f4a <BSP_OSPI_NOR_Write+0x9a>
 c005f2c:	eba6 0409 	sub.w	r4, r6, r9
    } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
 c005f30:	454e      	cmp	r6, r9
 c005f32:	d8ce      	bhi.n	c005ed2 <BSP_OSPI_NOR_Write+0x22>
 c005f34:	e7d5      	b.n	c005ee2 <BSP_OSPI_NOR_Write+0x32>
          if(MX25LM51245G_PageProgramDTR(&hospi_nor[Instance], (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
 c005f36:	4623      	mov	r3, r4
 c005f38:	464a      	mov	r2, r9
 c005f3a:	4639      	mov	r1, r7
 c005f3c:	4640      	mov	r0, r8
 c005f3e:	f7ff fb28 	bl	c005592 <MX25LM51245G_PageProgramDTR>
 c005f42:	e7e2      	b.n	c005f0a <BSP_OSPI_NOR_Write+0x5a>
    ret = BSP_ERROR_WRONG_PARAM;
 c005f44:	f06f 0001 	mvn.w	r0, #1
  return ret;
 c005f48:	e7cb      	b.n	c005ee2 <BSP_OSPI_NOR_Write+0x32>
            current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
 c005f4a:	f44f 7480 	mov.w	r4, #256	; 0x100
 c005f4e:	e7ef      	b.n	c005f30 <BSP_OSPI_NOR_Write+0x80>
 c005f50:	300302e4 	.word	0x300302e4
 c005f54:	300302e8 	.word	0x300302e8

0c005f58 <BSP_OSPI_NOR_Erase_Block>:
{
 c005f58:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c005f5a:	460d      	mov	r5, r1
 c005f5c:	4616      	mov	r6, r2
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c005f5e:	b9e0      	cbnz	r0, c005f9a <BSP_OSPI_NOR_Erase_Block+0x42>
    if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005f60:	4c0f      	ldr	r4, [pc, #60]	; (c005fa0 <BSP_OSPI_NOR_Erase_Block+0x48>)
 c005f62:	4810      	ldr	r0, [pc, #64]	; (c005fa4 <BSP_OSPI_NOR_Erase_Block+0x4c>)
 c005f64:	78a2      	ldrb	r2, [r4, #2]
 c005f66:	7861      	ldrb	r1, [r4, #1]
 c005f68:	f7ff f9b9 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c005f6c:	b118      	cbz	r0, c005f76 <BSP_OSPI_NOR_Erase_Block+0x1e>
      ret = BSP_ERROR_COMPONENT_FAILURE;
 c005f6e:	f06f 0004 	mvn.w	r0, #4
}
 c005f72:	b002      	add	sp, #8
 c005f74:	bd70      	pop	{r4, r5, r6, pc}
    else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c005f76:	78a2      	ldrb	r2, [r4, #2]
 c005f78:	7861      	ldrb	r1, [r4, #1]
 c005f7a:	480a      	ldr	r0, [pc, #40]	; (c005fa4 <BSP_OSPI_NOR_Erase_Block+0x4c>)
 c005f7c:	f7ff fc56 	bl	c00582c <MX25LM51245G_WriteEnable>
 c005f80:	2800      	cmp	r0, #0
 c005f82:	d1f4      	bne.n	c005f6e <BSP_OSPI_NOR_Erase_Block+0x16>
    else if(MX25LM51245G_BlockErase(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_4BYTES_SIZE, BlockAddress, BlockSize) != MX25LM51245G_OK)
 c005f84:	78a2      	ldrb	r2, [r4, #2]
 c005f86:	7861      	ldrb	r1, [r4, #1]
 c005f88:	e9cd 5600 	strd	r5, r6, [sp]
 c005f8c:	2301      	movs	r3, #1
 c005f8e:	4805      	ldr	r0, [pc, #20]	; (c005fa4 <BSP_OSPI_NOR_Erase_Block+0x4c>)
 c005f90:	f7ff fb3a 	bl	c005608 <MX25LM51245G_BlockErase>
 c005f94:	2800      	cmp	r0, #0
 c005f96:	d0ec      	beq.n	c005f72 <BSP_OSPI_NOR_Erase_Block+0x1a>
 c005f98:	e7e9      	b.n	c005f6e <BSP_OSPI_NOR_Erase_Block+0x16>
    ret = BSP_ERROR_WRONG_PARAM;
 c005f9a:	f06f 0001 	mvn.w	r0, #1
  return ret;
 c005f9e:	e7e8      	b.n	c005f72 <BSP_OSPI_NOR_Erase_Block+0x1a>
 c005fa0:	300302e4 	.word	0x300302e4
 c005fa4:	300302e8 	.word	0x300302e8

0c005fa8 <BSP_OSPI_NOR_GetStatus>:
{
 c005fa8:	b538      	push	{r3, r4, r5, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c005faa:	bb08      	cbnz	r0, c005ff0 <BSP_OSPI_NOR_GetStatus+0x48>
    if(MX25LM51245G_ReadSecurityRegister(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, reg) != MX25LM51245G_OK)
 c005fac:	4d13      	ldr	r5, [pc, #76]	; (c005ffc <BSP_OSPI_NOR_GetStatus+0x54>)
 c005fae:	4c14      	ldr	r4, [pc, #80]	; (c006000 <BSP_OSPI_NOR_GetStatus+0x58>)
 c005fb0:	78aa      	ldrb	r2, [r5, #2]
 c005fb2:	4623      	mov	r3, r4
 c005fb4:	7869      	ldrb	r1, [r5, #1]
 c005fb6:	4813      	ldr	r0, [pc, #76]	; (c006004 <BSP_OSPI_NOR_GetStatus+0x5c>)
 c005fb8:	f7ff fddc 	bl	c005b74 <MX25LM51245G_ReadSecurityRegister>
 c005fbc:	b110      	cbz	r0, c005fc4 <BSP_OSPI_NOR_GetStatus+0x1c>
      ret = BSP_ERROR_COMPONENT_FAILURE;
 c005fbe:	f06f 0004 	mvn.w	r0, #4
}
 c005fc2:	bd38      	pop	{r3, r4, r5, pc}
    else if ((reg[0] & (MX25LM51245G_SECR_P_FAIL | MX25LM51245G_SECR_E_FAIL)) != 0U)
 c005fc4:	7823      	ldrb	r3, [r4, #0]
 c005fc6:	f013 0f60 	tst.w	r3, #96	; 0x60
 c005fca:	d1f8      	bne.n	c005fbe <BSP_OSPI_NOR_GetStatus+0x16>
    else if ((reg[0] & (MX25LM51245G_SECR_PSB | MX25LM51245G_SECR_ESB)) != 0U)
 c005fcc:	f013 0f0c 	tst.w	r3, #12
 c005fd0:	d111      	bne.n	c005ff6 <BSP_OSPI_NOR_GetStatus+0x4e>
    else if(MX25LM51245G_ReadStatusRegister(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, reg) != MX25LM51245G_OK)
 c005fd2:	4623      	mov	r3, r4
 c005fd4:	78aa      	ldrb	r2, [r5, #2]
 c005fd6:	7869      	ldrb	r1, [r5, #1]
 c005fd8:	480a      	ldr	r0, [pc, #40]	; (c006004 <BSP_OSPI_NOR_GetStatus+0x5c>)
 c005fda:	f7ff fca6 	bl	c00592a <MX25LM51245G_ReadStatusRegister>
 c005fde:	2800      	cmp	r0, #0
 c005fe0:	d1ed      	bne.n	c005fbe <BSP_OSPI_NOR_GetStatus+0x16>
    else if ((reg[0] & MX25LM51245G_SR_WIP) != 0U)
 c005fe2:	7823      	ldrb	r3, [r4, #0]
      ret = BSP_ERROR_BUSY;
 c005fe4:	f013 0f01 	tst.w	r3, #1
 c005fe8:	bf18      	it	ne
 c005fea:	f06f 0002 	mvnne.w	r0, #2
 c005fee:	e7e8      	b.n	c005fc2 <BSP_OSPI_NOR_GetStatus+0x1a>
    ret = BSP_ERROR_WRONG_PARAM;
 c005ff0:	f06f 0001 	mvn.w	r0, #1
 c005ff4:	e7e5      	b.n	c005fc2 <BSP_OSPI_NOR_GetStatus+0x1a>
      ret = BSP_ERROR_OSPI_SUSPENDED;
 c005ff6:	f06f 0013 	mvn.w	r0, #19
 c005ffa:	e7e2      	b.n	c005fc2 <BSP_OSPI_NOR_GetStatus+0x1a>
 c005ffc:	300302e4 	.word	0x300302e4
 c006000:	30030340 	.word	0x30030340
 c006004:	300302e8 	.word	0x300302e8

0c006008 <BSP_OSPI_NOR_EnableMemoryMappedMode>:
{
 c006008:	b510      	push	{r4, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c00600a:	b998      	cbnz	r0, c006034 <BSP_OSPI_NOR_EnableMemoryMappedMode+0x2c>
 c00600c:	4c0b      	ldr	r4, [pc, #44]	; (c00603c <BSP_OSPI_NOR_EnableMemoryMappedMode+0x34>)
    if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 c00600e:	78a2      	ldrb	r2, [r4, #2]
 c006010:	7861      	ldrb	r1, [r4, #1]
 c006012:	b95a      	cbnz	r2, c00602c <BSP_OSPI_NOR_EnableMemoryMappedMode+0x24>
      if(MX25LM51245G_EnableMemoryMappedModeSTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE) != MX25LM51245G_OK)
 c006014:	2201      	movs	r2, #1
 c006016:	480a      	ldr	r0, [pc, #40]	; (c006040 <BSP_OSPI_NOR_EnableMemoryMappedMode+0x38>)
 c006018:	f7ff fb53 	bl	c0056c2 <MX25LM51245G_EnableSTRMemoryMappedMode>
 c00601c:	b110      	cbz	r0, c006024 <BSP_OSPI_NOR_EnableMemoryMappedMode+0x1c>
        ret = BSP_ERROR_COMPONENT_FAILURE;
 c00601e:	f06f 0004 	mvn.w	r0, #4
}
 c006022:	bd10      	pop	{r4, pc}
        Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_MMP;
 c006024:	2302      	movs	r3, #2
  int32_t ret = BSP_ERROR_NONE;
 c006026:	2000      	movs	r0, #0
        Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_MMP;
 c006028:	7023      	strb	r3, [r4, #0]
 c00602a:	e7fa      	b.n	c006022 <BSP_OSPI_NOR_EnableMemoryMappedMode+0x1a>
      if(MX25LM51245G_EnableMemoryMappedModeDTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode) != MX25LM51245G_OK)
 c00602c:	4804      	ldr	r0, [pc, #16]	; (c006040 <BSP_OSPI_NOR_EnableMemoryMappedMode+0x38>)
 c00602e:	f7ff fbae 	bl	c00578e <MX25LM51245G_EnableDTRMemoryMappedMode>
 c006032:	e7f3      	b.n	c00601c <BSP_OSPI_NOR_EnableMemoryMappedMode+0x14>
    ret = BSP_ERROR_WRONG_PARAM;
 c006034:	f06f 0001 	mvn.w	r0, #1
  return ret;
 c006038:	e7f3      	b.n	c006022 <BSP_OSPI_NOR_EnableMemoryMappedMode+0x1a>
 c00603a:	bf00      	nop
 c00603c:	300302e4 	.word	0x300302e4
 c006040:	300302e8 	.word	0x300302e8

0c006044 <BSP_OSPI_NOR_DisableMemoryMappedMode>:
{
 c006044:	b510      	push	{r4, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c006046:	b950      	cbnz	r0, c00605e <BSP_OSPI_NOR_DisableMemoryMappedMode+0x1a>
    if(Ospi_Nor_Ctx[Instance].IsInitialized != OSPI_ACCESS_MMP)
 c006048:	4c09      	ldr	r4, [pc, #36]	; (c006070 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x2c>)
 c00604a:	7823      	ldrb	r3, [r4, #0]
 c00604c:	2b02      	cmp	r3, #2
 c00604e:	d109      	bne.n	c006064 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x20>
    else if(HAL_OSPI_Abort(&hospi_nor[Instance]) != HAL_OK)
 c006050:	4808      	ldr	r0, [pc, #32]	; (c006074 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x30>)
 c006052:	f002 facd 	bl	c0085f0 <HAL_OSPI_Abort>
 c006056:	b940      	cbnz	r0, c00606a <BSP_OSPI_NOR_DisableMemoryMappedMode+0x26>
      Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
 c006058:	2301      	movs	r3, #1
 c00605a:	7023      	strb	r3, [r4, #0]
}
 c00605c:	bd10      	pop	{r4, pc}
    ret = BSP_ERROR_WRONG_PARAM;
 c00605e:	f06f 0001 	mvn.w	r0, #1
 c006062:	e7fb      	b.n	c00605c <BSP_OSPI_NOR_DisableMemoryMappedMode+0x18>
      ret = BSP_ERROR_OSPI_MMP_UNLOCK_FAILURE;
 c006064:	f06f 0014 	mvn.w	r0, #20
 c006068:	e7f8      	b.n	c00605c <BSP_OSPI_NOR_DisableMemoryMappedMode+0x18>
      ret = BSP_ERROR_PERIPH_FAILURE;
 c00606a:	f06f 0003 	mvn.w	r0, #3
  return ret;
 c00606e:	e7f5      	b.n	c00605c <BSP_OSPI_NOR_DisableMemoryMappedMode+0x18>
 c006070:	300302e4 	.word	0x300302e4
 c006074:	300302e8 	.word	0x300302e8

0c006078 <BSP_OSPI_NOR_DeInit>:
{
 c006078:	b510      	push	{r4, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c00607a:	2800      	cmp	r0, #0
 c00607c:	d152      	bne.n	c006124 <BSP_OSPI_NOR_DeInit+0xac>
    if (Ospi_Nor_Ctx[Instance].IsInitialized != OSPI_ACCESS_NONE)
 c00607e:	4c2b      	ldr	r4, [pc, #172]	; (c00612c <BSP_OSPI_NOR_DeInit+0xb4>)
 c006080:	7823      	ldrb	r3, [r4, #0]
 c006082:	b90b      	cbnz	r3, c006088 <BSP_OSPI_NOR_DeInit+0x10>
  int32_t ret = BSP_ERROR_NONE;
 c006084:	2000      	movs	r0, #0
}
 c006086:	bd10      	pop	{r4, pc}
      if(Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_MMP)
 c006088:	2b02      	cmp	r3, #2
 c00608a:	d044      	beq.n	c006116 <BSP_OSPI_NOR_DeInit+0x9e>
      Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_NONE;
 c00608c:	2300      	movs	r3, #0
  HAL_GPIO_DeInit(OSPI_CLK_GPIO_PORT, OSPI_CLK_PIN);
 c00608e:	2108      	movs	r1, #8
 c006090:	4827      	ldr	r0, [pc, #156]	; (c006130 <BSP_OSPI_NOR_DeInit+0xb8>)
      Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_NONE;
 c006092:	7023      	strb	r3, [r4, #0]
      Ospi_Nor_Ctx[Instance].InterfaceMode = BSP_OSPI_NOR_SPI_MODE;
 c006094:	7063      	strb	r3, [r4, #1]
      Ospi_Nor_Ctx[Instance].TransferRate  = BSP_OSPI_NOR_STR_TRANSFER;
 c006096:	70a3      	strb	r3, [r4, #2]
  HAL_GPIO_DeInit(OSPI_CLK_GPIO_PORT, OSPI_CLK_PIN);
 c006098:	f001 fc14 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_DQS_GPIO_PORT, OSPI_DQS_PIN);
 c00609c:	2104      	movs	r1, #4
 c00609e:	4825      	ldr	r0, [pc, #148]	; (c006134 <BSP_OSPI_NOR_DeInit+0xbc>)
 c0060a0:	f001 fc10 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_CS_GPIO_PORT, OSPI_CS_PIN);
 c0060a4:	2104      	movs	r1, #4
 c0060a6:	4822      	ldr	r0, [pc, #136]	; (c006130 <BSP_OSPI_NOR_DeInit+0xb8>)
 c0060a8:	f001 fc0c 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D0_GPIO_PORT, OSPI_D0_PIN);
 c0060ac:	2102      	movs	r1, #2
 c0060ae:	4821      	ldr	r0, [pc, #132]	; (c006134 <BSP_OSPI_NOR_DeInit+0xbc>)
 c0060b0:	f001 fc08 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D1_GPIO_PORT, OSPI_D1_PIN);
 c0060b4:	2101      	movs	r1, #1
 c0060b6:	481f      	ldr	r0, [pc, #124]	; (c006134 <BSP_OSPI_NOR_DeInit+0xbc>)
 c0060b8:	f001 fc04 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D2_GPIO_PORT, OSPI_D2_PIN);
 c0060bc:	2180      	movs	r1, #128	; 0x80
 c0060be:	481c      	ldr	r0, [pc, #112]	; (c006130 <BSP_OSPI_NOR_DeInit+0xb8>)
 c0060c0:	f001 fc00 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D3_GPIO_PORT, OSPI_D3_PIN);
 c0060c4:	2140      	movs	r1, #64	; 0x40
 c0060c6:	481a      	ldr	r0, [pc, #104]	; (c006130 <BSP_OSPI_NOR_DeInit+0xb8>)
 c0060c8:	f001 fbfc 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D4_GPIO_PORT, OSPI_D4_PIN);
 c0060cc:	2102      	movs	r1, #2
 c0060ce:	481a      	ldr	r0, [pc, #104]	; (c006138 <BSP_OSPI_NOR_DeInit+0xc0>)
 c0060d0:	f001 fbf8 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D5_GPIO_PORT, OSPI_D5_PIN);
 c0060d4:	2104      	movs	r1, #4
 c0060d6:	4818      	ldr	r0, [pc, #96]	; (c006138 <BSP_OSPI_NOR_DeInit+0xc0>)
 c0060d8:	f001 fbf4 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D6_GPIO_PORT, OSPI_D6_PIN);
 c0060dc:	2108      	movs	r1, #8
 c0060de:	4816      	ldr	r0, [pc, #88]	; (c006138 <BSP_OSPI_NOR_DeInit+0xc0>)
 c0060e0:	f001 fbf0 	bl	c0078c4 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D7_GPIO_PORT, OSPI_D7_PIN);
 c0060e4:	4814      	ldr	r0, [pc, #80]	; (c006138 <BSP_OSPI_NOR_DeInit+0xc0>)
 c0060e6:	2101      	movs	r1, #1
 c0060e8:	f001 fbec 	bl	c0078c4 <HAL_GPIO_DeInit>
  OSPI_FORCE_RESET();
 c0060ec:	4b13      	ldr	r3, [pc, #76]	; (c00613c <BSP_OSPI_NOR_DeInit+0xc4>)
      if (HAL_OSPI_DeInit(&hospi_nor[Instance]) != HAL_OK)
 c0060ee:	4814      	ldr	r0, [pc, #80]	; (c006140 <BSP_OSPI_NOR_DeInit+0xc8>)
  OSPI_FORCE_RESET();
 c0060f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c0060f2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c0060f6:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_RELEASE_RESET();
 c0060f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 c0060fa:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c0060fe:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_CLK_DISABLE();
 c006100:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 c006102:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c006106:	651a      	str	r2, [r3, #80]	; 0x50
      if (HAL_OSPI_DeInit(&hospi_nor[Instance]) != HAL_OK)
 c006108:	f002 f8f5 	bl	c0082f6 <HAL_OSPI_DeInit>
 c00610c:	2800      	cmp	r0, #0
 c00610e:	d0b9      	beq.n	c006084 <BSP_OSPI_NOR_DeInit+0xc>
        ret = BSP_ERROR_PERIPH_FAILURE;
 c006110:	f06f 0003 	mvn.w	r0, #3
 c006114:	e7b7      	b.n	c006086 <BSP_OSPI_NOR_DeInit+0xe>
        if(BSP_OSPI_NOR_DisableMemoryMappedMode(Instance) != BSP_ERROR_NONE)
 c006116:	f7ff ff95 	bl	c006044 <BSP_OSPI_NOR_DisableMemoryMappedMode>
 c00611a:	2800      	cmp	r0, #0
 c00611c:	d0b6      	beq.n	c00608c <BSP_OSPI_NOR_DeInit+0x14>
          return BSP_ERROR_COMPONENT_FAILURE;
 c00611e:	f06f 0004 	mvn.w	r0, #4
 c006122:	e7b0      	b.n	c006086 <BSP_OSPI_NOR_DeInit+0xe>
    ret = BSP_ERROR_WRONG_PARAM;
 c006124:	f06f 0001 	mvn.w	r0, #1
 c006128:	e7ad      	b.n	c006086 <BSP_OSPI_NOR_DeInit+0xe>
 c00612a:	bf00      	nop
 c00612c:	300302e4 	.word	0x300302e4
 c006130:	52020000 	.word	0x52020000
 c006134:	52020400 	.word	0x52020400
 c006138:	52020800 	.word	0x52020800
 c00613c:	50021000 	.word	0x50021000
 c006140:	300302e8 	.word	0x300302e8

0c006144 <BSP_OSPI_NOR_ConfigFlash>:
{
 c006144:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 c006148:	460e      	mov	r6, r1
 c00614a:	4617      	mov	r7, r2
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c00614c:	2800      	cmp	r0, #0
 c00614e:	d15d      	bne.n	c00620c <BSP_OSPI_NOR_ConfigFlash+0xc8>
    if(Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_MMP)
 c006150:	4c31      	ldr	r4, [pc, #196]	; (c006218 <BSP_OSPI_NOR_ConfigFlash+0xd4>)
 c006152:	7823      	ldrb	r3, [r4, #0]
 c006154:	2b02      	cmp	r3, #2
 c006156:	d05c      	beq.n	c006212 <BSP_OSPI_NOR_ConfigFlash+0xce>
      switch(Ospi_Nor_Ctx[Instance].InterfaceMode)
 c006158:	7863      	ldrb	r3, [r4, #1]
 c00615a:	2b01      	cmp	r3, #1
 c00615c:	d14d      	bne.n	c0061fa <BSP_OSPI_NOR_ConfigFlash+0xb6>
        if((Mode != BSP_OSPI_NOR_OPI_MODE) || (Rate != Ospi_Nor_Ctx[Instance].TransferRate))
 c00615e:	2901      	cmp	r1, #1
 c006160:	78a2      	ldrb	r2, [r4, #2]
 c006162:	d109      	bne.n	c006178 <BSP_OSPI_NOR_ConfigFlash+0x34>
 c006164:	4297      	cmp	r7, r2
 c006166:	d107      	bne.n	c006178 <BSP_OSPI_NOR_ConfigFlash+0x34>
        Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
 c006168:	2301      	movs	r3, #1
        Ospi_Nor_Ctx[Instance].TransferRate  = Rate;
 c00616a:	2000      	movs	r0, #0
        Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
 c00616c:	7023      	strb	r3, [r4, #0]
        Ospi_Nor_Ctx[Instance].InterfaceMode = Mode;
 c00616e:	7066      	strb	r6, [r4, #1]
        Ospi_Nor_Ctx[Instance].TransferRate  = Rate;
 c006170:	70a7      	strb	r7, [r4, #2]
}
 c006172:	b004      	add	sp, #16
 c006174:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  /* Enable write operations */
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c006178:	4d28      	ldr	r5, [pc, #160]	; (c00621c <BSP_OSPI_NOR_ConfigFlash+0xd8>)
 c00617a:	2101      	movs	r1, #1
 c00617c:	4628      	mov	r0, r5
 c00617e:	f7ff fb55 	bl	c00582c <MX25LM51245G_WriteEnable>
 c006182:	4603      	mov	r3, r0
 c006184:	b9b0      	cbnz	r0, c0061b4 <BSP_OSPI_NOR_ConfigFlash+0x70>
    ret = BSP_ERROR_COMPONENT_FAILURE;
  }
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
 c006186:	f8ad 000c 	strh.w	r0, [sp, #12]
    reg[1] = 0;
    if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, reg[0]) != MX25LM51245G_OK)
 c00618a:	9000      	str	r0, [sp, #0]
 c00618c:	78a2      	ldrb	r2, [r4, #2]
 c00618e:	7861      	ldrb	r1, [r4, #1]
 c006190:	4628      	mov	r0, r5
 c006192:	f7ff fc2d 	bl	c0059f0 <MX25LM51245G_WriteCfg2Register>
 c006196:	4680      	mov	r8, r0
 c006198:	b960      	cbnz	r0, c0061b4 <BSP_OSPI_NOR_ConfigFlash+0x70>
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
 c00619a:	2028      	movs	r0, #40	; 0x28
 c00619c:	f000 f99a 	bl	c0064d4 <HAL_Delay>

      if (Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_DTR_TRANSFER)
 c0061a0:	78a3      	ldrb	r3, [r4, #2]
 c0061a2:	2b01      	cmp	r3, #1
 c0061a4:	d009      	beq.n	c0061ba <BSP_OSPI_NOR_ConfigFlash+0x76>
      }

      if (ret == BSP_ERROR_NONE)
      {
        /* Check Flash busy ? */
        if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 c0061a6:	2200      	movs	r2, #0
 c0061a8:	481c      	ldr	r0, [pc, #112]	; (c00621c <BSP_OSPI_NOR_ConfigFlash+0xd8>)
 c0061aa:	4611      	mov	r1, r2
 c0061ac:	f7ff f897 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c0061b0:	4603      	mov	r3, r0
 c0061b2:	b170      	cbz	r0, c0061d2 <BSP_OSPI_NOR_ConfigFlash+0x8e>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        else if (reg[0] != 0U)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
 c0061b4:	f06f 0004 	mvn.w	r0, #4
 c0061b8:	e7db      	b.n	c006172 <BSP_OSPI_NOR_ConfigFlash+0x2e>
        if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 c0061ba:	4628      	mov	r0, r5
        hospi_nor[Instance].Init.MemoryType            = HAL_OSPI_MEMTYPE_MICRON;
 c0061bc:	f8c5 800c 	str.w	r8, [r5, #12]
        hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
 c0061c0:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
        if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 c0061c4:	f002 f826 	bl	c008214 <HAL_OSPI_Init>
 c0061c8:	2800      	cmp	r0, #0
 c0061ca:	d0ec      	beq.n	c0061a6 <BSP_OSPI_NOR_ConfigFlash+0x62>
          ret = BSP_ERROR_PERIPH_FAILURE;
 c0061cc:	f06f 0003 	mvn.w	r0, #3
 c0061d0:	e7cf      	b.n	c006172 <BSP_OSPI_NOR_ConfigFlash+0x2e>
        else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
 c0061d2:	aa03      	add	r2, sp, #12
 c0061d4:	9200      	str	r2, [sp, #0]
 c0061d6:	4601      	mov	r1, r0
 c0061d8:	4602      	mov	r2, r0
 c0061da:	4810      	ldr	r0, [pc, #64]	; (c00621c <BSP_OSPI_NOR_ConfigFlash+0xd8>)
 c0061dc:	f7ff fc65 	bl	c005aaa <MX25LM51245G_ReadCfg2Register>
 c0061e0:	2800      	cmp	r0, #0
 c0061e2:	d1e7      	bne.n	c0061b4 <BSP_OSPI_NOR_ConfigFlash+0x70>
        else if (reg[0] != 0U)
 c0061e4:	f89d 300c 	ldrb.w	r3, [sp, #12]
 c0061e8:	2b00      	cmp	r3, #0
 c0061ea:	d1e3      	bne.n	c0061b4 <BSP_OSPI_NOR_ConfigFlash+0x70>
          if ((ret == BSP_ERROR_NONE) && (Mode == BSP_OSPI_NOR_OPI_MODE))
 c0061ec:	2e01      	cmp	r6, #1
 c0061ee:	d1bb      	bne.n	c006168 <BSP_OSPI_NOR_ConfigFlash+0x24>
            if (Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 c0061f0:	78a3      	ldrb	r3, [r4, #2]
 c0061f2:	b933      	cbnz	r3, c006202 <BSP_OSPI_NOR_ConfigFlash+0xbe>
            ret = OSPI_NOR_EnterDOPIMode(Instance);
 c0061f4:	f7ff fdc8 	bl	c005d88 <OSPI_NOR_EnterDOPIMode.constprop.5>
 c0061f8:	e005      	b.n	c006206 <BSP_OSPI_NOR_ConfigFlash+0xc2>
        if(Mode == BSP_OSPI_NOR_OPI_MODE)
 c0061fa:	2901      	cmp	r1, #1
 c0061fc:	d1b4      	bne.n	c006168 <BSP_OSPI_NOR_ConfigFlash+0x24>
          if(Rate == BSP_OSPI_NOR_STR_TRANSFER)
 c0061fe:	2a00      	cmp	r2, #0
 c006200:	d1f8      	bne.n	c0061f4 <BSP_OSPI_NOR_ConfigFlash+0xb0>
            ret = OSPI_NOR_EnterSOPIMode(Instance);
 c006202:	f7ff fd79 	bl	c005cf8 <OSPI_NOR_EnterSOPIMode.constprop.4>
      if(ret == BSP_ERROR_NONE)
 c006206:	2800      	cmp	r0, #0
 c006208:	d1b3      	bne.n	c006172 <BSP_OSPI_NOR_ConfigFlash+0x2e>
 c00620a:	e7ad      	b.n	c006168 <BSP_OSPI_NOR_ConfigFlash+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
 c00620c:	f06f 0001 	mvn.w	r0, #1
 c006210:	e7af      	b.n	c006172 <BSP_OSPI_NOR_ConfigFlash+0x2e>
      ret = BSP_ERROR_OSPI_MMP_LOCK_FAILURE;
 c006212:	f06f 0015 	mvn.w	r0, #21
  return ret;
 c006216:	e7ac      	b.n	c006172 <BSP_OSPI_NOR_ConfigFlash+0x2e>
 c006218:	300302e4 	.word	0x300302e4
 c00621c:	300302e8 	.word	0x300302e8

0c006220 <BSP_OSPI_NOR_Init>:
{
 c006220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c006224:	460e      	mov	r6, r1
 c006226:	b09d      	sub	sp, #116	; 0x74
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 c006228:	2800      	cmp	r0, #0
 c00622a:	f040 812e 	bne.w	c00648a <BSP_OSPI_NOR_Init+0x26a>
    if (Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_NONE)
 c00622e:	4d9a      	ldr	r5, [pc, #616]	; (c006498 <BSP_OSPI_NOR_Init+0x278>)
 c006230:	f895 b000 	ldrb.w	fp, [r5]
 c006234:	f1bb 0f00 	cmp.w	fp, #0
 c006238:	f040 8125 	bne.w	c006486 <BSP_OSPI_NOR_Init+0x266>
  OSPI_CLK_ENABLE();
 c00623c:	4b97      	ldr	r3, [pc, #604]	; (c00649c <BSP_OSPI_NOR_Init+0x27c>)
  GPIO_InitStruct.Alternate = OSPI_CS_PIN_AF;
 c00623e:	240a      	movs	r4, #10
  OSPI_CLK_ENABLE();
 c006240:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 c006242:	f04f 0904 	mov.w	r9, #4
  OSPI_CLK_ENABLE();
 c006246:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c00624a:	651a      	str	r2, [r3, #80]	; 0x50
 c00624c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 c00624e:	f04f 0a02 	mov.w	sl, #2
  OSPI_CLK_ENABLE();
 c006252:	f402 7280 	and.w	r2, r2, #256	; 0x100
 c006256:	9203      	str	r2, [sp, #12]
 c006258:	9a03      	ldr	r2, [sp, #12]
  OSPI_FORCE_RESET();
 c00625a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 c00625c:	f04f 0801 	mov.w	r8, #1
  OSPI_FORCE_RESET();
 c006260:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c006264:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_RELEASE_RESET();
 c006266:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 c006268:	2703      	movs	r7, #3
  OSPI_RELEASE_RESET();
 c00626a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c00626e:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_CLK_GPIO_CLK_ENABLE();
 c006270:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 c006272:	a913      	add	r1, sp, #76	; 0x4c
  OSPI_CLK_GPIO_CLK_ENABLE();
 c006274:	f042 0201 	orr.w	r2, r2, #1
 c006278:	64da      	str	r2, [r3, #76]	; 0x4c
 c00627a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 c00627c:	4888      	ldr	r0, [pc, #544]	; (c0064a0 <BSP_OSPI_NOR_Init+0x280>)
  OSPI_CLK_GPIO_CLK_ENABLE();
 c00627e:	f002 0201 	and.w	r2, r2, #1
 c006282:	9204      	str	r2, [sp, #16]
 c006284:	9a04      	ldr	r2, [sp, #16]
  OSPI_DQS_GPIO_CLK_ENABLE();
 c006286:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c006288:	f042 0202 	orr.w	r2, r2, #2
 c00628c:	64da      	str	r2, [r3, #76]	; 0x4c
 c00628e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c006290:	f002 0202 	and.w	r2, r2, #2
 c006294:	9205      	str	r2, [sp, #20]
 c006296:	9a05      	ldr	r2, [sp, #20]
  OSPI_CS_GPIO_CLK_ENABLE();
 c006298:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00629a:	f042 0201 	orr.w	r2, r2, #1
 c00629e:	64da      	str	r2, [r3, #76]	; 0x4c
 c0062a0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062a2:	f002 0201 	and.w	r2, r2, #1
 c0062a6:	9206      	str	r2, [sp, #24]
 c0062a8:	9a06      	ldr	r2, [sp, #24]
  OSPI_D0_GPIO_CLK_ENABLE();
 c0062aa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062ac:	f042 0202 	orr.w	r2, r2, #2
 c0062b0:	64da      	str	r2, [r3, #76]	; 0x4c
 c0062b2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062b4:	f002 0202 	and.w	r2, r2, #2
 c0062b8:	9207      	str	r2, [sp, #28]
 c0062ba:	9a07      	ldr	r2, [sp, #28]
  OSPI_D1_GPIO_CLK_ENABLE();
 c0062bc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062be:	f042 0202 	orr.w	r2, r2, #2
 c0062c2:	64da      	str	r2, [r3, #76]	; 0x4c
 c0062c4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062c6:	f002 0202 	and.w	r2, r2, #2
 c0062ca:	9208      	str	r2, [sp, #32]
 c0062cc:	9a08      	ldr	r2, [sp, #32]
  OSPI_D2_GPIO_CLK_ENABLE();
 c0062ce:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062d0:	f042 0201 	orr.w	r2, r2, #1
 c0062d4:	64da      	str	r2, [r3, #76]	; 0x4c
 c0062d6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062d8:	f002 0201 	and.w	r2, r2, #1
 c0062dc:	9209      	str	r2, [sp, #36]	; 0x24
 c0062de:	9a09      	ldr	r2, [sp, #36]	; 0x24
  OSPI_D3_GPIO_CLK_ENABLE();
 c0062e0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062e2:	f042 0201 	orr.w	r2, r2, #1
 c0062e6:	64da      	str	r2, [r3, #76]	; 0x4c
 c0062e8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062ea:	f002 0201 	and.w	r2, r2, #1
 c0062ee:	920a      	str	r2, [sp, #40]	; 0x28
 c0062f0:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  OSPI_D4_GPIO_CLK_ENABLE();
 c0062f2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062f4:	f042 0204 	orr.w	r2, r2, #4
 c0062f8:	64da      	str	r2, [r3, #76]	; 0x4c
 c0062fa:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c0062fc:	f002 0204 	and.w	r2, r2, #4
 c006300:	920b      	str	r2, [sp, #44]	; 0x2c
 c006302:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  OSPI_D5_GPIO_CLK_ENABLE();
 c006304:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c006306:	f042 0204 	orr.w	r2, r2, #4
 c00630a:	64da      	str	r2, [r3, #76]	; 0x4c
 c00630c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00630e:	f002 0204 	and.w	r2, r2, #4
 c006312:	920c      	str	r2, [sp, #48]	; 0x30
 c006314:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  OSPI_D6_GPIO_CLK_ENABLE();
 c006316:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c006318:	f042 0204 	orr.w	r2, r2, #4
 c00631c:	64da      	str	r2, [r3, #76]	; 0x4c
 c00631e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c006320:	f002 0204 	and.w	r2, r2, #4
 c006324:	920d      	str	r2, [sp, #52]	; 0x34
 c006326:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  OSPI_D7_GPIO_CLK_ENABLE();
 c006328:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 c00632a:	f042 0204 	orr.w	r2, r2, #4
 c00632e:	64da      	str	r2, [r3, #76]	; 0x4c
 c006330:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c006332:	f003 0304 	and.w	r3, r3, #4
 c006336:	930e      	str	r3, [sp, #56]	; 0x38
 c006338:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 c00633a:	e9cd 9a13 	strd	r9, sl, [sp, #76]	; 0x4c
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 c00633e:	e9cd 8715 	strd	r8, r7, [sp, #84]	; 0x54
  GPIO_InitStruct.Alternate = OSPI_CS_PIN_AF;
 c006342:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 c006344:	f001 f9f6 	bl	c007734 <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_DQS_GPIO_PORT, &GPIO_InitStruct);
 c006348:	a913      	add	r1, sp, #76	; 0x4c
 c00634a:	4856      	ldr	r0, [pc, #344]	; (c0064a4 <BSP_OSPI_NOR_Init+0x284>)
  GPIO_InitStruct.Pin       = OSPI_DQS_PIN;
 c00634c:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_DQS_PIN_AF;
 c006350:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_DQS_GPIO_PORT, &GPIO_InitStruct);
 c006352:	f001 f9ef 	bl	c007734 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_CLK_PIN;
 c006356:	2308      	movs	r3, #8
  HAL_GPIO_Init(OSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 c006358:	a913      	add	r1, sp, #76	; 0x4c
 c00635a:	4851      	ldr	r0, [pc, #324]	; (c0064a0 <BSP_OSPI_NOR_Init+0x280>)
  GPIO_InitStruct.Pin       = OSPI_CLK_PIN;
 c00635c:	9313      	str	r3, [sp, #76]	; 0x4c
 c00635e:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 c006360:	f8cd b054 	str.w	fp, [sp, #84]	; 0x54
  GPIO_InitStruct.Alternate = OSPI_CLK_PIN_AF;
 c006364:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 c006366:	f001 f9e5 	bl	c007734 <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 c00636a:	a913      	add	r1, sp, #76	; 0x4c
 c00636c:	484d      	ldr	r0, [pc, #308]	; (c0064a4 <BSP_OSPI_NOR_Init+0x284>)
  GPIO_InitStruct.Pin       = OSPI_D0_PIN;
 c00636e:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D0_PIN_AF;
 c006372:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 c006374:	f001 f9de 	bl	c007734 <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 c006378:	a913      	add	r1, sp, #76	; 0x4c
 c00637a:	484a      	ldr	r0, [pc, #296]	; (c0064a4 <BSP_OSPI_NOR_Init+0x284>)
  GPIO_InitStruct.Pin       = OSPI_D1_PIN;
 c00637c:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D1_PIN_AF;
 c006380:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 c006382:	f001 f9d7 	bl	c007734 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_D2_PIN;
 c006386:	2280      	movs	r2, #128	; 0x80
  HAL_GPIO_Init(OSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 c006388:	a913      	add	r1, sp, #76	; 0x4c
 c00638a:	4845      	ldr	r0, [pc, #276]	; (c0064a0 <BSP_OSPI_NOR_Init+0x280>)
  GPIO_InitStruct.Pin       = OSPI_D2_PIN;
 c00638c:	9213      	str	r2, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D2_PIN_AF;
 c00638e:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 c006390:	f001 f9d0 	bl	c007734 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_D3_PIN;
 c006394:	2240      	movs	r2, #64	; 0x40
  HAL_GPIO_Init(OSPI_D3_GPIO_PORT, &GPIO_InitStruct);
 c006396:	a913      	add	r1, sp, #76	; 0x4c
 c006398:	4841      	ldr	r0, [pc, #260]	; (c0064a0 <BSP_OSPI_NOR_Init+0x280>)
  GPIO_InitStruct.Pin       = OSPI_D3_PIN;
 c00639a:	9213      	str	r2, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D3_PIN_AF;
 c00639c:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D3_GPIO_PORT, &GPIO_InitStruct);
 c00639e:	f001 f9c9 	bl	c007734 <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D4_GPIO_PORT, &GPIO_InitStruct);
 c0063a2:	a913      	add	r1, sp, #76	; 0x4c
 c0063a4:	4840      	ldr	r0, [pc, #256]	; (c0064a8 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D4_PIN;
 c0063a6:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D4_PIN_AF;
 c0063aa:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D4_GPIO_PORT, &GPIO_InitStruct);
 c0063ac:	f001 f9c2 	bl	c007734 <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D5_GPIO_PORT, &GPIO_InitStruct);
 c0063b0:	a913      	add	r1, sp, #76	; 0x4c
 c0063b2:	483d      	ldr	r0, [pc, #244]	; (c0064a8 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D5_PIN;
 c0063b4:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D5_PIN_AF;
 c0063b8:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D5_GPIO_PORT, &GPIO_InitStruct);
 c0063ba:	f001 f9bb 	bl	c007734 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_D6_PIN;
 c0063be:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_Init(OSPI_D6_GPIO_PORT, &GPIO_InitStruct);
 c0063c0:	a913      	add	r1, sp, #76	; 0x4c
 c0063c2:	4839      	ldr	r0, [pc, #228]	; (c0064a8 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D6_PIN;
 c0063c4:	9313      	str	r3, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D6_PIN_AF;
 c0063c6:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D6_GPIO_PORT, &GPIO_InitStruct);
 c0063c8:	f001 f9b4 	bl	c007734 <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D7_GPIO_PORT, &GPIO_InitStruct);
 c0063cc:	a913      	add	r1, sp, #76	; 0x4c
 c0063ce:	4836      	ldr	r0, [pc, #216]	; (c0064a8 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D7_PIN;
 c0063d0:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D7_PIN_AF;
 c0063d4:	9717      	str	r7, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D7_GPIO_PORT, &GPIO_InitStruct);
 c0063d6:	f001 f9ad 	bl	c007734 <HAL_GPIO_Init>
      (void)MX25LM51245G_GetFlashInfo(&pInfo);
 c0063da:	a813      	add	r0, sp, #76	; 0x4c
 c0063dc:	f7fe ff66 	bl	c0052ac <MX25LM51245G_GetFlashInfo>
      ospi_init.ClockPrescaler = 3; /* OctoSPI clock = 120MHz / ClockPrescaler = 40MHz */
 c0063e0:	9710      	str	r7, [sp, #64]	; 0x40
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 c0063e2:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 c0063e4:	fa93 f3a3 	rbit	r3, r3
  return __builtin_clz(value);
 c0063e8:	fab3 f383 	clz	r3, r3
      ospi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
 c0063ec:	930f      	str	r3, [sp, #60]	; 0x3c
      ospi_init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
 c0063ee:	2300      	movs	r3, #0
 c0063f0:	9311      	str	r3, [sp, #68]	; 0x44
      ospi_init.TransferRate   = (uint32_t) Init->TransferRate;
 c0063f2:	7873      	ldrb	r3, [r6, #1]
      if (MX_OSPI_NOR_Init(&hospi_nor[Instance], &ospi_init) != HAL_OK)
 c0063f4:	a90f      	add	r1, sp, #60	; 0x3c
 c0063f6:	482d      	ldr	r0, [pc, #180]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
      ospi_init.TransferRate   = (uint32_t) Init->TransferRate;
 c0063f8:	9312      	str	r3, [sp, #72]	; 0x48
      if (MX_OSPI_NOR_Init(&hospi_nor[Instance], &ospi_init) != HAL_OK)
 c0063fa:	f7ff fd19 	bl	c005e30 <MX_OSPI_NOR_Init>
 c0063fe:	4602      	mov	r2, r0
 c006400:	2800      	cmp	r0, #0
 c006402:	d145      	bne.n	c006490 <BSP_OSPI_NOR_Init+0x270>
  else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 c006404:	4601      	mov	r1, r0
 c006406:	4829      	ldr	r0, [pc, #164]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c006408:	f7ff fc17 	bl	c005c3a <MX25LM51245G_ResetEnable>
 c00640c:	4602      	mov	r2, r0
 c00640e:	b120      	cbz	r0, c00641a <BSP_OSPI_NOR_Init+0x1fa>
        ret = BSP_ERROR_COMPONENT_FAILURE;
 c006410:	f06f 0004 	mvn.w	r0, #4
}
 c006414:	b01d      	add	sp, #116	; 0x74
 c006416:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 c00641a:	4601      	mov	r1, r0
 c00641c:	4823      	ldr	r0, [pc, #140]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c00641e:	f7ff fc3b 	bl	c005c98 <MX25LM51245G_ResetMemory>
 c006422:	4602      	mov	r2, r0
 c006424:	2800      	cmp	r0, #0
 c006426:	d1f3      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 c006428:	2101      	movs	r1, #1
 c00642a:	4820      	ldr	r0, [pc, #128]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c00642c:	f7ff fc05 	bl	c005c3a <MX25LM51245G_ResetEnable>
 c006430:	4602      	mov	r2, r0
 c006432:	2800      	cmp	r0, #0
 c006434:	d1ec      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 c006436:	2101      	movs	r1, #1
 c006438:	481c      	ldr	r0, [pc, #112]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c00643a:	f7ff fc2d 	bl	c005c98 <MX25LM51245G_ResetMemory>
 c00643e:	2800      	cmp	r0, #0
 c006440:	d1e6      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
 c006442:	2201      	movs	r2, #1
 c006444:	4819      	ldr	r0, [pc, #100]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c006446:	4611      	mov	r1, r2
 c006448:	f7ff fbf7 	bl	c005c3a <MX25LM51245G_ResetEnable>
 c00644c:	2800      	cmp	r0, #0
 c00644e:	d1df      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
 c006450:	2201      	movs	r2, #1
 c006452:	4816      	ldr	r0, [pc, #88]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c006454:	4611      	mov	r1, r2
 c006456:	f7ff fc1f 	bl	c005c98 <MX25LM51245G_ResetMemory>
 c00645a:	2800      	cmp	r0, #0
 c00645c:	d1d8      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
    Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access   */
 c00645e:	2301      	movs	r3, #1
    Ospi_Nor_Ctx[Instance].InterfaceMode = BSP_OSPI_NOR_SPI_MODE;         /* After reset H/W back to SPI mode by default  */
 c006460:	7068      	strb	r0, [r5, #1]
    Ospi_Nor_Ctx[Instance].TransferRate  = BSP_OSPI_NOR_STR_TRANSFER;     /* After reset S/W setting to STR mode          */
 c006462:	70a8      	strb	r0, [r5, #2]
    HAL_Delay(MX25LM51245G_RESET_MAX_TIME);
 c006464:	2064      	movs	r0, #100	; 0x64
    Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access   */
 c006466:	702b      	strb	r3, [r5, #0]
    HAL_Delay(MX25LM51245G_RESET_MAX_TIME);
 c006468:	f000 f834 	bl	c0064d4 <HAL_Delay>
      else if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 c00646c:	78aa      	ldrb	r2, [r5, #2]
 c00646e:	7869      	ldrb	r1, [r5, #1]
 c006470:	480e      	ldr	r0, [pc, #56]	; (c0064ac <BSP_OSPI_NOR_Init+0x28c>)
 c006472:	f7fe ff34 	bl	c0052de <MX25LM51245G_AutoPollingMemReady>
 c006476:	2800      	cmp	r0, #0
 c006478:	d1ca      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
      else if (BSP_OSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
 c00647a:	7872      	ldrb	r2, [r6, #1]
 c00647c:	7831      	ldrb	r1, [r6, #0]
 c00647e:	f7ff fe61 	bl	c006144 <BSP_OSPI_NOR_ConfigFlash>
 c006482:	2800      	cmp	r0, #0
 c006484:	d1c4      	bne.n	c006410 <BSP_OSPI_NOR_Init+0x1f0>
        ret = BSP_ERROR_NONE;
 c006486:	2000      	movs	r0, #0
 c006488:	e7c4      	b.n	c006414 <BSP_OSPI_NOR_Init+0x1f4>
    ret = BSP_ERROR_WRONG_PARAM;
 c00648a:	f06f 0001 	mvn.w	r0, #1
 c00648e:	e7c1      	b.n	c006414 <BSP_OSPI_NOR_Init+0x1f4>
        ret = BSP_ERROR_PERIPH_FAILURE;
 c006490:	f06f 0003 	mvn.w	r0, #3
  return ret;
 c006494:	e7be      	b.n	c006414 <BSP_OSPI_NOR_Init+0x1f4>
 c006496:	bf00      	nop
 c006498:	300302e4 	.word	0x300302e4
 c00649c:	50021000 	.word	0x50021000
 c0064a0:	52020000 	.word	0x52020000
 c0064a4:	52020400 	.word	0x52020400
 c0064a8:	52020800 	.word	0x52020800
 c0064ac:	300302e8 	.word	0x300302e8

0c0064b0 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 c0064b0:	4770      	bx	lr

0c0064b2 <HAL_Init>:
{
 c0064b2:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 c0064b4:	2004      	movs	r0, #4
 c0064b6:	f000 f81f 	bl	c0064f8 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 c0064ba:	f7fe fac9 	bl	c004a50 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 c0064be:	2007      	movs	r0, #7
 c0064c0:	f7fc ffe2 	bl	c003488 <HAL_InitTick>
 c0064c4:	4604      	mov	r4, r0
 c0064c6:	b918      	cbnz	r0, c0064d0 <HAL_Init+0x1e>
    HAL_MspInit();
 c0064c8:	f7ff fff2 	bl	c0064b0 <HAL_MspInit>
}
 c0064cc:	4620      	mov	r0, r4
 c0064ce:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 c0064d0:	2401      	movs	r4, #1
 c0064d2:	e7fb      	b.n	c0064cc <HAL_Init+0x1a>

0c0064d4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 c0064d4:	b538      	push	{r3, r4, r5, lr}
 c0064d6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 c0064d8:	f7fc ffe4 	bl	c0034a4 <HAL_GetTick>
 c0064dc:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 c0064de:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)uwTickFreq;
 c0064e0:	bf1e      	ittt	ne
 c0064e2:	4b04      	ldrne	r3, [pc, #16]	; (c0064f4 <HAL_Delay+0x20>)
 c0064e4:	781b      	ldrbne	r3, [r3, #0]
 c0064e6:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 c0064e8:	f7fc ffdc 	bl	c0034a4 <HAL_GetTick>
 c0064ec:	1b40      	subs	r0, r0, r5
 c0064ee:	42a0      	cmp	r0, r4
 c0064f0:	d3fa      	bcc.n	c0064e8 <HAL_Delay+0x14>
  {
  }
}
 c0064f2:	bd38      	pop	{r3, r4, r5, pc}
 c0064f4:	300300ac 	.word	0x300300ac

0c0064f8 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c0064f8:	4a07      	ldr	r2, [pc, #28]	; (c006518 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c0064fa:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 c0064fc:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 c0064fe:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 c006502:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 c006506:	041b      	lsls	r3, r3, #16
 c006508:	0c1b      	lsrs	r3, r3, #16
 c00650a:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 c00650e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 c006512:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 c006514:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 c006516:	4770      	bx	lr
 c006518:	e000ed00 	.word	0xe000ed00

0c00651c <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 c00651c:	4b17      	ldr	r3, [pc, #92]	; (c00657c <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 c00651e:	b570      	push	{r4, r5, r6, lr}
 c006520:	68dc      	ldr	r4, [r3, #12]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c006522:	f04f 36ff 	mov.w	r6, #4294967295
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 c006526:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 c00652a:	f1c4 0507 	rsb	r5, r4, #7
 c00652e:	2d03      	cmp	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c006530:	f104 0303 	add.w	r3, r4, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 c006534:	bf28      	it	cs
 c006536:	2503      	movcs	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c006538:	2b06      	cmp	r3, #6
 c00653a:	bf98      	it	ls
 c00653c:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c00653e:	fa06 f305 	lsl.w	r3, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 c006542:	bf88      	it	hi
 c006544:	3c04      	subhi	r4, #4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c006546:	ea21 0303 	bic.w	r3, r1, r3
 c00654a:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 c00654c:	fa06 f404 	lsl.w	r4, r6, r4
 c006550:	ea22 0404 	bic.w	r4, r2, r4
  if ((int32_t)(IRQn) >= 0)
 c006554:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 c006556:	ea43 0304 	orr.w	r3, r3, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c00655a:	bfa8      	it	ge
 c00655c:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 c006560:	ea4f 1343 	mov.w	r3, r3, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c006564:	bfb8      	it	lt
 c006566:	4a06      	ldrlt	r2, [pc, #24]	; (c006580 <HAL_NVIC_SetPriority+0x64>)
 c006568:	b2db      	uxtb	r3, r3
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c00656a:	bfab      	itete	ge
 c00656c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c006570:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c006574:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 c006578:	5413      	strblt	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 c00657a:	bd70      	pop	{r4, r5, r6, pc}
 c00657c:	e000ed00 	.word	0xe000ed00
 c006580:	e000ed14 	.word	0xe000ed14

0c006584 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 c006584:	2800      	cmp	r0, #0
 c006586:	db08      	blt.n	c00659a <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 c006588:	2301      	movs	r3, #1
 c00658a:	0942      	lsrs	r2, r0, #5
 c00658c:	f000 001f 	and.w	r0, r0, #31
 c006590:	fa03 f000 	lsl.w	r0, r3, r0
 c006594:	4b01      	ldr	r3, [pc, #4]	; (c00659c <HAL_NVIC_EnableIRQ+0x18>)
 c006596:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 c00659a:	4770      	bx	lr
 c00659c:	e000e100 	.word	0xe000e100

0c0065a0 <HAL_NVIC_SystemReset>:
  __ASM volatile ("dsb 0xF":::"memory");
 c0065a0:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c0065a4:	4905      	ldr	r1, [pc, #20]	; (c0065bc <HAL_NVIC_SystemReset+0x1c>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c0065a6:	4b06      	ldr	r3, [pc, #24]	; (c0065c0 <HAL_NVIC_SystemReset+0x20>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 c0065a8:	68ca      	ldr	r2, [r1, #12]
 c0065aa:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 c0065ae:	4313      	orrs	r3, r2
 c0065b0:	60cb      	str	r3, [r1, #12]
 c0065b2:	f3bf 8f4f 	dsb	sy
    __NOP();
 c0065b6:	bf00      	nop
 c0065b8:	e7fd      	b.n	c0065b6 <HAL_NVIC_SystemReset+0x16>
 c0065ba:	bf00      	nop
 c0065bc:	e000ed00 	.word	0xe000ed00
 c0065c0:	05fa0004 	.word	0x05fa0004

0c0065c4 <CRYP_SetKey>:
  *         occurs when the key is written out of HAL scope.
  * @retval None
  */
static void CRYP_SetKey(CRYP_HandleTypeDef *hcryp, uint32_t KeySize)
{
  if (hcryp->Init.pKey != NULL)
 c0065c4:	68c3      	ldr	r3, [r0, #12]
 c0065c6:	b1a3      	cbz	r3, c0065f2 <CRYP_SetKey+0x2e>
  {
    switch (KeySize)
 c0065c8:	b1a1      	cbz	r1, c0065f4 <CRYP_SetKey+0x30>
 c0065ca:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 c0065ce:	d110      	bne.n	c0065f2 <CRYP_SetKey+0x2e>
    {
      case CRYP_KEYSIZE_256B:
        hcryp->Instance->KEYR7 = *(uint32_t *)(hcryp->Init.pKey);
 c0065d0:	6819      	ldr	r1, [r3, #0]
 c0065d2:	6802      	ldr	r2, [r0, #0]
 c0065d4:	63d1      	str	r1, [r2, #60]	; 0x3c
        hcryp->Instance->KEYR6 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 c0065d6:	6859      	ldr	r1, [r3, #4]
 c0065d8:	6391      	str	r1, [r2, #56]	; 0x38
        hcryp->Instance->KEYR5 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 c0065da:	6899      	ldr	r1, [r3, #8]
 c0065dc:	6351      	str	r1, [r2, #52]	; 0x34
        hcryp->Instance->KEYR4 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 c0065de:	68d9      	ldr	r1, [r3, #12]
 c0065e0:	6311      	str	r1, [r2, #48]	; 0x30
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey + 4U);
 c0065e2:	6919      	ldr	r1, [r3, #16]
 c0065e4:	61d1      	str	r1, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 5U);
 c0065e6:	6959      	ldr	r1, [r3, #20]
 c0065e8:	6191      	str	r1, [r2, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 6U);
 c0065ea:	6999      	ldr	r1, [r3, #24]
 c0065ec:	6151      	str	r1, [r2, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 7U);
 c0065ee:	69db      	ldr	r3, [r3, #28]
        break;
      case CRYP_KEYSIZE_128B:
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 c0065f0:	6113      	str	r3, [r2, #16]
        break;
      default:
        break;
    }
  }
}
 c0065f2:	4770      	bx	lr
        hcryp->Instance->KEYR3 = *(uint32_t *)(hcryp->Init.pKey);
 c0065f4:	6819      	ldr	r1, [r3, #0]
 c0065f6:	6802      	ldr	r2, [r0, #0]
 c0065f8:	61d1      	str	r1, [r2, #28]
        hcryp->Instance->KEYR2 = *(uint32_t *)(hcryp->Init.pKey + 1U);
 c0065fa:	6859      	ldr	r1, [r3, #4]
 c0065fc:	6191      	str	r1, [r2, #24]
        hcryp->Instance->KEYR1 = *(uint32_t *)(hcryp->Init.pKey + 2U);
 c0065fe:	6899      	ldr	r1, [r3, #8]
 c006600:	6151      	str	r1, [r2, #20]
        hcryp->Instance->KEYR0 = *(uint32_t *)(hcryp->Init.pKey + 3U);
 c006602:	68db      	ldr	r3, [r3, #12]
 c006604:	e7f4      	b.n	c0065f0 <CRYP_SetKey+0x2c>

0c006606 <CRYP_WaitOnCCFlag>:
  * @param  Timeout Timeout duration.
  * @note   This function can only be used in thread mode.
  * @retval HAL status
  */
static HAL_StatusTypeDef CRYP_WaitOnCCFlag(CRYP_HandleTypeDef *hcryp, uint32_t Timeout)
{
 c006606:	b570      	push	{r4, r5, r6, lr}
 c006608:	4606      	mov	r6, r0
 c00660a:	460c      	mov	r4, r1
  uint32_t tickstart;

  /* Get timeout */
  tickstart = HAL_GetTick();
 c00660c:	f7fc ff4a 	bl	c0034a4 <HAL_GetTick>
 c006610:	4605      	mov	r5, r0

  while (HAL_IS_BIT_CLR(hcryp->Instance->SR, AES_SR_CCF))
 c006612:	6832      	ldr	r2, [r6, #0]
 c006614:	6853      	ldr	r3, [r2, #4]
 c006616:	07db      	lsls	r3, r3, #31
 c006618:	d501      	bpl.n	c00661e <CRYP_WaitOnCCFlag+0x18>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 c00661a:	2000      	movs	r0, #0
}
 c00661c:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 c00661e:	1c61      	adds	r1, r4, #1
 c006620:	d0f8      	beq.n	c006614 <CRYP_WaitOnCCFlag+0xe>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c006622:	f7fc ff3f 	bl	c0034a4 <HAL_GetTick>
 c006626:	1b40      	subs	r0, r0, r5
 c006628:	42a0      	cmp	r0, r4
 c00662a:	d801      	bhi.n	c006630 <CRYP_WaitOnCCFlag+0x2a>
 c00662c:	2c00      	cmp	r4, #0
 c00662e:	d1f0      	bne.n	c006612 <CRYP_WaitOnCCFlag+0xc>
        return HAL_ERROR;
 c006630:	2001      	movs	r0, #1
 c006632:	e7f3      	b.n	c00661c <CRYP_WaitOnCCFlag+0x16>

0c006634 <CRYP_GCMCCM_SetHeaderPhase>:
{
 c006634:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c006638:	b08c      	sub	sp, #48	; 0x30
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 c00663a:	466d      	mov	r5, sp
{
 c00663c:	4604      	mov	r4, r0
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 c00663e:	4e78      	ldr	r6, [pc, #480]	; (c006820 <CRYP_GCMCCM_SetHeaderPhase+0x1ec>)
{
 c006640:	460f      	mov	r7, r1
  uint32_t mask[12] = {0x0U, 0xFF000000U, 0xFFFF0000U, 0xFFFFFF00U,  /* 32-bit data type */
 c006642:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c006644:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c006646:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 c006648:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 c00664a:	e896 000f 	ldmia.w	r6, {r0, r1, r2, r3}
 c00664e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
  if (hcryp->Init.HeaderWidthUnit == CRYP_HEADERWIDTHUNIT_WORD)
 c006652:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c006654:	69e5      	ldr	r5, [r4, #28]
 c006656:	b903      	cbnz	r3, c00665a <CRYP_GCMCCM_SetHeaderPhase+0x26>
    size_in_bytes = hcryp->Init.HeaderSize * 4U;
 c006658:	00ad      	lsls	r5, r5, #2
 c00665a:	6823      	ldr	r3, [r4, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c00665c:	681a      	ldr	r2, [r3, #0]
  if ((size_in_bytes != 0U))
 c00665e:	2d00      	cmp	r5, #0
 c006660:	f000 80cd 	beq.w	c0067fe <CRYP_GCMCCM_SetHeaderPhase+0x1ca>
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c006664:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 c006668:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 c00666c:	601a      	str	r2, [r3, #0]
    __HAL_CRYP_ENABLE(hcryp);
 c00666e:	681a      	ldr	r2, [r3, #0]
    if ((size_in_bytes % 16U) == 0U)
 c006670:	f015 060f 	ands.w	r6, r5, #15
    __HAL_CRYP_ENABLE(hcryp);
 c006674:	f042 0201 	orr.w	r2, r2, #1
 c006678:	601a      	str	r2, [r3, #0]
    if ((size_in_bytes % 16U) == 0U)
 c00667a:	d022      	beq.n	c0066c2 <CRYP_GCMCCM_SetHeaderPhase+0x8e>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 c00667c:	2600      	movs	r6, #0
 c00667e:	ea4f 1815 	mov.w	r8, r5, lsr #4
 c006682:	ea4f 0888 	mov.w	r8, r8, lsl #2
 c006686:	45b0      	cmp	r8, r6
 c006688:	6823      	ldr	r3, [r4, #0]
 c00668a:	d861      	bhi.n	c006750 <CRYP_GCMCCM_SetHeaderPhase+0x11c>
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 c00668c:	2100      	movs	r1, #0
 c00668e:	f3c5 0281 	ubfx	r2, r5, #2, #2
 c006692:	428a      	cmp	r2, r1
 c006694:	f040 808e 	bne.w	c0067b4 <CRYP_GCMCCM_SetHeaderPhase+0x180>
      if ((size_in_bytes % 4U) == 0U)
 c006698:	f015 0503 	ands.w	r5, r5, #3
 c00669c:	f040 8096 	bne.w	c0067cc <CRYP_GCMCCM_SetHeaderPhase+0x198>
          loopcounter++;
 c0066a0:	3101      	adds	r1, #1
        while (loopcounter < 4U)
 c0066a2:	2904      	cmp	r1, #4
          hcryp->Instance->DINR = 0x0U;
 c0066a4:	609d      	str	r5, [r3, #8]
        while (loopcounter < 4U)
 c0066a6:	d1fb      	bne.n	c0066a0 <CRYP_GCMCCM_SetHeaderPhase+0x6c>
      if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c0066a8:	4639      	mov	r1, r7
 c0066aa:	4620      	mov	r0, r4
 c0066ac:	f7ff ffab 	bl	c006606 <CRYP_WaitOnCCFlag>
 c0066b0:	6823      	ldr	r3, [r4, #0]
 c0066b2:	2800      	cmp	r0, #0
 c0066b4:	f040 80a1 	bne.w	c0067fa <CRYP_GCMCCM_SetHeaderPhase+0x1c6>
      __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c0066b8:	681a      	ldr	r2, [r3, #0]
 c0066ba:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c0066be:	601a      	str	r2, [r3, #0]
 c0066c0:	e003      	b.n	c0066ca <CRYP_GCMCCM_SetHeaderPhase+0x96>
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 c0066c2:	08ad      	lsrs	r5, r5, #2
 c0066c4:	42b5      	cmp	r5, r6
 c0066c6:	d803      	bhi.n	c0066d0 <CRYP_GCMCCM_SetHeaderPhase+0x9c>
  return HAL_OK;
 c0066c8:	2000      	movs	r0, #0
}
 c0066ca:	b00c      	add	sp, #48	; 0x30
 c0066cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0066d0:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c0066d2:	69a1      	ldr	r1, [r4, #24]
 c0066d4:	b29b      	uxth	r3, r3
 c0066d6:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c0066da:	6822      	ldr	r2, [r4, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c0066dc:	4620      	mov	r0, r4
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0066de:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 c0066e0:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c0066e2:	3301      	adds	r3, #1
 c0066e4:	b29b      	uxth	r3, r3
 c0066e6:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0066e8:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c0066ea:	b29b      	uxth	r3, r3
 c0066ec:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c0066f0:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 c0066f2:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c0066f4:	3301      	adds	r3, #1
 c0066f6:	b29b      	uxth	r3, r3
 c0066f8:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0066fa:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c0066fc:	b29b      	uxth	r3, r3
 c0066fe:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c006702:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 c006704:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c006706:	3301      	adds	r3, #1
 c006708:	b29b      	uxth	r3, r3
 c00670a:	87a3      	strh	r3, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c00670c:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c00670e:	b29b      	uxth	r3, r3
 c006710:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006714:	4639      	mov	r1, r7
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c006716:	6093      	str	r3, [r2, #8]
        hcryp->CrypHeaderCount++ ;
 c006718:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c00671a:	3301      	adds	r3, #1
 c00671c:	b29b      	uxth	r3, r3
 c00671e:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006720:	f7ff ff71 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006724:	6823      	ldr	r3, [r4, #0]
          __HAL_CRYP_DISABLE(hcryp);
 c006726:	681a      	ldr	r2, [r3, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006728:	b168      	cbz	r0, c006746 <CRYP_GCMCCM_SetHeaderPhase+0x112>
        __HAL_CRYP_DISABLE(hcryp);
 c00672a:	f022 0201 	bic.w	r2, r2, #1
 c00672e:	601a      	str	r2, [r3, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006730:	6d63      	ldr	r3, [r4, #84]	; 0x54
        hcryp->State = HAL_CRYP_STATE_READY;
 c006732:	2001      	movs	r0, #1
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006734:	f043 0310 	orr.w	r3, r3, #16
 c006738:	6563      	str	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hcryp);
 c00673a:	2300      	movs	r3, #0
        hcryp->State = HAL_CRYP_STATE_READY;
 c00673c:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
        __HAL_UNLOCK(hcryp);
 c006740:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        return HAL_ERROR;
 c006744:	e7c1      	b.n	c0066ca <CRYP_GCMCCM_SetHeaderPhase+0x96>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006746:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c00674a:	601a      	str	r2, [r3, #0]
      for (loopcounter = 0U; (loopcounter < (size_in_bytes / 4U)); loopcounter += 4U)
 c00674c:	3604      	adds	r6, #4
 c00674e:	e7b9      	b.n	c0066c4 <CRYP_GCMCCM_SetHeaderPhase+0x90>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c006750:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c006752:	69a1      	ldr	r1, [r4, #24]
 c006754:	b292      	uxth	r2, r2
 c006756:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c00675a:	4620      	mov	r0, r4
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c00675c:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 c00675e:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c006760:	3201      	adds	r2, #1
 c006762:	b292      	uxth	r2, r2
 c006764:	87a2      	strh	r2, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c006766:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c006768:	b292      	uxth	r2, r2
 c00676a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 c00676e:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 c006770:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c006772:	3201      	adds	r2, #1
 c006774:	b292      	uxth	r2, r2
 c006776:	87a2      	strh	r2, [r4, #60]	; 0x3c
        hcryp->Instance->DINR  = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c006778:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c00677a:	b292      	uxth	r2, r2
 c00677c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 c006780:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 c006782:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c006784:	3201      	adds	r2, #1
 c006786:	b292      	uxth	r2, r2
 c006788:	87a2      	strh	r2, [r4, #60]	; 0x3c
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c00678a:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 c00678c:	b292      	uxth	r2, r2
 c00678e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006792:	4639      	mov	r1, r7
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c006794:	609a      	str	r2, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 c006796:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 c006798:	3301      	adds	r3, #1
 c00679a:	b29b      	uxth	r3, r3
 c00679c:	87a3      	strh	r3, [r4, #60]	; 0x3c
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c00679e:	f7ff ff32 	bl	c006606 <CRYP_WaitOnCCFlag>
 c0067a2:	6823      	ldr	r3, [r4, #0]
          __HAL_CRYP_DISABLE(hcryp);
 c0067a4:	681a      	ldr	r2, [r3, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c0067a6:	2800      	cmp	r0, #0
 c0067a8:	d1bf      	bne.n	c00672a <CRYP_GCMCCM_SetHeaderPhase+0xf6>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c0067aa:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c0067ae:	601a      	str	r2, [r3, #0]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 16U) * 4U)); loopcounter += 4U)
 c0067b0:	3604      	adds	r6, #4
 c0067b2:	e768      	b.n	c006686 <CRYP_GCMCCM_SetHeaderPhase+0x52>
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0067b4:	8fa0      	ldrh	r0, [r4, #60]	; 0x3c
 c0067b6:	69a6      	ldr	r6, [r4, #24]
 c0067b8:	b280      	uxth	r0, r0
 c0067ba:	f856 0020 	ldr.w	r0, [r6, r0, lsl #2]
      for (loopcounter = 0U; (loopcounter < ((size_in_bytes / 4U) % 4U)); loopcounter++)
 c0067be:	3101      	adds	r1, #1
        hcryp->Instance->DINR = *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0067c0:	6098      	str	r0, [r3, #8]
        hcryp->CrypHeaderCount++ ;
 c0067c2:	8fa0      	ldrh	r0, [r4, #60]	; 0x3c
 c0067c4:	3001      	adds	r0, #1
 c0067c6:	b280      	uxth	r0, r0
 c0067c8:	87a0      	strh	r0, [r4, #60]	; 0x3c
 c0067ca:	e762      	b.n	c006692 <CRYP_GCMCCM_SetHeaderPhase+0x5e>
         tmp =  *(uint32_t *)(hcryp->Init.Header + hcryp->CrypHeaderCount);
 c0067cc:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
 c0067ce:	69a0      	ldr	r0, [r4, #24]
 c0067d0:	b289      	uxth	r1, r1
 c0067d2:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
         tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 c0067d6:	6860      	ldr	r0, [r4, #4]
         loopcounter++;
 c0067d8:	3201      	adds	r2, #1
         tmp &= mask[(hcryp->Init.DataType * 2U) + (size_in_bytes % 4U)];
 c0067da:	eb05 0540 	add.w	r5, r5, r0, lsl #1
 c0067de:	a80c      	add	r0, sp, #48	; 0x30
 c0067e0:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 c0067e4:	f855 0c30 	ldr.w	r0, [r5, #-48]
 c0067e8:	4001      	ands	r1, r0
         hcryp->Instance->DINR = tmp;
 c0067ea:	6099      	str	r1, [r3, #8]
           hcryp->Instance->DINR = 0x0U;
 c0067ec:	2100      	movs	r1, #0
         while (loopcounter < 4U)
 c0067ee:	2a04      	cmp	r2, #4
 c0067f0:	f43f af5a 	beq.w	c0066a8 <CRYP_GCMCCM_SetHeaderPhase+0x74>
           hcryp->Instance->DINR = 0x0U;
 c0067f4:	6099      	str	r1, [r3, #8]
           loopcounter++;
 c0067f6:	3201      	adds	r2, #1
 c0067f8:	e7f9      	b.n	c0067ee <CRYP_GCMCCM_SetHeaderPhase+0x1ba>
        __HAL_CRYP_DISABLE(hcryp);
 c0067fa:	681a      	ldr	r2, [r3, #0]
 c0067fc:	e795      	b.n	c00672a <CRYP_GCMCCM_SetHeaderPhase+0xf6>
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE, hcryp->Init.DataType);
 c0067fe:	6861      	ldr	r1, [r4, #4]
 c006800:	f022 0206 	bic.w	r2, r2, #6
 c006804:	430a      	orrs	r2, r1
 c006806:	601a      	str	r2, [r3, #0]
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c006808:	681a      	ldr	r2, [r3, #0]
  return HAL_OK;
 c00680a:	4628      	mov	r0, r5
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_HEADER);
 c00680c:	f422 42c0 	bic.w	r2, r2, #24576	; 0x6000
 c006810:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 c006814:	601a      	str	r2, [r3, #0]
    __HAL_CRYP_ENABLE(hcryp);
 c006816:	681a      	ldr	r2, [r3, #0]
 c006818:	f042 0201 	orr.w	r2, r2, #1
 c00681c:	601a      	str	r2, [r3, #0]
 c00681e:	e754      	b.n	c0066ca <CRYP_GCMCCM_SetHeaderPhase+0x96>
 c006820:	0c010150 	.word	0x0c010150

0c006824 <HAL_CRYP_SetConfig>:
{
 c006824:	b570      	push	{r4, r5, r6, lr}
  if ((hcryp == NULL) || (pConf == NULL))
 c006826:	2800      	cmp	r0, #0
 c006828:	d041      	beq.n	c0068ae <HAL_CRYP_SetConfig+0x8a>
 c00682a:	2900      	cmp	r1, #0
 c00682c:	d03f      	beq.n	c0068ae <HAL_CRYP_SetConfig+0x8a>
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c00682e:	f890 2051 	ldrb.w	r2, [r0, #81]	; 0x51
 c006832:	b2d2      	uxtb	r2, r2
 c006834:	2a01      	cmp	r2, #1
 c006836:	d133      	bne.n	c0068a0 <HAL_CRYP_SetConfig+0x7c>
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c006838:	2302      	movs	r3, #2
    __HAL_LOCK(hcryp);
 c00683a:	f890 4050 	ldrb.w	r4, [r0, #80]	; 0x50
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c00683e:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51
    __HAL_LOCK(hcryp);
 c006842:	2c01      	cmp	r4, #1
 c006844:	d02a      	beq.n	c00689c <HAL_CRYP_SetConfig+0x78>
    hcryp->Init.pKey            = pConf->pKey;
 c006846:	688c      	ldr	r4, [r1, #8]
    hcryp->Init.DataType        = pConf->DataType;
 c006848:	680b      	ldr	r3, [r1, #0]
    hcryp->Init.pKey            = pConf->pKey;
 c00684a:	60c4      	str	r4, [r0, #12]
    hcryp->Init.pInitVect       = pConf->pInitVect;
 c00684c:	68cc      	ldr	r4, [r1, #12]
    hcryp->Init.Algorithm       = pConf->Algorithm;
 c00684e:	690e      	ldr	r6, [r1, #16]
    hcryp->Init.KeySize         = pConf->KeySize;
 c006850:	684d      	ldr	r5, [r1, #4]
    hcryp->Init.pInitVect       = pConf->pInitVect;
 c006852:	6104      	str	r4, [r0, #16]
    hcryp->Init.Header          = pConf->Header;
 c006854:	694c      	ldr	r4, [r1, #20]
    hcryp->Init.DataType        = pConf->DataType;
 c006856:	6043      	str	r3, [r0, #4]
    hcryp->Init.Header          = pConf->Header;
 c006858:	6184      	str	r4, [r0, #24]
    hcryp->Init.HeaderSize      = pConf->HeaderSize;
 c00685a:	698c      	ldr	r4, [r1, #24]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 c00685c:	4333      	orrs	r3, r6
    hcryp->Init.HeaderSize      = pConf->HeaderSize;
 c00685e:	61c4      	str	r4, [r0, #28]
    hcryp->Init.B0              = pConf->B0;
 c006860:	69cc      	ldr	r4, [r1, #28]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 c006862:	432b      	orrs	r3, r5
    hcryp->Init.B0              = pConf->B0;
 c006864:	6204      	str	r4, [r0, #32]
    hcryp->Init.DataWidthUnit   = pConf->DataWidthUnit;
 c006866:	6a0c      	ldr	r4, [r1, #32]
    hcryp->Init.Algorithm       = pConf->Algorithm;
 c006868:	6146      	str	r6, [r0, #20]
    hcryp->Init.DataWidthUnit   = pConf->DataWidthUnit;
 c00686a:	6244      	str	r4, [r0, #36]	; 0x24
    hcryp->Init.HeaderWidthUnit = pConf->HeaderWidthUnit;
 c00686c:	6a4c      	ldr	r4, [r1, #36]	; 0x24
    hcryp->Init.KeyIVConfigSkip = pConf->KeyIVConfigSkip;
 c00686e:	6a89      	ldr	r1, [r1, #40]	; 0x28
    hcryp->Init.HeaderWidthUnit = pConf->HeaderWidthUnit;
 c006870:	6284      	str	r4, [r0, #40]	; 0x28
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 c006872:	6804      	ldr	r4, [r0, #0]
    hcryp->Init.KeyIVConfigSkip = pConf->KeyIVConfigSkip;
 c006874:	62c1      	str	r1, [r0, #44]	; 0x2c
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 c006876:	6821      	ldr	r1, [r4, #0]
    hcryp->Init.KeySize         = pConf->KeySize;
 c006878:	6085      	str	r5, [r0, #8]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 c00687a:	f421 21a0 	bic.w	r1, r1, #327680	; 0x50000
 c00687e:	f021 0166 	bic.w	r1, r1, #102	; 0x66
 c006882:	430b      	orrs	r3, r1
 c006884:	6023      	str	r3, [r4, #0]
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_ERR_CLEAR);
 c006886:	6823      	ldr	r3, [r4, #0]
 c006888:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c00688c:	6023      	str	r3, [r4, #0]
    __HAL_UNLOCK(hcryp);
 c00688e:	2300      	movs	r3, #0
    hcryp->Phase = CRYP_PHASE_READY;
 c006890:	6442      	str	r2, [r0, #68]	; 0x44
    hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 c006892:	6543      	str	r3, [r0, #84]	; 0x54
    __HAL_UNLOCK(hcryp);
 c006894:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
    hcryp->State = HAL_CRYP_STATE_READY;
 c006898:	f880 2051 	strb.w	r2, [r0, #81]	; 0x51
    __HAL_LOCK(hcryp);
 c00689c:	4618      	mov	r0, r3
 c00689e:	e007      	b.n	c0068b0 <HAL_CRYP_SetConfig+0x8c>
    __HAL_UNLOCK(hcryp);
 c0068a0:	2300      	movs	r3, #0
 c0068a2:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c0068a6:	6d43      	ldr	r3, [r0, #84]	; 0x54
 c0068a8:	f043 0308 	orr.w	r3, r3, #8
 c0068ac:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 c0068ae:	2001      	movs	r0, #1
}
 c0068b0:	bd70      	pop	{r4, r5, r6, pc}

0c0068b2 <HAL_CRYP_MspInit>:
}
 c0068b2:	4770      	bx	lr

0c0068b4 <HAL_CRYP_Init>:
{
 c0068b4:	b510      	push	{r4, lr}
  if (hcryp == NULL)
 c0068b6:	4604      	mov	r4, r0
 c0068b8:	b1e8      	cbz	r0, c0068f6 <HAL_CRYP_Init+0x42>
  if (hcryp->State == HAL_CRYP_STATE_RESET)
 c0068ba:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 c0068be:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c0068c2:	b91b      	cbnz	r3, c0068cc <HAL_CRYP_Init+0x18>
    hcryp->Lock = HAL_UNLOCKED;
 c0068c4:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50
    HAL_CRYP_MspInit(hcryp);
 c0068c8:	f7ff fff3 	bl	c0068b2 <HAL_CRYP_MspInit>
  MODIFY_REG(hcryp->Instance->CR, AES_CR_DATATYPE | AES_CR_KEYSIZE | AES_CR_CHMOD, hcryp->Init.DataType | hcryp->Init.KeySize | hcryp->Init.Algorithm);
 c0068cc:	e9d4 3001 	ldrd	r3, r0, [r4, #4]
 c0068d0:	6821      	ldr	r1, [r4, #0]
 c0068d2:	4303      	orrs	r3, r0
 c0068d4:	680a      	ldr	r2, [r1, #0]
 c0068d6:	6960      	ldr	r0, [r4, #20]
 c0068d8:	f422 22a0 	bic.w	r2, r2, #327680	; 0x50000
 c0068dc:	4303      	orrs	r3, r0
 c0068de:	f022 0266 	bic.w	r2, r2, #102	; 0x66
 c0068e2:	4313      	orrs	r3, r2
 c0068e4:	600b      	str	r3, [r1, #0]
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 c0068e6:	2000      	movs	r0, #0
  hcryp->State = HAL_CRYP_STATE_READY;
 c0068e8:	2301      	movs	r3, #1
  hcryp->ErrorCode = HAL_CRYP_ERROR_NONE;
 c0068ea:	6560      	str	r0, [r4, #84]	; 0x54
  hcryp->KeyIVConfig = 0U;
 c0068ec:	65a0      	str	r0, [r4, #88]	; 0x58
  hcryp->State = HAL_CRYP_STATE_READY;
 c0068ee:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hcryp->Phase = CRYP_PHASE_READY;
 c0068f2:	6463      	str	r3, [r4, #68]	; 0x44
}
 c0068f4:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 c0068f6:	2001      	movs	r0, #1
 c0068f8:	e7fc      	b.n	c0068f4 <HAL_CRYP_Init+0x40>

0c0068fa <HAL_CRYP_MspDeInit>:
 c0068fa:	4770      	bx	lr

0c0068fc <HAL_CRYP_DeInit>:
{
 c0068fc:	b538      	push	{r3, r4, r5, lr}
  if (hcryp == NULL)
 c0068fe:	4605      	mov	r5, r0
 c006900:	2401      	movs	r4, #1
 c006902:	b180      	cbz	r0, c006926 <HAL_CRYP_DeInit+0x2a>
  hcryp->Phase = CRYP_PHASE_READY;
 c006904:	6444      	str	r4, [r0, #68]	; 0x44
  hcryp->CrypInCount = 0;
 c006906:	2400      	movs	r4, #0
  __HAL_CRYP_DISABLE(hcryp);
 c006908:	6802      	ldr	r2, [r0, #0]
  hcryp->CrypInCount = 0;
 c00690a:	87c4      	strh	r4, [r0, #62]	; 0x3e
  hcryp->CrypOutCount = 0;
 c00690c:	f8a0 4040 	strh.w	r4, [r0, #64]	; 0x40
  hcryp->CrypHeaderCount = 0;
 c006910:	8784      	strh	r4, [r0, #60]	; 0x3c
  __HAL_CRYP_DISABLE(hcryp);
 c006912:	6813      	ldr	r3, [r2, #0]
 c006914:	f023 0301 	bic.w	r3, r3, #1
 c006918:	6013      	str	r3, [r2, #0]
  HAL_CRYP_MspDeInit(hcryp);
 c00691a:	f7ff ffee 	bl	c0068fa <HAL_CRYP_MspDeInit>
  hcryp->State = HAL_CRYP_STATE_RESET;
 c00691e:	f885 4051 	strb.w	r4, [r5, #81]	; 0x51
  __HAL_UNLOCK(hcryp);
 c006922:	f885 4050 	strb.w	r4, [r5, #80]	; 0x50
    return HAL_ERROR;
 c006926:	4620      	mov	r0, r4
}
 c006928:	bd38      	pop	{r3, r4, r5, pc}

0c00692a <HAL_CRYP_ErrorCallback>:
 c00692a:	4770      	bx	lr

0c00692c <CRYP_AES_ProcessData>:
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c00692c:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
{
 c00692e:	b530      	push	{r4, r5, lr}
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c006930:	6b45      	ldr	r5, [r0, #52]	; 0x34
 c006932:	b29b      	uxth	r3, r3
 c006934:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c006938:	6802      	ldr	r2, [r0, #0]
{
 c00693a:	b085      	sub	sp, #20
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c00693c:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c00693e:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
{
 c006940:	4604      	mov	r4, r0
  hcryp->CrypInCount++;
 c006942:	3301      	adds	r3, #1
 c006944:	b29b      	uxth	r3, r3
 c006946:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c006948:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 c00694a:	b29b      	uxth	r3, r3
 c00694c:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c006950:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c006952:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 c006954:	3301      	adds	r3, #1
 c006956:	b29b      	uxth	r3, r3
 c006958:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c00695a:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 c00695c:	b29b      	uxth	r3, r3
 c00695e:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c006962:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c006964:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 c006966:	3301      	adds	r3, #1
 c006968:	b29b      	uxth	r3, r3
 c00696a:	87c3      	strh	r3, [r0, #62]	; 0x3e
  hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c00696c:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 c00696e:	b29b      	uxth	r3, r3
 c006970:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c006974:	6093      	str	r3, [r2, #8]
  hcryp->CrypInCount++;
 c006976:	8fc3      	ldrh	r3, [r0, #62]	; 0x3e
 c006978:	3301      	adds	r3, #1
 c00697a:	b29b      	uxth	r3, r3
 c00697c:	87c3      	strh	r3, [r0, #62]	; 0x3e
  if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c00697e:	f7ff fe42 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006982:	b188      	cbz	r0, c0069a8 <CRYP_AES_ProcessData+0x7c>
    __HAL_CRYP_DISABLE(hcryp);
 c006984:	6822      	ldr	r2, [r4, #0]
    HAL_CRYP_ErrorCallback(hcryp);
 c006986:	4620      	mov	r0, r4
    __HAL_CRYP_DISABLE(hcryp);
 c006988:	6813      	ldr	r3, [r2, #0]
 c00698a:	f023 0301 	bic.w	r3, r3, #1
 c00698e:	6013      	str	r3, [r2, #0]
    hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006990:	6d63      	ldr	r3, [r4, #84]	; 0x54
 c006992:	f043 0310 	orr.w	r3, r3, #16
 c006996:	6563      	str	r3, [r4, #84]	; 0x54
    hcryp->State = HAL_CRYP_STATE_READY;
 c006998:	2301      	movs	r3, #1
 c00699a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
    __HAL_UNLOCK(hcryp);
 c00699e:	2300      	movs	r3, #0
 c0069a0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    HAL_CRYP_ErrorCallback(hcryp);
 c0069a4:	f7ff ffc1 	bl	c00692a <HAL_CRYP_ErrorCallback>
  i= 0U;
 c0069a8:	2100      	movs	r1, #0
  __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c0069aa:	6823      	ldr	r3, [r4, #0]
 c0069ac:	681a      	ldr	r2, [r3, #0]
 c0069ae:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c0069b2:	601a      	str	r2, [r3, #0]
    temp[i] = hcryp->Instance->DOUTR;
 c0069b4:	68da      	ldr	r2, [r3, #12]
 c0069b6:	9200      	str	r2, [sp, #0]
 c0069b8:	68da      	ldr	r2, [r3, #12]
 c0069ba:	9201      	str	r2, [sp, #4]
 c0069bc:	68da      	ldr	r2, [r3, #12]
 c0069be:	68db      	ldr	r3, [r3, #12]
 c0069c0:	9202      	str	r2, [sp, #8]
 c0069c2:	9303      	str	r3, [sp, #12]
  while((hcryp->CrypOutCount < ((hcryp->Size + 3U)/4U)) && (i<4U))
 c0069c4:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 c0069c8:	3303      	adds	r3, #3
 c0069ca:	089b      	lsrs	r3, r3, #2
 c0069cc:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
 c0069d0:	4293      	cmp	r3, r2
 c0069d2:	d901      	bls.n	c0069d8 <CRYP_AES_ProcessData+0xac>
 c0069d4:	2904      	cmp	r1, #4
 c0069d6:	d101      	bne.n	c0069dc <CRYP_AES_ProcessData+0xb0>
}
 c0069d8:	b005      	add	sp, #20
 c0069da:	bd30      	pop	{r4, r5, pc}
    *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[i];
 c0069dc:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
 c0069e0:	f85d 5021 	ldr.w	r5, [sp, r1, lsl #2]
 c0069e4:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 c0069e6:	b292      	uxth	r2, r2
 c0069e8:	f840 5022 	str.w	r5, [r0, r2, lsl #2]
    hcryp->CrypOutCount++;
 c0069ec:	f8b4 2040 	ldrh.w	r2, [r4, #64]	; 0x40
    i++;
 c0069f0:	3101      	adds	r1, #1
    hcryp->CrypOutCount++;
 c0069f2:	3201      	adds	r2, #1
 c0069f4:	b292      	uxth	r2, r2
 c0069f6:	f8a4 2040 	strh.w	r2, [r4, #64]	; 0x40
 c0069fa:	e7e7      	b.n	c0069cc <CRYP_AES_ProcessData+0xa0>

0c0069fc <CRYP_AESCCM_Process>:
{
 c0069fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c0069fe:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
 c006a00:	b085      	sub	sp, #20
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006a02:	2b01      	cmp	r3, #1
{
 c006a04:	4604      	mov	r4, r0
 c006a06:	460e      	mov	r6, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 c006a08:	f8b0 5042 	ldrh.w	r5, [r0, #66]	; 0x42
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006a0c:	d11f      	bne.n	c006a4e <CRYP_AESCCM_Process+0x52>
    if (hcryp->KeyIVConfig == 1U)
 c006a0e:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c006a10:	2a01      	cmp	r2, #1
 c006a12:	d11b      	bne.n	c006a4c <CRYP_AESCCM_Process+0x50>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 c006a14:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 c006a16:	442b      	add	r3, r5
 c006a18:	65c3      	str	r3, [r0, #92]	; 0x5c
  if ((hcryp->Size % 16U) != 0U)
 c006a1a:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 c006a1e:	08ad      	lsrs	r5, r5, #2
  if ((hcryp->Size % 16U) != 0U)
 c006a20:	0718      	lsls	r0, r3, #28
    wordsize = ((wordsize / 4U) * 4U) ;
 c006a22:	bf18      	it	ne
 c006a24:	f025 0503 	bicne.w	r5, r5, #3
  tickstart = HAL_GetTick();
 c006a28:	f7fc fd3c 	bl	c0034a4 <HAL_GetTick>
 c006a2c:	4607      	mov	r7, r0
    incount = hcryp->CrypInCount;
 c006a2e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    outcount = hcryp->CrypOutCount;
 c006a30:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    incount = hcryp->CrypInCount;
 c006a34:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 c006a36:	4295      	cmp	r5, r2
    outcount = hcryp->CrypOutCount;
 c006a38:	b29b      	uxth	r3, r3
  while ((incount < wordsize) && (outcount < wordsize))
 c006a3a:	d901      	bls.n	c006a40 <CRYP_AESCCM_Process+0x44>
 c006a3c:	429d      	cmp	r5, r3
 c006a3e:	d848      	bhi.n	c006ad2 <CRYP_AESCCM_Process+0xd6>
  if ((hcryp->Size % 16U) != 0U)
 c006a40:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 c006a44:	071a      	lsls	r2, r3, #28
 c006a46:	d161      	bne.n	c006b0c <CRYP_AESCCM_Process+0x110>
  return HAL_OK;
 c006a48:	2000      	movs	r0, #0
 c006a4a:	e027      	b.n	c006a9c <CRYP_AESCCM_Process+0xa0>
      hcryp->KeyIVConfig = 1U;
 c006a4c:	6583      	str	r3, [r0, #88]	; 0x58
    hcryp->CrypHeaderCount = 0U;
 c006a4e:	2700      	movs	r7, #0
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c006a50:	6822      	ldr	r2, [r4, #0]
    hcryp->CrypHeaderCount = 0U;
 c006a52:	87a7      	strh	r7, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c006a54:	6813      	ldr	r3, [r2, #0]
    hcryp->SizesSum = hcryp->Size;
 c006a56:	65e5      	str	r5, [r4, #92]	; 0x5c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c006a58:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 c006a5c:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006a5e:	68a1      	ldr	r1, [r4, #8]
 c006a60:	4620      	mov	r0, r4
 c006a62:	f7ff fdaf 	bl	c0065c4 <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.B0);
 c006a66:	6a22      	ldr	r2, [r4, #32]
 c006a68:	6823      	ldr	r3, [r4, #0]
 c006a6a:	6811      	ldr	r1, [r2, #0]
 c006a6c:	62d9      	str	r1, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.B0 + 1U);
 c006a6e:	6851      	ldr	r1, [r2, #4]
 c006a70:	6299      	str	r1, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.B0 + 2U);
 c006a72:	6891      	ldr	r1, [r2, #8]
 c006a74:	6259      	str	r1, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.B0 + 3U);
 c006a76:	68d2      	ldr	r2, [r2, #12]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006a78:	4631      	mov	r1, r6
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.B0 + 3U);
 c006a7a:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 c006a7c:	681a      	ldr	r2, [r3, #0]
 c006a7e:	f042 0201 	orr.w	r2, r2, #1
 c006a82:	601a      	str	r2, [r3, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006a84:	f7ff fdbf 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006a88:	b150      	cbz	r0, c006aa0 <CRYP_AESCCM_Process+0xa4>
      hcryp->State = HAL_CRYP_STATE_READY;
 c006a8a:	2001      	movs	r0, #1
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006a8c:	6d63      	ldr	r3, [r4, #84]	; 0x54
      __HAL_UNLOCK(hcryp);
 c006a8e:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006a92:	f043 0310 	orr.w	r3, r3, #16
 c006a96:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 c006a98:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
}
 c006a9c:	b005      	add	sp, #20
 c006a9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006aa0:	6822      	ldr	r2, [r4, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c006aa2:	4631      	mov	r1, r6
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006aa4:	6813      	ldr	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c006aa6:	4620      	mov	r0, r4
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006aa8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c006aac:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c006aae:	f7ff fdc1 	bl	c006634 <CRYP_GCMCCM_SetHeaderPhase>
 c006ab2:	2800      	cmp	r0, #0
 c006ab4:	d17c      	bne.n	c006bb0 <CRYP_AESCCM_Process+0x1b4>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c006ab6:	2302      	movs	r3, #2
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 c006ab8:	6822      	ldr	r2, [r4, #0]
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c006aba:	6463      	str	r3, [r4, #68]	; 0x44
    MODIFY_REG(hcryp->Instance->CR, AES_CR_GCMPH, CRYP_PHASE_PAYLOAD);
 c006abc:	6813      	ldr	r3, [r2, #0]
 c006abe:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 c006ac2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 c006ac6:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 c006ac8:	6813      	ldr	r3, [r2, #0]
 c006aca:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 c006ace:	6013      	str	r3, [r2, #0]
 c006ad0:	e7a3      	b.n	c006a1a <CRYP_AESCCM_Process+0x1e>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c006ad2:	4631      	mov	r1, r6
 c006ad4:	4620      	mov	r0, r4
 c006ad6:	f7ff ff29 	bl	c00692c <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 c006ada:	1c71      	adds	r1, r6, #1
 c006adc:	d0a7      	beq.n	c006a2e <CRYP_AESCCM_Process+0x32>
      if (((HAL_GetTick() - tickstart) > Timeout) ||(Timeout == 0U))
 c006ade:	f7fc fce1 	bl	c0034a4 <HAL_GetTick>
 c006ae2:	1bc0      	subs	r0, r0, r7
 c006ae4:	42b0      	cmp	r0, r6
 c006ae6:	d801      	bhi.n	c006aec <CRYP_AESCCM_Process+0xf0>
 c006ae8:	2e00      	cmp	r6, #0
 c006aea:	d1a0      	bne.n	c006a2e <CRYP_AESCCM_Process+0x32>
        __HAL_CRYP_DISABLE(hcryp);
 c006aec:	6822      	ldr	r2, [r4, #0]
 c006aee:	6813      	ldr	r3, [r2, #0]
 c006af0:	f023 0301 	bic.w	r3, r3, #1
 c006af4:	6013      	str	r3, [r2, #0]
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006af6:	6d63      	ldr	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 c006af8:	2001      	movs	r0, #1
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006afa:	f043 0310 	orr.w	r3, r3, #16
 c006afe:	6563      	str	r3, [r4, #84]	; 0x54
      __HAL_UNLOCK(hcryp);
 c006b00:	2300      	movs	r3, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 c006b02:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 c006b06:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      return HAL_ERROR;
 c006b0a:	e7c7      	b.n	c006a9c <CRYP_AESCCM_Process+0xa0>
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c006b0c:	2500      	movs	r5, #0
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c006b0e:	091a      	lsrs	r2, r3, #4
 c006b10:	3201      	adds	r2, #1
 c006b12:	ebc3 1302 	rsb	r3, r3, r2, lsl #4
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_DECRYPT)
 c006b16:	6822      	ldr	r2, [r4, #0]
 c006b18:	6811      	ldr	r1, [r2, #0]
 c006b1a:	f001 0118 	and.w	r1, r1, #24
 c006b1e:	2910      	cmp	r1, #16
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20);
 c006b20:	bf01      	itttt	eq
 c006b22:	6811      	ldreq	r1, [r2, #0]
 c006b24:	f421 0170 	biceq.w	r1, r1, #15728640	; 0xf00000
 c006b28:	ea41 5103 	orreq.w	r1, r1, r3, lsl #20
 c006b2c:	6011      	streq	r1, [r2, #0]
 c006b2e:	f1c3 0110 	rsb	r1, r3, #16
 c006b32:	0889      	lsrs	r1, r1, #2
    if ((npblb % 4U) == 0U)
 c006b34:	079b      	lsls	r3, r3, #30
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 c006b36:	bf18      	it	ne
 c006b38:	3101      	addne	r1, #1
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c006b3a:	428d      	cmp	r5, r1
 c006b3c:	d129      	bne.n	c006b92 <CRYP_AESCCM_Process+0x196>
 c006b3e:	462b      	mov	r3, r5
      hcryp->Instance->DINR  = 0U;
 c006b40:	2100      	movs	r1, #0
    while (loopcounter < 4U)
 c006b42:	2b03      	cmp	r3, #3
 c006b44:	d931      	bls.n	c006baa <CRYP_AESCCM_Process+0x1ae>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006b46:	4631      	mov	r1, r6
 c006b48:	4620      	mov	r0, r4
 c006b4a:	f7ff fd5c 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006b4e:	2800      	cmp	r0, #0
 c006b50:	d1d1      	bne.n	c006af6 <CRYP_AESCCM_Process+0xfa>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006b52:	6823      	ldr	r3, [r4, #0]
 c006b54:	681a      	ldr	r2, [r3, #0]
 c006b56:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c006b5a:	601a      	str	r2, [r3, #0]
      temp[loopcounter] = hcryp->Instance->DOUTR;
 c006b5c:	68da      	ldr	r2, [r3, #12]
 c006b5e:	9200      	str	r2, [sp, #0]
 c006b60:	68da      	ldr	r2, [r3, #12]
 c006b62:	9201      	str	r2, [sp, #4]
 c006b64:	68da      	ldr	r2, [r3, #12]
 c006b66:	68db      	ldr	r3, [r3, #12]
 c006b68:	9202      	str	r2, [sp, #8]
 c006b6a:	9303      	str	r3, [sp, #12]
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 c006b6c:	4285      	cmp	r5, r0
 c006b6e:	f43f af6b 	beq.w	c006a48 <CRYP_AESCCM_Process+0x4c>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + hcryp->CrypOutCount) = temp[loopcounter];
 c006b72:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 c006b76:	f85d 1020 	ldr.w	r1, [sp, r0, lsl #2]
 c006b7a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 c006b7c:	b29b      	uxth	r3, r3
 c006b7e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      hcryp->CrypOutCount++;
 c006b82:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    for (loopcounter = 0U; loopcounter<lastwordsize; loopcounter++)
 c006b86:	3001      	adds	r0, #1
      hcryp->CrypOutCount++;
 c006b88:	3301      	adds	r3, #1
 c006b8a:	b29b      	uxth	r3, r3
 c006b8c:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
 c006b90:	e7ec      	b.n	c006b6c <CRYP_AESCCM_Process+0x170>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c006b92:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 c006b94:	6b60      	ldr	r0, [r4, #52]	; 0x34
 c006b96:	b29b      	uxth	r3, r3
 c006b98:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    for (loopcounter = 0U; loopcounter < lastwordsize; loopcounter ++)
 c006b9c:	3501      	adds	r5, #1
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c006b9e:	6093      	str	r3, [r2, #8]
      hcryp->CrypInCount++;
 c006ba0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 c006ba2:	3301      	adds	r3, #1
 c006ba4:	b29b      	uxth	r3, r3
 c006ba6:	87e3      	strh	r3, [r4, #62]	; 0x3e
 c006ba8:	e7c7      	b.n	c006b3a <CRYP_AESCCM_Process+0x13e>
      hcryp->Instance->DINR  = 0U;
 c006baa:	6091      	str	r1, [r2, #8]
      loopcounter++;
 c006bac:	3301      	adds	r3, #1
 c006bae:	e7c8      	b.n	c006b42 <CRYP_AESCCM_Process+0x146>
      return HAL_ERROR;
 c006bb0:	2001      	movs	r0, #1
 c006bb2:	e773      	b.n	c006a9c <CRYP_AESCCM_Process+0xa0>

0c006bb4 <CRYP_AESGCM_Process>:
{
 c006bb4:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006bb6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
{
 c006bb8:	b085      	sub	sp, #20
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006bba:	2b01      	cmp	r3, #1
{
 c006bbc:	4604      	mov	r4, r0
 c006bbe:	460e      	mov	r6, r1
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 c006bc0:	f8b0 5042 	ldrh.w	r5, [r0, #66]	; 0x42
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006bc4:	d11f      	bne.n	c006c06 <CRYP_AESGCM_Process+0x52>
    if (hcryp->KeyIVConfig == 1U)
 c006bc6:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c006bc8:	2a01      	cmp	r2, #1
 c006bca:	d11b      	bne.n	c006c04 <CRYP_AESGCM_Process+0x50>
      hcryp->SizesSum += hcryp->Size; /* Compute message total payload length */
 c006bcc:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 c006bce:	442b      	add	r3, r5
 c006bd0:	65c3      	str	r3, [r0, #92]	; 0x5c
  if ((hcryp->Size % 16U) != 0U)
 c006bd2:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
  uint32_t wordsize = ((uint32_t)hcryp->Size / 4U) ;
 c006bd6:	08ad      	lsrs	r5, r5, #2
  if ((hcryp->Size % 16U) != 0U)
 c006bd8:	0718      	lsls	r0, r3, #28
    wordsize = ((wordsize / 4U) * 4U) ;
 c006bda:	bf18      	it	ne
 c006bdc:	f025 0503 	bicne.w	r5, r5, #3
  tickstart = HAL_GetTick();
 c006be0:	f7fc fc60 	bl	c0034a4 <HAL_GetTick>
 c006be4:	4607      	mov	r7, r0
    incount = hcryp->CrypInCount;
 c006be6:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
    outcount = hcryp->CrypOutCount;
 c006be8:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    incount = hcryp->CrypInCount;
 c006bec:	b292      	uxth	r2, r2
  while ((incount < wordsize) && (outcount < wordsize))
 c006bee:	4295      	cmp	r5, r2
    outcount = hcryp->CrypOutCount;
 c006bf0:	b29b      	uxth	r3, r3
  while ((incount < wordsize) && (outcount < wordsize))
 c006bf2:	d901      	bls.n	c006bf8 <CRYP_AESGCM_Process+0x44>
 c006bf4:	429d      	cmp	r5, r3
 c006bf6:	d849      	bhi.n	c006c8c <CRYP_AESGCM_Process+0xd8>
  if ((hcryp->Size % 16U) != 0U)
 c006bf8:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42
 c006bfc:	071a      	lsls	r2, r3, #28
 c006bfe:	d162      	bne.n	c006cc6 <CRYP_AESGCM_Process+0x112>
  return HAL_OK;
 c006c00:	2000      	movs	r0, #0
 c006c02:	e027      	b.n	c006c54 <CRYP_AESGCM_Process+0xa0>
      hcryp->KeyIVConfig = 1U;
 c006c04:	6583      	str	r3, [r0, #88]	; 0x58
    hcryp->CrypHeaderCount = 0U;
 c006c06:	2700      	movs	r7, #0
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c006c08:	6822      	ldr	r2, [r4, #0]
    hcryp->CrypHeaderCount = 0U;
 c006c0a:	87a7      	strh	r7, [r4, #60]	; 0x3c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c006c0c:	6813      	ldr	r3, [r2, #0]
    hcryp->SizesSum = hcryp->Size;
 c006c0e:	65e5      	str	r5, [r4, #92]	; 0x5c
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_INIT);
 c006c10:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 c006c14:	6013      	str	r3, [r2, #0]
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006c16:	68a1      	ldr	r1, [r4, #8]
 c006c18:	4620      	mov	r0, r4
 c006c1a:	f7ff fcd3 	bl	c0065c4 <CRYP_SetKey>
    hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 c006c1e:	6922      	ldr	r2, [r4, #16]
 c006c20:	6823      	ldr	r3, [r4, #0]
 c006c22:	6811      	ldr	r1, [r2, #0]
 c006c24:	62d9      	str	r1, [r3, #44]	; 0x2c
    hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 c006c26:	6851      	ldr	r1, [r2, #4]
 c006c28:	6299      	str	r1, [r3, #40]	; 0x28
    hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 c006c2a:	6891      	ldr	r1, [r2, #8]
 c006c2c:	6259      	str	r1, [r3, #36]	; 0x24
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 c006c2e:	68d2      	ldr	r2, [r2, #12]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006c30:	4631      	mov	r1, r6
    hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 c006c32:	621a      	str	r2, [r3, #32]
    __HAL_CRYP_ENABLE(hcryp);
 c006c34:	681a      	ldr	r2, [r3, #0]
 c006c36:	f042 0201 	orr.w	r2, r2, #1
 c006c3a:	601a      	str	r2, [r3, #0]
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006c3c:	f7ff fce3 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006c40:	b150      	cbz	r0, c006c58 <CRYP_AESGCM_Process+0xa4>
      hcryp->State = HAL_CRYP_STATE_READY;
 c006c42:	2001      	movs	r0, #1
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006c44:	6d63      	ldr	r3, [r4, #84]	; 0x54
      __HAL_UNLOCK(hcryp);
 c006c46:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
      hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006c4a:	f043 0310 	orr.w	r3, r3, #16
 c006c4e:	6563      	str	r3, [r4, #84]	; 0x54
      hcryp->State = HAL_CRYP_STATE_READY;
 c006c50:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
}
 c006c54:	b005      	add	sp, #20
 c006c56:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006c58:	6822      	ldr	r2, [r4, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c006c5a:	4631      	mov	r1, r6
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006c5c:	6813      	ldr	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c006c5e:	4620      	mov	r0, r4
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006c60:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c006c64:	6013      	str	r3, [r2, #0]
    if (CRYP_GCMCCM_SetHeaderPhase(hcryp,  Timeout) != HAL_OK)
 c006c66:	f7ff fce5 	bl	c006634 <CRYP_GCMCCM_SetHeaderPhase>
 c006c6a:	2800      	cmp	r0, #0
 c006c6c:	f040 8085 	bne.w	c006d7a <CRYP_AESGCM_Process+0x1c6>
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c006c70:	2302      	movs	r3, #2
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 c006c72:	6822      	ldr	r2, [r4, #0]
    hcryp->Phase = CRYP_PHASE_PROCESS;
 c006c74:	6463      	str	r3, [r4, #68]	; 0x44
    CRYP_SET_PHASE(hcryp, CRYP_PHASE_PAYLOAD);
 c006c76:	6813      	ldr	r3, [r2, #0]
 c006c78:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 c006c7c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 c006c80:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, 0U);
 c006c82:	6813      	ldr	r3, [r2, #0]
 c006c84:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 c006c88:	6013      	str	r3, [r2, #0]
 c006c8a:	e7a2      	b.n	c006bd2 <CRYP_AESGCM_Process+0x1e>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c006c8c:	4631      	mov	r1, r6
 c006c8e:	4620      	mov	r0, r4
 c006c90:	f7ff fe4c 	bl	c00692c <CRYP_AES_ProcessData>
    if (Timeout != HAL_MAX_DELAY)
 c006c94:	1c71      	adds	r1, r6, #1
 c006c96:	d0a6      	beq.n	c006be6 <CRYP_AESGCM_Process+0x32>
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 c006c98:	f7fc fc04 	bl	c0034a4 <HAL_GetTick>
 c006c9c:	1bc0      	subs	r0, r0, r7
 c006c9e:	42b0      	cmp	r0, r6
 c006ca0:	d801      	bhi.n	c006ca6 <CRYP_AESGCM_Process+0xf2>
 c006ca2:	2e00      	cmp	r6, #0
 c006ca4:	d19f      	bne.n	c006be6 <CRYP_AESGCM_Process+0x32>
        __HAL_CRYP_DISABLE(hcryp);
 c006ca6:	6822      	ldr	r2, [r4, #0]
        hcryp->State = HAL_CRYP_STATE_READY;
 c006ca8:	2001      	movs	r0, #1
        __HAL_CRYP_DISABLE(hcryp);
 c006caa:	6813      	ldr	r3, [r2, #0]
 c006cac:	f023 0301 	bic.w	r3, r3, #1
 c006cb0:	6013      	str	r3, [r2, #0]
        hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006cb2:	6d63      	ldr	r3, [r4, #84]	; 0x54
 c006cb4:	f043 0310 	orr.w	r3, r3, #16
 c006cb8:	6563      	str	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hcryp);
 c006cba:	2300      	movs	r3, #0
        hcryp->State = HAL_CRYP_STATE_READY;
 c006cbc:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
        __HAL_UNLOCK(hcryp);
 c006cc0:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
        return HAL_ERROR;
 c006cc4:	e7c6      	b.n	c006c54 <CRYP_AESGCM_Process+0xa0>
    for (index = 0U; index < lastwordsize; index ++)
 c006cc6:	2500      	movs	r5, #0
    npblb = ((((uint32_t)hcryp->Size / 16U) + 1U) * 16U) - ((uint32_t)hcryp->Size);
 c006cc8:	091a      	lsrs	r2, r3, #4
 c006cca:	3201      	adds	r2, #1
 c006ccc:	ebc3 1302 	rsb	r3, r3, r2, lsl #4
    if ((hcryp->Instance->CR & AES_CR_MODE) == CRYP_OPERATINGMODE_ENCRYPT)
 c006cd0:	6822      	ldr	r2, [r4, #0]
 c006cd2:	6811      	ldr	r1, [r2, #0]
 c006cd4:	f011 0f18 	tst.w	r1, #24
      MODIFY_REG(hcryp->Instance->CR, AES_CR_NPBLB, npblb << 20U);
 c006cd8:	bf01      	itttt	eq
 c006cda:	6811      	ldreq	r1, [r2, #0]
 c006cdc:	f421 0170 	biceq.w	r1, r1, #15728640	; 0xf00000
 c006ce0:	ea41 5103 	orreq.w	r1, r1, r3, lsl #20
 c006ce4:	6011      	streq	r1, [r2, #0]
 c006ce6:	f1c3 0110 	rsb	r1, r3, #16
 c006cea:	0889      	lsrs	r1, r1, #2
    if ((npblb % 4U) == 0U)
 c006cec:	079b      	lsls	r3, r3, #30
      lastwordsize = ((16U - npblb) / 4U) + 1U;
 c006cee:	bf18      	it	ne
 c006cf0:	3101      	addne	r1, #1
    for (index = 0U; index < lastwordsize; index ++)
 c006cf2:	428d      	cmp	r5, r1
 c006cf4:	d132      	bne.n	c006d5c <CRYP_AESGCM_Process+0x1a8>
 c006cf6:	462b      	mov	r3, r5
      hcryp->Instance->DINR  = 0U;
 c006cf8:	2100      	movs	r1, #0
    while (index < 4U)
 c006cfa:	2b03      	cmp	r3, #3
 c006cfc:	d93a      	bls.n	c006d74 <CRYP_AESGCM_Process+0x1c0>
    if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006cfe:	4631      	mov	r1, r6
 c006d00:	4620      	mov	r0, r4
 c006d02:	f7ff fc80 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006d06:	b140      	cbz	r0, c006d1a <CRYP_AESGCM_Process+0x166>
      hcryp->State = HAL_CRYP_STATE_READY;
 c006d08:	2301      	movs	r3, #1
 c006d0a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 c006d0e:	2300      	movs	r3, #0
      HAL_CRYP_ErrorCallback(hcryp);
 c006d10:	4620      	mov	r0, r4
      __HAL_UNLOCK(hcryp);
 c006d12:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
      HAL_CRYP_ErrorCallback(hcryp);
 c006d16:	f7ff fe08 	bl	c00692a <HAL_CRYP_ErrorCallback>
    __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006d1a:	6823      	ldr	r3, [r4, #0]
 c006d1c:	681a      	ldr	r2, [r3, #0]
 c006d1e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c006d22:	601a      	str	r2, [r3, #0]
      temp[index] = hcryp->Instance->DOUTR;
 c006d24:	68da      	ldr	r2, [r3, #12]
 c006d26:	9200      	str	r2, [sp, #0]
 c006d28:	68da      	ldr	r2, [r3, #12]
 c006d2a:	9201      	str	r2, [sp, #4]
 c006d2c:	68da      	ldr	r2, [r3, #12]
 c006d2e:	68db      	ldr	r3, [r3, #12]
 c006d30:	9202      	str	r2, [sp, #8]
    for (index = 0U; index < lastwordsize; index++)
 c006d32:	2200      	movs	r2, #0
      temp[index] = hcryp->Instance->DOUTR;
 c006d34:	9303      	str	r3, [sp, #12]
    for (index = 0U; index < lastwordsize; index++)
 c006d36:	4295      	cmp	r5, r2
 c006d38:	f43f af62 	beq.w	c006c00 <CRYP_AESGCM_Process+0x4c>
      *(uint32_t *)(hcryp->pCrypOutBuffPtr + (hcryp->CrypOutCount)) = temp[index];
 c006d3c:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
 c006d40:	f85d 0022 	ldr.w	r0, [sp, r2, lsl #2]
 c006d44:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 c006d46:	b29b      	uxth	r3, r3
 c006d48:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
      hcryp->CrypOutCount++;
 c006d4c:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
    for (index = 0U; index < lastwordsize; index++)
 c006d50:	3201      	adds	r2, #1
      hcryp->CrypOutCount++;
 c006d52:	3301      	adds	r3, #1
 c006d54:	b29b      	uxth	r3, r3
 c006d56:	f8a4 3040 	strh.w	r3, [r4, #64]	; 0x40
 c006d5a:	e7ec      	b.n	c006d36 <CRYP_AESGCM_Process+0x182>
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c006d5c:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 c006d5e:	6b60      	ldr	r0, [r4, #52]	; 0x34
 c006d60:	b29b      	uxth	r3, r3
 c006d62:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    for (index = 0U; index < lastwordsize; index ++)
 c006d66:	3501      	adds	r5, #1
      hcryp->Instance->DINR  = *(uint32_t *)(hcryp->pCrypInBuffPtr + hcryp->CrypInCount);
 c006d68:	6093      	str	r3, [r2, #8]
      hcryp->CrypInCount++;
 c006d6a:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 c006d6c:	3301      	adds	r3, #1
 c006d6e:	b29b      	uxth	r3, r3
 c006d70:	87e3      	strh	r3, [r4, #62]	; 0x3e
 c006d72:	e7be      	b.n	c006cf2 <CRYP_AESGCM_Process+0x13e>
      hcryp->Instance->DINR  = 0U;
 c006d74:	6091      	str	r1, [r2, #8]
      index++;
 c006d76:	3301      	adds	r3, #1
 c006d78:	e7bf      	b.n	c006cfa <CRYP_AESGCM_Process+0x146>
      return HAL_ERROR;
 c006d7a:	2001      	movs	r0, #1
 c006d7c:	e76a      	b.n	c006c54 <CRYP_AESGCM_Process+0xa0>
	...

0c006d80 <HAL_CRYP_Encrypt>:
{
 c006d80:	b570      	push	{r4, r5, r6, lr}
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c006d82:	f890 5051 	ldrb.w	r5, [r0, #81]	; 0x51
{
 c006d86:	4604      	mov	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c006d88:	b2ed      	uxtb	r5, r5
 c006d8a:	2d01      	cmp	r5, #1
 c006d8c:	d176      	bne.n	c006e7c <HAL_CRYP_Encrypt+0xfc>
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c006d8e:	2002      	movs	r0, #2
    __HAL_LOCK(hcryp);
 c006d90:	f894 6050 	ldrb.w	r6, [r4, #80]	; 0x50
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c006d94:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
    __HAL_LOCK(hcryp);
 c006d98:	2e01      	cmp	r6, #1
 c006d9a:	d069      	beq.n	c006e70 <HAL_CRYP_Encrypt+0xf0>
    hcryp->CrypInCount = 0U;
 c006d9c:	2000      	movs	r0, #0
    hcryp->pCrypOutBuffPtr = Output;
 c006d9e:	e9c4 130d 	strd	r1, r3, [r4, #52]	; 0x34
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c006da2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    hcryp->CrypInCount = 0U;
 c006da4:	87e0      	strh	r0, [r4, #62]	; 0x3e
    __HAL_LOCK(hcryp);
 c006da6:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    hcryp->CrypOutCount = 0U;
 c006daa:	f8a4 0040 	strh.w	r0, [r4, #64]	; 0x40
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c006dae:	b903      	cbnz	r3, c006db2 <HAL_CRYP_Encrypt+0x32>
      hcryp->Size = Size * 4U;
 c006db0:	0092      	lsls	r2, r2, #2
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 c006db2:	6823      	ldr	r3, [r4, #0]
      hcryp->Size = Size;
 c006db4:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_ENCRYPT);
 c006db8:	681a      	ldr	r2, [r3, #0]
 c006dba:	f022 0218 	bic.w	r2, r2, #24
 c006dbe:	601a      	str	r2, [r3, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 c006dc0:	681a      	ldr	r2, [r3, #0]
 c006dc2:	4b30      	ldr	r3, [pc, #192]	; (c006e84 <HAL_CRYP_Encrypt+0x104>)
 c006dc4:	4013      	ands	r3, r2
    switch (algo)
 c006dc6:	2b40      	cmp	r3, #64	; 0x40
 c006dc8:	d003      	beq.n	c006dd2 <HAL_CRYP_Encrypt+0x52>
 c006dca:	d83b      	bhi.n	c006e44 <HAL_CRYP_Encrypt+0xc4>
 c006dcc:	b10b      	cbz	r3, c006dd2 <HAL_CRYP_Encrypt+0x52>
 c006dce:	2b20      	cmp	r3, #32
 c006dd0:	d13d      	bne.n	c006e4e <HAL_CRYP_Encrypt+0xce>
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006dd2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 c006dd4:	2b01      	cmp	r3, #1
 c006dd6:	d103      	bne.n	c006de0 <HAL_CRYP_Encrypt+0x60>
    if (hcryp->KeyIVConfig == 1U)
 c006dd8:	6da2      	ldr	r2, [r4, #88]	; 0x58
 c006dda:	2a01      	cmp	r2, #1
 c006ddc:	d010      	beq.n	c006e00 <HAL_CRYP_Encrypt+0x80>
      hcryp->KeyIVConfig = 1U;
 c006dde:	65a3      	str	r3, [r4, #88]	; 0x58
    CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006de0:	68a1      	ldr	r1, [r4, #8]
 c006de2:	4620      	mov	r0, r4
 c006de4:	f7ff fbee 	bl	c0065c4 <CRYP_SetKey>
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 c006de8:	6963      	ldr	r3, [r4, #20]
 c006dea:	b14b      	cbz	r3, c006e00 <HAL_CRYP_Encrypt+0x80>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 c006dec:	6922      	ldr	r2, [r4, #16]
 c006dee:	6823      	ldr	r3, [r4, #0]
 c006df0:	6811      	ldr	r1, [r2, #0]
 c006df2:	62d9      	str	r1, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 c006df4:	6851      	ldr	r1, [r2, #4]
 c006df6:	6299      	str	r1, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 c006df8:	6891      	ldr	r1, [r2, #8]
 c006dfa:	6259      	str	r1, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 c006dfc:	68d2      	ldr	r2, [r2, #12]
 c006dfe:	621a      	str	r2, [r3, #32]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c006e00:	2302      	movs	r3, #2
  __HAL_CRYP_ENABLE(hcryp);
 c006e02:	6822      	ldr	r2, [r4, #0]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c006e04:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 c006e06:	6813      	ldr	r3, [r2, #0]
 c006e08:	f043 0301 	orr.w	r3, r3, #1
 c006e0c:	6013      	str	r3, [r2, #0]
    incount = hcryp->CrypInCount;
 c006e0e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c006e10:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
    incount = hcryp->CrypInCount;
 c006e14:	b292      	uxth	r2, r2
    outcount = hcryp->CrypOutCount;
 c006e16:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c006e1a:	0889      	lsrs	r1, r1, #2
 c006e1c:	4291      	cmp	r1, r2
    outcount = hcryp->CrypOutCount;
 c006e1e:	b29b      	uxth	r3, r3
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c006e20:	d901      	bls.n	c006e26 <HAL_CRYP_Encrypt+0xa6>
 c006e22:	4299      	cmp	r1, r3
 c006e24:	d819      	bhi.n	c006e5a <HAL_CRYP_Encrypt+0xda>
  __HAL_CRYP_DISABLE(hcryp);
 c006e26:	6822      	ldr	r2, [r4, #0]
 c006e28:	6813      	ldr	r3, [r2, #0]
 c006e2a:	f023 0301 	bic.w	r3, r3, #1
 c006e2e:	6013      	str	r3, [r2, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 c006e30:	2301      	movs	r3, #1
 c006e32:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      hcryp->State = HAL_CRYP_STATE_READY;
 c006e36:	2301      	movs	r3, #1
      __HAL_UNLOCK(hcryp);
 c006e38:	2000      	movs	r0, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 c006e3a:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 c006e3e:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
 c006e42:	e015      	b.n	c006e70 <HAL_CRYP_Encrypt+0xf0>
    switch (algo)
 c006e44:	2b60      	cmp	r3, #96	; 0x60
 c006e46:	d00d      	beq.n	c006e64 <HAL_CRYP_Encrypt+0xe4>
 c006e48:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 c006e4c:	d011      	beq.n	c006e72 <HAL_CRYP_Encrypt+0xf2>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 c006e4e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 c006e50:	f043 0320 	orr.w	r3, r3, #32
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c006e54:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 c006e56:	2001      	movs	r0, #1
 c006e58:	e00a      	b.n	c006e70 <HAL_CRYP_Encrypt+0xf0>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c006e5a:	9904      	ldr	r1, [sp, #16]
 c006e5c:	4620      	mov	r0, r4
 c006e5e:	f7ff fd65 	bl	c00692c <CRYP_AES_ProcessData>
 c006e62:	e7d4      	b.n	c006e0e <HAL_CRYP_Encrypt+0x8e>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 c006e64:	9904      	ldr	r1, [sp, #16]
 c006e66:	4620      	mov	r0, r4
 c006e68:	f7ff fea4 	bl	c006bb4 <CRYP_AESGCM_Process>
    if (status == HAL_OK)
 c006e6c:	2800      	cmp	r0, #0
 c006e6e:	d0e2      	beq.n	c006e36 <HAL_CRYP_Encrypt+0xb6>
}
 c006e70:	bd70      	pop	{r4, r5, r6, pc}
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 c006e72:	9904      	ldr	r1, [sp, #16]
 c006e74:	4620      	mov	r0, r4
 c006e76:	f7ff fdc1 	bl	c0069fc <CRYP_AESCCM_Process>
        break;
 c006e7a:	e7f7      	b.n	c006e6c <HAL_CRYP_Encrypt+0xec>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c006e7c:	6d43      	ldr	r3, [r0, #84]	; 0x54
 c006e7e:	f043 0308 	orr.w	r3, r3, #8
 c006e82:	e7e7      	b.n	c006e54 <HAL_CRYP_Encrypt+0xd4>
 c006e84:	00010060 	.word	0x00010060

0c006e88 <HAL_CRYP_Decrypt>:
{
 c006e88:	b570      	push	{r4, r5, r6, lr}
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c006e8a:	f890 5051 	ldrb.w	r5, [r0, #81]	; 0x51
{
 c006e8e:	4604      	mov	r4, r0
  if (hcryp->State == HAL_CRYP_STATE_READY)
 c006e90:	b2ed      	uxtb	r5, r5
 c006e92:	2d01      	cmp	r5, #1
 c006e94:	f040 80b4 	bne.w	c007000 <HAL_CRYP_Decrypt+0x178>
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c006e98:	2002      	movs	r0, #2
    __HAL_LOCK(hcryp);
 c006e9a:	f894 6050 	ldrb.w	r6, [r4, #80]	; 0x50
    hcryp->State = HAL_CRYP_STATE_BUSY;
 c006e9e:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
    __HAL_LOCK(hcryp);
 c006ea2:	2e01      	cmp	r6, #1
 c006ea4:	d04b      	beq.n	c006f3e <HAL_CRYP_Decrypt+0xb6>
    hcryp->CrypInCount = 0U;
 c006ea6:	2000      	movs	r0, #0
    hcryp->pCrypOutBuffPtr = Output;
 c006ea8:	e9c4 130d 	strd	r1, r3, [r4, #52]	; 0x34
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c006eac:	6a63      	ldr	r3, [r4, #36]	; 0x24
    hcryp->CrypInCount = 0U;
 c006eae:	87e0      	strh	r0, [r4, #62]	; 0x3e
    __HAL_LOCK(hcryp);
 c006eb0:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
    hcryp->CrypOutCount = 0U;
 c006eb4:	f8a4 0040 	strh.w	r0, [r4, #64]	; 0x40
    if (hcryp->Init.DataWidthUnit == CRYP_DATAWIDTHUNIT_WORD)
 c006eb8:	b903      	cbnz	r3, c006ebc <HAL_CRYP_Decrypt+0x34>
      hcryp->Size = Size * 4U;
 c006eba:	0092      	lsls	r2, r2, #2
      hcryp->Size = Size;
 c006ebc:	f8a4 2042 	strh.w	r2, [r4, #66]	; 0x42
    MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 c006ec0:	6822      	ldr	r2, [r4, #0]
 c006ec2:	6813      	ldr	r3, [r2, #0]
 c006ec4:	f023 0318 	bic.w	r3, r3, #24
 c006ec8:	f043 0310 	orr.w	r3, r3, #16
 c006ecc:	6013      	str	r3, [r2, #0]
    algo = hcryp->Instance->CR & AES_CR_CHMOD;
 c006ece:	6811      	ldr	r1, [r2, #0]
 c006ed0:	4b4d      	ldr	r3, [pc, #308]	; (c007008 <HAL_CRYP_Decrypt+0x180>)
 c006ed2:	400b      	ands	r3, r1
    switch (algo)
 c006ed4:	2b40      	cmp	r3, #64	; 0x40
 c006ed6:	d003      	beq.n	c006ee0 <HAL_CRYP_Decrypt+0x58>
 c006ed8:	d832      	bhi.n	c006f40 <HAL_CRYP_Decrypt+0xb8>
 c006eda:	b10b      	cbz	r3, c006ee0 <HAL_CRYP_Decrypt+0x58>
 c006edc:	2b20      	cmp	r3, #32
 c006ede:	d134      	bne.n	c006f4a <HAL_CRYP_Decrypt+0xc2>
  if (hcryp->Init.KeyIVConfigSkip == CRYP_KEYIVCONFIG_ONCE)
 c006ee0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 c006ee2:	2b01      	cmp	r3, #1
 c006ee4:	d103      	bne.n	c006eee <HAL_CRYP_Decrypt+0x66>
    if (hcryp->KeyIVConfig == 1U)
 c006ee6:	6da1      	ldr	r1, [r4, #88]	; 0x58
 c006ee8:	2901      	cmp	r1, #1
 c006eea:	d049      	beq.n	c006f80 <HAL_CRYP_Decrypt+0xf8>
      hcryp->KeyIVConfig = 1U;
 c006eec:	65a3      	str	r3, [r4, #88]	; 0x58
    if (hcryp->Init.Algorithm != CRYP_AES_CTR)   /*ECB or CBC*/
 c006eee:	6963      	ldr	r3, [r4, #20]
 c006ef0:	68a1      	ldr	r1, [r4, #8]
 c006ef2:	2b40      	cmp	r3, #64	; 0x40
 c006ef4:	d06f      	beq.n	c006fd6 <HAL_CRYP_Decrypt+0x14e>
      if (hcryp->AutoKeyDerivation == DISABLE)/*Mode 2 Key preparation*/
 c006ef6:	f894 5030 	ldrb.w	r5, [r4, #48]	; 0x30
 c006efa:	2d00      	cmp	r5, #0
 c006efc:	d162      	bne.n	c006fc4 <HAL_CRYP_Decrypt+0x13c>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 c006efe:	6813      	ldr	r3, [r2, #0]
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006f00:	4620      	mov	r0, r4
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION);
 c006f02:	f023 0318 	bic.w	r3, r3, #24
 c006f06:	f043 0308 	orr.w	r3, r3, #8
 c006f0a:	6013      	str	r3, [r2, #0]
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006f0c:	f7ff fb5a 	bl	c0065c4 <CRYP_SetKey>
        __HAL_CRYP_ENABLE(hcryp);
 c006f10:	6822      	ldr	r2, [r4, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006f12:	9904      	ldr	r1, [sp, #16]
        __HAL_CRYP_ENABLE(hcryp);
 c006f14:	6813      	ldr	r3, [r2, #0]
 c006f16:	f043 0301 	orr.w	r3, r3, #1
 c006f1a:	6013      	str	r3, [r2, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006f1c:	f7ff fb73 	bl	c006606 <CRYP_WaitOnCCFlag>
 c006f20:	6823      	ldr	r3, [r4, #0]
          __HAL_CRYP_DISABLE(hcryp);
 c006f22:	681a      	ldr	r2, [r3, #0]
        if (CRYP_WaitOnCCFlag(hcryp, Timeout) != HAL_OK)
 c006f24:	b1b8      	cbz	r0, c006f56 <HAL_CRYP_Decrypt+0xce>
          hcryp->State = HAL_CRYP_STATE_READY;
 c006f26:	2001      	movs	r0, #1
          __HAL_CRYP_DISABLE(hcryp);
 c006f28:	f022 0201 	bic.w	r2, r2, #1
 c006f2c:	601a      	str	r2, [r3, #0]
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006f2e:	6d63      	ldr	r3, [r4, #84]	; 0x54
          __HAL_UNLOCK(hcryp);
 c006f30:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
          hcryp->ErrorCode |= HAL_CRYP_ERROR_TIMEOUT;
 c006f34:	f043 0310 	orr.w	r3, r3, #16
 c006f38:	6563      	str	r3, [r4, #84]	; 0x54
          hcryp->State = HAL_CRYP_STATE_READY;
 c006f3a:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51
}
 c006f3e:	bd70      	pop	{r4, r5, r6, pc}
    switch (algo)
 c006f40:	2b60      	cmp	r3, #96	; 0x60
 c006f42:	d051      	beq.n	c006fe8 <HAL_CRYP_Decrypt+0x160>
 c006f44:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 c006f48:	d055      	beq.n	c006ff6 <HAL_CRYP_Decrypt+0x16e>
        hcryp->ErrorCode |= HAL_CRYP_ERROR_NOT_SUPPORTED;
 c006f4a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 c006f4c:	f043 0320 	orr.w	r3, r3, #32
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c006f50:	6563      	str	r3, [r4, #84]	; 0x54
    status = HAL_ERROR;
 c006f52:	2001      	movs	r0, #1
 c006f54:	e7f3      	b.n	c006f3e <HAL_CRYP_Decrypt+0xb6>
        __HAL_CRYP_CLEAR_FLAG(hcryp, CRYP_CCF_CLEAR);
 c006f56:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 c006f5a:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_DECRYPT);
 c006f5c:	681a      	ldr	r2, [r3, #0]
 c006f5e:	f022 0218 	bic.w	r2, r2, #24
 c006f62:	f042 0210 	orr.w	r2, r2, #16
 c006f66:	601a      	str	r2, [r3, #0]
    if (hcryp->Init.Algorithm != CRYP_AES_ECB)
 c006f68:	6963      	ldr	r3, [r4, #20]
 c006f6a:	b14b      	cbz	r3, c006f80 <HAL_CRYP_Decrypt+0xf8>
      hcryp->Instance->IVR3 = *(uint32_t *)(hcryp->Init.pInitVect);
 c006f6c:	6922      	ldr	r2, [r4, #16]
 c006f6e:	6823      	ldr	r3, [r4, #0]
 c006f70:	6811      	ldr	r1, [r2, #0]
 c006f72:	62d9      	str	r1, [r3, #44]	; 0x2c
      hcryp->Instance->IVR2 = *(uint32_t *)(hcryp->Init.pInitVect + 1U);
 c006f74:	6851      	ldr	r1, [r2, #4]
 c006f76:	6299      	str	r1, [r3, #40]	; 0x28
      hcryp->Instance->IVR1 = *(uint32_t *)(hcryp->Init.pInitVect + 2U);
 c006f78:	6891      	ldr	r1, [r2, #8]
 c006f7a:	6259      	str	r1, [r3, #36]	; 0x24
      hcryp->Instance->IVR0 = *(uint32_t *)(hcryp->Init.pInitVect + 3U);
 c006f7c:	68d2      	ldr	r2, [r2, #12]
 c006f7e:	621a      	str	r2, [r3, #32]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c006f80:	2302      	movs	r3, #2
  __HAL_CRYP_ENABLE(hcryp);
 c006f82:	6822      	ldr	r2, [r4, #0]
  hcryp->Phase = CRYP_PHASE_PROCESS;
 c006f84:	6463      	str	r3, [r4, #68]	; 0x44
  __HAL_CRYP_ENABLE(hcryp);
 c006f86:	6813      	ldr	r3, [r2, #0]
 c006f88:	f043 0301 	orr.w	r3, r3, #1
 c006f8c:	6013      	str	r3, [r2, #0]
    incount = hcryp->CrypInCount;
 c006f8e:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c006f90:	f8b4 1042 	ldrh.w	r1, [r4, #66]	; 0x42
    incount = hcryp->CrypInCount;
 c006f94:	b292      	uxth	r2, r2
    outcount = hcryp->CrypOutCount;
 c006f96:	f8b4 3040 	ldrh.w	r3, [r4, #64]	; 0x40
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c006f9a:	0889      	lsrs	r1, r1, #2
 c006f9c:	4291      	cmp	r1, r2
    outcount = hcryp->CrypOutCount;
 c006f9e:	b29b      	uxth	r3, r3
  while ((incount < (hcryp->Size / 4U)) && (outcount < (hcryp->Size / 4U)))
 c006fa0:	d901      	bls.n	c006fa6 <HAL_CRYP_Decrypt+0x11e>
 c006fa2:	4299      	cmp	r1, r3
 c006fa4:	d81b      	bhi.n	c006fde <HAL_CRYP_Decrypt+0x156>
  __HAL_CRYP_DISABLE(hcryp);
 c006fa6:	6822      	ldr	r2, [r4, #0]
 c006fa8:	6813      	ldr	r3, [r2, #0]
 c006faa:	f023 0301 	bic.w	r3, r3, #1
 c006fae:	6013      	str	r3, [r2, #0]
  hcryp->State = HAL_CRYP_STATE_READY;
 c006fb0:	2301      	movs	r3, #1
 c006fb2:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      hcryp->State = HAL_CRYP_STATE_READY;
 c006fb6:	2301      	movs	r3, #1
      __HAL_UNLOCK(hcryp);
 c006fb8:	2000      	movs	r0, #0
      hcryp->State = HAL_CRYP_STATE_READY;
 c006fba:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
      __HAL_UNLOCK(hcryp);
 c006fbe:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
 c006fc2:	e7bc      	b.n	c006f3e <HAL_CRYP_Decrypt+0xb6>
        CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006fc4:	4620      	mov	r0, r4
 c006fc6:	f7ff fafd 	bl	c0065c4 <CRYP_SetKey>
        MODIFY_REG(hcryp->Instance->CR, AES_CR_MODE, CRYP_OPERATINGMODE_KEYDERIVATION_DECRYPT);
 c006fca:	6822      	ldr	r2, [r4, #0]
 c006fcc:	6813      	ldr	r3, [r2, #0]
 c006fce:	f043 0318 	orr.w	r3, r3, #24
 c006fd2:	6013      	str	r3, [r2, #0]
 c006fd4:	e7c8      	b.n	c006f68 <HAL_CRYP_Decrypt+0xe0>
      CRYP_SetKey(hcryp, hcryp->Init.KeySize);
 c006fd6:	4620      	mov	r0, r4
 c006fd8:	f7ff faf4 	bl	c0065c4 <CRYP_SetKey>
 c006fdc:	e7c4      	b.n	c006f68 <HAL_CRYP_Decrypt+0xe0>
    CRYP_AES_ProcessData(hcryp, Timeout);
 c006fde:	9904      	ldr	r1, [sp, #16]
 c006fe0:	4620      	mov	r0, r4
 c006fe2:	f7ff fca3 	bl	c00692c <CRYP_AES_ProcessData>
 c006fe6:	e7d2      	b.n	c006f8e <HAL_CRYP_Decrypt+0x106>
        status = CRYP_AESGCM_Process(hcryp, Timeout) ;
 c006fe8:	9904      	ldr	r1, [sp, #16]
 c006fea:	4620      	mov	r0, r4
 c006fec:	f7ff fde2 	bl	c006bb4 <CRYP_AESGCM_Process>
    if (status == HAL_OK)
 c006ff0:	2800      	cmp	r0, #0
 c006ff2:	d1a4      	bne.n	c006f3e <HAL_CRYP_Decrypt+0xb6>
 c006ff4:	e7df      	b.n	c006fb6 <HAL_CRYP_Decrypt+0x12e>
        status = CRYP_AESCCM_Process(hcryp, Timeout);
 c006ff6:	9904      	ldr	r1, [sp, #16]
 c006ff8:	4620      	mov	r0, r4
 c006ffa:	f7ff fcff 	bl	c0069fc <CRYP_AESCCM_Process>
        break;
 c006ffe:	e7f7      	b.n	c006ff0 <HAL_CRYP_Decrypt+0x168>
    hcryp->ErrorCode |= HAL_CRYP_ERROR_BUSY;
 c007000:	6d43      	ldr	r3, [r0, #84]	; 0x54
 c007002:	f043 0308 	orr.w	r3, r3, #8
 c007006:	e7a3      	b.n	c006f50 <HAL_CRYP_Decrypt+0xc8>
 c007008:	00010060 	.word	0x00010060

0c00700c <HAL_DMA_Abort>:
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 c00700c:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 c007010:	2b02      	cmp	r3, #2
 c007012:	d006      	beq.n	c007022 <HAL_DMA_Abort+0x16>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 c007014:	2304      	movs	r3, #4
 c007016:	6443      	str	r3, [r0, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 c007018:	2300      	movs	r3, #0
 c00701a:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 c00701e:	2001      	movs	r0, #1
 c007020:	4770      	bx	lr
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 c007022:	6803      	ldr	r3, [r0, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 c007024:	6d01      	ldr	r1, [r0, #80]	; 0x50
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 c007026:	681a      	ldr	r2, [r3, #0]
 c007028:	f022 020e 	bic.w	r2, r2, #14
 c00702c:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 c00702e:	680a      	ldr	r2, [r1, #0]
 c007030:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c007034:	600a      	str	r2, [r1, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 c007036:	681a      	ldr	r2, [r3, #0]
 c007038:	f022 0201 	bic.w	r2, r2, #1
 c00703c:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 c00703e:	e9d0 1312 	ldrd	r1, r3, [r0, #72]	; 0x48
 c007042:	f003 021c 	and.w	r2, r3, #28
 c007046:	2301      	movs	r3, #1
 c007048:	4093      	lsls	r3, r2
 c00704a:	604b      	str	r3, [r1, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 c00704c:	e9d0 3215 	ldrd	r3, r2, [r0, #84]	; 0x54
 c007050:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
 c007052:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 c007054:	b133      	cbz	r3, c007064 <HAL_DMA_Abort+0x58>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 c007056:	681a      	ldr	r2, [r3, #0]
 c007058:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c00705c:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 c00705e:	e9d0 3218 	ldrd	r3, r2, [r0, #96]	; 0x60
 c007062:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 c007064:	2301      	movs	r3, #1
 c007066:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 c00706a:	2300      	movs	r3, #0
 c00706c:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

    return status;
 c007070:	4618      	mov	r0, r3
  }
}
 c007072:	4770      	bx	lr

0c007074 <FLASH_Program_DoubleWord>:
  __IO uint32_t *reg;
  /* Check the parameters */
  assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c007074:	490b      	ldr	r1, [pc, #44]	; (c0070a4 <FLASH_Program_DoubleWord+0x30>)
{
 c007076:	b530      	push	{r4, r5, lr}
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c007078:	688d      	ldr	r5, [r1, #8]
 c00707a:	4c0b      	ldr	r4, [pc, #44]	; (c0070a8 <FLASH_Program_DoubleWord+0x34>)
 c00707c:	490b      	ldr	r1, [pc, #44]	; (c0070ac <FLASH_Program_DoubleWord+0x38>)
 c00707e:	ea31 0125 	bics.w	r1, r1, r5, asr #32
 c007082:	bf28      	it	cs
 c007084:	4621      	movcs	r1, r4
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c007086:	f3ef 8510 	mrs	r5, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c00708a:	b672      	cpsid	i
  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
 c00708c:	680c      	ldr	r4, [r1, #0]
 c00708e:	f044 0401 	orr.w	r4, r4, #1
 c007092:	600c      	str	r4, [r1, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
 c007094:	6002      	str	r2, [r0, #0]
  __ASM volatile ("isb 0xF":::"memory");
 c007096:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
 c00709a:	6043      	str	r3, [r0, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c00709c:	f385 8810 	msr	PRIMASK, r5

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
}
 c0070a0:	bd30      	pop	{r4, r5, pc}
 c0070a2:	bf00      	nop
 c0070a4:	300300b4 	.word	0x300300b4
 c0070a8:	40022028 	.word	0x40022028
 c0070ac:	5002202c 	.word	0x5002202c

0c0070b0 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c0070b0:	4b0d      	ldr	r3, [pc, #52]	; (c0070e8 <HAL_FLASH_Unlock+0x38>)
 c0070b2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c0070b4:	2a00      	cmp	r2, #0
 c0070b6:	461a      	mov	r2, r3
 c0070b8:	db04      	blt.n	c0070c4 <HAL_FLASH_Unlock+0x14>
    if(READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c0070ba:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 c0070bc:	2b00      	cmp	r3, #0
 c0070be:	db0b      	blt.n	c0070d8 <HAL_FLASH_Unlock+0x28>
 c0070c0:	2000      	movs	r0, #0
 c0070c2:	4770      	bx	lr
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
 c0070c4:	4909      	ldr	r1, [pc, #36]	; (c0070ec <HAL_FLASH_Unlock+0x3c>)
 c0070c6:	6099      	str	r1, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
 c0070c8:	f101 3188 	add.w	r1, r1, #2290649224	; 0x88888888
 c0070cc:	6099      	str	r1, [r3, #8]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c0070ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c0070d0:	2b00      	cmp	r3, #0
 c0070d2:	daf2      	bge.n	c0070ba <HAL_FLASH_Unlock+0xa>
      status = HAL_ERROR;
 c0070d4:	2001      	movs	r0, #1
}
 c0070d6:	4770      	bx	lr
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY1);
 c0070d8:	4b04      	ldr	r3, [pc, #16]	; (c0070ec <HAL_FLASH_Unlock+0x3c>)
 c0070da:	60d3      	str	r3, [r2, #12]
      WRITE_REG(FLASH->SECKEYR, FLASH_KEY2);
 c0070dc:	f103 3388 	add.w	r3, r3, #2290649224	; 0x88888888
 c0070e0:	60d3      	str	r3, [r2, #12]
      if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c0070e2:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
      status = HAL_ERROR;
 c0070e4:	0fc0      	lsrs	r0, r0, #31
 c0070e6:	4770      	bx	lr
 c0070e8:	50022000 	.word	0x50022000
 c0070ec:	45670123 	.word	0x45670123

0c0070f0 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
 c0070f0:	4b08      	ldr	r3, [pc, #32]	; (c007114 <HAL_FLASH_Lock+0x24>)
 c0070f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c0070f4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 c0070f8:	629a      	str	r2, [r3, #40]	; 0x28
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
 c0070fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 c0070fc:	2a00      	cmp	r2, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c0070fe:	bfbf      	itttt	lt
 c007100:	6ada      	ldrlt	r2, [r3, #44]	; 0x2c
    status = HAL_OK;
 c007102:	2000      	movlt	r0, #0
    SET_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK);
 c007104:	f042 4200 	orrlt.w	r2, r2, #2147483648	; 0x80000000
 c007108:	62da      	strlt	r2, [r3, #44]	; 0x2c
    if (READ_BIT(FLASH->SECCR, FLASH_SECCR_SECLOCK) != 0u)
 c00710a:	bfb4      	ite	lt
 c00710c:	6adb      	ldrlt	r3, [r3, #44]	; 0x2c
  HAL_StatusTypeDef status = HAL_ERROR;
 c00710e:	2001      	movge	r0, #1
}
 c007110:	4770      	bx	lr
 c007112:	bf00      	nop
 c007114:	50022000 	.word	0x50022000

0c007118 <HAL_FLASH_OB_Unlock>:
  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0u)
 c007118:	4b06      	ldr	r3, [pc, #24]	; (c007134 <HAL_FLASH_OB_Unlock+0x1c>)
 c00711a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 c00711c:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
 c007120:	d007      	beq.n	c007132 <HAL_FLASH_OB_Unlock+0x1a>
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 c007122:	4a05      	ldr	r2, [pc, #20]	; (c007138 <HAL_FLASH_OB_Unlock+0x20>)
 c007124:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 c007126:	f102 3244 	add.w	r2, r2, #1145324612	; 0x44444444
 c00712a:	611a      	str	r2, [r3, #16]
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_OPTLOCK) != 0u)
 c00712c:	6a98      	ldr	r0, [r3, #40]	; 0x28
      return HAL_ERROR;
 c00712e:	f3c0 7080 	ubfx	r0, r0, #30, #1
}
 c007132:	4770      	bx	lr
 c007134:	50022000 	.word	0x50022000
 c007138:	08192a3b 	.word	0x08192a3b

0c00713c <HAL_FLASH_OB_Launch>:
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OBL_LAUNCH);
 c00713c:	4a03      	ldr	r2, [pc, #12]	; (c00714c <HAL_FLASH_OB_Launch+0x10>)
}
 c00713e:	2001      	movs	r0, #1
  SET_BIT(FLASH->NSCR, FLASH_NSCR_OBL_LAUNCH);
 c007140:	6a93      	ldr	r3, [r2, #40]	; 0x28
 c007142:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 c007146:	6293      	str	r3, [r2, #40]	; 0x28
}
 c007148:	4770      	bx	lr
 c00714a:	bf00      	nop
 c00714c:	50022000 	.word	0x50022000

0c007150 <FLASH_WaitForLastOperation>:
{
 c007150:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c007152:	4d1a      	ldr	r5, [pc, #104]	; (c0071bc <FLASH_WaitForLastOperation+0x6c>)
{
 c007154:	4606      	mov	r6, r0
  uint32_t timeout = HAL_GetTick() + Timeout;
 c007156:	f7fc f9a5 	bl	c0034a4 <HAL_GetTick>
 c00715a:	462c      	mov	r4, r5
 c00715c:	1987      	adds	r7, r0, r6
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 c00715e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 c007160:	03da      	lsls	r2, r3, #15
 c007162:	d41a      	bmi.n	c00719a <FLASH_WaitForLastOperation+0x4a>
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);
 c007164:	4b16      	ldr	r3, [pc, #88]	; (c0071c0 <FLASH_WaitForLastOperation+0x70>)
 c007166:	4a17      	ldr	r2, [pc, #92]	; (c0071c4 <FLASH_WaitForLastOperation+0x74>)
 c007168:	6898      	ldr	r0, [r3, #8]
 c00716a:	4917      	ldr	r1, [pc, #92]	; (c0071c8 <FLASH_WaitForLastOperation+0x78>)
 c00716c:	ea31 0120 	bics.w	r1, r1, r0, asr #32
 c007170:	bf28      	it	cs
 c007172:	4611      	movcs	r1, r2
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c007174:	680a      	ldr	r2, [r1, #0]
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c007176:	6a20      	ldr	r0, [r4, #32]
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
 c007178:	f002 02fa 	and.w	r2, r2, #250	; 0xfa
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
 c00717c:	f400 5000 	and.w	r0, r0, #8192	; 0x2000
  if(error != 0u)
 c007180:	4302      	orrs	r2, r0
 c007182:	d012      	beq.n	c0071aa <FLASH_WaitForLastOperation+0x5a>
    pFlash.ErrorCode |= error;
 c007184:	6858      	ldr	r0, [r3, #4]
 c007186:	4310      	orrs	r0, r2
 c007188:	6058      	str	r0, [r3, #4]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c00718a:	0493      	lsls	r3, r2, #18
    (*reg_sr) = error;
 c00718c:	600a      	str	r2, [r1, #0]
    if ((error & FLASH_FLAG_OPTWERR) != 0U)
 c00718e:	d502      	bpl.n	c007196 <FLASH_WaitForLastOperation+0x46>
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
 c007190:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 c007194:	6223      	str	r3, [r4, #32]
    return HAL_ERROR;
 c007196:	2001      	movs	r0, #1
 c007198:	e00e      	b.n	c0071b8 <FLASH_WaitForLastOperation+0x68>
    if(Timeout != HAL_MAX_DELAY)
 c00719a:	1c71      	adds	r1, r6, #1
 c00719c:	d0df      	beq.n	c00715e <FLASH_WaitForLastOperation+0xe>
      if(HAL_GetTick() >= timeout)
 c00719e:	f7fc f981 	bl	c0034a4 <HAL_GetTick>
 c0071a2:	42b8      	cmp	r0, r7
 c0071a4:	d3db      	bcc.n	c00715e <FLASH_WaitForLastOperation+0xe>
        return HAL_TIMEOUT;
 c0071a6:	2003      	movs	r0, #3
 c0071a8:	e006      	b.n	c0071b8 <FLASH_WaitForLastOperation+0x68>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
 c0071aa:	6808      	ldr	r0, [r1, #0]
 c0071ac:	f010 0001 	ands.w	r0, r0, #1
 c0071b0:	d002      	beq.n	c0071b8 <FLASH_WaitForLastOperation+0x68>
    (*reg_sr) = FLASH_FLAG_EOP;
 c0071b2:	2301      	movs	r3, #1
  return HAL_OK;
 c0071b4:	4610      	mov	r0, r2
    (*reg_sr) = FLASH_FLAG_EOP;
 c0071b6:	600b      	str	r3, [r1, #0]
}
 c0071b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c0071ba:	bf00      	nop
 c0071bc:	50022000 	.word	0x50022000
 c0071c0:	300300b4 	.word	0x300300b4
 c0071c4:	40022020 	.word	0x40022020
 c0071c8:	50022024 	.word	0x50022024

0c0071cc <HAL_FLASH_Program>:
{
 c0071cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
 c0071d0:	4c16      	ldr	r4, [pc, #88]	; (c00722c <HAL_FLASH_Program+0x60>)
{
 c0071d2:	461f      	mov	r7, r3
  __HAL_LOCK(&pFlash);
 c0071d4:	7823      	ldrb	r3, [r4, #0]
{
 c0071d6:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c0071d8:	2b01      	cmp	r3, #1
{
 c0071da:	4688      	mov	r8, r1
 c0071dc:	4616      	mov	r6, r2
  __HAL_LOCK(&pFlash);
 c0071de:	d023      	beq.n	c007228 <HAL_FLASH_Program+0x5c>
 c0071e0:	2301      	movs	r3, #1
 c0071e2:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0071e4:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0071e6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0071ea:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0071ec:	f7ff ffb0 	bl	c007150 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 c0071f0:	b9b0      	cbnz	r0, c007220 <HAL_FLASH_Program+0x54>
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0071f2:	4a0f      	ldr	r2, [pc, #60]	; (c007230 <HAL_FLASH_Program+0x64>)
 c0071f4:	4b0f      	ldr	r3, [pc, #60]	; (c007234 <HAL_FLASH_Program+0x68>)
    pFlash.ProcedureOnGoing = TypeProgram;
 c0071f6:	60a5      	str	r5, [r4, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0071f8:	ea32 0525 	bics.w	r5, r2, r5, asr #32
 c0071fc:	bf28      	it	cs
 c0071fe:	461d      	movcs	r5, r3
    FLASH_Program_DoubleWord(Address, Data);
 c007200:	4640      	mov	r0, r8
 c007202:	4632      	mov	r2, r6
 c007204:	463b      	mov	r3, r7
 c007206:	f7ff ff35 	bl	c007074 <FLASH_Program_DoubleWord>
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c00720a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c00720e:	f7ff ff9f 	bl	c007150 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c007212:	68a2      	ldr	r2, [r4, #8]
 c007214:	682b      	ldr	r3, [r5, #0]
 c007216:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 c00721a:	ea23 0302 	bic.w	r3, r3, r2
 c00721e:	602b      	str	r3, [r5, #0]
  __HAL_UNLOCK(&pFlash);
 c007220:	2300      	movs	r3, #0
 c007222:	7023      	strb	r3, [r4, #0]
}
 c007224:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(&pFlash);
 c007228:	2002      	movs	r0, #2
 c00722a:	e7fb      	b.n	c007224 <HAL_FLASH_Program+0x58>
 c00722c:	300300b4 	.word	0x300300b4
 c007230:	5002202c 	.word	0x5002202c
 c007234:	40022028 	.word	0x40022028

0c007238 <FLASH_MassErase>:
  *            @arg FLASH_BANK_2: Bank2 to be erased
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
 c007238:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c00723a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c00723e:	b672      	cpsid	i
  primask_bit = __get_PRIMASK();
  __disable_irq();
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c007240:	4b12      	ldr	r3, [pc, #72]	; (c00728c <FLASH_MassErase+0x54>)
 c007242:	4a13      	ldr	r2, [pc, #76]	; (c007290 <FLASH_MassErase+0x58>)
 c007244:	689c      	ldr	r4, [r3, #8]
 c007246:	4b13      	ldr	r3, [pc, #76]	; (c007294 <FLASH_MassErase+0x5c>)
 c007248:	ea33 0324 	bics.w	r3, r3, r4, asr #32
 c00724c:	bf28      	it	cs
 c00724e:	4613      	movcs	r3, r2

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 c007250:	4a11      	ldr	r2, [pc, #68]	; (c007298 <FLASH_MassErase+0x60>)
 c007252:	6c12      	ldr	r2, [r2, #64]	; 0x40
 c007254:	0252      	lsls	r2, r2, #9
 c007256:	d512      	bpl.n	c00727e <FLASH_MassErase+0x46>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 c007258:	07c4      	lsls	r4, r0, #31
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
 c00725a:	bf42      	ittt	mi
 c00725c:	681a      	ldrmi	r2, [r3, #0]
 c00725e:	f042 0204 	orrmi.w	r2, r2, #4
 c007262:	601a      	strmi	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 c007264:	0782      	lsls	r2, r0, #30
 c007266:	d503      	bpl.n	c007270 <FLASH_MassErase+0x38>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
 c007268:	681a      	ldr	r2, [r3, #0]
 c00726a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c00726e:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c007270:	681a      	ldr	r2, [r3, #0]
 c007272:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c007276:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c007278:	f381 8810 	msr	PRIMASK, r1

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
 c00727c:	bd10      	pop	{r4, pc}
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
 c00727e:	681a      	ldr	r2, [r3, #0]
 c007280:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 c007284:	f042 0204 	orr.w	r2, r2, #4
 c007288:	e7f1      	b.n	c00726e <FLASH_MassErase+0x36>
 c00728a:	bf00      	nop
 c00728c:	300300b4 	.word	0x300300b4
 c007290:	40022028 	.word	0x40022028
 c007294:	5002202c 	.word	0x5002202c
 c007298:	50022000 	.word	0x50022000

0c00729c <HAL_FLASHEx_OBProgram>:
{
 c00729c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 c00729e:	4d96      	ldr	r5, [pc, #600]	; (c0074f8 <HAL_FLASHEx_OBProgram+0x25c>)
{
 c0072a0:	4604      	mov	r4, r0
  __HAL_LOCK(&pFlash);
 c0072a2:	782b      	ldrb	r3, [r5, #0]
 c0072a4:	2b01      	cmp	r3, #1
 c0072a6:	f000 8124 	beq.w	c0074f2 <HAL_FLASHEx_OBProgram+0x256>
 c0072aa:	2301      	movs	r3, #1
 c0072ac:	702b      	strb	r3, [r5, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0072ae:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0072b0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0072b4:	606b      	str	r3, [r5, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0072b6:	f7ff ff4b 	bl	c007150 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 c0072ba:	2800      	cmp	r0, #0
 c0072bc:	f040 80db 	bne.w	c007476 <HAL_FLASHEx_OBProgram+0x1da>
    if((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 c0072c0:	6826      	ldr	r6, [r4, #0]
 c0072c2:	07f1      	lsls	r1, r6, #31
 c0072c4:	d50d      	bpl.n	c0072e2 <HAL_FLASHEx_OBProgram+0x46>
      FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 c0072c6:	e9d4 2001 	ldrd	r2, r0, [r4, #4]
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRPEndOffset));

  /* Configure the write protected area */
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c0072ca:	2a01      	cmp	r2, #1
      FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset);
 c0072cc:	68e1      	ldr	r1, [r4, #12]
 c0072ce:	4b8b      	ldr	r3, [pc, #556]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c0072d0:	f040 80d4 	bne.w	c00747c <HAL_FLASHEx_OBProgram+0x1e0>
  {
    MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_PSTRT | FLASH_WRP1AR_WRP1A_PEND),
 c0072d4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c0072d6:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0072da:	4302      	orrs	r2, r0
 c0072dc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0072e0:	659a      	str	r2, [r3, #88]	; 0x58
    if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 c0072e2:	07b2      	lsls	r2, r6, #30
 c0072e4:	d506      	bpl.n	c0072f4 <HAL_FLASHEx_OBProgram+0x58>
{
  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));

  /* Configure the RDP level in the option bytes register */
  MODIFY_REG(FLASH->OPTR, FLASH_OPTR_RDP, RDPLevel);
 c0072e6:	4a85      	ldr	r2, [pc, #532]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
 c0072e8:	6921      	ldr	r1, [r4, #16]
 c0072ea:	6c13      	ldr	r3, [r2, #64]	; 0x40
 c0072ec:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 c0072f0:	430b      	orrs	r3, r1
 c0072f2:	6413      	str	r3, [r2, #64]	; 0x40
    if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 c0072f4:	0773      	lsls	r3, r6, #29
 c0072f6:	d579      	bpl.n	c0073ec <HAL_FLASHEx_OBProgram+0x150>
      FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig);
 c0072f8:	e9d4 0105 	ldrd	r0, r1, [r4, #20]
  uint32_t optr_reg_mask = 0;

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));

  if((UserType & OB_USER_BOR_LEV) != 0U)
 c0072fc:	f010 0301 	ands.w	r3, r0, #1
  uint32_t optr_reg_val = 0;
 c007300:	bf0e      	itee	eq
 c007302:	461a      	moveq	r2, r3
    /* BOR level option byte should be modified */
    assert_param(IS_OB_USER_BOR_LEVEL(UserConfig & FLASH_OPTR_BOR_LEV));

    /* Set value and mask for BOR level option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
    optr_reg_mask |= FLASH_OPTR_BOR_LEV;
 c007304:	f44f 63e0 	movne.w	r3, #1792	; 0x700
    optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
 c007308:	f401 62e0 	andne.w	r2, r1, #1792	; 0x700
  }

  if((UserType & OB_USER_nRST_STOP) != 0U)
 c00730c:	0787      	lsls	r7, r0, #30
  {
    /* nRST_STOP option byte should be modified */
    assert_param(IS_OB_USER_STOP(UserConfig & FLASH_OPTR_nRST_STOP));

    /* Set value and mask for nRST_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STOP);
 c00730e:	bf42      	ittt	mi
 c007310:	f401 5780 	andmi.w	r7, r1, #4096	; 0x1000
 c007314:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nRST_STOP;
 c007316:	f443 5380 	orrmi.w	r3, r3, #4096	; 0x1000
  }

  if((UserType & OB_USER_nRST_STDBY) != 0U)
 c00731a:	0747      	lsls	r7, r0, #29
  {
    /* nRST_STDBY option byte should be modified */
    assert_param(IS_OB_USER_STANDBY(UserConfig & FLASH_OPTR_nRST_STDBY));

    /* Set value and mask for nRST_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STDBY);
 c00731c:	bf42      	ittt	mi
 c00731e:	f401 5700 	andmi.w	r7, r1, #8192	; 0x2000
 c007322:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nRST_STDBY;
 c007324:	f443 5300 	orrmi.w	r3, r3, #8192	; 0x2000
  }

  if((UserType & OB_USER_nRST_SHDW) != 0U)
 c007328:	0707      	lsls	r7, r0, #28
  {
    /* nRST_SHDW option byte should be modified */
    assert_param(IS_OB_USER_SHUTDOWN(UserConfig & FLASH_OPTR_nRST_SHDW));

    /* Set value and mask for nRST_SHDW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_SHDW);
 c00732a:	bf42      	ittt	mi
 c00732c:	f401 4780 	andmi.w	r7, r1, #16384	; 0x4000
 c007330:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nRST_SHDW;
 c007332:	f443 4380 	orrmi.w	r3, r3, #16384	; 0x4000
  }

  if((UserType & OB_USER_IWDG_SW) != 0U)
 c007336:	06c7      	lsls	r7, r0, #27
  {
    /* IWDG_SW option byte should be modified */
    assert_param(IS_OB_USER_IWDG(UserConfig & FLASH_OPTR_IWDG_SW));

    /* Set value and mask for IWDG_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_SW);
 c007338:	bf42      	ittt	mi
 c00733a:	f401 3780 	andmi.w	r7, r1, #65536	; 0x10000
 c00733e:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_SW;
 c007340:	f443 3380 	orrmi.w	r3, r3, #65536	; 0x10000
  }

  if((UserType & OB_USER_IWDG_STOP) != 0U)
 c007344:	0687      	lsls	r7, r0, #26
  {
    /* IWDG_STOP option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTR_IWDG_STOP));

    /* Set value and mask for IWDG_STOP option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STOP);
 c007346:	bf42      	ittt	mi
 c007348:	f401 3700 	andmi.w	r7, r1, #131072	; 0x20000
 c00734c:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_STOP;
 c00734e:	f443 3300 	orrmi.w	r3, r3, #131072	; 0x20000
  }

  if((UserType & OB_USER_IWDG_STDBY) != 0U)
 c007352:	0647      	lsls	r7, r0, #25
  {
    /* IWDG_STDBY option byte should be modified */
    assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTR_IWDG_STDBY));

    /* Set value and mask for IWDG_STDBY option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STDBY);
 c007354:	bf42      	ittt	mi
 c007356:	f401 2780 	andmi.w	r7, r1, #262144	; 0x40000
 c00735a:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_IWDG_STDBY;
 c00735c:	f443 2380 	orrmi.w	r3, r3, #262144	; 0x40000
  }

  if((UserType & OB_USER_WWDG_SW) != 0U)
 c007360:	0607      	lsls	r7, r0, #24
  {
    /* WWDG_SW option byte should be modified */
    assert_param(IS_OB_USER_WWDG(UserConfig & FLASH_OPTR_WWDG_SW));

    /* Set value and mask for WWDG_SW option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_WWDG_SW);
 c007362:	bf42      	ittt	mi
 c007364:	f401 2700 	andmi.w	r7, r1, #524288	; 0x80000
 c007368:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_WWDG_SW;
 c00736a:	f443 2300 	orrmi.w	r3, r3, #524288	; 0x80000
  }

  if((UserType & OB_USER_SWAP_BANK) != 0U)
 c00736e:	05c7      	lsls	r7, r0, #23
  {
    /* SWAP_BANK option byte should be modified */
    assert_param(IS_OB_USER_SWAP_BANK(UserConfig & FLASH_OPTR_SWAP_BANK));

    /* Set value and mask for SWAP_BANK option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SWAP_BANK);
 c007370:	bf42      	ittt	mi
 c007372:	f401 1780 	andmi.w	r7, r1, #1048576	; 0x100000
 c007376:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_SWAP_BANK;
 c007378:	f443 1380 	orrmi.w	r3, r3, #1048576	; 0x100000
  }

  if((UserType & OB_USER_DUALBANK) != 0U)
 c00737c:	0587      	lsls	r7, r0, #22
  {
    /* DUALBANK option byte should be modified */
    assert_param(IS_OB_USER_DUALBANK(UserConfig & FLASH_OPTR_DB256K));

    /* Set value and mask for DB256K option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_DB256K);
 c00737e:	bf42      	ittt	mi
 c007380:	f401 1700 	andmi.w	r7, r1, #2097152	; 0x200000
 c007384:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_DB256K;
 c007386:	f443 1300 	orrmi.w	r3, r3, #2097152	; 0x200000
  }

  if((UserType & OB_USER_SRAM2_PE) != 0U)
 c00738a:	0507      	lsls	r7, r0, #20
  {
    /* SRAM2_PAR option byte should be modified */
    assert_param(IS_OB_USER_SRAM2_PARITY(UserConfig & FLASH_OPTR_SRAM2_PE));

    /* Set value and mask for SRAM2_PAR option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_PE);
 c00738c:	bf42      	ittt	mi
 c00738e:	f001 7780 	andmi.w	r7, r1, #16777216	; 0x1000000
 c007392:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_SRAM2_PE;
 c007394:	f043 7380 	orrmi.w	r3, r3, #16777216	; 0x1000000
  }

  if((UserType & OB_USER_SRAM2_RST) != 0U)
 c007398:	04c7      	lsls	r7, r0, #19
  {
    /* SRAM2_RST option byte should be modified */
    assert_param(IS_OB_USER_SRAM2_RST(UserConfig & FLASH_OPTR_SRAM2_RST));

    /* Set value and mask for SRAM2_RST option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_RST);
 c00739a:	bf42      	ittt	mi
 c00739c:	f001 7700 	andmi.w	r7, r1, #33554432	; 0x2000000
 c0073a0:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_SRAM2_RST;
 c0073a2:	f043 7300 	orrmi.w	r3, r3, #33554432	; 0x2000000
  }

  if((UserType & OB_USER_nSWBOOT0) != 0U)
 c0073a6:	0487      	lsls	r7, r0, #18
  {
    /* nSWBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_SWBOOT0(UserConfig & FLASH_OPTR_nSWBOOT0));

    /* Set value and mask for nSWBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nSWBOOT0);
 c0073a8:	bf42      	ittt	mi
 c0073aa:	f001 6780 	andmi.w	r7, r1, #67108864	; 0x4000000
 c0073ae:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nSWBOOT0;
 c0073b0:	f043 6380 	orrmi.w	r3, r3, #67108864	; 0x4000000
  }

  if((UserType & OB_USER_nBOOT0) != 0U)
 c0073b4:	0447      	lsls	r7, r0, #17
  {
    /* nBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_BOOT0(UserConfig & FLASH_OPTR_nBOOT0));

    /* Set value and mask for nBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT0);
 c0073b6:	bf42      	ittt	mi
 c0073b8:	f001 6700 	andmi.w	r7, r1, #134217728	; 0x8000000
 c0073bc:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_nBOOT0;
 c0073be:	f043 6300 	orrmi.w	r3, r3, #134217728	; 0x8000000
  }

  if((UserType & OB_USER_PA15_PUPEN) != 0U)
 c0073c2:	0407      	lsls	r7, r0, #16
  {
    /* nBOOT0 option byte should be modified */
    assert_param(IS_OB_USER_PA15_PUPEN(UserConfig & FLASH_OPTR_PA15_PUPEN));

    /* Set value and mask for nBOOT0 option byte */
    optr_reg_val |= (UserConfig & FLASH_OPTR_PA15_PUPEN);
 c0073c4:	bf42      	ittt	mi
 c0073c6:	f001 5780 	andmi.w	r7, r1, #268435456	; 0x10000000
 c0073ca:	433a      	orrmi	r2, r7
    optr_reg_mask |= FLASH_OPTR_PA15_PUPEN;
 c0073cc:	f043 5380 	orrmi.w	r3, r3, #268435456	; 0x10000000
  }

  if((UserType & OB_USER_TZEN) != 0U)
 c0073d0:	03c0      	lsls	r0, r0, #15
    optr_reg_val |= (UserConfig & FLASH_OPTR_TZEN);
    optr_reg_mask |= FLASH_OPTR_TZEN;
  }

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0073d2:	484a      	ldr	r0, [pc, #296]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
    optr_reg_val |= (UserConfig & FLASH_OPTR_TZEN);
 c0073d4:	bf44      	itt	mi
 c0073d6:	f001 4100 	andmi.w	r1, r1, #2147483648	; 0x80000000
 c0073da:	430a      	orrmi	r2, r1
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0073dc:	6c01      	ldr	r1, [r0, #64]	; 0x40
    optr_reg_mask |= FLASH_OPTR_TZEN;
 c0073de:	bf48      	it	mi
 c0073e0:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
  MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 c0073e4:	ea21 0303 	bic.w	r3, r1, r3
 c0073e8:	431a      	orrs	r2, r3
 c0073ea:	6402      	str	r2, [r0, #64]	; 0x40
    if((pOBInit->OptionType & OPTIONBYTE_WMSEC) != 0U)
 c0073ec:	06f1      	lsls	r1, r6, #27
 c0073ee:	d524      	bpl.n	c00743a <HAL_FLASHEx_OBProgram+0x19e>
      FLASH_OB_WMSECConfig(pOBInit->WMSecConfig, pOBInit->WMSecStartPage, pOBInit->WMSecEndPage, pOBInit->WMHDPEndPage);
 c0073f0:	e9d4 1007 	ldrd	r1, r0, [r4, #28]
 c0073f4:	e9d4 ec09 	ldrd	lr, ip, [r4, #36]	; 0x24
  assert_param(IS_FLASH_PAGE(WMSecStartPage));
  assert_param(IS_FLASH_PAGE(WMSecEndPage));
  assert_param(IS_FLASH_PAGE(WMHDPEndPage));

  /* Read SECWM registers */
  if ((WMSecConfig & OB_WMSEC_AREA1) != 0U)
 c0073f8:	f011 0701 	ands.w	r7, r1, #1
 c0073fc:	4b3f      	ldr	r3, [pc, #252]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
 c0073fe:	d05c      	beq.n	c0074ba <HAL_FLASHEx_OBProgram+0x21e>
  {
    tmp_secwm1 = FLASH->SECWM1R1;
 c007400:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    tmp_secwm2 = FLASH->SECWM1R2;
 c007402:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  {
    /* Nothing to do */
  }

  /* Configure Secure Area */
  if ((WMSecConfig & OB_WMSEC_SECURE_AREA_CONFIG) != 0U)
 c007404:	f011 0f10 	tst.w	r1, #16
  {
    MODIFY_REG(tmp_secwm1, (FLASH_SECWM1R1_SECWM1_PSTRT | FLASH_SECWM1R1_SECWM1_PEND),
 c007408:	bf1e      	ittt	ne
 c00740a:	ea40 400e 	orrne.w	r0, r0, lr, lsl #16
 c00740e:	f022 127f 	bicne.w	r2, r2, #8323199	; 0x7f007f
 c007412:	4302      	orrne	r2, r0
               ((WMSecEndPage << FLASH_SECWM1R1_SECWM1_PEND_Pos) | WMSecStartPage));
  }

  /* Configure Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_CONFIG) != 0U)
 c007414:	0688      	lsls	r0, r1, #26
  {
    tmp_secwm2 &= (~(FLASH_SECWM1R2_HDP1_PEND));
 c007416:	bf44      	itt	mi
 c007418:	f423 03fe 	bicmi.w	r3, r3, #8323072	; 0x7f0000
    tmp_secwm2 |= (WMHDPEndPage << FLASH_SECWM1R2_HDP1_PEND_Pos);
 c00741c:	ea43 430c 	orrmi.w	r3, r3, ip, lsl #16
  }

  /* Enable Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_ENABLE) != 0U)
 c007420:	0608      	lsls	r0, r1, #24
  {
    tmp_secwm2 |= FLASH_SECWM1R2_HDP1EN;
 c007422:	bf48      	it	mi
 c007424:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
  }

  /* Disable Secure Hide Area */
  if ((WMSecConfig & OB_WMSEC_HDP_AREA_DISABLE) != 0U)
 c007428:	05c8      	lsls	r0, r1, #23
  {
    tmp_secwm2 &= (~FLASH_SECWM1R2_HDP1EN);
 c00742a:	bf48      	it	mi
 c00742c:	f023 4300 	bicmi.w	r3, r3, #2147483648	; 0x80000000
 c007430:	4832      	ldr	r0, [pc, #200]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
  }

  /* Write SECWM registers */
  if ((WMSecConfig & OB_WMSEC_AREA1) != 0U)
 c007432:	2f00      	cmp	r7, #0
 c007434:	d048      	beq.n	c0074c8 <HAL_FLASHEx_OBProgram+0x22c>
  {
    FLASH->SECWM1R1 = tmp_secwm1;
 c007436:	6502      	str	r2, [r0, #80]	; 0x50
    FLASH->SECWM1R2 = tmp_secwm2;
 c007438:	6543      	str	r3, [r0, #84]	; 0x54
    if((pOBInit->OptionType & OPTIONBYTE_BOOT_LOCK) != 0U)
 c00743a:	06b2      	lsls	r2, r6, #26
 c00743c:	d506      	bpl.n	c00744c <HAL_FLASHEx_OBProgram+0x1b0>
{
  /* Check the parameters */
  assert_param(IS_OB_BOOT_LOCK(BootLockConfig));

  /* Configure the option bytes register */
  MODIFY_REG(FLASH->SECBOOTADD0R, FLASH_SECBOOTADD0R_BOOT_LOCK, BootLockConfig);
 c00743e:	4a2f      	ldr	r2, [pc, #188]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
 c007440:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 c007442:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c007444:	f023 0301 	bic.w	r3, r3, #1
 c007448:	430b      	orrs	r3, r1
 c00744a:	64d3      	str	r3, [r2, #76]	; 0x4c
    if((pOBInit->OptionType & OPTIONBYTE_BOOTADDR) != 0U)
 c00744c:	0733      	lsls	r3, r6, #28
 c00744e:	d509      	bpl.n	c007464 <HAL_FLASHEx_OBProgram+0x1c8>
      FLASH_OB_BootAddrConfig(pOBInit->BootAddrConfig, pOBInit->BootAddr);
 c007450:	e9d4 210c 	ldrd	r2, r1, [r4, #48]	; 0x30
static void FLASH_OB_BootAddrConfig(uint32_t BootAddrConfig, uint32_t BootAddr)
{
  /* Check the parameters */
  assert_param(IS_OB_BOOTADDR_CONFIG(BootAddrConfig));

  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c007454:	2a01      	cmp	r2, #1
 c007456:	4b29      	ldr	r3, [pc, #164]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
 c007458:	d13b      	bne.n	c0074d2 <HAL_FLASHEx_OBProgram+0x236>
  {
    MODIFY_REG(FLASH->NSBOOTADD0R, FLASH_NSBOOTADD0R_NSBOOTADD0, BootAddr);
 c00745a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 c00745c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c007460:	430a      	orrs	r2, r1
 c007462:	645a      	str	r2, [r3, #68]	; 0x44
    SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTSTRT);
 c007464:	4a25      	ldr	r2, [pc, #148]	; (c0074fc <HAL_FLASHEx_OBProgram+0x260>)
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c007466:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    SET_BIT(FLASH->NSCR, FLASH_NSCR_OPTSTRT);
 c00746a:	6a93      	ldr	r3, [r2, #40]	; 0x28
 c00746c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 c007470:	6293      	str	r3, [r2, #40]	; 0x28
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c007472:	f7ff fe6d 	bl	c007150 <FLASH_WaitForLastOperation>
  __HAL_UNLOCK(&pFlash);
 c007476:	2300      	movs	r3, #0
 c007478:	702b      	strb	r3, [r5, #0]
}
 c00747a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 c00747c:	2a02      	cmp	r2, #2
 c00747e:	d107      	bne.n	c007490 <HAL_FLASHEx_OBProgram+0x1f4>
    MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_PSTRT | FLASH_WRP1BR_WRP1B_PEND),
 c007480:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c007482:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c007486:	4302      	orrs	r2, r0
 c007488:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c00748c:	65da      	str	r2, [r3, #92]	; 0x5c
 c00748e:	e728      	b.n	c0072e2 <HAL_FLASHEx_OBProgram+0x46>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAA)
 c007490:	2a04      	cmp	r2, #4
 c007492:	d107      	bne.n	c0074a4 <HAL_FLASHEx_OBProgram+0x208>
    MODIFY_REG(FLASH->WRP2AR, (FLASH_WRP2AR_WRP2A_PSTRT | FLASH_WRP2AR_WRP2A_PEND),
 c007494:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 c007496:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c00749a:	4302      	orrs	r2, r0
 c00749c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0074a0:	669a      	str	r2, [r3, #104]	; 0x68
 c0074a2:	e71e      	b.n	c0072e2 <HAL_FLASHEx_OBProgram+0x46>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
 c0074a4:	2a08      	cmp	r2, #8
 c0074a6:	f47f af1c 	bne.w	c0072e2 <HAL_FLASHEx_OBProgram+0x46>
    MODIFY_REG(FLASH->WRP2BR, (FLASH_WRP2BR_WRP2B_PSTRT | FLASH_WRP2BR_WRP2B_PEND),
 c0074aa:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 c0074ac:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 c0074b0:	4302      	orrs	r2, r0
 c0074b2:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 c0074b6:	66da      	str	r2, [r3, #108]	; 0x6c
 c0074b8:	e713      	b.n	c0072e2 <HAL_FLASHEx_OBProgram+0x46>
  else if ((WMSecConfig & OB_WMSEC_AREA2) != 0U)
 c0074ba:	078a      	lsls	r2, r1, #30
    tmp_secwm1 = FLASH->SECWM2R1;
 c0074bc:	bf4b      	itete	mi
 c0074be:	6e1a      	ldrmi	r2, [r3, #96]	; 0x60
  uint32_t tmp_secwm1 = 0U, tmp_secwm2 = 0U;
 c0074c0:	463b      	movpl	r3, r7
    tmp_secwm2 = FLASH->SECWM2R2;
 c0074c2:	6e5b      	ldrmi	r3, [r3, #100]	; 0x64
  uint32_t tmp_secwm1 = 0U, tmp_secwm2 = 0U;
 c0074c4:	463a      	movpl	r2, r7
 c0074c6:	e79d      	b.n	c007404 <HAL_FLASHEx_OBProgram+0x168>
  else if ((WMSecConfig & OB_WMSEC_AREA2) != 0U)
 c0074c8:	0789      	lsls	r1, r1, #30
    FLASH->SECWM2R1 = tmp_secwm1;
 c0074ca:	bf44      	itt	mi
 c0074cc:	6602      	strmi	r2, [r0, #96]	; 0x60
    FLASH->SECWM2R2 = tmp_secwm2;
 c0074ce:	6643      	strmi	r3, [r0, #100]	; 0x64
 c0074d0:	e7b3      	b.n	c00743a <HAL_FLASHEx_OBProgram+0x19e>
  }
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 c0074d2:	2a02      	cmp	r2, #2
 c0074d4:	d105      	bne.n	c0074e2 <HAL_FLASHEx_OBProgram+0x246>
  {
    MODIFY_REG(FLASH->NSBOOTADD1R, FLASH_NSBOOTADD1R_NSBOOTADD1, BootAddr);
 c0074d6:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 c0074d8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0074dc:	430a      	orrs	r2, r1
 c0074de:	649a      	str	r2, [r3, #72]	; 0x48
 c0074e0:	e7c0      	b.n	c007464 <HAL_FLASHEx_OBProgram+0x1c8>
  }
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
 c0074e2:	2a04      	cmp	r2, #4
  {
    MODIFY_REG(FLASH->SECBOOTADD0R, FLASH_SECBOOTADD0R_SECBOOTADD0, BootAddr);
 c0074e4:	bf01      	itttt	eq
 c0074e6:	6cda      	ldreq	r2, [r3, #76]	; 0x4c
 c0074e8:	f002 027f 	andeq.w	r2, r2, #127	; 0x7f
 c0074ec:	430a      	orreq	r2, r1
 c0074ee:	64da      	streq	r2, [r3, #76]	; 0x4c
 c0074f0:	e7b8      	b.n	c007464 <HAL_FLASHEx_OBProgram+0x1c8>
  __HAL_LOCK(&pFlash);
 c0074f2:	2002      	movs	r0, #2
 c0074f4:	e7c1      	b.n	c00747a <HAL_FLASHEx_OBProgram+0x1de>
 c0074f6:	bf00      	nop
 c0074f8:	300300b4 	.word	0x300300b4
 c0074fc:	50022000 	.word	0x50022000

0c007500 <HAL_FLASHEx_OBGetConfig>:
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 c007500:	2306      	movs	r3, #6
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c007502:	6842      	ldr	r2, [r0, #4]
{
 c007504:	b510      	push	{r4, lr}
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c007506:	2a08      	cmp	r2, #8
  pOBInit->OptionType = (OPTIONBYTE_RDP | OPTIONBYTE_USER);
 c007508:	6003      	str	r3, [r0, #0]
  if((pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAA) || (pOBInit->WRPArea == OB_WRPAREA_BANK1_AREAB) ||
 c00750a:	d811      	bhi.n	c007530 <HAL_FLASHEx_OBGetConfig+0x30>
 c00750c:	f44f 738b 	mov.w	r3, #278	; 0x116
 c007510:	40d3      	lsrs	r3, r2
 c007512:	07db      	lsls	r3, r3, #31
 c007514:	d50c      	bpl.n	c007530 <HAL_FLASHEx_OBGetConfig+0x30>
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 c007516:	2307      	movs	r3, #7
  * @retval None
  */
static void FLASH_OB_GetWRP(uint32_t WRPArea, uint32_t * WRPStartOffset, uint32_t * WRPEndOffset)
{
  /* Get the configuration of the write protected area */
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c007518:	2a01      	cmp	r2, #1
    pOBInit->OptionType |= OPTIONBYTE_WRP;
 c00751a:	6003      	str	r3, [r0, #0]
 c00751c:	4b39      	ldr	r3, [pc, #228]	; (c007604 <HAL_FLASHEx_OBGetConfig+0x104>)
  if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 c00751e:	d14e      	bne.n	c0075be <HAL_FLASHEx_OBGetConfig+0xbe>
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PSTRT);
 c007520:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c007522:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c007526:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1AR, FLASH_WRP1AR_WRP1A_PEND) >> FLASH_WRP1AR_WRP1A_PEND_Pos);
 c007528:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
  }
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
  {
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 c00752a:	f3c3 4306 	ubfx	r3, r3, #16, #7
 c00752e:	60c3      	str	r3, [r0, #12]
  *            @arg OB_RDP_LEVEL_1: Read protection of the memory
  *            @arg OB_RDP_LEVEL_2: Full chip protection
  */
static uint32_t FLASH_OB_GetRDP(void)
{
  uint32_t rdp_level = READ_BIT(FLASH->OPTR, FLASH_OPTR_RDP);
 c007530:	4a34      	ldr	r2, [pc, #208]	; (c007604 <HAL_FLASHEx_OBGetConfig+0x104>)
 c007532:	6c13      	ldr	r3, [r2, #64]	; 0x40
 c007534:	b2db      	uxtb	r3, r3

  if ((rdp_level != OB_RDP_LEVEL_0) && (rdp_level != OB_RDP_LEVEL_0_5) && (rdp_level != OB_RDP_LEVEL_2))
 c007536:	2baa      	cmp	r3, #170	; 0xaa
 c007538:	d004      	beq.n	c007544 <HAL_FLASHEx_OBGetConfig+0x44>
 c00753a:	2b55      	cmp	r3, #85	; 0x55
 c00753c:	d002      	beq.n	c007544 <HAL_FLASHEx_OBGetConfig+0x44>
  {
    return (OB_RDP_LEVEL_1);
 c00753e:	2bcc      	cmp	r3, #204	; 0xcc
 c007540:	bf18      	it	ne
 c007542:	23bb      	movne	r3, #187	; 0xbb
  pOBInit->RDPLevel = FLASH_OB_GetRDP();
 c007544:	6103      	str	r3, [r0, #16]
  *         @ref OB_USER_nSWBOOT0, @ref OB_USER_nBOOT0, @ref FLASH_OB_USER_PA15_PUPEN
  *         and @ref OB_USER_TZEN
  */
static uint32_t FLASH_OB_GetUser(void)
{
  uint32_t user_config = READ_REG(FLASH->OPTR);
 c007546:	6c13      	ldr	r3, [r2, #64]	; 0x40
  CLEAR_BIT(user_config, FLASH_OPTR_RDP);
 c007548:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  pOBInit->USERConfig = FLASH_OB_GetUser();
 c00754c:	6183      	str	r3, [r0, #24]
  if ((pOBInit->WMSecConfig == OB_WMSEC_AREA1) || (pOBInit->WMSecConfig == OB_WMSEC_AREA2))
 c00754e:	69c3      	ldr	r3, [r0, #28]
 c007550:	1e59      	subs	r1, r3, #1
 c007552:	2901      	cmp	r1, #1
 c007554:	d81a      	bhi.n	c00758c <HAL_FLASHEx_OBGetConfig+0x8c>
    pOBInit->OptionType |= OPTIONBYTE_WMSEC;
 c007556:	6801      	ldr	r1, [r0, #0]
  /* Check the parameters */
  assert_param(IS_OB_WMSEC_CONFIG(*WMSecConfig));
  assert_param(IS_FLASH_BANK_EXCLUSIVE((*WMSecConfig) & 0x3U));

  /* Read SECWM registers */
  if (((*WMSecConfig) & OB_WMSEC_AREA1) != 0U)
 c007558:	2b01      	cmp	r3, #1
    pOBInit->OptionType |= OPTIONBYTE_WMSEC;
 c00755a:	f041 0110 	orr.w	r1, r1, #16
 c00755e:	6001      	str	r1, [r0, #0]
  {
    tmp_secwm1 = FLASH->SECWM1R1;
 c007560:	bf0b      	itete	eq
 c007562:	6d11      	ldreq	r1, [r2, #80]	; 0x50
    tmp_secwm2 = FLASH->SECWM1R2;
  }
  else if (((*WMSecConfig) & OB_WMSEC_AREA2) != 0U)
  {
    tmp_secwm1 = FLASH->SECWM2R1;
 c007564:	6e11      	ldrne	r1, [r2, #96]	; 0x60
    tmp_secwm2 = FLASH->SECWM1R2;
 c007566:	6d52      	ldreq	r2, [r2, #84]	; 0x54
    tmp_secwm2 = FLASH->SECWM2R2;
 c007568:	6e52      	ldrne	r2, [r2, #100]	; 0x64
  {
    /* Nothing to do */
  }

  /* Configuration of secure area */
  *WMSecStartPage = (tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PSTRT);
 c00756a:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  *WMSecEndPage = ((tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PEND) >> FLASH_SECWM1R1_SECWM1_PEND_Pos);

  /* Configuration of secure hide area */
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);

  if ((tmp_secwm2 & FLASH_SECWM1R2_HDP1EN) == 0U)
 c00756e:	2a00      	cmp	r2, #0
  *WMSecEndPage = ((tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PEND) >> FLASH_SECWM1R1_SECWM1_PEND_Pos);
 c007570:	f3c1 4106 	ubfx	r1, r1, #16, #7
 c007574:	6241      	str	r1, [r0, #36]	; 0x24
  {
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_DISABLE);
 c007576:	bfa8      	it	ge
 c007578:	f443 7380 	orrge.w	r3, r3, #256	; 0x100
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);
 c00757c:	f3c2 4106 	ubfx	r1, r2, #16, #7
  }
  else
  {
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_ENABLE);
 c007580:	bfb8      	it	lt
 c007582:	f043 0380 	orrlt.w	r3, r3, #128	; 0x80
  *WMSecStartPage = (tmp_secwm1 & FLASH_SECWM1R1_SECWM1_PSTRT);
 c007586:	6204      	str	r4, [r0, #32]
  *WMHDPEndPage = ((tmp_secwm2 & FLASH_SECWM1R2_HDP1_PEND) >> FLASH_SECWM1R2_HDP1_PEND_Pos);
 c007588:	6281      	str	r1, [r0, #40]	; 0x28
    *WMSecConfig = ((*WMSecConfig) | OB_WMSEC_HDP_AREA_ENABLE);
 c00758a:	61c3      	str	r3, [r0, #28]
  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
 c00758c:	6801      	ldr	r1, [r0, #0]
  *            @arg OB_BOOT_LOCK_DISABLE: Boot Lock mode deactivated
  *            @arg OB_BOOT_LOCK_ENABLE: Boot Lock mode activated
  */
static uint32_t FLASH_OB_GetBootLock(void)
{
  return (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_BOOT_LOCK);
 c00758e:	4a1d      	ldr	r2, [pc, #116]	; (c007604 <HAL_FLASHEx_OBGetConfig+0x104>)
  pOBInit->OptionType |= OPTIONBYTE_BOOT_LOCK;
 c007590:	f041 0320 	orr.w	r3, r1, #32
 c007594:	6003      	str	r3, [r0, #0]
  return (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_BOOT_LOCK);
 c007596:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 c007598:	f003 0301 	and.w	r3, r3, #1
  pOBInit->BootLock = FLASH_OB_GetBootLock();
 c00759c:	62c3      	str	r3, [r0, #44]	; 0x2c
  if ((pOBInit->BootAddrConfig == OB_BOOTADDR_NS0) || (pOBInit->BootAddrConfig == OB_BOOTADDR_NS1) ||
 c00759e:	6b03      	ldr	r3, [r0, #48]	; 0x30
 c0075a0:	1e5c      	subs	r4, r3, #1
 c0075a2:	2c01      	cmp	r4, #1
 c0075a4:	d901      	bls.n	c0075aa <HAL_FLASHEx_OBGetConfig+0xaa>
 c0075a6:	2b04      	cmp	r3, #4
 c0075a8:	d108      	bne.n	c0075bc <HAL_FLASHEx_OBGetConfig+0xbc>
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 c0075aa:	f041 0128 	orr.w	r1, r1, #40	; 0x28
  *
  * @retval None
  */
static void FLASH_OB_GetBootAddr(uint32_t BootAddrConfig, uint32_t * BootAddr)
{
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c0075ae:	2b01      	cmp	r3, #1
    pOBInit->OptionType |= OPTIONBYTE_BOOTADDR;
 c0075b0:	6001      	str	r1, [r0, #0]
  if (BootAddrConfig == OB_BOOTADDR_NS0)
 c0075b2:	d11c      	bne.n	c0075ee <HAL_FLASHEx_OBGetConfig+0xee>
  {
    *BootAddr = (FLASH->NSBOOTADD0R & FLASH_NSBOOTADD0R_NSBOOTADD0);
 c0075b4:	6c53      	ldr	r3, [r2, #68]	; 0x44
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
  }
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
  {
    *BootAddr = (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_SECBOOTADD0);
 c0075b6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 c0075ba:	6343      	str	r3, [r0, #52]	; 0x34
}
 c0075bc:	bd10      	pop	{r4, pc}
  else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 c0075be:	2a02      	cmp	r2, #2
 c0075c0:	d105      	bne.n	c0075ce <HAL_FLASHEx_OBGetConfig+0xce>
    *WRPStartOffset = READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PSTRT);
 c0075c2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 c0075c4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0075c8:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP1BR, FLASH_WRP1BR_WRP1B_PEND) >> FLASH_WRP1BR_WRP1B_PEND_Pos);
 c0075ca:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 c0075cc:	e7ad      	b.n	c00752a <HAL_FLASHEx_OBGetConfig+0x2a>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAA)
 c0075ce:	2a04      	cmp	r2, #4
 c0075d0:	d105      	bne.n	c0075de <HAL_FLASHEx_OBGetConfig+0xde>
    *WRPStartOffset = READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PSTRT);
 c0075d2:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 c0075d4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0075d8:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2AR, FLASH_WRP2AR_WRP2A_PEND) >> FLASH_WRP2AR_WRP2A_PEND_Pos);
 c0075da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 c0075dc:	e7a5      	b.n	c00752a <HAL_FLASHEx_OBGetConfig+0x2a>
  else if(WRPArea == OB_WRPAREA_BANK2_AREAB)
 c0075de:	2a08      	cmp	r2, #8
 c0075e0:	d1a6      	bne.n	c007530 <HAL_FLASHEx_OBGetConfig+0x30>
    *WRPStartOffset = READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PSTRT);
 c0075e2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 c0075e4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 c0075e8:	6082      	str	r2, [r0, #8]
    *WRPEndOffset = (READ_BIT(FLASH->WRP2BR, FLASH_WRP2BR_WRP2B_PEND) >> FLASH_WRP2BR_WRP2B_PEND_Pos);
 c0075ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 c0075ec:	e79d      	b.n	c00752a <HAL_FLASHEx_OBGetConfig+0x2a>
  else if (BootAddrConfig == OB_BOOTADDR_NS1)
 c0075ee:	2b02      	cmp	r3, #2
 c0075f0:	d102      	bne.n	c0075f8 <HAL_FLASHEx_OBGetConfig+0xf8>
    *BootAddr = (FLASH->NSBOOTADD1R & FLASH_NSBOOTADD1R_NSBOOTADD1);
 c0075f2:	4b04      	ldr	r3, [pc, #16]	; (c007604 <HAL_FLASHEx_OBGetConfig+0x104>)
 c0075f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 c0075f6:	e7de      	b.n	c0075b6 <HAL_FLASHEx_OBGetConfig+0xb6>
  else if (BootAddrConfig == OB_BOOTADDR_SEC0)
 c0075f8:	2b04      	cmp	r3, #4
 c0075fa:	d1df      	bne.n	c0075bc <HAL_FLASHEx_OBGetConfig+0xbc>
    *BootAddr = (FLASH->SECBOOTADD0R & FLASH_SECBOOTADD0R_SECBOOTADD0);
 c0075fc:	4b01      	ldr	r3, [pc, #4]	; (c007604 <HAL_FLASHEx_OBGetConfig+0x104>)
 c0075fe:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 c007600:	e7d9      	b.n	c0075b6 <HAL_FLASHEx_OBGetConfig+0xb6>
 c007602:	bf00      	nop
 c007604:	50022000 	.word	0x50022000

0c007608 <HAL_FLASHEx_ConfigPrivMode>:
  MODIFY_REG(FLASH->PRIVCFGR, FLASH_PRIVCFGR_PRIV, PrivMode);
 c007608:	4a04      	ldr	r2, [pc, #16]	; (c00761c <HAL_FLASHEx_ConfigPrivMode+0x14>)
 c00760a:	f8d2 30c4 	ldr.w	r3, [r2, #196]	; 0xc4
 c00760e:	f023 0301 	bic.w	r3, r3, #1
 c007612:	4318      	orrs	r0, r3
 c007614:	f8c2 00c4 	str.w	r0, [r2, #196]	; 0xc4
}
 c007618:	4770      	bx	lr
 c00761a:	bf00      	nop
 c00761c:	50022000 	.word	0x50022000

0c007620 <FLASH_PageErase>:
{
 c007620:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 c007622:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 c007626:	b672      	cpsid	i
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c007628:	4b13      	ldr	r3, [pc, #76]	; (c007678 <FLASH_PageErase+0x58>)
 c00762a:	4a14      	ldr	r2, [pc, #80]	; (c00767c <FLASH_PageErase+0x5c>)
 c00762c:	689d      	ldr	r5, [r3, #8]
 c00762e:	4b14      	ldr	r3, [pc, #80]	; (c007680 <FLASH_PageErase+0x60>)
 c007630:	ea33 0325 	bics.w	r3, r3, r5, asr #32
 c007634:	bf28      	it	cs
 c007636:	4613      	movcs	r3, r2
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c007638:	4a12      	ldr	r2, [pc, #72]	; (c007684 <FLASH_PageErase+0x64>)
 c00763a:	6c12      	ldr	r2, [r2, #64]	; 0x40
 c00763c:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c007640:	681a      	ldr	r2, [r3, #0]
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 c007642:	d113      	bne.n	c00766c <FLASH_PageErase+0x4c>
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
 c007644:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c007648:	601a      	str	r2, [r3, #0]
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
 c00764a:	681a      	ldr	r2, [r3, #0]
 c00764c:	00c0      	lsls	r0, r0, #3
 c00764e:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
 c007652:	f022 0202 	bic.w	r2, r2, #2
 c007656:	f040 0002 	orr.w	r0, r0, #2
 c00765a:	4310      	orrs	r0, r2
 c00765c:	6018      	str	r0, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
 c00765e:	681a      	ldr	r2, [r3, #0]
 c007660:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 c007664:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 c007666:	f384 8810 	msr	PRIMASK, r4
}
 c00766a:	bd30      	pop	{r4, r5, pc}
    if((Banks & FLASH_BANK_1) != 0U)
 c00766c:	07c9      	lsls	r1, r1, #31
 c00766e:	d4e9      	bmi.n	c007644 <FLASH_PageErase+0x24>
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
 c007670:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 c007674:	e7e8      	b.n	c007648 <FLASH_PageErase+0x28>
 c007676:	bf00      	nop
 c007678:	300300b4 	.word	0x300300b4
 c00767c:	40022028 	.word	0x40022028
 c007680:	5002202c 	.word	0x5002202c
 c007684:	50022000 	.word	0x50022000

0c007688 <HAL_FLASHEx_Erase>:
{
 c007688:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  __HAL_LOCK(&pFlash);
 c00768c:	4c26      	ldr	r4, [pc, #152]	; (c007728 <HAL_FLASHEx_Erase+0xa0>)
{
 c00768e:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
 c007690:	7823      	ldrb	r3, [r4, #0]
{
 c007692:	4689      	mov	r9, r1
  __HAL_LOCK(&pFlash);
 c007694:	2b01      	cmp	r3, #1
 c007696:	d045      	beq.n	c007724 <HAL_FLASHEx_Erase+0x9c>
 c007698:	2301      	movs	r3, #1
 c00769a:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c00769c:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c00769e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 c0076a2:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0076a4:	f7ff fd54 	bl	c007150 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 c0076a8:	4606      	mov	r6, r0
 c0076aa:	b9f0      	cbnz	r0, c0076ea <HAL_FLASHEx_Erase+0x62>
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0076ac:	682b      	ldr	r3, [r5, #0]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0076ae:	4a1f      	ldr	r2, [pc, #124]	; (c00772c <HAL_FLASHEx_Erase+0xa4>)
 c0076b0:	491f      	ldr	r1, [pc, #124]	; (c007730 <HAL_FLASHEx_Erase+0xa8>)
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
 c0076b2:	60a3      	str	r3, [r4, #8]
    reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);
 c0076b4:	ea31 0823 	bics.w	r8, r1, r3, asr #32
 c0076b8:	bf28      	it	cs
 c0076ba:	4690      	movcs	r8, r2
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
 c0076bc:	f248 0204 	movw	r2, #32772	; 0x8004
 c0076c0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 c0076c4:	4293      	cmp	r3, r2
 c0076c6:	d115      	bne.n	c0076f4 <HAL_FLASHEx_Erase+0x6c>
      FLASH_MassErase(pEraseInit->Banks);
 c0076c8:	6868      	ldr	r0, [r5, #4]
 c0076ca:	f7ff fdb5 	bl	c007238 <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 c0076ce:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c0076d2:	f7ff fd3d 	bl	c007150 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c0076d6:	4606      	mov	r6, r0
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
 c0076d8:	68a2      	ldr	r2, [r4, #8]
 c0076da:	f8d8 3000 	ldr.w	r3, [r8]
 c0076de:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 c0076e2:	ea23 0302 	bic.w	r3, r3, r2
 c0076e6:	f8c8 3000 	str.w	r3, [r8]
  __HAL_UNLOCK(&pFlash);
 c0076ea:	2300      	movs	r3, #0
 c0076ec:	7023      	strb	r3, [r4, #0]
}
 c0076ee:	4630      	mov	r0, r6
 c0076f0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *PageError = 0xFFFFFFFFU;
 c0076f4:	f04f 33ff 	mov.w	r3, #4294967295
 c0076f8:	f8c9 3000 	str.w	r3, [r9]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c0076fc:	68af      	ldr	r7, [r5, #8]
 c0076fe:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
 c007702:	4413      	add	r3, r2
 c007704:	42bb      	cmp	r3, r7
 c007706:	d9e7      	bls.n	c0076d8 <HAL_FLASHEx_Erase+0x50>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 c007708:	4638      	mov	r0, r7
 c00770a:	6869      	ldr	r1, [r5, #4]
 c00770c:	f7ff ff88 	bl	c007620 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 c007710:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 c007714:	f7ff fd1c 	bl	c007150 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
 c007718:	b110      	cbz	r0, c007720 <HAL_FLASHEx_Erase+0x98>
          *PageError = page_index;
 c00771a:	f8c9 7000 	str.w	r7, [r9]
 c00771e:	e7da      	b.n	c0076d6 <HAL_FLASHEx_Erase+0x4e>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 c007720:	3701      	adds	r7, #1
 c007722:	e7ec      	b.n	c0076fe <HAL_FLASHEx_Erase+0x76>
  __HAL_LOCK(&pFlash);
 c007724:	2602      	movs	r6, #2
 c007726:	e7e2      	b.n	c0076ee <HAL_FLASHEx_Erase+0x66>
 c007728:	300300b4 	.word	0x300300b4
 c00772c:	40022028 	.word	0x40022028
 c007730:	5002202c 	.word	0x5002202c

0c007734 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
 c007734:	2300      	movs	r3, #0
{
 c007736:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 c00773a:	4a5f      	ldr	r2, [pc, #380]	; (c0078b8 <HAL_GPIO_Init+0x184>)
  while (((GPIO_Init->Pin) >> position) != 0U)
 c00773c:	f8d1 8000 	ldr.w	r8, [r1]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c007740:	f8df 917c 	ldr.w	r9, [pc, #380]	; c0078c0 <HAL_GPIO_Init+0x18c>
  while (((GPIO_Init->Pin) >> position) != 0U)
 c007744:	fa38 f403 	lsrs.w	r4, r8, r3
 c007748:	d101      	bne.n	c00774e <HAL_GPIO_Init+0x1a>
      }
    }

    position++;
  }
}
 c00774a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 c00774e:	f04f 0c01 	mov.w	ip, #1
 c007752:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
 c007756:	ea1c 0608 	ands.w	r6, ip, r8
 c00775a:	f000 809f 	beq.w	c00789c <HAL_GPIO_Init+0x168>
 c00775e:	2503      	movs	r5, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 c007760:	684c      	ldr	r4, [r1, #4]
 c007762:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 c007766:	f024 0a10 	bic.w	sl, r4, #16
 c00776a:	f10a 37ff 	add.w	r7, sl, #4294967295
 c00776e:	fa05 f50e 	lsl.w	r5, r5, lr
 c007772:	2f01      	cmp	r7, #1
 c007774:	ea6f 0505 	mvn.w	r5, r5
 c007778:	d811      	bhi.n	c00779e <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
 c00777a:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c00777c:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 c007780:	68cf      	ldr	r7, [r1, #12]
 c007782:	fa07 f70e 	lsl.w	r7, r7, lr
 c007786:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 c00778a:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 c00778c:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 c00778e:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 c007792:	f3c4 1700 	ubfx	r7, r4, #4, #1
 c007796:	409f      	lsls	r7, r3
 c007798:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 c00779c:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 c00779e:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 c0077a0:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 c0077a4:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 c0077a8:	688f      	ldr	r7, [r1, #8]
 c0077aa:	fa07 f70e 	lsl.w	r7, r7, lr
 c0077ae:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
 c0077b2:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 c0077b4:	d116      	bne.n	c0077e4 <HAL_GPIO_Init+0xb0>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0077b6:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
 c0077ba:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 c0077be:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0077c2:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 c0077c6:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c0077ca:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 c0077ce:	fa0c fc0b 	lsl.w	ip, ip, fp
 c0077d2:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 c0077d6:	690f      	ldr	r7, [r1, #16]
 c0077d8:	fa07 f70b 	lsl.w	r7, r7, fp
 c0077dc:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 c0077e0:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 c0077e4:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 c0077e6:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 c0077e8:	f004 0703 	and.w	r7, r4, #3
 c0077ec:	fa07 fe0e 	lsl.w	lr, r7, lr
 c0077f0:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
 c0077f4:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 c0077f6:	00e5      	lsls	r5, r4, #3
 c0077f8:	d550      	bpl.n	c00789c <HAL_GPIO_Init+0x168>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c0077fa:	f04f 0c0f 	mov.w	ip, #15
 c0077fe:	f023 0703 	bic.w	r7, r3, #3
 c007802:	f107 47a0 	add.w	r7, r7, #1342177280	; 0x50000000
 c007806:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
 c00780a:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
 c00780e:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 c007810:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 c007814:	fa0c fc0e 	lsl.w	ip, ip, lr
 c007818:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c00781c:	4d27      	ldr	r5, [pc, #156]	; (c0078bc <HAL_GPIO_Init+0x188>)
 c00781e:	42a8      	cmp	r0, r5
 c007820:	d03e      	beq.n	c0078a0 <HAL_GPIO_Init+0x16c>
 c007822:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c007826:	42a8      	cmp	r0, r5
 c007828:	d03c      	beq.n	c0078a4 <HAL_GPIO_Init+0x170>
 c00782a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c00782e:	42a8      	cmp	r0, r5
 c007830:	d03a      	beq.n	c0078a8 <HAL_GPIO_Init+0x174>
 c007832:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c007836:	42a8      	cmp	r0, r5
 c007838:	d038      	beq.n	c0078ac <HAL_GPIO_Init+0x178>
 c00783a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c00783e:	42a8      	cmp	r0, r5
 c007840:	d036      	beq.n	c0078b0 <HAL_GPIO_Init+0x17c>
 c007842:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 c007846:	42a8      	cmp	r0, r5
 c007848:	d034      	beq.n	c0078b4 <HAL_GPIO_Init+0x180>
 c00784a:	4548      	cmp	r0, r9
 c00784c:	bf14      	ite	ne
 c00784e:	2507      	movne	r5, #7
 c007850:	2506      	moveq	r5, #6
 c007852:	fa05 f50e 	lsl.w	r5, r5, lr
 c007856:	ea45 050c 	orr.w	r5, r5, ip
        EXTI->EXTICR[position >> 2U] = temp;
 c00785a:	663d      	str	r5, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
 c00785c:	43f7      	mvns	r7, r6
        temp = EXTI->IMR1;
 c00785e:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 c007862:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 c007866:	bf0c      	ite	eq
 c007868:	403d      	andeq	r5, r7
          temp |= iocurrent;
 c00786a:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 c00786c:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        temp = EXTI->EMR1;
 c007870:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 c007874:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 c007878:	bf0c      	ite	eq
 c00787a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 c00787c:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 c00787e:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        temp = EXTI->RTSR1;
 c007882:	6815      	ldr	r5, [r2, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 c007884:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 c007888:	bf0c      	ite	eq
 c00788a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 c00788c:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 c00788e:	6015      	str	r5, [r2, #0]
        temp = EXTI->FTSR1;
 c007890:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 c007892:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 c007894:	bf54      	ite	pl
 c007896:	403d      	andpl	r5, r7
          temp |= iocurrent;
 c007898:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 c00789a:	6055      	str	r5, [r2, #4]
    position++;
 c00789c:	3301      	adds	r3, #1
 c00789e:	e751      	b.n	c007744 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 c0078a0:	2500      	movs	r5, #0
 c0078a2:	e7d6      	b.n	c007852 <HAL_GPIO_Init+0x11e>
 c0078a4:	2501      	movs	r5, #1
 c0078a6:	e7d4      	b.n	c007852 <HAL_GPIO_Init+0x11e>
 c0078a8:	2502      	movs	r5, #2
 c0078aa:	e7d2      	b.n	c007852 <HAL_GPIO_Init+0x11e>
 c0078ac:	2503      	movs	r5, #3
 c0078ae:	e7d0      	b.n	c007852 <HAL_GPIO_Init+0x11e>
 c0078b0:	2504      	movs	r5, #4
 c0078b2:	e7ce      	b.n	c007852 <HAL_GPIO_Init+0x11e>
 c0078b4:	2505      	movs	r5, #5
 c0078b6:	e7cc      	b.n	c007852 <HAL_GPIO_Init+0x11e>
 c0078b8:	5002f400 	.word	0x5002f400
 c0078bc:	52020000 	.word	0x52020000
 c0078c0:	52021800 	.word	0x52021800

0c0078c4 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 c0078c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0U;
 c0078c8:	2300      	movs	r3, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0U)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1UL << position);
 c0078ca:	f04f 0901 	mov.w	r9, #1
      temp = EXTI->EXTICR[position >> 2U];
      temp &= ((0x0FUL) << (8U * (position & 0x03U)));
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
 c0078ce:	4c40      	ldr	r4, [pc, #256]	; (c0079d0 <HAL_GPIO_DeInit+0x10c>)
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 c0078d0:	f8df a104 	ldr.w	sl, [pc, #260]	; c0079d8 <HAL_GPIO_DeInit+0x114>
 c0078d4:	f8df b104 	ldr.w	fp, [pc, #260]	; c0079dc <HAL_GPIO_DeInit+0x118>
  while ((GPIO_Pin >> position) != 0U)
 c0078d8:	fa31 f203 	lsrs.w	r2, r1, r3
 c0078dc:	d101      	bne.n	c0078e2 <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 c0078de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1UL << position);
 c0078e2:	fa09 fe03 	lsl.w	lr, r9, r3
    if (iocurrent != 0U)
 c0078e6:	ea1e 0501 	ands.w	r5, lr, r1
 c0078ea:	d062      	beq.n	c0079b2 <HAL_GPIO_DeInit+0xee>
      temp &= ((0x0FUL) << (8U * (position & 0x03U)));
 c0078ec:	270f      	movs	r7, #15
 c0078ee:	f023 0603 	bic.w	r6, r3, #3
 c0078f2:	f106 46a0 	add.w	r6, r6, #1342177280	; 0x50000000
 c0078f6:	f506 363d 	add.w	r6, r6, #193536	; 0x2f400
 c0078fa:	f003 0c03 	and.w	ip, r3, #3
      temp = EXTI->EXTICR[position >> 2U];
 c0078fe:	6e32      	ldr	r2, [r6, #96]	; 0x60
      temp &= ((0x0FUL) << (8U * (position & 0x03U)));
 c007900:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 c007904:	fa07 f70c 	lsl.w	r7, r7, ip
 c007908:	ea07 0802 	and.w	r8, r7, r2
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 c00790c:	4a31      	ldr	r2, [pc, #196]	; (c0079d4 <HAL_GPIO_DeInit+0x110>)
 c00790e:	4290      	cmp	r0, r2
 c007910:	d051      	beq.n	c0079b6 <HAL_GPIO_DeInit+0xf2>
 c007912:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 c007916:	4290      	cmp	r0, r2
 c007918:	d04f      	beq.n	c0079ba <HAL_GPIO_DeInit+0xf6>
 c00791a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 c00791e:	4290      	cmp	r0, r2
 c007920:	d04d      	beq.n	c0079be <HAL_GPIO_DeInit+0xfa>
 c007922:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 c007926:	4290      	cmp	r0, r2
 c007928:	d04b      	beq.n	c0079c2 <HAL_GPIO_DeInit+0xfe>
 c00792a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 c00792e:	4290      	cmp	r0, r2
 c007930:	d049      	beq.n	c0079c6 <HAL_GPIO_DeInit+0x102>
 c007932:	4550      	cmp	r0, sl
 c007934:	d049      	beq.n	c0079ca <HAL_GPIO_DeInit+0x106>
 c007936:	4558      	cmp	r0, fp
 c007938:	bf0c      	ite	eq
 c00793a:	2206      	moveq	r2, #6
 c00793c:	2207      	movne	r2, #7
 c00793e:	fa02 f20c 	lsl.w	r2, r2, ip
 c007942:	4542      	cmp	r2, r8
 c007944:	d114      	bne.n	c007970 <HAL_GPIO_DeInit+0xac>
        EXTI->IMR1 &= ~(iocurrent);
 c007946:	43ed      	mvns	r5, r5
 c007948:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 c00794c:	402a      	ands	r2, r5
 c00794e:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 c007952:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 c007956:	402a      	ands	r2, r5
 c007958:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 c00795c:	6822      	ldr	r2, [r4, #0]
 c00795e:	402a      	ands	r2, r5
 c007960:	6022      	str	r2, [r4, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 c007962:	6862      	ldr	r2, [r4, #4]
 c007964:	4015      	ands	r5, r2
 c007966:	6065      	str	r5, [r4, #4]
        EXTI->EXTICR[position >> 2U] &= ~temp;
 c007968:	6e32      	ldr	r2, [r6, #96]	; 0x60
 c00796a:	ea22 0707 	bic.w	r7, r2, r7
 c00796e:	6637      	str	r7, [r6, #96]	; 0x60
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 c007970:	2603      	movs	r6, #3
      GPIOx->AFR[position >> 3U] &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c007972:	270f      	movs	r7, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 c007974:	6805      	ldr	r5, [r0, #0]
 c007976:	005a      	lsls	r2, r3, #1
 c007978:	fa06 f202 	lsl.w	r2, r6, r2
 c00797c:	4315      	orrs	r5, r2
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c00797e:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 c007980:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 c007982:	fa23 f506 	lsr.w	r5, r3, r6
 c007986:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 c00798a:	f003 0c07 	and.w	ip, r3, #7
 c00798e:	6a2e      	ldr	r6, [r5, #32]
 c007990:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 c007994:	fa07 f70c 	lsl.w	r7, r7, ip
 c007998:	ea26 0707 	bic.w	r7, r6, r7
 c00799c:	622f      	str	r7, [r5, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 c00799e:	6885      	ldr	r5, [r0, #8]
 c0079a0:	4015      	ands	r5, r2
 c0079a2:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 c0079a4:	6845      	ldr	r5, [r0, #4]
 c0079a6:	ea25 050e 	bic.w	r5, r5, lr
 c0079aa:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 c0079ac:	68c5      	ldr	r5, [r0, #12]
 c0079ae:	402a      	ands	r2, r5
 c0079b0:	60c2      	str	r2, [r0, #12]
    position++;
 c0079b2:	3301      	adds	r3, #1
 c0079b4:	e790      	b.n	c0078d8 <HAL_GPIO_DeInit+0x14>
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 c0079b6:	2200      	movs	r2, #0
 c0079b8:	e7c1      	b.n	c00793e <HAL_GPIO_DeInit+0x7a>
 c0079ba:	2201      	movs	r2, #1
 c0079bc:	e7bf      	b.n	c00793e <HAL_GPIO_DeInit+0x7a>
 c0079be:	2202      	movs	r2, #2
 c0079c0:	e7bd      	b.n	c00793e <HAL_GPIO_DeInit+0x7a>
 c0079c2:	2203      	movs	r2, #3
 c0079c4:	e7bb      	b.n	c00793e <HAL_GPIO_DeInit+0x7a>
 c0079c6:	2204      	movs	r2, #4
 c0079c8:	e7b9      	b.n	c00793e <HAL_GPIO_DeInit+0x7a>
 c0079ca:	2205      	movs	r2, #5
 c0079cc:	e7b7      	b.n	c00793e <HAL_GPIO_DeInit+0x7a>
 c0079ce:	bf00      	nop
 c0079d0:	5002f400 	.word	0x5002f400
 c0079d4:	52020000 	.word	0x52020000
 c0079d8:	52021400 	.word	0x52021400
 c0079dc:	52021800 	.word	0x52021800

0c0079e0 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != 0U)
 c0079e0:	6903      	ldr	r3, [r0, #16]
 c0079e2:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 c0079e4:	bf14      	ite	ne
 c0079e6:	2001      	movne	r0, #1
 c0079e8:	2000      	moveq	r0, #0
 c0079ea:	4770      	bx	lr

0c0079ec <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes>:
  uint32_t size;
  uint32_t start_pos, start_msk;
  uint32_t length_pos, length_msk;

  /* check entry parameters */
  if ((pMPCWM_Desc->AreaId > GTZC_TZSC_MPCWM_ID2)
 c0079ec:	680b      	ldr	r3, [r1, #0]
{
 c0079ee:	b510      	push	{r4, lr}
  if ((pMPCWM_Desc->AreaId > GTZC_TZSC_MPCWM_ID2)
 c0079f0:	2b01      	cmp	r3, #1
 c0079f2:	d833      	bhi.n	c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
      || ((MemBaseAddress == FMC_BANK3) && (pMPCWM_Desc->AreaId == GTZC_TZSC_MPCWM_ID2))
 c0079f4:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
 c0079f8:	d101      	bne.n	c0079fe <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x12>
 c0079fa:	2b01      	cmp	r3, #1
 c0079fc:	d02e      	beq.n	c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
      || ((pMPCWM_Desc->Offset % GTZC_TZSC_MPCWM_GRANULARITY) != 0U)
 c0079fe:	684a      	ldr	r2, [r1, #4]
 c007a00:	f3c2 0410 	ubfx	r4, r2, #0, #17
 c007a04:	bb54      	cbnz	r4, c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
      || ((pMPCWM_Desc->Length % GTZC_TZSC_MPCWM_GRANULARITY) != 0U))
 c007a06:	688c      	ldr	r4, [r1, #8]
 c007a08:	f3c4 0110 	ubfx	r1, r4, #0, #17
 c007a0c:	bb31      	cbnz	r1, c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
  {
    return HAL_ERROR;
  }

  /* check descriptor content vs. memory capacity */
  switch (MemBaseAddress)
 c007a0e:	f1b0 4f00 	cmp.w	r0, #2147483648	; 0x80000000
 c007a12:	d021      	beq.n	c007a58 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x6c>
 c007a14:	f1b0 4f10 	cmp.w	r0, #2415919104	; 0x90000000
 c007a18:	d005      	beq.n	c007a26 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x3a>
 c007a1a:	f1b0 4fc0 	cmp.w	r0, #1610612736	; 0x60000000
 c007a1e:	d11d      	bne.n	c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
      else
      {
        /* Here pMPCWM_Desc->AreaId == GTZC_TZSC_MPCWM_ID2
         * (Parameter already checked)
         */
        register_address = (uint32_t) &(GTZC_TZSC_S->MPCWM2_NSWMR2);
 c007a20:	490f      	ldr	r1, [pc, #60]	; (c007a60 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x74>)
 c007a22:	4810      	ldr	r0, [pc, #64]	; (c007a64 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x78>)
 c007a24:	e001      	b.n	c007a2a <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x3e>
        register_address = (uint32_t) &(GTZC_TZSC_S->MPCWM1_NSWMR2);
 c007a26:	4910      	ldr	r1, [pc, #64]	; (c007a68 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x7c>)
 c007a28:	4810      	ldr	r0, [pc, #64]	; (c007a6c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x80>)
        register_address = (uint32_t) &(GTZC_TZSC_S->MPCWM2_NSWMR2);
 c007a2a:	2b00      	cmp	r3, #0
 c007a2c:	bf08      	it	eq
 c007a2e:	4608      	moveq	r0, r1
    default:
      return HAL_ERROR;
      break;
  }

  if ((pMPCWM_Desc->Offset > size)
 c007a30:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 c007a34:	d812      	bhi.n	c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
      || ((pMPCWM_Desc->Offset + pMPCWM_Desc->Length) > size))
 c007a36:	1913      	adds	r3, r2, r4
 c007a38:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 c007a3c:	d80e      	bhi.n	c007a5c <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x70>
    return HAL_ERROR;
  }

  /* write descriptor value */
  reg_value = ((pMPCWM_Desc->Offset / GTZC_TZSC_MPCWM_GRANULARITY) << start_pos) & start_msk;
  reg_value |= ((pMPCWM_Desc->Length / GTZC_TZSC_MPCWM_GRANULARITY) << length_pos) & length_msk;
 c007a3e:	4b0c      	ldr	r3, [pc, #48]	; (c007a70 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x84>)
  reg_value = ((pMPCWM_Desc->Offset / GTZC_TZSC_MPCWM_GRANULARITY) << start_pos) & start_msk;
 c007a40:	f3c2 424a 	ubfx	r2, r2, #17, #11
  reg_value |= ((pMPCWM_Desc->Length / GTZC_TZSC_MPCWM_GRANULARITY) << length_pos) & length_msk;
 c007a44:	ea03 0354 	and.w	r3, r3, r4, lsr #1
  MODIFY_REG(*(__IO uint32_t *)register_address, start_msk | length_msk, reg_value);
 c007a48:	6801      	ldr	r1, [r0, #0]
  reg_value |= ((pMPCWM_Desc->Length / GTZC_TZSC_MPCWM_GRANULARITY) << length_pos) & length_msk;
 c007a4a:	4313      	orrs	r3, r2
  MODIFY_REG(*(__IO uint32_t *)register_address, start_msk | length_msk, reg_value);
 c007a4c:	4a09      	ldr	r2, [pc, #36]	; (c007a74 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x88>)
 c007a4e:	400a      	ands	r2, r1
 c007a50:	4313      	orrs	r3, r2
 c007a52:	6003      	str	r3, [r0, #0]

  return HAL_OK;
 c007a54:	2000      	movs	r0, #0
}
 c007a56:	bd10      	pop	{r4, pc}
      register_address = (uint32_t) &(GTZC_TZSC_S->MPCWM3_NSWMR1);
 c007a58:	4807      	ldr	r0, [pc, #28]	; (c007a78 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x8c>)
 c007a5a:	e7e9      	b.n	c007a30 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x44>
    return HAL_ERROR;
 c007a5c:	2001      	movs	r0, #1
 c007a5e:	e7fa      	b.n	c007a56 <HAL_GTZC_TZSC_MPCWM_ConfigMemAttributes+0x6a>
 c007a60:	50032438 	.word	0x50032438
 c007a64:	5003243c 	.word	0x5003243c
 c007a68:	50032430 	.word	0x50032430
 c007a6c:	50032434 	.word	0x50032434
 c007a70:	0fff0000 	.word	0x0fff0000
 c007a74:	f000f800 	.word	0xf000f800
 c007a78:	50032440 	.word	0x50032440

0c007a7c <HAL_GTZC_MPCBB_ConfigMem>:
  uint32_t size_mask;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if ((!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c007a7c:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
 c007a80:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
{
 c007a84:	b530      	push	{r4, r5, lr}
  if ((!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c007a86:	d002      	beq.n	c007a8e <HAL_GTZC_MPCBB_ConfigMem+0x12>
       &&  !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress)))
 c007a88:	4b19      	ldr	r3, [pc, #100]	; (c007af0 <HAL_GTZC_MPCBB_ConfigMem+0x74>)
 c007a8a:	4298      	cmp	r0, r3
 c007a8c:	d12e      	bne.n	c007aec <HAL_GTZC_MPCBB_ConfigMem+0x70>
      || ((pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_ENABLE)
 c007a8e:	680b      	ldr	r3, [r1, #0]
 c007a90:	f033 4200 	bics.w	r2, r3, #2147483648	; 0x80000000
 c007a94:	d12a      	bne.n	c007aec <HAL_GTZC_MPCBB_ConfigMem+0x70>
          && (pMPCBB_desc->SecureRWIllegalMode != GTZC_MPCBB_SRWILADIS_DISABLE))
      || ((pMPCBB_desc->InvertSecureState != GTZC_MPCBB_INVSECSTATE_NOT_INVERTED)
 c007a96:	684c      	ldr	r4, [r1, #4]
 c007a98:	f034 4280 	bics.w	r2, r4, #1073741824	; 0x40000000
 c007a9c:	d126      	bne.n	c007aec <HAL_GTZC_MPCBB_ConfigMem+0x70>
  reg_value = pMPCBB_desc->InvertSecureState;
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
  if (IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
  {
    mpcbb_ptr = GTZC_MPCBB1_S;
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c007a9e:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
 c007aa2:	4814      	ldr	r0, [pc, #80]	; (c007af4 <HAL_GTZC_MPCBB_ConfigMem+0x78>)
  reg_value |= pMPCBB_desc->SecureRWIllegalMode;
 c007aa4:	ea44 0403 	orr.w	r4, r4, r3
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c007aa8:	4b13      	ldr	r3, [pc, #76]	; (c007af8 <HAL_GTZC_MPCBB_ConfigMem+0x7c>)
 c007aaa:	bf18      	it	ne
 c007aac:	4603      	movne	r3, r0
    mpcbb_ptr = GTZC_MPCBB2_S;
    mem_size = GTZC_MEM_SIZE(SRAM2);
  }

  /* write configuration and lock register information */
  MODIFY_REG(mpcbb_ptr->CR,
 c007aae:	6818      	ldr	r0, [r3, #0]
 c007ab0:	f101 0108 	add.w	r1, r1, #8
 c007ab4:	f020 4040 	bic.w	r0, r0, #3221225472	; 0xc0000000
 c007ab8:	ea40 0004 	orr.w	r0, r0, r4
 c007abc:	6018      	str	r0, [r3, #0]
             GTZC_MPCBB_CR_INVSECSTATE_Msk | GTZC_MPCBB_CR_SRWILADIS_Msk, reg_value);
  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
  /* limitation: code not portable with memory > 256K */
  MODIFY_REG(mpcbb_ptr->LCKVTR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c007abe:	bf15      	itete	ne
 c007ac0:	f06f 00ff 	mvnne.w	r0, #255	; 0xff
 c007ac4:	f04f 407f 	moveq.w	r0, #4278190080	; 0xff000000
  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
 c007ac8:	2408      	movne	r4, #8
 c007aca:	2418      	moveq	r4, #24
  MODIFY_REG(mpcbb_ptr->LCKVTR1, size_mask, pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0]);
 c007acc:	691d      	ldr	r5, [r3, #16]
 c007ace:	4028      	ands	r0, r5
 c007ad0:	6e0d      	ldr	r5, [r1, #96]	; 0x60
 c007ad2:	4328      	orrs	r0, r5
 c007ad4:	6118      	str	r0, [r3, #16]

  /* write vector register information */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
  for (i = 0U; i < size_in_superblocks; i++)
  {
    WRITE_REG(mpcbb_ptr->VCTR[i],
 c007ad6:	f102 0040 	add.w	r0, r2, #64	; 0x40
 c007ada:	f851 5b04 	ldr.w	r5, [r1], #4
  for (i = 0U; i < size_in_superblocks; i++)
 c007ade:	3201      	adds	r2, #1
 c007ae0:	4294      	cmp	r4, r2
    WRITE_REG(mpcbb_ptr->VCTR[i],
 c007ae2:	f843 5020 	str.w	r5, [r3, r0, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c007ae6:	d1f6      	bne.n	c007ad6 <HAL_GTZC_MPCBB_ConfigMem+0x5a>
              pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i]);
  }

  return HAL_OK;
 c007ae8:	2000      	movs	r0, #0
}
 c007aea:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 c007aec:	2001      	movs	r0, #1
 c007aee:	e7fc      	b.n	c007aea <HAL_GTZC_MPCBB_ConfigMem+0x6e>
 c007af0:	20030000 	.word	0x20030000
 c007af4:	50033000 	.word	0x50033000
 c007af8:	50032c00 	.word	0x50032c00

0c007afc <HAL_GTZC_MPCBB_GetConfigMem>:
  uint32_t size_mask;
  uint32_t size_in_superblocks;
  uint32_t i;

  /* check entry parameters */
  if (!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c007afc:	f020 5080 	bic.w	r0, r0, #268435456	; 0x10000000
 c007b00:	f1b0 5f00 	cmp.w	r0, #536870912	; 0x20000000
{
 c007b04:	b510      	push	{r4, lr}
  if (!(IS_GTZC_BASE_ADDRESS(SRAM1, MemBaseAddress))
 c007b06:	d021      	beq.n	c007b4c <HAL_GTZC_MPCBB_GetConfigMem+0x50>
      && !(IS_GTZC_BASE_ADDRESS(SRAM2, MemBaseAddress)))
 c007b08:	4b13      	ldr	r3, [pc, #76]	; (c007b58 <HAL_GTZC_MPCBB_GetConfigMem+0x5c>)
 c007b0a:	4298      	cmp	r0, r3
 c007b0c:	d122      	bne.n	c007b54 <HAL_GTZC_MPCBB_GetConfigMem+0x58>
    mem_size = GTZC_MEM_SIZE(SRAM1);
  }
  else
  {
    mpcbb_ptr = GTZC_MPCBB2_S;
    mem_size = GTZC_MEM_SIZE(SRAM2);
 c007b0e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    mpcbb_ptr = GTZC_MPCBB2_S;
 c007b12:	4812      	ldr	r0, [pc, #72]	; (c007b5c <HAL_GTZC_MPCBB_GetConfigMem+0x60>)
  }

  /* read configuration and lock register information */
  reg_value = READ_REG(mpcbb_ptr->CR);
 c007b14:	6802      	ldr	r2, [r0, #0]
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
  pMPCBB_desc->SecureRWIllegalMode = (reg_value & GTZC_MPCBB_CR_SRWILADIS_Msk);
  size_mask = (1UL << (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE)) - 1U;
 c007b16:	0b5b      	lsrs	r3, r3, #13
  pMPCBB_desc->InvertSecureState = (reg_value & GTZC_MPCBB_CR_INVSECSTATE_Msk);
 c007b18:	f002 4480 	and.w	r4, r2, #1073741824	; 0x40000000
 c007b1c:	604c      	str	r4, [r1, #4]
  /* limitation: code not portable with memory > 256K */
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->LCKVTR1)& size_mask;
 c007b1e:	f04f 34ff 	mov.w	r4, #4294967295
  pMPCBB_desc->SecureRWIllegalMode = (reg_value & GTZC_MPCBB_CR_SRWILADIS_Msk);
 c007b22:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 c007b26:	600a      	str	r2, [r1, #0]
  pMPCBB_desc->AttributeConfig.MPCBB_LockConfig_array[0] = READ_REG(mpcbb_ptr->LCKVTR1)& size_mask;
 c007b28:	6902      	ldr	r2, [r0, #16]
 c007b2a:	409c      	lsls	r4, r3
 c007b2c:	ea22 0204 	bic.w	r2, r2, r4
 c007b30:	668a      	str	r2, [r1, #104]	; 0x68

  /* read vector register information */
  size_in_superblocks = (mem_size / GTZC_MPCBB_SUPERBLOCK_SIZE);
  for (i = 0U; i < size_in_superblocks; i++)
 c007b32:	2200      	movs	r2, #0
 c007b34:	3108      	adds	r1, #8
  {
    pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i] = mpcbb_ptr->VCTR[i];
 c007b36:	f102 0440 	add.w	r4, r2, #64	; 0x40
 c007b3a:	f850 4024 	ldr.w	r4, [r0, r4, lsl #2]
  for (i = 0U; i < size_in_superblocks; i++)
 c007b3e:	3201      	adds	r2, #1
 c007b40:	4293      	cmp	r3, r2
    pMPCBB_desc->AttributeConfig.MPCBB_SecConfig_array[i] = mpcbb_ptr->VCTR[i];
 c007b42:	f841 4b04 	str.w	r4, [r1], #4
  for (i = 0U; i < size_in_superblocks; i++)
 c007b46:	d1f6      	bne.n	c007b36 <HAL_GTZC_MPCBB_GetConfigMem+0x3a>
  }

  return HAL_OK;
 c007b48:	2000      	movs	r0, #0
}
 c007b4a:	bd10      	pop	{r4, pc}
    mem_size = GTZC_MEM_SIZE(SRAM1);
 c007b4c:	f44f 3340 	mov.w	r3, #196608	; 0x30000
    mpcbb_ptr = GTZC_MPCBB1_S;
 c007b50:	4803      	ldr	r0, [pc, #12]	; (c007b60 <HAL_GTZC_MPCBB_GetConfigMem+0x64>)
 c007b52:	e7df      	b.n	c007b14 <HAL_GTZC_MPCBB_GetConfigMem+0x18>
    return HAL_ERROR;
 c007b54:	2001      	movs	r0, #1
 c007b56:	e7f8      	b.n	c007b4a <HAL_GTZC_MPCBB_GetConfigMem+0x4e>
 c007b58:	20030000 	.word	0x20030000
 c007b5c:	50033000 	.word	0x50033000
 c007b60:	50032c00 	.word	0x50032c00

0c007b64 <HASH_WriteData>:
  *         processing is suspended when possible and the Peripheral feeding point reached at
  *         suspension time is stored in the handle for resumption later on.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WriteData(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
 c007b64:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t buffercounter;
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;

  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c007b66:	2400      	movs	r4, #0
  __IO uint32_t inputaddr = (uint32_t) pInBuffer;
 c007b68:	9101      	str	r1, [sp, #4]
  {
    /* Write input data 4 bytes at a time */
    HASH->DIN = *(uint32_t*)inputaddr;
 c007b6a:	491c      	ldr	r1, [pc, #112]	; (c007bdc <HASH_WriteData+0x78>)
  for(buffercounter = 0U; buffercounter < Size; buffercounter+=4U)
 c007b6c:	4294      	cmp	r4, r2
 c007b6e:	d220      	bcs.n	c007bb2 <HASH_WriteData+0x4e>
    HASH->DIN = *(uint32_t*)inputaddr;
 c007b70:	9b01      	ldr	r3, [sp, #4]
 c007b72:	1d25      	adds	r5, r4, #4
 c007b74:	681b      	ldr	r3, [r3, #0]
 c007b76:	604b      	str	r3, [r1, #4]
    inputaddr+=4U;
 c007b78:	9b01      	ldr	r3, [sp, #4]
 c007b7a:	3304      	adds	r3, #4
 c007b7c:	9301      	str	r3, [sp, #4]

    /* If the suspension flag has been raised and if the processing is not about
    to end, suspend processing */
    if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4U) < Size))
 c007b7e:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
 c007b82:	2b01      	cmp	r3, #1
 c007b84:	d128      	bne.n	c007bd8 <HASH_WriteData+0x74>
 c007b86:	4295      	cmp	r5, r2
 c007b88:	d226      	bcs.n	c007bd8 <HASH_WriteData+0x74>
    {
      /* Wait for DINIS = 1, which occurs when 16 32-bit locations are free
      in the input buffer */
      if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))
 c007b8a:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 c007b8c:	07f6      	lsls	r6, r6, #31
 c007b8e:	d523      	bpl.n	c007bd8 <HASH_WriteData+0x74>
      {
        /* Reset SuspendRequest */
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c007b90:	2500      	movs	r5, #0

        /* Depending whether the key or the input data were fed to the Peripheral, the feeding point
        reached at suspension time is not saved in the same handle fields */
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c007b92:	f890 102d 	ldrb.w	r1, [r0, #45]	; 0x2d
        hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c007b96:	f880 5036 	strb.w	r5, [r0, #54]	; 0x36
        if ((hhash->Phase == HAL_HASH_PHASE_PROCESS) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_2))
 c007b9a:	2902      	cmp	r1, #2
 c007b9c:	d001      	beq.n	c007ba2 <HASH_WriteData+0x3e>
 c007b9e:	2904      	cmp	r1, #4
 c007ba0:	d109      	bne.n	c007bb6 <HASH_WriteData+0x52>
        {
          /* Save current reading and writing locations of Input and Output buffers */
          hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 c007ba2:	9b01      	ldr	r3, [sp, #4]
          /* Save the number of bytes that remain to be processed at this point */
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 c007ba4:	3a04      	subs	r2, #4
 c007ba6:	1b12      	subs	r2, r2, r4
          hhash->pHashInBuffPtr =  (uint8_t *)inputaddr;
 c007ba8:	60c3      	str	r3, [r0, #12]
          hhash->HashInCount    =  Size - (buffercounter + 4U);
 c007baa:	6202      	str	r2, [r0, #32]
          __HAL_UNLOCK(hhash);
          return HAL_ERROR;
        }

        /* Set the HASH state to Suspended and exit to stop entering data */
        hhash->State = HAL_HASH_STATE_SUSPENDED;
 c007bac:	2308      	movs	r3, #8
 c007bae:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
      } /* if (__HAL_HASH_GET_FLAG(HASH_FLAG_DINIS))  */
    } /* if ((hhash->SuspendRequest == HAL_HASH_SUSPEND) && ((buffercounter+4) < Size)) */
  }   /* for(buffercounter = 0; buffercounter < Size; buffercounter+=4)                 */

  /* At this point, all the data have been entered to the Peripheral: exit */
  return  HAL_OK;
 c007bb2:	2000      	movs	r0, #0
 c007bb4:	e00e      	b.n	c007bd4 <HASH_WriteData+0x70>
        else if ((hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_1) || (hhash->Phase == HAL_HASH_PHASE_HMAC_STEP_3))
 c007bb6:	2903      	cmp	r1, #3
 c007bb8:	d001      	beq.n	c007bbe <HASH_WriteData+0x5a>
 c007bba:	2905      	cmp	r1, #5
 c007bbc:	d105      	bne.n	c007bca <HASH_WriteData+0x66>
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 c007bbe:	9b01      	ldr	r3, [sp, #4]
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c007bc0:	3a04      	subs	r2, #4
 c007bc2:	1b12      	subs	r2, r2, r4
          hhash->pHashKeyBuffPtr  =  (uint8_t *)inputaddr;
 c007bc4:	6143      	str	r3, [r0, #20]
          hhash->HashKeyCount  =  Size - (buffercounter + 4U);
 c007bc6:	6282      	str	r2, [r0, #40]	; 0x28
 c007bc8:	e7f0      	b.n	c007bac <HASH_WriteData+0x48>
          hhash->State = HAL_HASH_STATE_READY;
 c007bca:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
          __HAL_UNLOCK(hhash);
 c007bce:	f880 5034 	strb.w	r5, [r0, #52]	; 0x34
          return HAL_ERROR;
 c007bd2:	4618      	mov	r0, r3
}
 c007bd4:	b002      	add	sp, #8
 c007bd6:	bd70      	pop	{r4, r5, r6, pc}
{
 c007bd8:	462c      	mov	r4, r5
 c007bda:	e7c7      	b.n	c007b6c <HASH_WriteData+0x8>
 c007bdc:	520c0400 	.word	0x520c0400

0c007be0 <HASH_GetDigest>:
  */
static void HASH_GetDigest(uint8_t *pMsgDigest, uint8_t Size)
{
  uint32_t msgdigest = (uint32_t)pMsgDigest;

  switch(Size)
 c007be0:	2914      	cmp	r1, #20
 c007be2:	d016      	beq.n	c007c12 <HASH_GetDigest+0x32>
 c007be4:	d802      	bhi.n	c007bec <HASH_GetDigest+0xc>
 c007be6:	2910      	cmp	r1, #16
 c007be8:	d005      	beq.n	c007bf6 <HASH_GetDigest+0x16>
 c007bea:	4770      	bx	lr
 c007bec:	291c      	cmp	r1, #28
 c007bee:	d021      	beq.n	c007c34 <HASH_GetDigest+0x54>
 c007bf0:	2920      	cmp	r1, #32
 c007bf2:	d037      	beq.n	c007c64 <HASH_GetDigest+0x84>
 c007bf4:	4770      	bx	lr
  {
    /* Read the message digest */
    case 16:  /* MD5 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c007bf6:	4b29      	ldr	r3, [pc, #164]	; (c007c9c <HASH_GetDigest+0xbc>)
 c007bf8:	68da      	ldr	r2, [r3, #12]
  return __builtin_bswap32(value);
 c007bfa:	ba12      	rev	r2, r2
 c007bfc:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c007bfe:	691a      	ldr	r2, [r3, #16]
 c007c00:	ba12      	rev	r2, r2
 c007c02:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c007c04:	695a      	ldr	r2, [r3, #20]
 c007c06:	ba12      	rev	r2, r2
 c007c08:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c007c0a:	699b      	ldr	r3, [r3, #24]
 c007c0c:	ba1b      	rev	r3, r3
 c007c0e:	60c3      	str	r3, [r0, #12]
    break;
 c007c10:	4770      	bx	lr
    case 20:  /* SHA1 */
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c007c12:	4b22      	ldr	r3, [pc, #136]	; (c007c9c <HASH_GetDigest+0xbc>)
 c007c14:	68da      	ldr	r2, [r3, #12]
 c007c16:	ba12      	rev	r2, r2
 c007c18:	6002      	str	r2, [r0, #0]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c007c1a:	691a      	ldr	r2, [r3, #16]
 c007c1c:	ba12      	rev	r2, r2
 c007c1e:	6042      	str	r2, [r0, #4]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c007c20:	695a      	ldr	r2, [r3, #20]
 c007c22:	ba12      	rev	r2, r2
 c007c24:	6082      	str	r2, [r0, #8]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c007c26:	699a      	ldr	r2, [r3, #24]
 c007c28:	ba12      	rev	r2, r2
 c007c2a:	60c2      	str	r2, [r0, #12]
      msgdigest+=4U;
      *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c007c2c:	69db      	ldr	r3, [r3, #28]
 c007c2e:	ba1b      	rev	r3, r3
 c007c30:	6103      	str	r3, [r0, #16]
    break;
 c007c32:	4770      	bx	lr
  case 28:  /* SHA224 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c007c34:	4b19      	ldr	r3, [pc, #100]	; (c007c9c <HASH_GetDigest+0xbc>)
 c007c36:	68da      	ldr	r2, [r3, #12]
 c007c38:	ba12      	rev	r2, r2
 c007c3a:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c007c3c:	691a      	ldr	r2, [r3, #16]
 c007c3e:	ba12      	rev	r2, r2
 c007c40:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c007c42:	695a      	ldr	r2, [r3, #20]
 c007c44:	ba12      	rev	r2, r2
 c007c46:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c007c48:	699a      	ldr	r2, [r3, #24]
 c007c4a:	ba12      	rev	r2, r2
 c007c4c:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c007c4e:	69db      	ldr	r3, [r3, #28]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c007c50:	4a13      	ldr	r2, [pc, #76]	; (c007ca0 <HASH_GetDigest+0xc0>)
 c007c52:	ba1b      	rev	r3, r3
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c007c54:	6103      	str	r3, [r0, #16]
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c007c56:	6953      	ldr	r3, [r2, #20]
 c007c58:	ba1b      	rev	r3, r3
 c007c5a:	6143      	str	r3, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c007c5c:	6993      	ldr	r3, [r2, #24]
 c007c5e:	ba1b      	rev	r3, r3
 c007c60:	6183      	str	r3, [r0, #24]
    break;
 c007c62:	4770      	bx	lr
  case 32:   /* SHA256 */
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[0]);
 c007c64:	4b0d      	ldr	r3, [pc, #52]	; (c007c9c <HASH_GetDigest+0xbc>)
 c007c66:	68da      	ldr	r2, [r3, #12]
 c007c68:	ba12      	rev	r2, r2
 c007c6a:	6002      	str	r2, [r0, #0]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[1]);
 c007c6c:	691a      	ldr	r2, [r3, #16]
 c007c6e:	ba12      	rev	r2, r2
 c007c70:	6042      	str	r2, [r0, #4]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[2]);
 c007c72:	695a      	ldr	r2, [r3, #20]
 c007c74:	ba12      	rev	r2, r2
 c007c76:	6082      	str	r2, [r0, #8]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[3]);
 c007c78:	699a      	ldr	r2, [r3, #24]
 c007c7a:	ba12      	rev	r2, r2
 c007c7c:	60c2      	str	r2, [r0, #12]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH->HR[4]);
 c007c7e:	69db      	ldr	r3, [r3, #28]
 c007c80:	ba1b      	rev	r3, r3
 c007c82:	6103      	str	r3, [r0, #16]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[5]);
 c007c84:	4b06      	ldr	r3, [pc, #24]	; (c007ca0 <HASH_GetDigest+0xc0>)
 c007c86:	695a      	ldr	r2, [r3, #20]
 c007c88:	ba12      	rev	r2, r2
 c007c8a:	6142      	str	r2, [r0, #20]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[6]);
 c007c8c:	699a      	ldr	r2, [r3, #24]
 c007c8e:	ba12      	rev	r2, r2
 c007c90:	6182      	str	r2, [r0, #24]
    msgdigest+=4U;
    *(uint32_t*)(msgdigest) = __REV(HASH_DIGEST->HR[7]);
 c007c92:	69db      	ldr	r3, [r3, #28]
 c007c94:	ba1b      	rev	r3, r3
 c007c96:	61c3      	str	r3, [r0, #28]
    break;
    default:
    break;
  }
}
 c007c98:	4770      	bx	lr
 c007c9a:	bf00      	nop
 c007c9c:	520c0400 	.word	0x520c0400
 c007ca0:	520c0710 	.word	0x520c0710

0c007ca4 <HASH_WaitOnFlagUntilTimeout>:
  * @param  Status the Flag status (SET or RESET).
  * @param  Timeout Timeout duration.
  * @retval HAL status
  */
static HAL_StatusTypeDef HASH_WaitOnFlagUntilTimeout(HASH_HandleTypeDef *hhash, uint32_t Flag, FlagStatus Status, uint32_t Timeout)
{
 c007ca4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c007ca8:	4604      	mov	r4, r0
 c007caa:	460e      	mov	r6, r1
 c007cac:	4691      	mov	r9, r2
 c007cae:	461d      	mov	r5, r3
  uint32_t tickstart = HAL_GetTick();
 c007cb0:	f7fb fbf8 	bl	c0034a4 <HAL_GetTick>
 c007cb4:	4f16      	ldr	r7, [pc, #88]	; (c007d10 <HASH_WaitOnFlagUntilTimeout+0x6c>)
 c007cb6:	4680      	mov	r8, r0

  /* Wait until flag is set */
  if(Status == RESET)
 c007cb8:	f1b9 0f00 	cmp.w	r9, #0
 c007cbc:	d021      	beq.n	c007d02 <HASH_WaitOnFlagUntilTimeout+0x5e>
      }
    }
  }
  else
  {
    while(__HAL_HASH_GET_FLAG(Flag) != RESET)
 c007cbe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 c007cc0:	ea36 0303 	bics.w	r3, r6, r3
 c007cc4:	d121      	bne.n	c007d0a <HASH_WaitOnFlagUntilTimeout+0x66>
    {
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 c007cc6:	1c6b      	adds	r3, r5, #1
 c007cc8:	d0f9      	beq.n	c007cbe <HASH_WaitOnFlagUntilTimeout+0x1a>
      {
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 c007cca:	f7fb fbeb 	bl	c0034a4 <HAL_GetTick>
 c007cce:	eba0 0008 	sub.w	r0, r0, r8
 c007cd2:	42a8      	cmp	r0, r5
 c007cd4:	d80b      	bhi.n	c007cee <HASH_WaitOnFlagUntilTimeout+0x4a>
 c007cd6:	2d00      	cmp	r5, #0
 c007cd8:	d1f1      	bne.n	c007cbe <HASH_WaitOnFlagUntilTimeout+0x1a>
 c007cda:	e008      	b.n	c007cee <HASH_WaitOnFlagUntilTimeout+0x4a>
      if(Timeout != HAL_MAX_DELAY)
 c007cdc:	1c6a      	adds	r2, r5, #1
 c007cde:	d010      	beq.n	c007d02 <HASH_WaitOnFlagUntilTimeout+0x5e>
        if(((HAL_GetTick()-tickstart) > Timeout) || (Timeout == 0U))
 c007ce0:	f7fb fbe0 	bl	c0034a4 <HAL_GetTick>
 c007ce4:	eba0 0008 	sub.w	r0, r0, r8
 c007ce8:	42a8      	cmp	r0, r5
 c007cea:	d800      	bhi.n	c007cee <HASH_WaitOnFlagUntilTimeout+0x4a>
 c007cec:	b94d      	cbnz	r5, c007d02 <HASH_WaitOnFlagUntilTimeout+0x5e>
        {
          /* Set State to Ready to be able to restart later on */
          hhash->State  = HAL_HASH_STATE_READY;
 c007cee:	2301      	movs	r3, #1
          /* Store time out issue in handle status */
          hhash->Status = HAL_TIMEOUT;
 c007cf0:	2003      	movs	r0, #3
          hhash->State  = HAL_HASH_STATE_READY;
 c007cf2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hhash);
 c007cf6:	2300      	movs	r3, #0
          hhash->Status = HAL_TIMEOUT;
 c007cf8:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
          __HAL_UNLOCK(hhash);
 c007cfc:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

          return HAL_TIMEOUT;
 c007d00:	e004      	b.n	c007d0c <HASH_WaitOnFlagUntilTimeout+0x68>
    while(__HAL_HASH_GET_FLAG(Flag) == RESET)
 c007d02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 c007d04:	ea36 0303 	bics.w	r3, r6, r3
 c007d08:	d1e8      	bne.n	c007cdc <HASH_WaitOnFlagUntilTimeout+0x38>
        }
      }
    }
  }
  return HAL_OK;
 c007d0a:	2000      	movs	r0, #0
}
 c007d0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c007d10:	520c0400 	.word	0x520c0400

0c007d14 <HAL_HASH_MspInit>:
}
 c007d14:	4770      	bx	lr
	...

0c007d18 <HAL_HASH_Init>:
{
 c007d18:	b538      	push	{r3, r4, r5, lr}
  if(hhash == NULL)
 c007d1a:	4604      	mov	r4, r0
 c007d1c:	b340      	cbz	r0, c007d70 <HAL_HASH_Init+0x58>
  if(hhash->State == HAL_HASH_STATE_RESET)
 c007d1e:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 c007d22:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c007d26:	b91b      	cbnz	r3, c007d30 <HAL_HASH_Init+0x18>
    hhash->Lock = HAL_UNLOCKED;
 c007d28:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
    HAL_HASH_MspInit(hhash);
 c007d2c:	f7ff fff2 	bl	c007d14 <HAL_HASH_MspInit>
  hhash->HashInCount = 0;
 c007d30:	2000      	movs	r0, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c007d32:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c007d34:	2101      	movs	r1, #1
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c007d36:	4a0f      	ldr	r2, [pc, #60]	; (c007d74 <HAL_HASH_Init+0x5c>)
  hhash->State = HAL_HASH_STATE_BUSY;
 c007d38:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  hhash->HashBuffSize = 0;
 c007d3c:	61e0      	str	r0, [r4, #28]
  hhash->HashInCount = 0;
 c007d3e:	6220      	str	r0, [r4, #32]
  hhash->HashITCounter = 0;
 c007d40:	6260      	str	r0, [r4, #36]	; 0x24
  hhash->NbWordsAlreadyPushed = 0;
 c007d42:	63a0      	str	r0, [r4, #56]	; 0x38
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c007d44:	6813      	ldr	r3, [r2, #0]
 c007d46:	6825      	ldr	r5, [r4, #0]
 c007d48:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 c007d4c:	432b      	orrs	r3, r5
  hhash->DigestCalculationDisable = RESET;
 c007d4e:	f884 0037 	strb.w	r0, [r4, #55]	; 0x37
  hhash->Phase = HAL_HASH_PHASE_READY;
 c007d52:	f884 102d 	strb.w	r1, [r4, #45]	; 0x2d
  hhash->SuspendRequest = HAL_HASH_SUSPEND_NONE;
 c007d56:	f884 0036 	strb.w	r0, [r4, #54]	; 0x36
  MODIFY_REG(HASH->CR, HASH_CR_DATATYPE, hhash->Init.DataType);
 c007d5a:	6013      	str	r3, [r2, #0]
__HAL_HASH_RESET_MDMAT();
 c007d5c:	6813      	ldr	r3, [r2, #0]
 c007d5e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 c007d62:	6013      	str	r3, [r2, #0]
  hhash->State = HAL_HASH_STATE_READY;
 c007d64:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
  hhash->Status = HAL_OK;
 c007d68:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c007d6c:	63e0      	str	r0, [r4, #60]	; 0x3c
}
 c007d6e:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 c007d70:	2001      	movs	r0, #1
 c007d72:	e7fc      	b.n	c007d6e <HAL_HASH_Init+0x56>
 c007d74:	520c0400 	.word	0x520c0400

0c007d78 <HAL_HASH_MspDeInit>:
 c007d78:	4770      	bx	lr

0c007d7a <HAL_HASH_DeInit>:
{
 c007d7a:	b538      	push	{r3, r4, r5, lr}
  if(hhash == NULL)
 c007d7c:	4605      	mov	r5, r0
 c007d7e:	2401      	movs	r4, #1
 c007d80:	b190      	cbz	r0, c007da8 <HAL_HASH_DeInit+0x2e>
  hhash->State = HAL_HASH_STATE_BUSY;
 c007d82:	2302      	movs	r3, #2
  hhash->Phase = HAL_HASH_PHASE_READY;
 c007d84:	f880 402d 	strb.w	r4, [r0, #45]	; 0x2d
  hhash->HashInCount = 0;
 c007d88:	2400      	movs	r4, #0
  hhash->State = HAL_HASH_STATE_BUSY;
 c007d8a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
  hhash->HashBuffSize = 0;
 c007d8e:	61c4      	str	r4, [r0, #28]
  hhash->HashInCount = 0;
 c007d90:	6204      	str	r4, [r0, #32]
  hhash->DigestCalculationDisable = RESET;
 c007d92:	f880 4037 	strb.w	r4, [r0, #55]	; 0x37
  hhash->HashITCounter = 0;
 c007d96:	6244      	str	r4, [r0, #36]	; 0x24
  HAL_HASH_MspDeInit(hhash);
 c007d98:	f7ff ffee 	bl	c007d78 <HAL_HASH_MspDeInit>
  hhash->State = HAL_HASH_STATE_RESET;
 c007d9c:	f885 4035 	strb.w	r4, [r5, #53]	; 0x35
  hhash->Status = HAL_OK;
 c007da0:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  hhash->ErrorCode = HAL_HASH_ERROR_NONE;
 c007da4:	63ec      	str	r4, [r5, #60]	; 0x3c
  hhash->Accumulation = 0U;
 c007da6:	642c      	str	r4, [r5, #64]	; 0x40
    return HAL_ERROR;
 c007da8:	4620      	mov	r0, r4
}
 c007daa:	bd38      	pop	{r3, r4, r5, pc}

0c007dac <HASH_Start>:
  * @param  Timeout Timeout value.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout, uint32_t Algorithm)
{
 c007dac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c007dae:	461f      	mov	r7, r3
  uint8_t *pInBuffer_tmp;  /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp; /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c007db0:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
{
 c007db4:	4604      	mov	r4, r0
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c007db6:	b2db      	uxtb	r3, r3


  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c007db8:	2b01      	cmp	r3, #1
 c007dba:	d001      	beq.n	c007dc0 <HASH_Start+0x14>
 c007dbc:	2b08      	cmp	r3, #8
 c007dbe:	d17b      	bne.n	c007eb8 <HASH_Start+0x10c>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (pOutBuffer == NULL))
 c007dc0:	b101      	cbz	r1, c007dc4 <HASH_Start+0x18>
 c007dc2:	b927      	cbnz	r7, c007dce <HASH_Start+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c007dc4:	2501      	movs	r5, #1
 c007dc6:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  }
  else
  {
    return HAL_BUSY;
  }
}
 c007dca:	4628      	mov	r0, r5
 c007dcc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hhash);
 c007dce:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 c007dd2:	2b01      	cmp	r3, #1
 c007dd4:	d070      	beq.n	c007eb8 <HASH_Start+0x10c>
 c007dd6:	2501      	movs	r5, #1
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 c007dd8:	f894 302d 	ldrb.w	r3, [r4, #45]	; 0x2d
    __HAL_LOCK(hhash);
 c007ddc:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    if(hhash->Phase == HAL_HASH_PHASE_READY)
 c007de0:	42ab      	cmp	r3, r5
 c007de2:	d147      	bne.n	c007e74 <HASH_Start+0xc8>
      hhash->State = HAL_HASH_STATE_BUSY;
 c007de4:	2602      	movs	r6, #2
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c007de6:	4d36      	ldr	r5, [pc, #216]	; (c007ec0 <HASH_Start+0x114>)
      hhash->State = HAL_HASH_STATE_BUSY;
 c007de8:	f884 6035 	strb.w	r6, [r4, #53]	; 0x35
      MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c007dec:	682b      	ldr	r3, [r5, #0]
 c007dee:	9807      	ldr	r0, [sp, #28]
 c007df0:	f423 23a0 	bic.w	r3, r3, #327680	; 0x50000
 c007df4:	f023 03c4 	bic.w	r3, r3, #196	; 0xc4
 c007df8:	f043 0304 	orr.w	r3, r3, #4
 c007dfc:	4303      	orrs	r3, r0
 c007dfe:	602b      	str	r3, [r5, #0]
      __HAL_HASH_SET_NBVALIDBITS(Size);
 c007e00:	68a8      	ldr	r0, [r5, #8]
 c007e02:	f002 0303 	and.w	r3, r2, #3
 c007e06:	f020 001f 	bic.w	r0, r0, #31
 c007e0a:	ea40 03c3 	orr.w	r3, r0, r3, lsl #3
 c007e0e:	60ab      	str	r3, [r5, #8]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c007e10:	f884 602d 	strb.w	r6, [r4, #45]	; 0x2d
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c007e14:	4620      	mov	r0, r4
 c007e16:	f7ff fea5 	bl	c007b64 <HASH_WriteData>
 c007e1a:	4605      	mov	r5, r0
 c007e1c:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 c007e20:	2800      	cmp	r0, #0
 c007e22:	d1d2      	bne.n	c007dca <HASH_Start+0x1e>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c007e24:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c007e28:	2b08      	cmp	r3, #8
 c007e2a:	d03d      	beq.n	c007ea8 <HASH_Start+0xfc>
      __HAL_HASH_START_DIGEST();
 c007e2c:	4e24      	ldr	r6, [pc, #144]	; (c007ec0 <HASH_Start+0x114>)
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c007e2e:	4602      	mov	r2, r0
      __HAL_HASH_START_DIGEST();
 c007e30:	68b3      	ldr	r3, [r6, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c007e32:	2102      	movs	r1, #2
      __HAL_HASH_START_DIGEST();
 c007e34:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c007e38:	60b3      	str	r3, [r6, #8]
      if (HASH_WaitOnFlagUntilTimeout(hhash, HASH_FLAG_DCIS, RESET, Timeout) != HAL_OK)
 c007e3a:	9b06      	ldr	r3, [sp, #24]
 c007e3c:	4620      	mov	r0, r4
 c007e3e:	f7ff ff31 	bl	c007ca4 <HASH_WaitOnFlagUntilTimeout>
 c007e42:	2800      	cmp	r0, #0
 c007e44:	d13a      	bne.n	c007ebc <HASH_Start+0x110>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c007e46:	6832      	ldr	r2, [r6, #0]
 c007e48:	4b1e      	ldr	r3, [pc, #120]	; (c007ec4 <HASH_Start+0x118>)
 c007e4a:	421a      	tst	r2, r3
 c007e4c:	d030      	beq.n	c007eb0 <HASH_Start+0x104>
 c007e4e:	6832      	ldr	r2, [r6, #0]
 c007e50:	401a      	ands	r2, r3
 c007e52:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 c007e56:	d02d      	beq.n	c007eb4 <HASH_Start+0x108>
 c007e58:	6832      	ldr	r2, [r6, #0]
 c007e5a:	4393      	bics	r3, r2
 c007e5c:	bf0c      	ite	eq
 c007e5e:	2120      	moveq	r1, #32
 c007e60:	2110      	movne	r1, #16
 c007e62:	4638      	mov	r0, r7
 c007e64:	f7ff febc 	bl	c007be0 <HASH_GetDigest>
      hhash->State = HAL_HASH_STATE_READY;
 c007e68:	2301      	movs	r3, #1
 c007e6a:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      hhash->Phase = HAL_HASH_PHASE_READY;
 c007e6e:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 c007e72:	e019      	b.n	c007ea8 <HASH_Start+0xfc>
    else if (hhash->Phase == HAL_HASH_PHASE_PROCESS)
 c007e74:	2b02      	cmp	r3, #2
 c007e76:	d115      	bne.n	c007ea4 <HASH_Start+0xf8>
      if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c007e78:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c007e7c:	2b08      	cmp	r3, #8
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c007e7e:	bf1d      	ittte	ne
 c007e80:	4d0f      	ldrne	r5, [pc, #60]	; (c007ec0 <HASH_Start+0x114>)
 c007e82:	f002 0303 	andne.w	r3, r2, #3
 c007e86:	68a8      	ldrne	r0, [r5, #8]
        Size_tmp = hhash->HashInCount;
 c007e88:	6a22      	ldreq	r2, [r4, #32]
        __HAL_HASH_SET_NBVALIDBITS(Size);
 c007e8a:	bf1e      	ittt	ne
 c007e8c:	f020 001f 	bicne.w	r0, r0, #31
 c007e90:	ea40 03c3 	orrne.w	r3, r0, r3, lsl #3
 c007e94:	60ab      	strne	r3, [r5, #8]
      hhash->State = HAL_HASH_STATE_BUSY;
 c007e96:	f04f 0302 	mov.w	r3, #2
        pInBuffer_tmp = hhash->pHashInBuffPtr;
 c007e9a:	bf08      	it	eq
 c007e9c:	68e1      	ldreq	r1, [r4, #12]
      hhash->State = HAL_HASH_STATE_BUSY;
 c007e9e:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
 c007ea2:	e7b7      	b.n	c007e14 <HASH_Start+0x68>
      hhash->State = HAL_HASH_STATE_READY;
 c007ea4:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    __HAL_UNLOCK(hhash);
 c007ea8:	2300      	movs	r3, #0
 c007eaa:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 c007eae:	e78c      	b.n	c007dca <HASH_Start+0x1e>
      HASH_GetDigest(pOutBuffer, HASH_DIGEST_LENGTH());
 c007eb0:	2114      	movs	r1, #20
 c007eb2:	e7d6      	b.n	c007e62 <HASH_Start+0xb6>
 c007eb4:	211c      	movs	r1, #28
 c007eb6:	e7d4      	b.n	c007e62 <HASH_Start+0xb6>
    return HAL_BUSY;
 c007eb8:	2502      	movs	r5, #2
 c007eba:	e786      	b.n	c007dca <HASH_Start+0x1e>
        return HAL_TIMEOUT;
 c007ebc:	2503      	movs	r5, #3
 c007ebe:	e784      	b.n	c007dca <HASH_Start+0x1e>
 c007ec0:	520c0400 	.word	0x520c0400
 c007ec4:	00040080 	.word	0x00040080

0c007ec8 <HASH_Accumulate>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @param  Algorithm HASH algorithm.
  * @retval HAL status
  */
HAL_StatusTypeDef HASH_Accumulate(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint32_t Algorithm)
{
 c007ec8:	b538      	push	{r3, r4, r5, lr}
  uint8_t *pInBuffer_tmp;   /* input data address, input parameter of HASH_WriteData()         */
  uint32_t Size_tmp;  /* input data size (in bytes), input parameter of HASH_WriteData() */
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c007eca:	f890 5035 	ldrb.w	r5, [r0, #53]	; 0x35
{
 c007ece:	4604      	mov	r4, r0

  /* Make sure the input buffer size (in bytes) is a multiple of 4 */
  if ((Size % 4U) != 0U)
 c007ed0:	0790      	lsls	r0, r2, #30
  HAL_HASH_StateTypeDef State_tmp = hhash->State;
 c007ed2:	b2ed      	uxtb	r5, r5
  if ((Size % 4U) != 0U)
 c007ed4:	d13d      	bne.n	c007f52 <HASH_Accumulate+0x8a>
  {
    return  HAL_ERROR;
  }

  /* Initiate HASH processing in case of start or resumption */
if((State_tmp == HAL_HASH_STATE_READY) || (State_tmp == HAL_HASH_STATE_SUSPENDED))
 c007ed6:	2d01      	cmp	r5, #1
 c007ed8:	d001      	beq.n	c007ede <HASH_Accumulate+0x16>
 c007eda:	2d08      	cmp	r5, #8
 c007edc:	d13b      	bne.n	c007f56 <HASH_Accumulate+0x8e>
  {
    /* Check input parameters */
    if ((pInBuffer == NULL) || (Size == 0U))
 c007ede:	b101      	cbz	r1, c007ee2 <HASH_Accumulate+0x1a>
 c007ee0:	b91a      	cbnz	r2, c007eea <HASH_Accumulate+0x22>
    {
      hhash->State = HAL_HASH_STATE_READY;
 c007ee2:	2001      	movs	r0, #1
 c007ee4:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  {
    return HAL_BUSY;
  }


}
 c007ee8:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_LOCK(hhash);
 c007eea:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 c007eee:	2801      	cmp	r0, #1
 c007ef0:	d031      	beq.n	c007f56 <HASH_Accumulate+0x8e>
 c007ef2:	2001      	movs	r0, #1
 c007ef4:	2502      	movs	r5, #2
 c007ef6:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c007efa:	f894 0035 	ldrb.w	r0, [r4, #53]	; 0x35
      hhash->State = HAL_HASH_STATE_BUSY;
 c007efe:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
    if (hhash->State == HAL_HASH_STATE_SUSPENDED)
 c007f02:	2808      	cmp	r0, #8
 c007f04:	d113      	bne.n	c007f2e <HASH_Accumulate+0x66>
      pInBuffer_tmp = hhash->pHashInBuffPtr;  /* pInBuffer_tmp is set to the input data address */
 c007f06:	68e1      	ldr	r1, [r4, #12]
      Size_tmp = hhash->HashInCount;          /* Size_tmp contains the input data size in bytes */
 c007f08:	6a22      	ldr	r2, [r4, #32]
    hhash->Status = HASH_WriteData(hhash, pInBuffer_tmp, Size_tmp);
 c007f0a:	4620      	mov	r0, r4
 c007f0c:	f7ff fe2a 	bl	c007b64 <HASH_WriteData>
 c007f10:	f884 002c 	strb.w	r0, [r4, #44]	; 0x2c
    if (hhash->Status != HAL_OK)
 c007f14:	2800      	cmp	r0, #0
 c007f16:	d1e7      	bne.n	c007ee8 <HASH_Accumulate+0x20>
    if (hhash->State != HAL_HASH_STATE_SUSPENDED)
 c007f18:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 c007f1c:	2b08      	cmp	r3, #8
      hhash->State = HAL_HASH_STATE_READY;
 c007f1e:	bf1c      	itt	ne
 c007f20:	2301      	movne	r3, #1
 c007f22:	f884 3035 	strbne.w	r3, [r4, #53]	; 0x35
    __HAL_UNLOCK(hhash);
 c007f26:	2300      	movs	r3, #0
 c007f28:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 c007f2c:	e7dc      	b.n	c007ee8 <HASH_Accumulate+0x20>
      if(hhash->Phase == HAL_HASH_PHASE_READY)
 c007f2e:	f894 002d 	ldrb.w	r0, [r4, #45]	; 0x2d
 c007f32:	2801      	cmp	r0, #1
 c007f34:	d109      	bne.n	c007f4a <HASH_Accumulate+0x82>
        MODIFY_REG(HASH->CR, HASH_CR_LKEY|HASH_CR_ALGO|HASH_CR_MODE|HASH_CR_INIT, Algorithm | HASH_CR_INIT);
 c007f36:	4d09      	ldr	r5, [pc, #36]	; (c007f5c <HASH_Accumulate+0x94>)
 c007f38:	6828      	ldr	r0, [r5, #0]
 c007f3a:	f420 20a0 	bic.w	r0, r0, #327680	; 0x50000
 c007f3e:	f020 00c4 	bic.w	r0, r0, #196	; 0xc4
 c007f42:	f040 0004 	orr.w	r0, r0, #4
 c007f46:	4303      	orrs	r3, r0
 c007f48:	602b      	str	r3, [r5, #0]
      hhash->Phase = HAL_HASH_PHASE_PROCESS;
 c007f4a:	2302      	movs	r3, #2
 c007f4c:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
 c007f50:	e7db      	b.n	c007f0a <HASH_Accumulate+0x42>
    return  HAL_ERROR;
 c007f52:	2001      	movs	r0, #1
 c007f54:	e7c8      	b.n	c007ee8 <HASH_Accumulate+0x20>
    return HAL_BUSY;
 c007f56:	2002      	movs	r0, #2
 c007f58:	e7c6      	b.n	c007ee8 <HASH_Accumulate+0x20>
 c007f5a:	bf00      	nop
 c007f5c:	520c0400 	.word	0x520c0400

0c007f60 <HAL_HASHEx_SHA224_Start>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 28 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 c007f60:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA224);
 c007f62:	f44f 2480 	mov.w	r4, #262144	; 0x40000
 c007f66:	9401      	str	r4, [sp, #4]
 c007f68:	9c04      	ldr	r4, [sp, #16]
 c007f6a:	9400      	str	r4, [sp, #0]
 c007f6c:	f7ff ff1e 	bl	c007dac <HASH_Start>
}
 c007f70:	b002      	add	sp, #8
 c007f72:	bd10      	pop	{r4, pc}

0c007f74 <HAL_HASHEx_SHA224_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA224_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA224);
 c007f74:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 c007f78:	f7ff bfa6 	b.w	c007ec8 <HASH_Accumulate>

0c007f7c <HAL_HASHEx_SHA224_Accmlt_End>:
 c007f7c:	f7ff bff0 	b.w	c007f60 <HAL_HASHEx_SHA224_Start>

0c007f80 <HAL_HASHEx_SHA256_Start>:
  * @param  pOutBuffer pointer to the computed digest. Digest size is 32 bytes.
  * @param  Timeout Timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Start(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size, uint8_t* pOutBuffer, uint32_t Timeout)
{
 c007f80:	b513      	push	{r0, r1, r4, lr}
  return HASH_Start(hhash, pInBuffer, Size, pOutBuffer, Timeout, HASH_ALGOSELECTION_SHA256);
 c007f82:	4c04      	ldr	r4, [pc, #16]	; (c007f94 <HAL_HASHEx_SHA256_Start+0x14>)
 c007f84:	9401      	str	r4, [sp, #4]
 c007f86:	9c04      	ldr	r4, [sp, #16]
 c007f88:	9400      	str	r4, [sp, #0]
 c007f8a:	f7ff ff0f 	bl	c007dac <HASH_Start>
}
 c007f8e:	b002      	add	sp, #8
 c007f90:	bd10      	pop	{r4, pc}
 c007f92:	bf00      	nop
 c007f94:	00040080 	.word	0x00040080

0c007f98 <HAL_HASHEx_SHA256_Accmlt>:
  * @param  Size length of the input buffer in bytes, must be a multiple of 4.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HASHEx_SHA256_Accmlt(HASH_HandleTypeDef *hhash, uint8_t *pInBuffer, uint32_t Size)
{
  return  HASH_Accumulate(hhash, pInBuffer, Size,HASH_ALGOSELECTION_SHA256);
 c007f98:	4b01      	ldr	r3, [pc, #4]	; (c007fa0 <HAL_HASHEx_SHA256_Accmlt+0x8>)
 c007f9a:	f7ff bf95 	b.w	c007ec8 <HASH_Accumulate>
 c007f9e:	bf00      	nop
 c007fa0:	00040080 	.word	0x00040080

0c007fa4 <HAL_HASHEx_SHA256_Accmlt_End>:
 c007fa4:	f7ff bfec 	b.w	c007f80 <HAL_HASHEx_SHA256_Start>

0c007fa8 <HAL_ICACHE_Enable>:
  *         cache operation completes.
  * @retval HAL status (HAL_OK)
  */
HAL_StatusTypeDef HAL_ICACHE_Enable(void)
{
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 c007fa8:	4a03      	ldr	r2, [pc, #12]	; (c007fb8 <HAL_ICACHE_Enable+0x10>)

  return HAL_OK;
}
 c007faa:	2000      	movs	r0, #0
  SET_BIT(ICACHE->CR, ICACHE_CR_EN);
 c007fac:	6813      	ldr	r3, [r2, #0]
 c007fae:	f043 0301 	orr.w	r3, r3, #1
 c007fb2:	6013      	str	r3, [r2, #0]
}
 c007fb4:	4770      	bx	lr
 c007fb6:	bf00      	nop
 c007fb8:	50030400 	.word	0x50030400

0c007fbc <HAL_ICACHE_WaitForInvalidateComplete>:
  * @brief Wait for the end of the Instruction Cache invalidate procedure.
  * @note This function checks and clears the BSYENDF flag when set.
  * @retval HAL status (HAL_OK/HAL_TIMEOUT)
  */
HAL_StatusTypeDef HAL_ICACHE_WaitForInvalidateComplete(void)
{
 c007fbc:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tickstart;

  /* Check if ongoing invalidation operation */
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) != 0U)
 c007fbe:	4c0c      	ldr	r4, [pc, #48]	; (c007ff0 <HAL_ICACHE_WaitForInvalidateComplete+0x34>)
 c007fc0:	6863      	ldr	r3, [r4, #4]
 c007fc2:	07d9      	lsls	r1, r3, #31
 c007fc4:	d404      	bmi.n	c007fd0 <HAL_ICACHE_WaitForInvalidateComplete+0x14>
  HAL_StatusTypeDef status = HAL_OK;
 c007fc6:	2000      	movs	r0, #0
      }
    }
  }

  /* Clear BSYENDF */
  WRITE_REG(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c007fc8:	2202      	movs	r2, #2
 c007fca:	4b09      	ldr	r3, [pc, #36]	; (c007ff0 <HAL_ICACHE_WaitForInvalidateComplete+0x34>)
 c007fcc:	60da      	str	r2, [r3, #12]

  return status;
}
 c007fce:	bd38      	pop	{r3, r4, r5, pc}
    tickstart = HAL_GetTick();
 c007fd0:	f7fb fa68 	bl	c0034a4 <HAL_GetTick>
 c007fd4:	4605      	mov	r5, r0
    while (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c007fd6:	6863      	ldr	r3, [r4, #4]
 c007fd8:	079b      	lsls	r3, r3, #30
 c007fda:	d4f4      	bmi.n	c007fc6 <HAL_ICACHE_WaitForInvalidateComplete+0xa>
      if ((HAL_GetTick() - tickstart) > ICACHE_INVALIDATE_TIMEOUT_VALUE)
 c007fdc:	f7fb fa62 	bl	c0034a4 <HAL_GetTick>
 c007fe0:	1b40      	subs	r0, r0, r5
 c007fe2:	2801      	cmp	r0, #1
 c007fe4:	d9f7      	bls.n	c007fd6 <HAL_ICACHE_WaitForInvalidateComplete+0x1a>
        if (READ_BIT(ICACHE->SR, ICACHE_SR_BSYENDF) == 0U)
 c007fe6:	6863      	ldr	r3, [r4, #4]
 c007fe8:	079a      	lsls	r2, r3, #30
 c007fea:	d4f4      	bmi.n	c007fd6 <HAL_ICACHE_WaitForInvalidateComplete+0x1a>
          status = HAL_TIMEOUT;
 c007fec:	2003      	movs	r0, #3
 c007fee:	e7eb      	b.n	c007fc8 <HAL_ICACHE_WaitForInvalidateComplete+0xc>
 c007ff0:	50030400 	.word	0x50030400

0c007ff4 <HAL_ICACHE_Invalidate>:
  if (READ_BIT(ICACHE->SR, ICACHE_SR_BUSYF) != 0U)
 c007ff4:	4b07      	ldr	r3, [pc, #28]	; (c008014 <HAL_ICACHE_Invalidate+0x20>)
 c007ff6:	685a      	ldr	r2, [r3, #4]
 c007ff8:	07d2      	lsls	r2, r2, #31
 c007ffa:	d409      	bmi.n	c008010 <HAL_ICACHE_Invalidate+0x1c>
    CLEAR_BIT(ICACHE->FCR, ICACHE_FCR_CBSYENDF);
 c007ffc:	68da      	ldr	r2, [r3, #12]
 c007ffe:	f022 0202 	bic.w	r2, r2, #2
 c008002:	60da      	str	r2, [r3, #12]
    SET_BIT(ICACHE->CR, ICACHE_CR_CACHEINV);
 c008004:	681a      	ldr	r2, [r3, #0]
 c008006:	f042 0202 	orr.w	r2, r2, #2
 c00800a:	601a      	str	r2, [r3, #0]
    status = HAL_ICACHE_WaitForInvalidateComplete();
 c00800c:	f7ff bfd6 	b.w	c007fbc <HAL_ICACHE_WaitForInvalidateComplete>
}
 c008010:	2001      	movs	r0, #1
 c008012:	4770      	bx	lr
 c008014:	50030400 	.word	0x50030400

0c008018 <OSPI_ConfigCmd>:
  * @param  hospi : OSPI handle
  * @param  cmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_ConfigCmd(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd)
{
 c008018:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t *ccr_reg, *tcr_reg, *ir_reg, *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 c00801c:	6804      	ldr	r4, [r0, #0]
 c00801e:	6823      	ldr	r3, [r4, #0]
 c008020:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 c008024:	6023      	str	r3, [r4, #0]

  /* Configure the flash ID */
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
 c008026:	6883      	ldr	r3, [r0, #8]
 c008028:	b92b      	cbnz	r3, c008036 <OSPI_ConfigCmd+0x1e>
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
 c00802a:	6823      	ldr	r3, [r4, #0]
 c00802c:	684a      	ldr	r2, [r1, #4]
 c00802e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c008032:	4313      	orrs	r3, r2
 c008034:	6023      	str	r3, [r4, #0]
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 c008036:	680b      	ldr	r3, [r1, #0]
 c008038:	2b02      	cmp	r3, #2
 c00803a:	d14e      	bne.n	c0080da <OSPI_ConfigCmd+0xc2>
  {
    ccr_reg = &(hospi->Instance->WCCR);
 c00803c:	f504 72c0 	add.w	r2, r4, #384	; 0x180
    tcr_reg = &(hospi->Instance->WTCR);
 c008040:	f504 76c4 	add.w	r6, r4, #392	; 0x188
    ir_reg  = &(hospi->Instance->WIR);
 c008044:	f504 75c8 	add.w	r5, r4, #400	; 0x190
    abr_reg = &(hospi->Instance->WABR);
 c008048:	f504 7cd0 	add.w	ip, r4, #416	; 0x1a0
    ir_reg  = &(hospi->Instance->IR);
    abr_reg = &(hospi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 c00804c:	e9d1 3712 	ldrd	r3, r7, [r1, #72]	; 0x48
 c008050:	433b      	orrs	r3, r7
 c008052:	6013      	str	r3, [r2, #0]

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 c008054:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 c008056:	b16b      	cbz	r3, c008074 <OSPI_ConfigCmd+0x5c>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = cmd->AlternateBytes;
 c008058:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 c00805a:	f8cc 3000 	str.w	r3, [ip]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ABMODE | OCTOSPI_CCR_ABDTR | OCTOSPI_CCR_ABSIZE),
 c00805e:	6b4f      	ldr	r7, [r1, #52]	; 0x34
 c008060:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 c008062:	f8d2 c000 	ldr.w	ip, [r2]
 c008066:	433b      	orrs	r3, r7
 c008068:	6b0f      	ldr	r7, [r1, #48]	; 0x30
 c00806a:	433b      	orrs	r3, r7
 c00806c:	f42c 177c 	bic.w	r7, ip, #4128768	; 0x3f0000
 c008070:	433b      	orrs	r3, r7
 c008072:	6013      	str	r3, [r2, #0]
                           (cmd->AlternateBytesMode | cmd->AlternateBytesDtrMode | cmd->AlternateBytesSize));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), OCTOSPI_TCR_DCYC, cmd->DummyCycles);
 c008074:	6833      	ldr	r3, [r6, #0]
 c008076:	6c4f      	ldr	r7, [r1, #68]	; 0x44
 c008078:	f023 031f 	bic.w	r3, r3, #31
 c00807c:	433b      	orrs	r3, r7
 c00807e:	6033      	str	r3, [r6, #0]

  if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 c008080:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 c008082:	b123      	cbz	r3, c00808e <OSPI_ConfigCmd+0x76>
  {
    if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 c008084:	680e      	ldr	r6, [r1, #0]
 c008086:	b916      	cbnz	r6, c00808e <OSPI_ConfigCmd+0x76>
    {
      /* Configure the DLR register with the number of data */
      hospi->Instance->DLR = (cmd->NbData - 1U);
 c008088:	6bce      	ldr	r6, [r1, #60]	; 0x3c
 c00808a:	3e01      	subs	r6, #1
 c00808c:	6426      	str	r6, [r4, #64]	; 0x40
    }
  }

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
 c00808e:	f8d1 a00c 	ldr.w	sl, [r1, #12]
 c008092:	f8d1 901c 	ldr.w	r9, [r1, #28]
 c008096:	f1ba 0f00 	cmp.w	sl, #0
 c00809a:	d076      	beq.n	c00818a <OSPI_ConfigCmd+0x172>
 c00809c:	e9d1 e804 	ldrd	lr, r8, [r1, #16]
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 c0080a0:	f1b9 0f00 	cmp.w	r9, #0
 c0080a4:	d047      	beq.n	c008136 <OSPI_ConfigCmd+0x11e>
 c0080a6:	e9d1 6c08 	ldrd	r6, ip, [r1, #32]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 c0080aa:	6817      	ldr	r7, [r2, #0]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 c0080ac:	b34b      	cbz	r3, c008102 <OSPI_ConfigCmd+0xea>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 c0080ae:	ea43 000a 	orr.w	r0, r3, sl
 c0080b2:	ea40 0309 	orr.w	r3, r0, r9
 c0080b6:	ea43 0308 	orr.w	r3, r3, r8
 c0080ba:	ea43 030e 	orr.w	r3, r3, lr
 c0080be:	6c08      	ldr	r0, [r1, #64]	; 0x40
 c0080c0:	ea43 030c 	orr.w	r3, r3, ip
 c0080c4:	4333      	orrs	r3, r6
 c0080c6:	4303      	orrs	r3, r0
 c0080c8:	483e      	ldr	r0, [pc, #248]	; (c0081c4 <OSPI_ConfigCmd+0x1ac>)
 c0080ca:	4038      	ands	r0, r7
 c0080cc:	4303      	orrs	r3, r0

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 c0080ce:	6013      	str	r3, [r2, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 c0080d0:	688b      	ldr	r3, [r1, #8]
 c0080d2:	602b      	str	r3, [r5, #0]
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
                               (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize));
      }

      /* Configure the AR register with the instruction value */
      hospi->Instance->AR = cmd->Address;
 c0080d4:	698b      	ldr	r3, [r1, #24]
 c0080d6:	64a3      	str	r3, [r4, #72]	; 0x48
 c0080d8:	e040      	b.n	c00815c <OSPI_ConfigCmd+0x144>
  else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG)
 c0080da:	2b03      	cmp	r3, #3
    ccr_reg = &(hospi->Instance->WPCCR);
 c0080dc:	bf01      	itttt	eq
 c0080de:	f504 72a0 	addeq.w	r2, r4, #320	; 0x140
    tcr_reg = &(hospi->Instance->WPTCR);
 c0080e2:	f504 76a4 	addeq.w	r6, r4, #328	; 0x148
    ir_reg  = &(hospi->Instance->WPIR);
 c0080e6:	f504 75a8 	addeq.w	r5, r4, #336	; 0x150
    abr_reg = &(hospi->Instance->WPABR);
 c0080ea:	f504 7cb0 	addeq.w	ip, r4, #352	; 0x160
    ccr_reg = &(hospi->Instance->CCR);
 c0080ee:	bf1f      	itttt	ne
 c0080f0:	f504 7280 	addne.w	r2, r4, #256	; 0x100
    tcr_reg = &(hospi->Instance->TCR);
 c0080f4:	f504 7684 	addne.w	r6, r4, #264	; 0x108
    ir_reg  = &(hospi->Instance->IR);
 c0080f8:	f504 7588 	addne.w	r5, r4, #272	; 0x110
    abr_reg = &(hospi->Instance->ABR);
 c0080fc:	f504 7c90 	addne.w	ip, r4, #288	; 0x120
 c008100:	e7a4      	b.n	c00804c <OSPI_ConfigCmd+0x34>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 c008102:	ea4a 0309 	orr.w	r3, sl, r9
 c008106:	ea43 0308 	orr.w	r3, r3, r8
 c00810a:	ea43 030e 	orr.w	r3, r3, lr
 c00810e:	ea43 030c 	orr.w	r3, r3, ip
 c008112:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
 c008116:	4333      	orrs	r3, r6
 c008118:	f027 073f 	bic.w	r7, r7, #63	; 0x3f
 c00811c:	433b      	orrs	r3, r7
 c00811e:	6013      	str	r3, [r2, #0]
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 c008120:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 c008122:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 c008126:	d1d3      	bne.n	c0080d0 <OSPI_ConfigCmd+0xb8>
 c008128:	694b      	ldr	r3, [r1, #20]
 c00812a:	2b08      	cmp	r3, #8
 c00812c:	d1d0      	bne.n	c0080d0 <OSPI_ConfigCmd+0xb8>
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 c00812e:	6813      	ldr	r3, [r2, #0]
 c008130:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 c008134:	e7cb      	b.n	c0080ce <OSPI_ConfigCmd+0xb6>
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 c008136:	b1a3      	cbz	r3, c008162 <OSPI_ConfigCmd+0x14a>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE |
 c008138:	6810      	ldr	r0, [r2, #0]
 c00813a:	ea43 030a 	orr.w	r3, r3, sl
 c00813e:	ea43 0308 	orr.w	r3, r3, r8
 c008142:	6c0c      	ldr	r4, [r1, #64]	; 0x40
 c008144:	ea43 030e 	orr.w	r3, r3, lr
 c008148:	f020 6e70 	bic.w	lr, r0, #251658240	; 0xf000000
 c00814c:	4323      	orrs	r3, r4
 c00814e:	f02e 0e3f 	bic.w	lr, lr, #63	; 0x3f
 c008152:	ea43 030e 	orr.w	r3, r3, lr
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 c008156:	6013      	str	r3, [r2, #0]
      *ir_reg = cmd->Instruction;
 c008158:	688b      	ldr	r3, [r1, #8]
 c00815a:	602b      	str	r3, [r5, #0]
  HAL_StatusTypeDef status = HAL_OK;
 c00815c:	2000      	movs	r0, #0
    }
  }

  /* Return function status */
  return status;
}
 c00815e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE),
 c008162:	6814      	ldr	r4, [r2, #0]
 c008164:	ea4a 0308 	orr.w	r3, sl, r8
 c008168:	ea43 030e 	orr.w	r3, r3, lr
 c00816c:	f024 043f 	bic.w	r4, r4, #63	; 0x3f
 c008170:	4323      	orrs	r3, r4
 c008172:	6013      	str	r3, [r2, #0]
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 c008174:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 c008176:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 c00817a:	d1ed      	bne.n	c008158 <OSPI_ConfigCmd+0x140>
 c00817c:	694b      	ldr	r3, [r1, #20]
 c00817e:	2b08      	cmp	r3, #8
 c008180:	d1ea      	bne.n	c008158 <OSPI_ConfigCmd+0x140>
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 c008182:	6813      	ldr	r3, [r2, #0]
 c008184:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 c008188:	e7e5      	b.n	c008156 <OSPI_ConfigCmd+0x13e>
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 c00818a:	f1b9 0f00 	cmp.w	r9, #0
 c00818e:	d014      	beq.n	c0081ba <OSPI_ConfigCmd+0x1a2>
 c008190:	e9d1 5608 	ldrd	r5, r6, [r1, #32]
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 c008194:	6810      	ldr	r0, [r2, #0]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 c008196:	b163      	cbz	r3, c0081b2 <OSPI_ConfigCmd+0x19a>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 c008198:	ea43 0309 	orr.w	r3, r3, r9
 c00819c:	4333      	orrs	r3, r6
 c00819e:	432b      	orrs	r3, r5
 c0081a0:	6c0d      	ldr	r5, [r1, #64]	; 0x40
 c0081a2:	f020 6070 	bic.w	r0, r0, #251658240	; 0xf000000
 c0081a6:	432b      	orrs	r3, r5
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
 c0081a8:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
 c0081ac:	4303      	orrs	r3, r0
 c0081ae:	6013      	str	r3, [r2, #0]
 c0081b0:	e790      	b.n	c0080d4 <OSPI_ConfigCmd+0xbc>
 c0081b2:	ea49 0306 	orr.w	r3, r9, r6
 c0081b6:	432b      	orrs	r3, r5
 c0081b8:	e7f6      	b.n	c0081a8 <OSPI_ConfigCmd+0x190>
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 c0081ba:	2308      	movs	r3, #8
 c0081bc:	6503      	str	r3, [r0, #80]	; 0x50
      status = HAL_ERROR;
 c0081be:	2001      	movs	r0, #1
 c0081c0:	e7cd      	b.n	c00815e <OSPI_ConfigCmd+0x146>
 c0081c2:	bf00      	nop
 c0081c4:	f0ffc0c0 	.word	0xf0ffc0c0

0c0081c8 <OSPI_WaitFlagStateUntilTimeout>:
{
 c0081c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c0081cc:	4604      	mov	r4, r0
 c0081ce:	460f      	mov	r7, r1
 c0081d0:	4616      	mov	r6, r2
 c0081d2:	4698      	mov	r8, r3
 c0081d4:	9d06      	ldr	r5, [sp, #24]
  while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 c0081d6:	6821      	ldr	r1, [r4, #0]
 c0081d8:	6a0a      	ldr	r2, [r1, #32]
 c0081da:	423a      	tst	r2, r7
 c0081dc:	bf14      	ite	ne
 c0081de:	2201      	movne	r2, #1
 c0081e0:	2200      	moveq	r2, #0
 c0081e2:	42b2      	cmp	r2, r6
 c0081e4:	d101      	bne.n	c0081ea <OSPI_WaitFlagStateUntilTimeout+0x22>
  return HAL_OK;
 c0081e6:	2000      	movs	r0, #0
 c0081e8:	e011      	b.n	c00820e <OSPI_WaitFlagStateUntilTimeout+0x46>
    if (Timeout != HAL_MAX_DELAY)
 c0081ea:	1c6b      	adds	r3, r5, #1
 c0081ec:	d0f4      	beq.n	c0081d8 <OSPI_WaitFlagStateUntilTimeout+0x10>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c0081ee:	f7fb f959 	bl	c0034a4 <HAL_GetTick>
 c0081f2:	eba0 0008 	sub.w	r0, r0, r8
 c0081f6:	42a8      	cmp	r0, r5
 c0081f8:	d801      	bhi.n	c0081fe <OSPI_WaitFlagStateUntilTimeout+0x36>
 c0081fa:	2d00      	cmp	r5, #0
 c0081fc:	d1eb      	bne.n	c0081d6 <OSPI_WaitFlagStateUntilTimeout+0xe>
        hospi->State     = HAL_OSPI_STATE_ERROR;
 c0081fe:	f44f 7300 	mov.w	r3, #512	; 0x200
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 c008202:	2001      	movs	r0, #1
        hospi->State     = HAL_OSPI_STATE_ERROR;
 c008204:	64e3      	str	r3, [r4, #76]	; 0x4c
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 c008206:	6d23      	ldr	r3, [r4, #80]	; 0x50
 c008208:	f043 0301 	orr.w	r3, r3, #1
 c00820c:	6523      	str	r3, [r4, #80]	; 0x50
}
 c00820e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c008212 <HAL_OSPI_MspInit>:
}
 c008212:	4770      	bx	lr

0c008214 <HAL_OSPI_Init>:
{
 c008214:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c008216:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 c008218:	f7fb f944 	bl	c0034a4 <HAL_GetTick>
 c00821c:	4606      	mov	r6, r0
  if (hospi == NULL)
 c00821e:	2c00      	cmp	r4, #0
 c008220:	d064      	beq.n	c0082ec <HAL_OSPI_Init+0xd8>
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 c008222:	2000      	movs	r0, #0
 c008224:	6520      	str	r0, [r4, #80]	; 0x50
    if (hospi->State == HAL_OSPI_STATE_RESET)
 c008226:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 c008228:	2d00      	cmp	r5, #0
 c00822a:	d15d      	bne.n	c0082e8 <HAL_OSPI_Init+0xd4>
      HAL_OSPI_MspInit(hospi);
 c00822c:	4620      	mov	r0, r4
 c00822e:	f7ff fff0 	bl	c008212 <HAL_OSPI_MspInit>
  hospi->Timeout = Timeout;
 c008232:	f241 3388 	movw	r3, #5000	; 0x1388
      MODIFY_REG(hospi->Instance->DCR1,
 c008236:	6b62      	ldr	r2, [r4, #52]	; 0x34
 c008238:	68e1      	ldr	r1, [r4, #12]
 c00823a:	6820      	ldr	r0, [r4, #0]
 c00823c:	4311      	orrs	r1, r2
 c00823e:	69e2      	ldr	r2, [r4, #28]
 c008240:	6887      	ldr	r7, [r0, #8]
 c008242:	4311      	orrs	r1, r2
 c008244:	4a2a      	ldr	r2, [pc, #168]	; (c0082f0 <HAL_OSPI_Init+0xdc>)
  hospi->Timeout = Timeout;
 c008246:	6563      	str	r3, [r4, #84]	; 0x54
      MODIFY_REG(hospi->Instance->DCR1,
 c008248:	403a      	ands	r2, r7
 c00824a:	4311      	orrs	r1, r2
 c00824c:	6922      	ldr	r2, [r4, #16]
 c00824e:	3a01      	subs	r2, #1
 c008250:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 c008254:	6962      	ldr	r2, [r4, #20]
 c008256:	3a01      	subs	r2, #1
 c008258:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 c00825c:	6081      	str	r1, [r0, #8]
      MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_WRAPSIZE, hospi->Init.WrapSize);
 c00825e:	68c2      	ldr	r2, [r0, #12]
 c008260:	6a21      	ldr	r1, [r4, #32]
 c008262:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 c008266:	430a      	orrs	r2, r1
 c008268:	60c2      	str	r2, [r0, #12]
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 c00826a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 c00826c:	0412      	lsls	r2, r2, #16
 c00826e:	6102      	str	r2, [r0, #16]
      hospi->Instance->DCR4 = hospi->Init.Refresh;
 c008270:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 c008272:	6142      	str	r2, [r0, #20]
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 c008274:	6801      	ldr	r1, [r0, #0]
 c008276:	6862      	ldr	r2, [r4, #4]
 c008278:	f421 51f8 	bic.w	r1, r1, #7936	; 0x1f00
 c00827c:	3a01      	subs	r2, #1
 c00827e:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 c008282:	6001      	str	r1, [r0, #0]
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 c008284:	462a      	mov	r2, r5
 c008286:	9300      	str	r3, [sp, #0]
 c008288:	2120      	movs	r1, #32
 c00828a:	4633      	mov	r3, r6
 c00828c:	4620      	mov	r0, r4
 c00828e:	f7ff ff9b 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 c008292:	bb48      	cbnz	r0, c0082e8 <HAL_OSPI_Init+0xd4>
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 c008294:	6823      	ldr	r3, [r4, #0]
 c008296:	6a62      	ldr	r2, [r4, #36]	; 0x24
 c008298:	68d9      	ldr	r1, [r3, #12]
 c00829a:	3a01      	subs	r2, #1
 c00829c:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 c0082a0:	430a      	orrs	r2, r1
 c0082a2:	60da      	str	r2, [r3, #12]
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
 c0082a4:	681a      	ldr	r2, [r3, #0]
 c0082a6:	68a1      	ldr	r1, [r4, #8]
 c0082a8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 c0082ac:	430a      	orrs	r2, r1
 c0082ae:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 c0082b0:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 c0082b4:	e9d4 250a 	ldrd	r2, r5, [r4, #40]	; 0x28
 c0082b8:	f021 41a0 	bic.w	r1, r1, #1342177280	; 0x50000000
 c0082bc:	432a      	orrs	r2, r5
 c0082be:	430a      	orrs	r2, r1
 c0082c0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        __HAL_OSPI_ENABLE(hospi);
 c0082c4:	681a      	ldr	r2, [r3, #0]
 c0082c6:	f042 0201 	orr.w	r2, r2, #1
 c0082ca:	601a      	str	r2, [r3, #0]
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 c0082cc:	69a2      	ldr	r2, [r4, #24]
 c0082ce:	2a02      	cmp	r2, #2
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 c0082d0:	bf02      	ittt	eq
 c0082d2:	689a      	ldreq	r2, [r3, #8]
 c0082d4:	f042 0202 	orreq.w	r2, r2, #2
 c0082d8:	609a      	streq	r2, [r3, #8]
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 c0082da:	68e3      	ldr	r3, [r4, #12]
 c0082dc:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 c0082e0:	bf0c      	ite	eq
 c0082e2:	2301      	moveq	r3, #1
          hospi->State = HAL_OSPI_STATE_READY;
 c0082e4:	2302      	movne	r3, #2
 c0082e6:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 c0082e8:	b003      	add	sp, #12
 c0082ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_ERROR;
 c0082ec:	2001      	movs	r0, #1
 c0082ee:	e7fb      	b.n	c0082e8 <HAL_OSPI_Init+0xd4>
 c0082f0:	f8e0f8f4 	.word	0xf8e0f8f4

0c0082f4 <HAL_OSPI_MspDeInit>:
 c0082f4:	4770      	bx	lr

0c0082f6 <HAL_OSPI_DeInit>:
{
 c0082f6:	b510      	push	{r4, lr}
  if (hospi == NULL)
 c0082f8:	4604      	mov	r4, r0
 c0082fa:	b168      	cbz	r0, c008318 <HAL_OSPI_DeInit+0x22>
     __HAL_OSPI_DISABLE(hospi);
 c0082fc:	6803      	ldr	r3, [r0, #0]
 c0082fe:	681a      	ldr	r2, [r3, #0]
 c008300:	f022 0201 	bic.w	r2, r2, #1
 c008304:	601a      	str	r2, [r3, #0]
     CLEAR_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 c008306:	689a      	ldr	r2, [r3, #8]
 c008308:	f022 0202 	bic.w	r2, r2, #2
 c00830c:	609a      	str	r2, [r3, #8]
     HAL_OSPI_MspDeInit(hospi);
 c00830e:	f7ff fff1 	bl	c0082f4 <HAL_OSPI_MspDeInit>
     hospi->State = HAL_OSPI_STATE_RESET;
 c008312:	2000      	movs	r0, #0
 c008314:	64e0      	str	r0, [r4, #76]	; 0x4c
}
 c008316:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 c008318:	2001      	movs	r0, #1
 c00831a:	e7fc      	b.n	c008316 <HAL_OSPI_DeInit+0x20>

0c00831c <HAL_OSPI_Command>:
{
 c00831c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c00831e:	4604      	mov	r4, r0
 c008320:	460d      	mov	r5, r1
 c008322:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 c008324:	f7fb f8be 	bl	c0034a4 <HAL_GetTick>
  state = hospi->State;
 c008328:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  uint32_t tickstart = HAL_GetTick();
 c00832a:	4606      	mov	r6, r0
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 c00832c:	2b02      	cmp	r3, #2
 c00832e:	d107      	bne.n	c008340 <HAL_OSPI_Command+0x24>
 c008330:	68e3      	ldr	r3, [r4, #12]
 c008332:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 c008336:	d109      	bne.n	c00834c <HAL_OSPI_Command+0x30>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c008338:	2310      	movs	r3, #16
    status = HAL_ERROR;
 c00833a:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c00833c:	6523      	str	r3, [r4, #80]	; 0x50
 c00833e:	e01f      	b.n	c008380 <HAL_OSPI_Command+0x64>
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 c008340:	2b14      	cmp	r3, #20
 c008342:	d11f      	bne.n	c008384 <HAL_OSPI_Command+0x68>
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && ((cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG) || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))) ||
 c008344:	682b      	ldr	r3, [r5, #0]
 c008346:	3b02      	subs	r3, #2
 c008348:	2b01      	cmp	r3, #1
 c00834a:	d8f5      	bhi.n	c008338 <HAL_OSPI_Command+0x1c>
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 c00834c:	9700      	str	r7, [sp, #0]
 c00834e:	4633      	mov	r3, r6
 c008350:	2200      	movs	r2, #0
 c008352:	2120      	movs	r1, #32
 c008354:	4620      	mov	r0, r4
 c008356:	f7ff ff37 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 c00835a:	b988      	cbnz	r0, c008380 <HAL_OSPI_Command+0x64>
      hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 c00835c:	6520      	str	r0, [r4, #80]	; 0x50
      status = OSPI_ConfigCmd(hospi, cmd);
 c00835e:	4629      	mov	r1, r5
 c008360:	4620      	mov	r0, r4
 c008362:	f7ff fe59 	bl	c008018 <OSPI_ConfigCmd>
      if (status == HAL_OK)
 c008366:	b958      	cbnz	r0, c008380 <HAL_OSPI_Command+0x64>
        if (cmd->DataMode == HAL_OSPI_DATA_NONE)
 c008368:	6bab      	ldr	r3, [r5, #56]	; 0x38
 c00836a:	b99b      	cbnz	r3, c008394 <HAL_OSPI_Command+0x78>
          status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 c00836c:	4633      	mov	r3, r6
 c00836e:	2201      	movs	r2, #1
 c008370:	9700      	str	r7, [sp, #0]
 c008372:	2102      	movs	r1, #2
 c008374:	4620      	mov	r0, r4
 c008376:	f7ff ff27 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 c00837a:	2202      	movs	r2, #2
 c00837c:	6823      	ldr	r3, [r4, #0]
 c00837e:	625a      	str	r2, [r3, #36]	; 0x24
}
 c008380:	b003      	add	sp, #12
 c008382:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && ((cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG) || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))) ||
 c008384:	2b24      	cmp	r3, #36	; 0x24
 c008386:	d1d7      	bne.n	c008338 <HAL_OSPI_Command+0x1c>
      ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && ((cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)  || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))))
 c008388:	682b      	ldr	r3, [r5, #0]
 c00838a:	f023 0302 	bic.w	r3, r3, #2
 c00838e:	2b01      	cmp	r3, #1
 c008390:	d1d2      	bne.n	c008338 <HAL_OSPI_Command+0x1c>
 c008392:	e7db      	b.n	c00834c <HAL_OSPI_Command+0x30>
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 c008394:	682b      	ldr	r3, [r5, #0]
 c008396:	b90b      	cbnz	r3, c00839c <HAL_OSPI_Command+0x80>
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 c008398:	2304      	movs	r3, #4
 c00839a:	e005      	b.n	c0083a8 <HAL_OSPI_Command+0x8c>
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 c00839c:	2b01      	cmp	r3, #1
 c00839e:	d105      	bne.n	c0083ac <HAL_OSPI_Command+0x90>
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 c0083a0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c0083a2:	2b24      	cmp	r3, #36	; 0x24
 c0083a4:	d0f8      	beq.n	c008398 <HAL_OSPI_Command+0x7c>
              hospi->State = HAL_OSPI_STATE_READ_CMD_CFG;
 c0083a6:	2314      	movs	r3, #20
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 c0083a8:	64e3      	str	r3, [r4, #76]	; 0x4c
 c0083aa:	e7e9      	b.n	c008380 <HAL_OSPI_Command+0x64>
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 c0083ac:	2b02      	cmp	r3, #2
 c0083ae:	d1e7      	bne.n	c008380 <HAL_OSPI_Command+0x64>
            if (hospi->State == HAL_OSPI_STATE_READ_CMD_CFG)
 c0083b0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c0083b2:	2b14      	cmp	r3, #20
 c0083b4:	d0f0      	beq.n	c008398 <HAL_OSPI_Command+0x7c>
              hospi->State = HAL_OSPI_STATE_WRITE_CMD_CFG;
 c0083b6:	2324      	movs	r3, #36	; 0x24
 c0083b8:	e7f6      	b.n	c0083a8 <HAL_OSPI_Command+0x8c>

0c0083ba <HAL_OSPI_Transmit>:
{
 c0083ba:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c0083be:	4604      	mov	r4, r0
 c0083c0:	4688      	mov	r8, r1
 c0083c2:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 c0083c4:	f7fb f86e 	bl	c0034a4 <HAL_GetTick>
 c0083c8:	4606      	mov	r6, r0
  if (pData == NULL)
 c0083ca:	f1b8 0f00 	cmp.w	r8, #0
 c0083ce:	d103      	bne.n	c0083d8 <HAL_OSPI_Transmit+0x1e>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 c0083d0:	2308      	movs	r3, #8
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c0083d2:	6523      	str	r3, [r4, #80]	; 0x50
      status = HAL_ERROR;
 c0083d4:	2001      	movs	r0, #1
 c0083d6:	e02f      	b.n	c008438 <HAL_OSPI_Transmit+0x7e>
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 c0083d8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c0083da:	2b04      	cmp	r3, #4
 c0083dc:	d12f      	bne.n	c00843e <HAL_OSPI_Transmit+0x84>
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 c0083de:	6825      	ldr	r5, [r4, #0]
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 c0083e0:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      hospi->pBuffPtr  = pData;
 c0083e2:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 c0083e6:	3301      	adds	r3, #1
 c0083e8:	6463      	str	r3, [r4, #68]	; 0x44
      hospi->XferSize  = hospi->XferCount;
 c0083ea:	6c63      	ldr	r3, [r4, #68]	; 0x44
 c0083ec:	6423      	str	r3, [r4, #64]	; 0x40
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 c0083ee:	682b      	ldr	r3, [r5, #0]
 c0083f0:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 c0083f4:	602b      	str	r3, [r5, #0]
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_FT, SET, tickstart, Timeout);
 c0083f6:	9700      	str	r7, [sp, #0]
 c0083f8:	4633      	mov	r3, r6
 c0083fa:	2201      	movs	r2, #1
 c0083fc:	2104      	movs	r1, #4
 c0083fe:	4620      	mov	r0, r4
 c008400:	f7ff fee2 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
 c008404:	b9c0      	cbnz	r0, c008438 <HAL_OSPI_Transmit+0x7e>
        *((__IO uint8_t *)data_reg) = *hospi->pBuffPtr;
 c008406:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 c008408:	781b      	ldrb	r3, [r3, #0]
 c00840a:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
        hospi->pBuffPtr++;
 c00840e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 c008410:	3301      	adds	r3, #1
 c008412:	63e3      	str	r3, [r4, #60]	; 0x3c
        hospi->XferCount--;
 c008414:	6c63      	ldr	r3, [r4, #68]	; 0x44
 c008416:	3b01      	subs	r3, #1
 c008418:	6463      	str	r3, [r4, #68]	; 0x44
      } while (hospi->XferCount > 0U);
 c00841a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 c00841c:	2b00      	cmp	r3, #0
 c00841e:	d1ea      	bne.n	c0083f6 <HAL_OSPI_Transmit+0x3c>
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 c008420:	9700      	str	r7, [sp, #0]
 c008422:	4633      	mov	r3, r6
 c008424:	2201      	movs	r2, #1
 c008426:	2102      	movs	r1, #2
 c008428:	4620      	mov	r0, r4
 c00842a:	f7ff fecd 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 c00842e:	b918      	cbnz	r0, c008438 <HAL_OSPI_Transmit+0x7e>
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 c008430:	2302      	movs	r3, #2
 c008432:	6822      	ldr	r2, [r4, #0]
 c008434:	6253      	str	r3, [r2, #36]	; 0x24
          hospi->State = HAL_OSPI_STATE_READY;
 c008436:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 c008438:	b002      	add	sp, #8
 c00843a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c00843e:	2310      	movs	r3, #16
 c008440:	e7c7      	b.n	c0083d2 <HAL_OSPI_Transmit+0x18>

0c008442 <HAL_OSPI_Receive>:
{
 c008442:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c008446:	4604      	mov	r4, r0
 c008448:	4688      	mov	r8, r1
 c00844a:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 c00844c:	f7fb f82a 	bl	c0034a4 <HAL_GetTick>
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 c008450:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
 c008452:	4606      	mov	r6, r0
  uint32_t addr_reg = hospi->Instance->AR;
 c008454:	6caa      	ldr	r2, [r5, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 c008456:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110
  if (pData == NULL)
 c00845a:	f1b8 0f00 	cmp.w	r8, #0
 c00845e:	d103      	bne.n	c008468 <HAL_OSPI_Receive+0x26>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 c008460:	2308      	movs	r3, #8
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c008462:	6523      	str	r3, [r4, #80]	; 0x50
      status = HAL_ERROR;
 c008464:	2001      	movs	r0, #1
 c008466:	e035      	b.n	c0084d4 <HAL_OSPI_Receive+0x92>
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 c008468:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c00846a:	2b04      	cmp	r3, #4
 c00846c:	d13d      	bne.n	c0084ea <HAL_OSPI_Receive+0xa8>
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 c00846e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      hospi->pBuffPtr  = pData;
 c008470:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 c008474:	3301      	adds	r3, #1
 c008476:	6463      	str	r3, [r4, #68]	; 0x44
      hospi->XferSize  = hospi->XferCount;
 c008478:	6c63      	ldr	r3, [r4, #68]	; 0x44
 c00847a:	6423      	str	r3, [r4, #64]	; 0x40
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 c00847c:	682b      	ldr	r3, [r5, #0]
 c00847e:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 c008482:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c008486:	602b      	str	r3, [r5, #0]
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 c008488:	68e3      	ldr	r3, [r4, #12]
 c00848a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 c00848e:	d124      	bne.n	c0084da <HAL_OSPI_Receive+0x98>
          WRITE_REG(hospi->Instance->AR, addr_reg);
 c008490:	64aa      	str	r2, [r5, #72]	; 0x48
        status = OSPI_WaitFlagStateUntilTimeout(hospi, (HAL_OSPI_FLAG_FT | HAL_OSPI_FLAG_TC), SET, tickstart, Timeout);
 c008492:	9700      	str	r7, [sp, #0]
 c008494:	4633      	mov	r3, r6
 c008496:	2201      	movs	r2, #1
 c008498:	2106      	movs	r1, #6
 c00849a:	4620      	mov	r0, r4
 c00849c:	f7ff fe94 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
 c0084a0:	b9c0      	cbnz	r0, c0084d4 <HAL_OSPI_Receive+0x92>
        *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 c0084a2:	f895 2050 	ldrb.w	r2, [r5, #80]	; 0x50
 c0084a6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 c0084a8:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 c0084aa:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 c0084ac:	3301      	adds	r3, #1
 c0084ae:	63e3      	str	r3, [r4, #60]	; 0x3c
        hospi->XferCount--;
 c0084b0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 c0084b2:	3b01      	subs	r3, #1
 c0084b4:	6463      	str	r3, [r4, #68]	; 0x44
      } while(hospi->XferCount > 0U);
 c0084b6:	6c63      	ldr	r3, [r4, #68]	; 0x44
 c0084b8:	2b00      	cmp	r3, #0
 c0084ba:	d1ea      	bne.n	c008492 <HAL_OSPI_Receive+0x50>
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 c0084bc:	9700      	str	r7, [sp, #0]
 c0084be:	4633      	mov	r3, r6
 c0084c0:	2201      	movs	r2, #1
 c0084c2:	2102      	movs	r1, #2
 c0084c4:	4620      	mov	r0, r4
 c0084c6:	f7ff fe7f 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 c0084ca:	b918      	cbnz	r0, c0084d4 <HAL_OSPI_Receive+0x92>
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 c0084cc:	2302      	movs	r3, #2
 c0084ce:	6822      	ldr	r2, [r4, #0]
 c0084d0:	6253      	str	r3, [r2, #36]	; 0x24
          hospi->State = HAL_OSPI_STATE_READY;
 c0084d2:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 c0084d4:	b002      	add	sp, #8
 c0084d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 c0084da:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 c0084de:	f413 6fe0 	tst.w	r3, #1792	; 0x700
 c0084e2:	d1d5      	bne.n	c008490 <HAL_OSPI_Receive+0x4e>
          WRITE_REG(hospi->Instance->IR, ir_reg);
 c0084e4:	f8c5 1110 	str.w	r1, [r5, #272]	; 0x110
 c0084e8:	e7d3      	b.n	c008492 <HAL_OSPI_Receive+0x50>
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c0084ea:	2310      	movs	r3, #16
 c0084ec:	e7b9      	b.n	c008462 <HAL_OSPI_Receive+0x20>

0c0084ee <HAL_OSPI_AutoPolling>:
{
 c0084ee:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c0084f2:	4604      	mov	r4, r0
 c0084f4:	460d      	mov	r5, r1
 c0084f6:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 c0084f8:	f7fa ffd4 	bl	c0034a4 <HAL_GetTick>
  uint32_t addr_reg = hospi->Instance->AR;
 c0084fc:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
 c0084fe:	4606      	mov	r6, r0
  uint32_t addr_reg = hospi->Instance->AR;
 c008500:	f8d3 8048 	ldr.w	r8, [r3, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 c008504:	f8d3 9110 	ldr.w	r9, [r3, #272]	; 0x110
  if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
 c008508:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 c00850a:	2b04      	cmp	r3, #4
 c00850c:	d13d      	bne.n	c00858a <HAL_OSPI_AutoPolling+0x9c>
 c00850e:	68eb      	ldr	r3, [r5, #12]
 c008510:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 c008514:	d139      	bne.n	c00858a <HAL_OSPI_AutoPolling+0x9c>
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 c008516:	4603      	mov	r3, r0
 c008518:	9700      	str	r7, [sp, #0]
 c00851a:	2200      	movs	r2, #0
 c00851c:	2120      	movs	r1, #32
 c00851e:	4620      	mov	r0, r4
 c008520:	f7ff fe52 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 c008524:	bb30      	cbnz	r0, c008574 <HAL_OSPI_AutoPolling+0x86>
      WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
 c008526:	6823      	ldr	r3, [r4, #0]
 c008528:	682a      	ldr	r2, [r5, #0]
 c00852a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
 c00852e:	686a      	ldr	r2, [r5, #4]
 c008530:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
 c008534:	692a      	ldr	r2, [r5, #16]
 c008536:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
 c00853a:	6819      	ldr	r1, [r3, #0]
 c00853c:	e9d5 2002 	ldrd	r2, r0, [r5, #8]
 c008540:	4302      	orrs	r2, r0
 c008542:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 c008546:	f021 5143 	bic.w	r1, r1, #817889280	; 0x30c00000
 c00854a:	430a      	orrs	r2, r1
 c00854c:	601a      	str	r2, [r3, #0]
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 c00854e:	68e2      	ldr	r2, [r4, #12]
 c008550:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 c008554:	d111      	bne.n	c00857a <HAL_OSPI_AutoPolling+0x8c>
          WRITE_REG(hospi->Instance->AR, addr_reg);
 c008556:	f8c3 8048 	str.w	r8, [r3, #72]	; 0x48
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_SM, SET, tickstart, Timeout);
 c00855a:	9700      	str	r7, [sp, #0]
 c00855c:	4633      	mov	r3, r6
 c00855e:	2201      	movs	r2, #1
 c008560:	2108      	movs	r1, #8
 c008562:	4620      	mov	r0, r4
 c008564:	f7ff fe30 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 c008568:	b920      	cbnz	r0, c008574 <HAL_OSPI_AutoPolling+0x86>
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_SM);
 c00856a:	2208      	movs	r2, #8
 c00856c:	6823      	ldr	r3, [r4, #0]
 c00856e:	625a      	str	r2, [r3, #36]	; 0x24
        hospi->State = HAL_OSPI_STATE_READY;
 c008570:	2302      	movs	r3, #2
 c008572:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 c008574:	b003      	add	sp, #12
 c008576:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 c00857a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 c00857e:	f412 6fe0 	tst.w	r2, #1792	; 0x700
 c008582:	d1e8      	bne.n	c008556 <HAL_OSPI_AutoPolling+0x68>
          WRITE_REG(hospi->Instance->IR, ir_reg);
 c008584:	f8c3 9110 	str.w	r9, [r3, #272]	; 0x110
 c008588:	e7e7      	b.n	c00855a <HAL_OSPI_AutoPolling+0x6c>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c00858a:	2310      	movs	r3, #16
    status = HAL_ERROR;
 c00858c:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c00858e:	6523      	str	r3, [r4, #80]	; 0x50
 c008590:	e7f0      	b.n	c008574 <HAL_OSPI_AutoPolling+0x86>

0c008592 <HAL_OSPI_MemoryMapped>:
{
 c008592:	b537      	push	{r0, r1, r2, r4, r5, lr}
 c008594:	4604      	mov	r4, r0
 c008596:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
 c008598:	f7fa ff84 	bl	c0034a4 <HAL_GetTick>
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 c00859c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
  uint32_t tickstart = HAL_GetTick();
 c00859e:	4603      	mov	r3, r0
  if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 c0085a0:	2a04      	cmp	r2, #4
 c0085a2:	d121      	bne.n	c0085e8 <HAL_OSPI_MemoryMapped+0x56>
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 c0085a4:	6d62      	ldr	r2, [r4, #84]	; 0x54
 c0085a6:	2120      	movs	r1, #32
 c0085a8:	9200      	str	r2, [sp, #0]
 c0085aa:	4620      	mov	r0, r4
 c0085ac:	2200      	movs	r2, #0
 c0085ae:	f7ff fe0b 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 c0085b2:	b9b8      	cbnz	r0, c0085e4 <HAL_OSPI_MemoryMapped+0x52>
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
 c0085b4:	2388      	movs	r3, #136	; 0x88
      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 c0085b6:	6829      	ldr	r1, [r5, #0]
      hospi->State = HAL_OSPI_STATE_BUSY_MEM_MAPPED;
 c0085b8:	64e3      	str	r3, [r4, #76]	; 0x4c
      if (cfg->TimeOutActivation == HAL_OSPI_TIMEOUT_COUNTER_ENABLE)
 c0085ba:	2908      	cmp	r1, #8
 c0085bc:	6822      	ldr	r2, [r4, #0]
 c0085be:	d108      	bne.n	c0085d2 <HAL_OSPI_MemoryMapped+0x40>
        WRITE_REG(hospi->Instance->LPTR, cfg->TimeOutPeriod);
 c0085c0:	686b      	ldr	r3, [r5, #4]
 c0085c2:	f8c2 3130 	str.w	r3, [r2, #304]	; 0x130
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TO);
 c0085c6:	2310      	movs	r3, #16
 c0085c8:	6253      	str	r3, [r2, #36]	; 0x24
        __HAL_OSPI_ENABLE_IT(hospi, HAL_OSPI_IT_TO);
 c0085ca:	6813      	ldr	r3, [r2, #0]
 c0085cc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c0085d0:	6013      	str	r3, [r2, #0]
      MODIFY_REG(hospi->Instance->CR, (OCTOSPI_CR_TCEN | OCTOSPI_CR_FMODE),
 c0085d2:	6813      	ldr	r3, [r2, #0]
 c0085d4:	f041 5140 	orr.w	r1, r1, #805306368	; 0x30000000
 c0085d8:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 c0085dc:	f023 0308 	bic.w	r3, r3, #8
 c0085e0:	430b      	orrs	r3, r1
 c0085e2:	6013      	str	r3, [r2, #0]
}
 c0085e4:	b003      	add	sp, #12
 c0085e6:	bd30      	pop	{r4, r5, pc}
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c0085e8:	2310      	movs	r3, #16
    status = HAL_ERROR;
 c0085ea:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c0085ec:	6523      	str	r3, [r4, #80]	; 0x50
 c0085ee:	e7f9      	b.n	c0085e4 <HAL_OSPI_MemoryMapped+0x52>

0c0085f0 <HAL_OSPI_Abort>:
{
 c0085f0:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c0085f2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 c0085f4:	f7fa ff56 	bl	c0034a4 <HAL_GetTick>
  state = hospi->State;
 c0085f8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  uint32_t tickstart = HAL_GetTick();
 c0085fa:	4605      	mov	r5, r0
  if (((state & OSPI_BUSY_STATE_MASK) != 0U) || ((state & OSPI_CFG_STATE_MASK) != 0U))
 c0085fc:	f013 0f0c 	tst.w	r3, #12
 c008600:	d031      	beq.n	c008666 <HAL_OSPI_Abort+0x76>
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 c008602:	6823      	ldr	r3, [r4, #0]
 c008604:	6818      	ldr	r0, [r3, #0]
 c008606:	f010 0004 	ands.w	r0, r0, #4
 c00860a:	d009      	beq.n	c008620 <HAL_OSPI_Abort+0x30>
      CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
 c00860c:	681a      	ldr	r2, [r3, #0]
      status = HAL_DMA_Abort(hospi->hdma);
 c00860e:	6ca0      	ldr	r0, [r4, #72]	; 0x48
      CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
 c008610:	f022 0204 	bic.w	r2, r2, #4
 c008614:	601a      	str	r2, [r3, #0]
      status = HAL_DMA_Abort(hospi->hdma);
 c008616:	f7fe fcf9 	bl	c00700c <HAL_DMA_Abort>
      if (status != HAL_OK)
 c00861a:	b108      	cbz	r0, c008620 <HAL_OSPI_Abort+0x30>
        hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
 c00861c:	2304      	movs	r3, #4
 c00861e:	6523      	str	r3, [r4, #80]	; 0x50
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 c008620:	6823      	ldr	r3, [r4, #0]
 c008622:	6a1a      	ldr	r2, [r3, #32]
 c008624:	0692      	lsls	r2, r2, #26
 c008626:	d51b      	bpl.n	c008660 <HAL_OSPI_Abort+0x70>
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
 c008628:	681a      	ldr	r2, [r3, #0]
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, hospi->Timeout);
 c00862a:	2102      	movs	r1, #2
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
 c00862c:	f042 0202 	orr.w	r2, r2, #2
 c008630:	601a      	str	r2, [r3, #0]
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, hospi->Timeout);
 c008632:	6d63      	ldr	r3, [r4, #84]	; 0x54
 c008634:	2201      	movs	r2, #1
 c008636:	9300      	str	r3, [sp, #0]
 c008638:	4620      	mov	r0, r4
 c00863a:	462b      	mov	r3, r5
 c00863c:	f7ff fdc4 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 c008640:	b960      	cbnz	r0, c00865c <HAL_OSPI_Abort+0x6c>
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 c008642:	2602      	movs	r6, #2
 c008644:	6823      	ldr	r3, [r4, #0]
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 c008646:	4602      	mov	r2, r0
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 c008648:	625e      	str	r6, [r3, #36]	; 0x24
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 c00864a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 c00864c:	2120      	movs	r1, #32
 c00864e:	9300      	str	r3, [sp, #0]
 c008650:	4620      	mov	r0, r4
 c008652:	462b      	mov	r3, r5
 c008654:	f7ff fdb8 	bl	c0081c8 <OSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 c008658:	b900      	cbnz	r0, c00865c <HAL_OSPI_Abort+0x6c>
          hospi->State = HAL_OSPI_STATE_READY;
 c00865a:	64e6      	str	r6, [r4, #76]	; 0x4c
}
 c00865c:	b002      	add	sp, #8
 c00865e:	bd70      	pop	{r4, r5, r6, pc}
      hospi->State = HAL_OSPI_STATE_READY;
 c008660:	2302      	movs	r3, #2
 c008662:	64e3      	str	r3, [r4, #76]	; 0x4c
 c008664:	e7fa      	b.n	c00865c <HAL_OSPI_Abort+0x6c>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c008666:	2310      	movs	r3, #16
    status = HAL_ERROR;
 c008668:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 c00866a:	6523      	str	r3, [r4, #80]	; 0x50
 c00866c:	e7f6      	b.n	c00865c <HAL_OSPI_Abort+0x6c>

0c00866e <HAL_OTFDEC_MspInit>:
  UNUSED(hotfdec);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_OTFDEC_MspInit can be implemented in the user file.
   */
}
 c00866e:	4770      	bx	lr

0c008670 <HAL_OTFDEC_Init>:
{
 c008670:	b538      	push	{r3, r4, r5, lr}
  if(hotfdec == NULL)
 c008672:	4605      	mov	r5, r0
 c008674:	2401      	movs	r4, #1
 c008676:	b138      	cbz	r0, c008688 <HAL_OTFDEC_Init+0x18>
  if(hotfdec->State == HAL_OTFDEC_STATE_RESET)
 c008678:	7903      	ldrb	r3, [r0, #4]
 c00867a:	b913      	cbnz	r3, c008682 <HAL_OTFDEC_Init+0x12>
    __HAL_UNLOCK(hotfdec);
 c00867c:	7143      	strb	r3, [r0, #5]
    HAL_OTFDEC_MspInit(hotfdec);
 c00867e:	f7ff fff6 	bl	c00866e <HAL_OTFDEC_MspInit>
  return HAL_OK;
 c008682:	2000      	movs	r0, #0
  hotfdec->State = HAL_OTFDEC_STATE_READY;
 c008684:	712c      	strb	r4, [r5, #4]
}
 c008686:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 c008688:	4620      	mov	r0, r4
 c00868a:	e7fc      	b.n	c008686 <HAL_OTFDEC_Init+0x16>

0c00868c <HAL_OTFDEC_RegionSetMode>:
  assert_param(IS_OTFDEC_ALL_INSTANCE(hotfdec->Instance));
  assert_param(IS_OTFDEC_REGIONINDEX(RegionIndex));
  assert_param(IS_OTFDEC_REGION_OPERATING_MODE(mode));

  /* Take Lock */
  __HAL_LOCK(hotfdec);
 c00868c:	7943      	ldrb	r3, [r0, #5]
{
 c00868e:	b510      	push	{r4, lr}
  __HAL_LOCK(hotfdec);
 c008690:	2b01      	cmp	r3, #1
 c008692:	d00c      	beq.n	c0086ae <HAL_OTFDEC_RegionSetMode+0x22>

  address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c008694:	2330      	movs	r3, #48	; 0x30
 c008696:	4359      	muls	r1, r3
 c008698:	6804      	ldr	r4, [r0, #0]
 c00869a:	3120      	adds	r1, #32
  region = (OTFDEC_Region_TypeDef *)address;

  /* Set mode */
  MODIFY_REG(region->REG_CONFIGR, OTFDEC_REG_CONFIGR_MODE, mode);
 c00869c:	5863      	ldr	r3, [r4, r1]
 c00869e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 c0086a2:	431a      	orrs	r2, r3

  /* Release Lock */
  __HAL_UNLOCK(hotfdec);
 c0086a4:	2300      	movs	r3, #0
  MODIFY_REG(region->REG_CONFIGR, OTFDEC_REG_CONFIGR_MODE, mode);
 c0086a6:	5062      	str	r2, [r4, r1]
  __HAL_UNLOCK(hotfdec);
 c0086a8:	7143      	strb	r3, [r0, #5]

  /* Status is okay */
  return HAL_OK;
 c0086aa:	4618      	mov	r0, r3
}
 c0086ac:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hotfdec);
 c0086ae:	2002      	movs	r0, #2
 c0086b0:	e7fc      	b.n	c0086ac <HAL_OTFDEC_RegionSetMode+0x20>

0c0086b2 <HAL_OTFDEC_RegionConfig>:
  *          @arg @ref OTFDEC_REG_CONFIGR_LOCK_DISABLE      OTFDEC region configuration is not locked
  *          @arg @ref OTFDEC_REG_CONFIGR_LOCK_ENABLE       OTFDEC region configuration is locked
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_OTFDEC_RegionConfig(OTFDEC_HandleTypeDef *hotfdec, uint32_t RegionIndex, OTFDEC_RegionConfigTypeDef *Config, uint32_t lock)
{
 c0086b2:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_OTFDEC_ALL_INSTANCE(hotfdec->Instance));
  assert_param(IS_OTFDEC_REGIONINDEX(RegionIndex));
  assert_param(IS_OTFDEC_REGION_CONFIG_LOCK(lock));

  if (Config == NULL)
 c0086b4:	b32a      	cbz	r2, c008702 <HAL_OTFDEC_RegionConfig+0x50>
  }
  else
  {

    /* Take Lock */
    __HAL_LOCK(hotfdec);
 c0086b6:	7944      	ldrb	r4, [r0, #5]
 c0086b8:	2c01      	cmp	r4, #1
 c0086ba:	d024      	beq.n	c008706 <HAL_OTFDEC_RegionConfig+0x54>
 c0086bc:	2401      	movs	r4, #1
 c0086be:	7144      	strb	r4, [r0, #5]

    address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c0086c0:	2430      	movs	r4, #48	; 0x30
 c0086c2:	4361      	muls	r1, r4
 c0086c4:	6805      	ldr	r5, [r0, #0]
    region = (OTFDEC_Region_TypeDef *)address;

    /* Set Nonce */
    WRITE_REG( region->REG_NONCER0, Config->Nonce[0]);
 c0086c6:	6816      	ldr	r6, [r2, #0]
    address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c0086c8:	3120      	adds	r1, #32
 c0086ca:	186c      	adds	r4, r5, r1
    WRITE_REG( region->REG_NONCER0, Config->Nonce[0]);
 c0086cc:	60e6      	str	r6, [r4, #12]

    WRITE_REG( region->REG_NONCER1, Config->Nonce[1]);
 c0086ce:	6856      	ldr	r6, [r2, #4]

    /* Enable region deciphering or enciphering (depending of OTFDEC_CR ENC bit setting) */
    SET_BIT( region->REG_CONFIGR, OTFDEC_REG_CONFIGR_REG_ENABLE);

    /* Lock the region configuration according to lock parameter value */
    if (lock == OTFDEC_REG_CONFIGR_LOCK_ENABLE)
 c0086d0:	2b02      	cmp	r3, #2
    WRITE_REG( region->REG_NONCER1, Config->Nonce[1]);
 c0086d2:	6126      	str	r6, [r4, #16]
    WRITE_REG( region->REG_START_ADDR, Config->StartAddress);
 c0086d4:	6896      	ldr	r6, [r2, #8]
 c0086d6:	6066      	str	r6, [r4, #4]
    WRITE_REG( region->REG_END_ADDR, Config->EndAddress);
 c0086d8:	68d6      	ldr	r6, [r2, #12]
 c0086da:	60a6      	str	r6, [r4, #8]
    MODIFY_REG( region->REG_CONFIGR, OTFDEC_REG_CONFIGR_VERSION, (uint32_t)(Config->Version) << OTFDEC_REG_CONFIGR_VERSION_Pos );
 c0086dc:	586c      	ldr	r4, [r5, r1]
 c0086de:	8a16      	ldrh	r6, [r2, #16]
 c0086e0:	b2a2      	uxth	r2, r4
 c0086e2:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
 c0086e6:	506a      	str	r2, [r5, r1]
    SET_BIT( region->REG_CONFIGR, OTFDEC_REG_CONFIGR_REG_ENABLE);
 c0086e8:	586a      	ldr	r2, [r5, r1]
 c0086ea:	f042 0201 	orr.w	r2, r2, #1
 c0086ee:	506a      	str	r2, [r5, r1]
    {
      SET_BIT( region->REG_CONFIGR, OTFDEC_REG_CONFIGR_LOCK_ENABLE);
 c0086f0:	bf02      	ittt	eq
 c0086f2:	586b      	ldreq	r3, [r5, r1]
 c0086f4:	f043 0302 	orreq.w	r3, r3, #2
 c0086f8:	506b      	streq	r3, [r5, r1]
    }

    /* Release Lock */
    __HAL_UNLOCK(hotfdec);
 c0086fa:	2300      	movs	r3, #0
 c0086fc:	7143      	strb	r3, [r0, #5]

    /* Status is okay */
    return HAL_OK;
 c0086fe:	4618      	mov	r0, r3
  }
}
 c008700:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 c008702:	2001      	movs	r0, #1
 c008704:	e7fc      	b.n	c008700 <HAL_OTFDEC_RegionConfig+0x4e>
    __HAL_LOCK(hotfdec);
 c008706:	2002      	movs	r0, #2
 c008708:	e7fa      	b.n	c008700 <HAL_OTFDEC_RegionConfig+0x4e>
	...

0c00870c <HAL_OTFDEC_KeyCRCComputation>:
  * @brief  Compute Key CRC
  * @param  pKey pointer at set of keys
  * @retval CRC value
  */
uint32_t HAL_OTFDEC_KeyCRCComputation(uint32_t *pKey)
{
 c00870c:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00870e:	b085      	sub	sp, #20
  uint8_t crc7_poly = 0x7;
  uint32_t key_strobe[4] = {0xAA55AA55U, 0x3U, 0x18U, 0xC0U};
 c008710:	466c      	mov	r4, sp
 c008712:	4b18      	ldr	r3, [pc, #96]	; (c008774 <HAL_OTFDEC_KeyCRCComputation+0x68>)
{
 c008714:	4605      	mov	r5, r0
  uint32_t key_strobe[4] = {0xAA55AA55U, 0x3U, 0x18U, 0xC0U};
 c008716:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 c008718:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
  uint8_t  i;
  uint8_t crc = 0;
  uint32_t  j, keyval, k;
  uint32_t * temp = pKey;

  for (j = 0U; j < 4U; j++)
 c00871c:	2300      	movs	r3, #0
  uint8_t crc = 0;
 c00871e:	4618      	mov	r0, r3
  {
    keyval = *temp;
    temp++;
    if (j == 0U)
    {
      keyval ^= key_strobe[0];
 c008720:	4e15      	ldr	r6, [pc, #84]	; (c008778 <HAL_OTFDEC_KeyCRCComputation+0x6c>)
    keyval = *temp;
 c008722:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
    if (j == 0U)
 c008726:	b9cb      	cbnz	r3, c00875c <HAL_OTFDEC_KeyCRCComputation+0x50>
      keyval ^= key_strobe[0];
 c008728:	ea81 0206 	eor.w	r2, r1, r6
  uint8_t crc = 0;
 c00872c:	271f      	movs	r7, #31
    else
    {
      keyval ^= (key_strobe[j] << 24) | ((uint32_t)crc << 16) | (key_strobe[j] << 8) | crc;
    }

    crc = 0;
 c00872e:	2000      	movs	r0, #0
    for (i = 0; i < (uint8_t)32; i++)
    {
      k = ((((uint32_t)crc >> 7) ^ ((keyval >> ((uint8_t)31-i))&((uint8_t)0xF)))) & 1U;
 c008730:	fa22 f107 	lsr.w	r1, r2, r7
 c008734:	f001 010f 	and.w	r1, r1, #15
 c008738:	ea81 11d0 	eor.w	r1, r1, r0, lsr #7
      crc <<= 1;
 c00873c:	0040      	lsls	r0, r0, #1
      if (k != 0U)
 c00873e:	07c9      	lsls	r1, r1, #31
      crc <<= 1;
 c008740:	b2c0      	uxtb	r0, r0
      {
        crc ^= crc7_poly;
 c008742:	bf48      	it	mi
 c008744:	f080 0007 	eormi.w	r0, r0, #7
    for (i = 0; i < (uint8_t)32; i++)
 c008748:	f117 37ff 	adds.w	r7, r7, #4294967295
 c00874c:	d2f0      	bcs.n	c008730 <HAL_OTFDEC_KeyCRCComputation+0x24>
  for (j = 0U; j < 4U; j++)
 c00874e:	3301      	adds	r3, #1
 c008750:	2b04      	cmp	r3, #4
       }
    }

    crc^=(uint8_t)0x55;
 c008752:	f080 0055 	eor.w	r0, r0, #85	; 0x55
  for (j = 0U; j < 4U; j++)
 c008756:	d1e4      	bne.n	c008722 <HAL_OTFDEC_KeyCRCComputation+0x16>
  }

  return (uint32_t) crc;
}
 c008758:	b005      	add	sp, #20
 c00875a:	bdf0      	pop	{r4, r5, r6, r7, pc}
      keyval ^= (key_strobe[j] << 24) | ((uint32_t)crc << 16) | (key_strobe[j] << 8) | crc;
 c00875c:	f854 7023 	ldr.w	r7, [r4, r3, lsl #2]
 c008760:	0402      	lsls	r2, r0, #16
 c008762:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
 c008766:	4310      	orrs	r0, r2
 c008768:	ea40 2007 	orr.w	r0, r0, r7, lsl #8
 c00876c:	ea80 0201 	eor.w	r2, r0, r1
 c008770:	e7dc      	b.n	c00872c <HAL_OTFDEC_KeyCRCComputation+0x20>
 c008772:	bf00      	nop
 c008774:	0c010180 	.word	0x0c010180
 c008778:	aa55aa55 	.word	0xaa55aa55

0c00877c <HAL_OTFDEC_RegionGetKeyCRC>:

  /* Check the parameters */
  assert_param(IS_OTFDEC_ALL_INSTANCE(hotfdec->Instance));
  assert_param(IS_OTFDEC_REGIONINDEX(RegionIndex));

  address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c00877c:	2330      	movs	r3, #48	; 0x30
 c00877e:	4359      	muls	r1, r3
 c008780:	6803      	ldr	r3, [r0, #0]
 c008782:	3120      	adds	r1, #32
  region = (OTFDEC_Region_TypeDef *)address;

  keycrc = (READ_REG( region->REG_CONFIGR )) & OTFDEC_REG_CONFIGR_KEYCRC;
 c008784:	5858      	ldr	r0, [r3, r1]

  keycrc >>= OTFDEC_REG_CONFIGR_KEYCRC_Pos;

  return keycrc;
}
 c008786:	f3c0 2007 	ubfx	r0, r0, #8, #8
 c00878a:	4770      	bx	lr

0c00878c <HAL_OTFDEC_RegionSetKey>:
{
 c00878c:	b570      	push	{r4, r5, r6, lr}
 c00878e:	4604      	mov	r4, r0
 c008790:	460e      	mov	r6, r1
  if (pKey == NULL)
 c008792:	b35a      	cbz	r2, c0087ec <HAL_OTFDEC_RegionSetKey+0x60>
    __HAL_LOCK(hotfdec);
 c008794:	7943      	ldrb	r3, [r0, #5]
 c008796:	2b01      	cmp	r3, #1
 c008798:	d02a      	beq.n	c0087f0 <HAL_OTFDEC_RegionSetKey+0x64>
    address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c00879a:	2330      	movs	r3, #48	; 0x30
    __HAL_LOCK(hotfdec);
 c00879c:	2501      	movs	r5, #1
    address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c00879e:	434b      	muls	r3, r1
    __HAL_LOCK(hotfdec);
 c0087a0:	7145      	strb	r5, [r0, #5]
    address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c0087a2:	f103 0020 	add.w	r0, r3, #32
 c0087a6:	6823      	ldr	r3, [r4, #0]
    WRITE_REG( region->REG_KEYR0, pKey[0]);
 c0087a8:	6811      	ldr	r1, [r2, #0]
    address =   (uint32_t)(hotfdec->Instance) + 0x20U + (0x30U * RegionIndex);
 c0087aa:	4403      	add	r3, r0
    WRITE_REG( region->REG_KEYR0, pKey[0]);
 c0087ac:	6159      	str	r1, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 c0087ae:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c0087b2:	f3bf 8f6f 	isb	sy
    WRITE_REG( region->REG_KEYR1, pKey[1]);
 c0087b6:	6851      	ldr	r1, [r2, #4]
 c0087b8:	6199      	str	r1, [r3, #24]
  __ASM volatile ("dsb 0xF":::"memory");
 c0087ba:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c0087be:	f3bf 8f6f 	isb	sy
    WRITE_REG( region->REG_KEYR2, pKey[2]);
 c0087c2:	6891      	ldr	r1, [r2, #8]
 c0087c4:	61d9      	str	r1, [r3, #28]
  __ASM volatile ("dsb 0xF":::"memory");
 c0087c6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 c0087ca:	f3bf 8f6f 	isb	sy
    WRITE_REG( region->REG_KEYR3, pKey[3]);
 c0087ce:	68d1      	ldr	r1, [r2, #12]
    if (HAL_OTFDEC_KeyCRCComputation(pKey) != HAL_OTFDEC_RegionGetKeyCRC(hotfdec, RegionIndex))
 c0087d0:	4610      	mov	r0, r2
    WRITE_REG( region->REG_KEYR3, pKey[3]);
 c0087d2:	6219      	str	r1, [r3, #32]
    if (HAL_OTFDEC_KeyCRCComputation(pKey) != HAL_OTFDEC_RegionGetKeyCRC(hotfdec, RegionIndex))
 c0087d4:	f7ff ff9a 	bl	c00870c <HAL_OTFDEC_KeyCRCComputation>
 c0087d8:	4631      	mov	r1, r6
 c0087da:	4602      	mov	r2, r0
 c0087dc:	4620      	mov	r0, r4
 c0087de:	f7ff ffcd 	bl	c00877c <HAL_OTFDEC_RegionGetKeyCRC>
 c0087e2:	4282      	cmp	r2, r0
 c0087e4:	f04f 0000 	mov.w	r0, #0
      __HAL_UNLOCK(hotfdec);
 c0087e8:	7160      	strb	r0, [r4, #5]
    if (HAL_OTFDEC_KeyCRCComputation(pKey) != HAL_OTFDEC_RegionGetKeyCRC(hotfdec, RegionIndex))
 c0087ea:	d000      	beq.n	c0087ee <HAL_OTFDEC_RegionSetKey+0x62>
    return HAL_ERROR;
 c0087ec:	2001      	movs	r0, #1
}
 c0087ee:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_LOCK(hotfdec);
 c0087f0:	2002      	movs	r0, #2
 c0087f2:	e7fc      	b.n	c0087ee <HAL_OTFDEC_RegionSetKey+0x62>

0c0087f4 <HAL_PKA_MspInit>:
  UNUSED(hpka);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_PKA_MspInit can be implemented in the user file
   */
}
 c0087f4:	4770      	bx	lr

0c0087f6 <HAL_PKA_Init>:
{
 c0087f6:	b570      	push	{r4, r5, r6, lr}
  if (hpka != NULL)
 c0087f8:	4604      	mov	r4, r0
 c0087fa:	b310      	cbz	r0, c008842 <HAL_PKA_Init+0x4c>
    if (hpka->State == HAL_PKA_STATE_RESET)
 c0087fc:	7903      	ldrb	r3, [r0, #4]
 c0087fe:	b90b      	cbnz	r3, c008804 <HAL_PKA_Init+0xe>
      HAL_PKA_MspInit(hpka);
 c008800:	f7ff fff8 	bl	c0087f4 <HAL_PKA_MspInit>
    hpka->State = HAL_PKA_STATE_BUSY;
 c008804:	2302      	movs	r3, #2
 c008806:	7123      	strb	r3, [r4, #4]
    tickstart = HAL_GetTick();
 c008808:	f7fa fe4c 	bl	c0034a4 <HAL_GetTick>
      hpka->Instance->CR = PKA_CR_EN;
 c00880c:	2601      	movs	r6, #1
    tickstart = HAL_GetTick();
 c00880e:	4605      	mov	r5, r0
    while ((hpka->Instance->CR & PKA_CR_EN) != PKA_CR_EN)
 c008810:	6823      	ldr	r3, [r4, #0]
 c008812:	681a      	ldr	r2, [r3, #0]
 c008814:	07d2      	lsls	r2, r2, #31
 c008816:	d508      	bpl.n	c00882a <HAL_PKA_Init+0x34>
      SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 c008818:	689a      	ldr	r2, [r3, #8]
      hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c00881a:	2000      	movs	r0, #0
      SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 c00881c:	f442 12d0 	orr.w	r2, r2, #1703936	; 0x1a0000
 c008820:	609a      	str	r2, [r3, #8]
      hpka->State = HAL_PKA_STATE_READY;
 c008822:	2301      	movs	r3, #1
      hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c008824:	60a0      	str	r0, [r4, #8]
      hpka->State = HAL_PKA_STATE_READY;
 c008826:	7123      	strb	r3, [r4, #4]
 c008828:	e00c      	b.n	c008844 <HAL_PKA_Init+0x4e>
      hpka->Instance->CR = PKA_CR_EN;
 c00882a:	601e      	str	r6, [r3, #0]
      if ((HAL_GetTick() - tickstart) > PKA_RAM_ERASE_TIMEOUT)
 c00882c:	f7fa fe3a 	bl	c0034a4 <HAL_GetTick>
 c008830:	1b40      	subs	r0, r0, r5
 c008832:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 c008836:	d9eb      	bls.n	c008810 <HAL_PKA_Init+0x1a>
      hpka->ErrorCode = HAL_PKA_ERROR_TIMEOUT;
 c008838:	2304      	movs	r3, #4
      hpka->State = HAL_PKA_STATE_ERROR;
 c00883a:	2003      	movs	r0, #3
      hpka->ErrorCode = HAL_PKA_ERROR_TIMEOUT;
 c00883c:	60a3      	str	r3, [r4, #8]
      hpka->State = HAL_PKA_STATE_ERROR;
 c00883e:	7120      	strb	r0, [r4, #4]
  return err;
 c008840:	e000      	b.n	c008844 <HAL_PKA_Init+0x4e>
    err = HAL_ERROR;
 c008842:	2001      	movs	r0, #1
}
 c008844:	bd70      	pop	{r4, r5, r6, pc}

0c008846 <HAL_PKA_MspDeInit>:
 c008846:	4770      	bx	lr

0c008848 <HAL_PKA_DeInit>:
{
 c008848:	b538      	push	{r3, r4, r5, lr}
  if (hpka != NULL)
 c00884a:	4605      	mov	r5, r0
 c00884c:	b170      	cbz	r0, c00886c <HAL_PKA_DeInit+0x24>
    hpka->State = HAL_PKA_STATE_BUSY;
 c00884e:	2302      	movs	r3, #2
    hpka->Instance->CR = 0;
 c008850:	2400      	movs	r4, #0
    hpka->State = HAL_PKA_STATE_BUSY;
 c008852:	7103      	strb	r3, [r0, #4]
    hpka->Instance->CR = 0;
 c008854:	6803      	ldr	r3, [r0, #0]
 c008856:	601c      	str	r4, [r3, #0]
    SET_BIT(hpka->Instance->CLRFR, PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 c008858:	689a      	ldr	r2, [r3, #8]
 c00885a:	f442 12d0 	orr.w	r2, r2, #1703936	; 0x1a0000
 c00885e:	609a      	str	r2, [r3, #8]
    HAL_PKA_MspDeInit(hpka);
 c008860:	f7ff fff1 	bl	c008846 <HAL_PKA_MspDeInit>
  HAL_StatusTypeDef err = HAL_OK;
 c008864:	4620      	mov	r0, r4
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c008866:	60ac      	str	r4, [r5, #8]
    hpka->State = HAL_PKA_STATE_RESET;
 c008868:	712c      	strb	r4, [r5, #4]
}
 c00886a:	bd38      	pop	{r3, r4, r5, pc}
    err = HAL_ERROR;
 c00886c:	2001      	movs	r0, #1
 c00886e:	e7fc      	b.n	c00886a <HAL_PKA_DeInit+0x22>

0c008870 <PKA_PollEndOfOperation>:
  * @param  Timeout Timeout duration in millisecond.
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
HAL_StatusTypeDef PKA_PollEndOfOperation(PKA_HandleTypeDef *hpka, uint32_t Timeout, uint32_t Tickstart)
{
 c008870:	b570      	push	{r4, r5, r6, lr}
 c008872:	4605      	mov	r5, r0
 c008874:	460c      	mov	r4, r1
 c008876:	4616      	mov	r6, r2
  /* Wait for the end of operation or timeout */
  while ((hpka->Instance->SR & PKA_SR_PROCENDF) == 0UL)
 c008878:	6829      	ldr	r1, [r5, #0]
 c00887a:	684b      	ldr	r3, [r1, #4]
 c00887c:	039b      	lsls	r3, r3, #14
 c00887e:	d501      	bpl.n	c008884 <PKA_PollEndOfOperation+0x14>
      {
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 c008880:	2000      	movs	r0, #0
}
 c008882:	bd70      	pop	{r4, r5, r6, pc}
    if (Timeout != HAL_MAX_DELAY)
 c008884:	1c62      	adds	r2, r4, #1
 c008886:	d0f8      	beq.n	c00887a <PKA_PollEndOfOperation+0xa>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0UL))
 c008888:	f7fa fe0c 	bl	c0034a4 <HAL_GetTick>
 c00888c:	1b80      	subs	r0, r0, r6
 c00888e:	42a0      	cmp	r0, r4
 c008890:	d801      	bhi.n	c008896 <PKA_PollEndOfOperation+0x26>
 c008892:	2c00      	cmp	r4, #0
 c008894:	d1f0      	bne.n	c008878 <PKA_PollEndOfOperation+0x8>
        return HAL_TIMEOUT;
 c008896:	2003      	movs	r0, #3
 c008898:	e7f3      	b.n	c008882 <PKA_PollEndOfOperation+0x12>

0c00889a <PKA_CheckError>:
uint32_t PKA_CheckError(PKA_HandleTypeDef *hpka, uint32_t mode)
{
  uint32_t err = HAL_PKA_ERROR_NONE;

  /* Check RAMERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_RAMERR) == SET)
 c00889a:	6803      	ldr	r3, [r0, #0]
 c00889c:	685a      	ldr	r2, [r3, #4]
  {
    err |= HAL_PKA_ERROR_RAMERR;
 c00889e:	f412 2f00 	tst.w	r2, #524288	; 0x80000
 c0088a2:	bf0c      	ite	eq
 c0088a4:	2000      	moveq	r0, #0
 c0088a6:	2002      	movne	r0, #2
  }

  /* Check ADDRERR error */
  if (__HAL_PKA_GET_FLAG(hpka, PKA_FLAG_ADDRERR) == SET)
 c0088a8:	685a      	ldr	r2, [r3, #4]
 c0088aa:	02d2      	lsls	r2, r2, #11
  {
    err |= HAL_PKA_ERROR_ADDRERR;
 c0088ac:	bf48      	it	mi
 c0088ae:	f040 0001 	orrmi.w	r0, r0, #1
  }

  /* Check the operation success in case of ECDSA signature */
  if (mode == PKA_MODE_ECDSA_SIGNATURE)
 c0088b2:	2924      	cmp	r1, #36	; 0x24
 c0088b4:	d104      	bne.n	c0088c0 <PKA_CheckError+0x26>
  {
    /* If error output result is different from 0, ecsa sign operation need to be repeated */
    if (hpka->Instance->RAM[PKA_ECDSA_SIGN_OUT_ERROR] != 0UL)
 c0088b6:	f8d3 3ee8 	ldr.w	r3, [r3, #3816]	; 0xee8
 c0088ba:	b10b      	cbz	r3, c0088c0 <PKA_CheckError+0x26>
    {
      err |= HAL_PKA_ERROR_OPERATION;
 c0088bc:	f040 0008 	orr.w	r0, r0, #8
    }
  }

  return err;
}
 c0088c0:	4770      	bx	lr

0c0088c2 <PKA_Memcpy_u32_to_u8>:
  * @param  src Pointer to source
  * @param  n Number of uint8_t to copy
  * @retval dst
  */
void PKA_Memcpy_u32_to_u8(uint8_t dst[], __IO const uint32_t src[], size_t n)
{
 c0088c2:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (dst != NULL)
 c0088c4:	b170      	cbz	r0, c0088e4 <PKA_Memcpy_u32_to_u8+0x22>
  {
    if (src != NULL)
 c0088c6:	b169      	cbz	r1, c0088e4 <PKA_Memcpy_u32_to_u8+0x22>
 c0088c8:	460c      	mov	r4, r1
    {
      uint32_t index_uint32_t = 0UL; /* This index is used outside of the loop */

      for (; index_uint32_t < (n / 4UL); index_uint32_t++)
 c0088ca:	0893      	lsrs	r3, r2, #2
 c0088cc:	1885      	adds	r5, r0, r2
 c0088ce:	eb01 0783 	add.w	r7, r1, r3, lsl #2
 c0088d2:	42a7      	cmp	r7, r4
 c0088d4:	d107      	bne.n	c0088e6 <PKA_Memcpy_u32_to_u8+0x24>
        dst[index_uint8_t + 1UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
        dst[index_uint8_t + 0UL] = (uint8_t)((src[index_uint32_t] & 0xFF000000U) >> 24UL);
      }

      /* Manage the buffers not aligned on uint32_t */
      if ((n % 4UL) == 1UL)
 c0088d6:	f002 0203 	and.w	r2, r2, #3
 c0088da:	2a01      	cmp	r2, #1
 c0088dc:	d114      	bne.n	c008908 <PKA_Memcpy_u32_to_u8+0x46>
      {
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c0088de:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
      }
      else if ((n % 4UL) == 3UL)
      {
        dst[2UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
        dst[1UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
 c0088e2:	7003      	strb	r3, [r0, #0]
      {
        /* The last element is already handle in the loop */
      }
    }
  }
}
 c0088e4:	bdf0      	pop	{r4, r5, r6, r7, pc}
        dst[index_uint8_t + 3UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c0088e6:	6826      	ldr	r6, [r4, #0]
 c0088e8:	f805 6c01 	strb.w	r6, [r5, #-1]
        dst[index_uint8_t + 2UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
 c0088ec:	6826      	ldr	r6, [r4, #0]
 c0088ee:	0a36      	lsrs	r6, r6, #8
 c0088f0:	f805 6c02 	strb.w	r6, [r5, #-2]
        dst[index_uint8_t + 1UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
 c0088f4:	6826      	ldr	r6, [r4, #0]
 c0088f6:	0c36      	lsrs	r6, r6, #16
 c0088f8:	f805 6c03 	strb.w	r6, [r5, #-3]
        dst[index_uint8_t + 0UL] = (uint8_t)((src[index_uint32_t] & 0xFF000000U) >> 24UL);
 c0088fc:	f854 6b04 	ldr.w	r6, [r4], #4
 c008900:	0e36      	lsrs	r6, r6, #24
 c008902:	f805 6d04 	strb.w	r6, [r5, #-4]!
 c008906:	e7e4      	b.n	c0088d2 <PKA_Memcpy_u32_to_u8+0x10>
      else if ((n % 4UL) == 2UL)
 c008908:	2a02      	cmp	r2, #2
 c00890a:	d106      	bne.n	c00891a <PKA_Memcpy_u32_to_u8+0x58>
        dst[1UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c00890c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 c008910:	7042      	strb	r2, [r0, #1]
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
 c008912:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c008916:	0a1b      	lsrs	r3, r3, #8
 c008918:	e7e3      	b.n	c0088e2 <PKA_Memcpy_u32_to_u8+0x20>
      else if ((n % 4UL) == 3UL)
 c00891a:	2a03      	cmp	r2, #3
 c00891c:	d1e2      	bne.n	c0088e4 <PKA_Memcpy_u32_to_u8+0x22>
        dst[2UL] = (uint8_t)((src[index_uint32_t] & 0x000000FFU));
 c00891e:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 c008922:	7082      	strb	r2, [r0, #2]
        dst[1UL] = (uint8_t)((src[index_uint32_t] & 0x0000FF00U) >> 8UL);
 c008924:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 c008928:	0a12      	lsrs	r2, r2, #8
 c00892a:	7042      	strb	r2, [r0, #1]
        dst[0UL] = (uint8_t)((src[index_uint32_t] & 0x00FF0000U) >> 16UL);
 c00892c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 c008930:	0c1b      	lsrs	r3, r3, #16
 c008932:	e7d6      	b.n	c0088e2 <PKA_Memcpy_u32_to_u8+0x20>

0c008934 <HAL_PKA_ModExp_GetResult>:
{
 c008934:	460b      	mov	r3, r1
  size = (hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] + 7UL) / 8UL;
 c008936:	6801      	ldr	r1, [r0, #0]
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_MODULAR_EXP_OUT_SM_ALGO_ACC1], size);
 c008938:	4618      	mov	r0, r3
  size = (hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] + 7UL) / 8UL;
 c00893a:	f8d1 2404 	ldr.w	r2, [r1, #1028]	; 0x404
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_MODULAR_EXP_OUT_SM_ALGO_ACC1], size);
 c00893e:	f201 7124 	addw	r1, r1, #1828	; 0x724
  size = (hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] + 7UL) / 8UL;
 c008942:	3207      	adds	r2, #7
  PKA_Memcpy_u32_to_u8(pRes, &hpka->Instance->RAM[PKA_MODULAR_EXP_OUT_SM_ALGO_ACC1], size);
 c008944:	08d2      	lsrs	r2, r2, #3
 c008946:	f7ff bfbc 	b.w	c0088c2 <PKA_Memcpy_u32_to_u8>

0c00894a <PKA_Memcpy_u8_to_u32>:
  * @param  src Pointer to source
  * @param  n Number of uint8_t to copy (must be multiple of 4)
  * @retval dst
  */
void PKA_Memcpy_u8_to_u32(__IO uint32_t dst[], const uint8_t src[], size_t n)
{
 c00894a:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (dst != NULL)
 c00894c:	b188      	cbz	r0, c008972 <PKA_Memcpy_u8_to_u32+0x28>
  {
    if (src != NULL)
 c00894e:	b181      	cbz	r1, c008972 <PKA_Memcpy_u8_to_u32+0x28>
 c008950:	4607      	mov	r7, r0
    {
      uint32_t index = 0UL; /* This index is used outside of the loop */

      for (; index < (n / 4UL); index++)
 c008952:	0895      	lsrs	r5, r2, #2
 c008954:	00ab      	lsls	r3, r5, #2
 c008956:	188e      	adds	r6, r1, r2
 c008958:	eb03 0c00 	add.w	ip, r3, r0
 c00895c:	45bc      	cmp	ip, r7
 c00895e:	d109      	bne.n	c008974 <PKA_Memcpy_u8_to_u32+0x2a>
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
                     | ((uint32_t)src[(n - (index * 4UL) - 4UL)] << 24UL);
      }

      /* Manage the buffers not aligned on uint32_t */
      if ((n % 4UL) == 1UL)
 c008960:	f002 0403 	and.w	r4, r2, #3
 c008964:	2c01      	cmp	r4, #1
 c008966:	d117      	bne.n	c008998 <PKA_Memcpy_u8_to_u32+0x4e>
      {
        dst[index] = (uint32_t)src[(n - (index * 4UL) - 1UL)];
 c008968:	3a01      	subs	r2, #1
 c00896a:	1ad2      	subs	r2, r2, r3
 c00896c:	5c8b      	ldrb	r3, [r1, r2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
      }
      else if ((n % 4UL) == 3UL)
      {
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c00896e:	f840 3025 	str.w	r3, [r0, r5, lsl #2]
      {
        /* The last element is already handle in the loop */
      }
    }
  }
}
 c008972:	bdf0      	pop	{r4, r5, r6, r7, pc}
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 c008974:	f816 4c03 	ldrb.w	r4, [r6, #-3]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 c008978:	f816 ec02 	ldrb.w	lr, [r6, #-2]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 c00897c:	0424      	lsls	r4, r4, #16
 c00897e:	ea44 240e 	orr.w	r4, r4, lr, lsl #8
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c008982:	f816 ec01 	ldrb.w	lr, [r6, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL) \
 c008986:	ea44 040e 	orr.w	r4, r4, lr
                     | ((uint32_t)src[(n - (index * 4UL) - 4UL)] << 24UL);
 c00898a:	f816 ed04 	ldrb.w	lr, [r6, #-4]!
 c00898e:	ea44 640e 	orr.w	r4, r4, lr, lsl #24
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c008992:	f847 4b04 	str.w	r4, [r7], #4
 c008996:	e7e1      	b.n	c00895c <PKA_Memcpy_u8_to_u32+0x12>
      else if ((n % 4UL) == 2UL)
 c008998:	2c02      	cmp	r4, #2
 c00899a:	d108      	bne.n	c0089ae <PKA_Memcpy_u8_to_u32+0x64>
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c00899c:	1ad2      	subs	r2, r2, r3
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
 c00899e:	440a      	add	r2, r1
 c0089a0:	f812 1c02 	ldrb.w	r1, [r2, #-2]
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c0089a4:	f812 3c01 	ldrb.w	r3, [r2, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL);
 c0089a8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 c0089ac:	e7df      	b.n	c00896e <PKA_Memcpy_u8_to_u32+0x24>
      else if ((n % 4UL) == 3UL)
 c0089ae:	2c03      	cmp	r4, #3
 c0089b0:	d1df      	bne.n	c008972 <PKA_Memcpy_u8_to_u32+0x28>
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c0089b2:	1ad2      	subs	r2, r2, r3
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 c0089b4:	440a      	add	r2, r1
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 c0089b6:	f812 3c03 	ldrb.w	r3, [r2, #-3]
                     | ((uint32_t)src[(n - (index * 4UL) - 2UL)] << 8UL) \
 c0089ba:	f812 1c02 	ldrb.w	r1, [r2, #-2]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 c0089be:	041b      	lsls	r3, r3, #16
        dst[index] = ((uint32_t)src[(n - (index * 4UL) - 1UL)]) \
 c0089c0:	f812 2c01 	ldrb.w	r2, [r2, #-1]
                     | ((uint32_t)src[(n - (index * 4UL) - 3UL)] << 16UL);
 c0089c4:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 c0089c8:	4313      	orrs	r3, r2
 c0089ca:	e7d0      	b.n	c00896e <PKA_Memcpy_u8_to_u32+0x24>

0c0089cc <PKA_Process>:
HAL_StatusTypeDef PKA_Process(PKA_HandleTypeDef *hpka, uint32_t mode, uint32_t Timeout)
{
  HAL_StatusTypeDef err = HAL_OK;
  uint32_t tickstart;

  if (hpka->State == HAL_PKA_STATE_READY)
 c0089cc:	7903      	ldrb	r3, [r0, #4]
{
 c0089ce:	b570      	push	{r4, r5, r6, lr}
  if (hpka->State == HAL_PKA_STATE_READY)
 c0089d0:	2b01      	cmp	r3, #1
{
 c0089d2:	4604      	mov	r4, r0
 c0089d4:	460d      	mov	r5, r1
 c0089d6:	4616      	mov	r6, r2
  if (hpka->State == HAL_PKA_STATE_READY)
 c0089d8:	d138      	bne.n	c008a4c <PKA_Process+0x80>
  {
    /* Set the state to busy */
    hpka->State = HAL_PKA_STATE_BUSY;
 c0089da:	2302      	movs	r3, #2
 c0089dc:	7103      	strb	r3, [r0, #4]

    /* Clear any pending error */
    hpka->ErrorCode = HAL_PKA_ERROR_NONE;
 c0089de:	2300      	movs	r3, #0
 c0089e0:	6083      	str	r3, [r0, #8]

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 c0089e2:	f7fa fd5f 	bl	c0034a4 <HAL_GetTick>

    /* Set the mode and deactivate the interrupts */
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE, mode << PKA_CR_MODE_Pos);
 c0089e6:	6822      	ldr	r2, [r4, #0]

    /* Start the computation */
    hpka->Instance->CR |= PKA_CR_START;

    /* Wait for the end of operation or timeout */
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 c0089e8:	4631      	mov	r1, r6
    MODIFY_REG(hpka->Instance->CR, PKA_CR_MODE | PKA_CR_PROCENDIE | PKA_CR_RAMERRIE | PKA_CR_ADDRERRIE, mode << PKA_CR_MODE_Pos);
 c0089ea:	6813      	ldr	r3, [r2, #0]
 c0089ec:	f423 13d1 	bic.w	r3, r3, #1712128	; 0x1a2000
 c0089f0:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 c0089f4:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 c0089f8:	6013      	str	r3, [r2, #0]
    hpka->Instance->CR |= PKA_CR_START;
 c0089fa:	6813      	ldr	r3, [r2, #0]
 c0089fc:	f043 0302 	orr.w	r3, r3, #2
 c008a00:	6013      	str	r3, [r2, #0]
    if (PKA_PollEndOfOperation(hpka, Timeout, tickstart) != HAL_OK)
 c008a02:	4602      	mov	r2, r0
 c008a04:	4620      	mov	r0, r4
 c008a06:	f7ff ff33 	bl	c008870 <PKA_PollEndOfOperation>
 c008a0a:	b160      	cbz	r0, c008a26 <PKA_Process+0x5a>
    {
      /* Abort any ongoing operation */
      CLEAR_BIT(hpka->Instance->CR, PKA_CR_EN);
 c008a0c:	6823      	ldr	r3, [r4, #0]
 c008a0e:	681a      	ldr	r2, [r3, #0]
 c008a10:	f022 0201 	bic.w	r2, r2, #1
 c008a14:	601a      	str	r2, [r3, #0]

      hpka->ErrorCode |= HAL_PKA_ERROR_TIMEOUT;
 c008a16:	68a2      	ldr	r2, [r4, #8]
 c008a18:	f042 0204 	orr.w	r2, r2, #4
 c008a1c:	60a2      	str	r2, [r4, #8]

      /* Make ready for the next operation */
      SET_BIT(hpka->Instance->CR, PKA_CR_EN);
 c008a1e:	681a      	ldr	r2, [r3, #0]
 c008a20:	f042 0201 	orr.w	r2, r2, #1
 c008a24:	601a      	str	r2, [r3, #0]
    }

    /* Check error */
    hpka->ErrorCode |= PKA_CheckError(hpka, mode);
 c008a26:	4629      	mov	r1, r5
 c008a28:	4620      	mov	r0, r4
 c008a2a:	f7ff ff36 	bl	c00889a <PKA_CheckError>
 c008a2e:	68a3      	ldr	r3, [r4, #8]

    /* Clear all flags */
    hpka->Instance->CLRFR |= (PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 c008a30:	6822      	ldr	r2, [r4, #0]
    hpka->ErrorCode |= PKA_CheckError(hpka, mode);
 c008a32:	4318      	orrs	r0, r3
 c008a34:	60a0      	str	r0, [r4, #8]
    hpka->Instance->CLRFR |= (PKA_CLRFR_PROCENDFC | PKA_CLRFR_RAMERRFC | PKA_CLRFR_ADDRERRFC);
 c008a36:	6893      	ldr	r3, [r2, #8]
 c008a38:	f443 13d0 	orr.w	r3, r3, #1703936	; 0x1a0000
 c008a3c:	6093      	str	r3, [r2, #8]

    /* Set the state to ready */
    hpka->State = HAL_PKA_STATE_READY;
 c008a3e:	2301      	movs	r3, #1
 c008a40:	7123      	strb	r3, [r4, #4]

    /* Manage the result based on encountered errors */
    if (hpka->ErrorCode != HAL_PKA_ERROR_NONE)
 c008a42:	68a0      	ldr	r0, [r4, #8]
    {
      err = HAL_ERROR;
 c008a44:	3000      	adds	r0, #0
 c008a46:	bf18      	it	ne
 c008a48:	2001      	movne	r0, #1
  else
  {
    err = HAL_ERROR;
  }
  return err;
}
 c008a4a:	bd70      	pop	{r4, r5, r6, pc}
    err = HAL_ERROR;
 c008a4c:	2001      	movs	r0, #1
 c008a4e:	e7fc      	b.n	c008a4a <PKA_Process+0x7e>

0c008a50 <PKA_ModExp_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_ModExp_Set(PKA_HandleTypeDef *hpka, PKA_ModExpInTypeDef *in)
{
 c008a50:	b570      	push	{r4, r5, r6, lr}
 c008a52:	460c      	mov	r4, r1
 c008a54:	4606      	mov	r6, r0
  /* Get the number of bit of the exponent */
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXP_NB_BITS] = PKA_GetBitSize_u8(in->expSize);

  /* Move the input parameters pOp1 to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT_BASE], in->pOp1, in->OpSize);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT_BASE + (in->OpSize / 4UL));
 c008a56:	2500      	movs	r5, #0
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] = PKA_GetBitSize_u8(in->OpSize);
 c008a58:	684a      	ldr	r2, [r1, #4]
 c008a5a:	6800      	ldr	r0, [r0, #0]
  return byteNumber * 8UL;
 c008a5c:	00d3      	lsls	r3, r2, #3
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_OP_NB_BITS] = PKA_GetBitSize_u8(in->OpSize);
 c008a5e:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  return byteNumber * 8UL;
 c008a62:	680b      	ldr	r3, [r1, #0]
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT_BASE], in->pOp1, in->OpSize);
 c008a64:	68c9      	ldr	r1, [r1, #12]
  return byteNumber * 8UL;
 c008a66:	00db      	lsls	r3, r3, #3
  hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXP_NB_BITS] = PKA_GetBitSize_u8(in->expSize);
 c008a68:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT_BASE], in->pOp1, in->OpSize);
 c008a6c:	f600 2044 	addw	r0, r0, #2628	; 0xa44
 c008a70:	f7ff ff6b 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT_BASE + (in->OpSize / 4UL));
 c008a74:	6863      	ldr	r3, [r4, #4]
 c008a76:	6830      	ldr	r0, [r6, #0]
 c008a78:	089b      	lsrs	r3, r3, #2
 c008a7a:	f203 2391 	addw	r3, r3, #657	; 0x291
 c008a7e:	f840 5023 	str.w	r5, [r0, r3, lsl #2]

  /* Move the exponent to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_EXPONENT], in->pExp, in->expSize);
 c008a82:	6822      	ldr	r2, [r4, #0]
 c008a84:	68a1      	ldr	r1, [r4, #8]
 c008a86:	f500 603d 	add.w	r0, r0, #3024	; 0xbd0
 c008a8a:	f7ff ff5e 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_EXPONENT + (in->expSize / 4UL));
 c008a8e:	6823      	ldr	r3, [r4, #0]
 c008a90:	6830      	ldr	r0, [r6, #0]
 c008a92:	089b      	lsrs	r3, r3, #2
 c008a94:	f503 733d 	add.w	r3, r3, #756	; 0x2f4
 c008a98:	f840 5023 	str.w	r5, [r0, r3, lsl #2]

  /* Move the modulus to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_MODULAR_EXP_IN_MODULUS], in->pMod, in->OpSize);
 c008a9c:	6862      	ldr	r2, [r4, #4]
 c008a9e:	6921      	ldr	r1, [r4, #16]
 c008aa0:	f600 505c 	addw	r0, r0, #3420	; 0xd5c
 c008aa4:	f7ff ff51 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_MODULAR_EXP_IN_MODULUS + (in->OpSize / 4UL));
 c008aa8:	6863      	ldr	r3, [r4, #4]
 c008aaa:	6832      	ldr	r2, [r6, #0]
 c008aac:	089b      	lsrs	r3, r3, #2
 c008aae:	f203 3357 	addw	r3, r3, #855	; 0x357
 c008ab2:	f842 5023 	str.w	r5, [r2, r3, lsl #2]
}
 c008ab6:	bd70      	pop	{r4, r5, r6, pc}

0c008ab8 <HAL_PKA_ModExp>:
{
 c008ab8:	b538      	push	{r3, r4, r5, lr}
 c008aba:	4604      	mov	r4, r0
 c008abc:	4615      	mov	r5, r2
  PKA_ModExp_Set(hpka, in);
 c008abe:	f7ff ffc7 	bl	c008a50 <PKA_ModExp_Set>
  return PKA_Process(hpka, PKA_MODE_MODULAR_EXP, Timeout);
 c008ac2:	462a      	mov	r2, r5
 c008ac4:	4620      	mov	r0, r4
}
 c008ac6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return PKA_Process(hpka, PKA_MODE_MODULAR_EXP, Timeout);
 c008aca:	2100      	movs	r1, #0
 c008acc:	f7ff bf7e 	b.w	c0089cc <PKA_Process>

0c008ad0 <PKA_RSACRTExp_Set>:
  * @brief  Set input parameters.
  * @param  hpka PKA handle
  * @param  in Input information
  */
void PKA_RSACRTExp_Set(PKA_HandleTypeDef *hpka, PKA_RSACRTExpInTypeDef *in)
{
 c008ad0:	b570      	push	{r4, r5, r6, lr}
 c008ad2:	460c      	mov	r4, r1
 c008ad4:	4605      	mov	r5, r0
  /* Get the operand length M */
  hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] = PKA_GetBitSize_u8(in->size);

  /* Move the input parameters operand dP to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DP_CRT], in->pOpDp, in->size / 2UL);
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DP_CRT + (in->size / 8UL));
 c008ad6:	2600      	movs	r6, #0
  hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] = PKA_GetBitSize_u8(in->size);
 c008ad8:	680a      	ldr	r2, [r1, #0]
 c008ada:	6800      	ldr	r0, [r0, #0]
  return byteNumber * 8UL;
 c008adc:	00d3      	lsls	r3, r2, #3
  hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_MOD_NB_BITS] = PKA_GetBitSize_u8(in->size);
 c008ade:	f8c0 3404 	str.w	r3, [r0, #1028]	; 0x404
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DP_CRT], in->pOpDp, in->size / 2UL);
 c008ae2:	0852      	lsrs	r2, r2, #1
 c008ae4:	6849      	ldr	r1, [r1, #4]
 c008ae6:	f200 605c 	addw	r0, r0, #1628	; 0x65c
 c008aea:	f7ff ff2e 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DP_CRT + (in->size / 8UL));
 c008aee:	6822      	ldr	r2, [r4, #0]
 c008af0:	6828      	ldr	r0, [r5, #0]
 c008af2:	08d3      	lsrs	r3, r2, #3
 c008af4:	f203 1397 	addw	r3, r3, #407	; 0x197
 c008af8:	f840 6023 	str.w	r6, [r0, r3, lsl #2]

  /* Move the input parameters operand dQ to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_DQ_CRT], in->pOpDq, in->size / 2UL);
 c008afc:	0852      	lsrs	r2, r2, #1
 c008afe:	68a1      	ldr	r1, [r4, #8]
 c008b00:	f500 603d 	add.w	r0, r0, #3024	; 0xbd0
 c008b04:	f7ff ff21 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_DQ_CRT + (in->size / 8UL));
 c008b08:	6822      	ldr	r2, [r4, #0]
 c008b0a:	6828      	ldr	r0, [r5, #0]
 c008b0c:	08d3      	lsrs	r3, r2, #3
 c008b0e:	f503 733d 	add.w	r3, r3, #756	; 0x2f4
 c008b12:	f840 6023 	str.w	r6, [r0, r3, lsl #2]

  /* Move the input parameters operand qinv to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_QINV_CRT], in->pOpQinv, in->size / 2UL);
 c008b16:	0852      	lsrs	r2, r2, #1
 c008b18:	68e1      	ldr	r1, [r4, #12]
 c008b1a:	f200 70ec 	addw	r0, r0, #2028	; 0x7ec
 c008b1e:	f7ff ff14 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_QINV_CRT + (in->size / 8UL));
 c008b22:	6822      	ldr	r2, [r4, #0]
 c008b24:	6828      	ldr	r0, [r5, #0]
 c008b26:	08d3      	lsrs	r3, r2, #3
 c008b28:	f203 13fb 	addw	r3, r3, #507	; 0x1fb
 c008b2c:	f840 6023 	str.w	r6, [r0, r3, lsl #2]

  /* Move the input parameters prime p to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_P], in->pPrimeP, in->size / 2UL);
 c008b30:	0852      	lsrs	r2, r2, #1
 c008b32:	6921      	ldr	r1, [r4, #16]
 c008b34:	f600 107c 	addw	r0, r0, #2428	; 0x97c
 c008b38:	f7ff ff07 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_P + (in->size / 8UL));
 c008b3c:	6822      	ldr	r2, [r4, #0]
 c008b3e:	6828      	ldr	r0, [r5, #0]
 c008b40:	08d3      	lsrs	r3, r2, #3
 c008b42:	f203 235f 	addw	r3, r3, #607	; 0x25f
 c008b46:	f840 6023 	str.w	r6, [r0, r3, lsl #2]

  /* Move the input parameters prime q to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_PRIME_Q], in->pPrimeQ, in->size / 2UL);
 c008b4a:	0852      	lsrs	r2, r2, #1
 c008b4c:	6961      	ldr	r1, [r4, #20]
 c008b4e:	f600 505c 	addw	r0, r0, #3420	; 0xd5c
 c008b52:	f7ff fefa 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_PRIME_Q + (in->size / 8UL));
 c008b56:	6822      	ldr	r2, [r4, #0]
 c008b58:	6828      	ldr	r0, [r5, #0]
 c008b5a:	08d3      	lsrs	r3, r2, #3
 c008b5c:	f203 3357 	addw	r3, r3, #855	; 0x357
 c008b60:	f840 6023 	str.w	r6, [r0, r3, lsl #2]

  /* Move the input parameters operand A to PKA RAM */
  PKA_Memcpy_u8_to_u32(&hpka->Instance->RAM[PKA_RSA_CRT_EXP_IN_EXPONENT_BASE], in->popA, in->size);
 c008b64:	69a1      	ldr	r1, [r4, #24]
 c008b66:	f600 60ec 	addw	r0, r0, #3820	; 0xeec
 c008b6a:	f7ff feee 	bl	c00894a <PKA_Memcpy_u8_to_u32>
  __PKA_RAM_PARAM_END(hpka->Instance->RAM, PKA_RSA_CRT_EXP_IN_EXPONENT_BASE + (in->size / 4UL));
 c008b6e:	6823      	ldr	r3, [r4, #0]
 c008b70:	682a      	ldr	r2, [r5, #0]
 c008b72:	089b      	lsrs	r3, r3, #2
 c008b74:	f203 33bb 	addw	r3, r3, #955	; 0x3bb
 c008b78:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
}
 c008b7c:	bd70      	pop	{r4, r5, r6, pc}

0c008b7e <HAL_PKA_RSACRTExp>:
{
 c008b7e:	b538      	push	{r3, r4, r5, lr}
 c008b80:	4604      	mov	r4, r0
 c008b82:	4615      	mov	r5, r2
  PKA_RSACRTExp_Set(hpka, in);
 c008b84:	f7ff ffa4 	bl	c008ad0 <PKA_RSACRTExp_Set>
  return PKA_Process(hpka, PKA_MODE_RSA_CRT_EXP, Timeout);
 c008b88:	462a      	mov	r2, r5
 c008b8a:	4620      	mov	r0, r4
}
 c008b8c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  return PKA_Process(hpka, PKA_MODE_RSA_CRT_EXP, Timeout);
 c008b90:	2107      	movs	r1, #7
 c008b92:	f7ff bf1b 	b.w	c0089cc <PKA_Process>
	...

0c008b98 <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 c008b98:	4a02      	ldr	r2, [pc, #8]	; (c008ba4 <HAL_PWR_EnableBkUpAccess+0xc>)
 c008b9a:	6813      	ldr	r3, [r2, #0]
 c008b9c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c008ba0:	6013      	str	r3, [r2, #0]
}
 c008ba2:	4770      	bx	lr
 c008ba4:	50007000 	.word	0x50007000

0c008ba8 <HAL_PWREx_GetVoltageRange>:
  * @brief Return Voltage Scaling Range.
  * @retval VOS bit field (PWR_REGULATOR_VOLTAGE_SCALE0, PWR_REGULATOR_VOLTAGE_SCALE1 or PWR_REGULATOR_VOLTAGE_SCALE2)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
  return (PWR->CR1 & PWR_CR1_VOS);
 c008ba8:	4b02      	ldr	r3, [pc, #8]	; (c008bb4 <HAL_PWREx_GetVoltageRange+0xc>)
 c008baa:	6818      	ldr	r0, [r3, #0]
}
 c008bac:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 c008bb0:	4770      	bx	lr
 c008bb2:	bf00      	nop
 c008bb4:	50007000 	.word	0x50007000

0c008bb8 <HAL_PWREx_ConfigSRAM2ContentRetention>:
{
  /* Check the parameters */
  assert_param(IS_PWR_SRAM2CONTENT_RETENTION(SRAM2ContentRetention));

  /* Set RRS bits */
  MODIFY_REG(PWR->CR3, PWR_CR3_RRS, SRAM2ContentRetention);
 c008bb8:	4a03      	ldr	r2, [pc, #12]	; (c008bc8 <HAL_PWREx_ConfigSRAM2ContentRetention+0x10>)
 c008bba:	6893      	ldr	r3, [r2, #8]
 c008bbc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 c008bc0:	4318      	orrs	r0, r3
 c008bc2:	6090      	str	r0, [r2, #8]

  return HAL_OK;
}
 c008bc4:	2000      	movs	r0, #0
 c008bc6:	4770      	bx	lr
 c008bc8:	50007000 	.word	0x50007000

0c008bcc <HAL_PWREx_EnableSRAM2ContentRetention>:
  *         Standby mode and its content is kept.
  * @retval None
  */
void HAL_PWREx_EnableSRAM2ContentRetention(void)
{
  (void) HAL_PWREx_ConfigSRAM2ContentRetention(PWR_FULL_SRAM2_RETENTION);
 c008bcc:	f44f 7080 	mov.w	r0, #256	; 0x100
 c008bd0:	f7ff bff2 	b.w	c008bb8 <HAL_PWREx_ConfigSRAM2ContentRetention>

0c008bd4 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 c008bd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
  uint32_t vos;

  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 c008bd6:	4c1d      	ldr	r4, [pc, #116]	; (c008c4c <RCC_SetFlashLatencyFromMSIRange+0x78>)
{
 c008bd8:	4605      	mov	r5, r0
  if (__HAL_RCC_PWR_IS_CLK_ENABLED())
 c008bda:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c008bdc:	00da      	lsls	r2, r3, #3
 c008bde:	d518      	bpl.n	c008c12 <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 c008be0:	f7ff ffe2 	bl	c008ba8 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if ((vos == PWR_REGULATOR_VOLTAGE_SCALE0) || (vos == PWR_REGULATOR_VOLTAGE_SCALE1))
 c008be4:	f430 7000 	bics.w	r0, r0, #512	; 0x200
 c008be8:	d123      	bne.n	c008c32 <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if (msirange > RCC_MSIRANGE_8)
 c008bea:	2d80      	cmp	r5, #128	; 0x80
 c008bec:	d903      	bls.n	c008bf6 <RCC_SetFlashLatencyFromMSIRange+0x22>
    {
      /* MSI > 16Mhz */
      if (msirange > RCC_MSIRANGE_10)
 c008bee:	2da0      	cmp	r5, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 c008bf0:	bf8c      	ite	hi
 c008bf2:	2002      	movhi	r0, #2
 c008bf4:	2001      	movls	r0, #1
        /* MSI < 8Mhz default FLASH_LATENCY_0 0WS */
      }
    }
  }

  __HAL_FLASH_SET_LATENCY(latency);
 c008bf6:	4a16      	ldr	r2, [pc, #88]	; (c008c50 <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 c008bf8:	6813      	ldr	r3, [r2, #0]
 c008bfa:	f023 030f 	bic.w	r3, r3, #15
 c008bfe:	4303      	orrs	r3, r0
 c008c00:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if ((FLASH->ACR & FLASH_ACR_LATENCY) != latency)
 c008c02:	6813      	ldr	r3, [r2, #0]
 c008c04:	f003 030f 	and.w	r3, r3, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 c008c08:	1a18      	subs	r0, r3, r0
 c008c0a:	bf18      	it	ne
 c008c0c:	2001      	movne	r0, #1
 c008c0e:	b003      	add	sp, #12
 c008c10:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 c008c12:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c008c14:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c008c18:	65a3      	str	r3, [r4, #88]	; 0x58
 c008c1a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c008c1c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c008c20:	9301      	str	r3, [sp, #4]
 c008c22:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 c008c24:	f7ff ffc0 	bl	c008ba8 <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 c008c28:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c008c2a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c008c2e:	65a3      	str	r3, [r4, #88]	; 0x58
 c008c30:	e7d8      	b.n	c008be4 <RCC_SetFlashLatencyFromMSIRange+0x10>
    if (msirange > RCC_MSIRANGE_8)
 c008c32:	2d80      	cmp	r5, #128	; 0x80
 c008c34:	d805      	bhi.n	c008c42 <RCC_SetFlashLatencyFromMSIRange+0x6e>
      if (msirange == RCC_MSIRANGE_8)
 c008c36:	d006      	beq.n	c008c46 <RCC_SetFlashLatencyFromMSIRange+0x72>
      else if (msirange == RCC_MSIRANGE_7)
 c008c38:	f1a5 0370 	sub.w	r3, r5, #112	; 0x70
 c008c3c:	4258      	negs	r0, r3
 c008c3e:	4158      	adcs	r0, r3
 c008c40:	e7d9      	b.n	c008bf6 <RCC_SetFlashLatencyFromMSIRange+0x22>
      latency = FLASH_LATENCY_3; /* 3WS */
 c008c42:	2003      	movs	r0, #3
 c008c44:	e7d7      	b.n	c008bf6 <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 c008c46:	2002      	movs	r0, #2
 c008c48:	e7d5      	b.n	c008bf6 <RCC_SetFlashLatencyFromMSIRange+0x22>
 c008c4a:	bf00      	nop
 c008c4c:	50021000 	.word	0x50021000
 c008c50:	50022000 	.word	0x50022000

0c008c54 <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c008c54:	4a24      	ldr	r2, [pc, #144]	; (c008ce8 <HAL_RCC_GetSysClockFreq+0x94>)
 c008c56:	6893      	ldr	r3, [r2, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c008c58:	68d1      	ldr	r1, [r2, #12]
  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 c008c5a:	f013 030c 	ands.w	r3, r3, #12
 c008c5e:	d005      	beq.n	c008c6c <HAL_RCC_GetSysClockFreq+0x18>
 c008c60:	2b0c      	cmp	r3, #12
 c008c62:	d116      	bne.n	c008c92 <HAL_RCC_GetSysClockFreq+0x3e>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 c008c64:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 c008c68:	2901      	cmp	r1, #1
 c008c6a:	d119      	bne.n	c008ca0 <HAL_RCC_GetSysClockFreq+0x4c>
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 c008c6c:	6811      	ldr	r1, [r2, #0]
 c008c6e:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c008c70:	bf54      	ite	pl
 c008c72:	f8d2 2094 	ldrpl.w	r2, [r2, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c008c76:	6812      	ldrmi	r2, [r2, #0]
    msirange = MSIRangeTable[msirange];
 c008c78:	491c      	ldr	r1, [pc, #112]	; (c008cec <HAL_RCC_GetSysClockFreq+0x98>)
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 c008c7a:	bf54      	ite	pl
 c008c7c:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 c008c80:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 c008c84:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 c008c88:	b113      	cbz	r3, c008c90 <HAL_RCC_GetSysClockFreq+0x3c>
  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 c008c8a:	2b0c      	cmp	r3, #12
 c008c8c:	d009      	beq.n	c008ca2 <HAL_RCC_GetSysClockFreq+0x4e>
 c008c8e:	2000      	movs	r0, #0
}
 c008c90:	4770      	bx	lr
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 c008c92:	2b04      	cmp	r3, #4
 c008c94:	d026      	beq.n	c008ce4 <HAL_RCC_GetSysClockFreq+0x90>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 c008c96:	2b08      	cmp	r3, #8
 c008c98:	4815      	ldr	r0, [pc, #84]	; (c008cf0 <HAL_RCC_GetSysClockFreq+0x9c>)
 c008c9a:	bf18      	it	ne
 c008c9c:	2000      	movne	r0, #0
 c008c9e:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 c008ca0:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c008ca2:	4a11      	ldr	r2, [pc, #68]	; (c008ce8 <HAL_RCC_GetSysClockFreq+0x94>)
 c008ca4:	68d1      	ldr	r1, [r2, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c008ca6:	68d3      	ldr	r3, [r2, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 c008ca8:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c008cac:	f3c3 1303 	ubfx	r3, r3, #4, #4
    switch (pllsource)
 c008cb0:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 c008cb2:	f103 0301 	add.w	r3, r3, #1
    switch (pllsource)
 c008cb6:	d005      	beq.n	c008cc4 <HAL_RCC_GetSysClockFreq+0x70>
 c008cb8:	2903      	cmp	r1, #3
 c008cba:	d003      	beq.n	c008cc4 <HAL_RCC_GetSysClockFreq+0x70>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c008cbc:	68d2      	ldr	r2, [r2, #12]
 c008cbe:	f3c2 2206 	ubfx	r2, r2, #8, #7
 c008cc2:	e003      	b.n	c008ccc <HAL_RCC_GetSysClockFreq+0x78>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c008cc4:	68d2      	ldr	r2, [r2, #12]
 c008cc6:	480a      	ldr	r0, [pc, #40]	; (c008cf0 <HAL_RCC_GetSysClockFreq+0x9c>)
 c008cc8:	f3c2 2206 	ubfx	r2, r2, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c008ccc:	fbb0 f0f3 	udiv	r0, r0, r3
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c008cd0:	4b05      	ldr	r3, [pc, #20]	; (c008ce8 <HAL_RCC_GetSysClockFreq+0x94>)
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 c008cd2:	4350      	muls	r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 c008cd4:	68db      	ldr	r3, [r3, #12]
 c008cd6:	f3c3 6341 	ubfx	r3, r3, #25, #2
 c008cda:	3301      	adds	r3, #1
 c008cdc:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 c008cde:	fbb0 f0f3 	udiv	r0, r0, r3
 c008ce2:	4770      	bx	lr
 c008ce4:	4802      	ldr	r0, [pc, #8]	; (c008cf0 <HAL_RCC_GetSysClockFreq+0x9c>)
 c008ce6:	4770      	bx	lr
 c008ce8:	50021000 	.word	0x50021000
 c008cec:	0c00fb5c 	.word	0x0c00fb5c
 c008cf0:	00f42400 	.word	0x00f42400

0c008cf4 <HAL_RCC_GetHCLKFreq>:
{
 c008cf4:	b508      	push	{r3, lr}
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 c008cf6:	f7ff ffad 	bl	c008c54 <HAL_RCC_GetSysClockFreq>
 c008cfa:	4b04      	ldr	r3, [pc, #16]	; (c008d0c <HAL_RCC_GetHCLKFreq+0x18>)
 c008cfc:	4a04      	ldr	r2, [pc, #16]	; (c008d10 <HAL_RCC_GetHCLKFreq+0x1c>)
 c008cfe:	689b      	ldr	r3, [r3, #8]
 c008d00:	f3c3 1303 	ubfx	r3, r3, #4, #4
 c008d04:	5cd3      	ldrb	r3, [r2, r3]
}
 c008d06:	40d8      	lsrs	r0, r3
 c008d08:	bd08      	pop	{r3, pc}
 c008d0a:	bf00      	nop
 c008d0c:	50021000 	.word	0x50021000
 c008d10:	0c00fb44 	.word	0x0c00fb44

0c008d14 <HAL_RCC_OscConfig>:
{
 c008d14:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if (RCC_OscInitStruct == NULL)
 c008d18:	4604      	mov	r4, r0
 c008d1a:	b908      	cbnz	r0, c008d20 <HAL_RCC_OscConfig+0xc>
        return HAL_ERROR;
 c008d1c:	2001      	movs	r0, #1
 c008d1e:	e041      	b.n	c008da4 <HAL_RCC_OscConfig+0x90>
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c008d20:	4b9a      	ldr	r3, [pc, #616]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 c008d22:	6802      	ldr	r2, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c008d24:	689e      	ldr	r6, [r3, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 c008d26:	68df      	ldr	r7, [r3, #12]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 c008d28:	06d5      	lsls	r5, r2, #27
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 c008d2a:	f006 060c 	and.w	r6, r6, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 c008d2e:	f007 0703 	and.w	r7, r7, #3
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 c008d32:	d570      	bpl.n	c008e16 <HAL_RCC_OscConfig+0x102>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 c008d34:	b11e      	cbz	r6, c008d3e <HAL_RCC_OscConfig+0x2a>
 c008d36:	2e0c      	cmp	r6, #12
 c008d38:	d14e      	bne.n	c008dd8 <HAL_RCC_OscConfig+0xc4>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_MSI)))
 c008d3a:	2f01      	cmp	r7, #1
 c008d3c:	d14c      	bne.n	c008dd8 <HAL_RCC_OscConfig+0xc4>
      if ((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 c008d3e:	681b      	ldr	r3, [r3, #0]
 c008d40:	0798      	lsls	r0, r3, #30
 c008d42:	d502      	bpl.n	c008d4a <HAL_RCC_OscConfig+0x36>
 c008d44:	69e3      	ldr	r3, [r4, #28]
 c008d46:	2b00      	cmp	r3, #0
 c008d48:	d0e8      	beq.n	c008d1c <HAL_RCC_OscConfig+0x8>
        if (RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 c008d4a:	4b90      	ldr	r3, [pc, #576]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008d4c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 c008d4e:	681a      	ldr	r2, [r3, #0]
 c008d50:	0711      	lsls	r1, r2, #28
 c008d52:	bf56      	itet	pl
 c008d54:	f8d3 2094 	ldrpl.w	r2, [r3, #148]	; 0x94
 c008d58:	681a      	ldrmi	r2, [r3, #0]
 c008d5a:	0912      	lsrpl	r2, r2, #4
 c008d5c:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 c008d60:	4290      	cmp	r0, r2
 c008d62:	d922      	bls.n	c008daa <HAL_RCC_OscConfig+0x96>
          if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 c008d64:	f7ff ff36 	bl	c008bd4 <RCC_SetFlashLatencyFromMSIRange>
 c008d68:	2800      	cmp	r0, #0
 c008d6a:	d1d7      	bne.n	c008d1c <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 c008d6c:	4b87      	ldr	r3, [pc, #540]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008d6e:	681a      	ldr	r2, [r3, #0]
 c008d70:	f042 0208 	orr.w	r2, r2, #8
 c008d74:	601a      	str	r2, [r3, #0]
 c008d76:	681a      	ldr	r2, [r3, #0]
 c008d78:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c008d7a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 c008d7e:	430a      	orrs	r2, r1
 c008d80:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 c008d82:	685a      	ldr	r2, [r3, #4]
 c008d84:	6a21      	ldr	r1, [r4, #32]
 c008d86:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 c008d8a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c008d8e:	605a      	str	r2, [r3, #4]
        SystemCoreClock = HAL_RCC_GetHCLKFreq();
 c008d90:	f7ff ffb0 	bl	c008cf4 <HAL_RCC_GetHCLKFreq>
 c008d94:	4b7e      	ldr	r3, [pc, #504]	; (c008f90 <HAL_RCC_OscConfig+0x27c>)
 c008d96:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 c008d98:	4b7e      	ldr	r3, [pc, #504]	; (c008f94 <HAL_RCC_OscConfig+0x280>)
 c008d9a:	6818      	ldr	r0, [r3, #0]
 c008d9c:	f7fa fb74 	bl	c003488 <HAL_InitTick>
        if (status != HAL_OK)
 c008da0:	2800      	cmp	r0, #0
 c008da2:	d038      	beq.n	c008e16 <HAL_RCC_OscConfig+0x102>
}
 c008da4:	b002      	add	sp, #8
 c008da6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 c008daa:	681a      	ldr	r2, [r3, #0]
 c008dac:	f042 0208 	orr.w	r2, r2, #8
 c008db0:	601a      	str	r2, [r3, #0]
 c008db2:	681a      	ldr	r2, [r3, #0]
 c008db4:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 c008db8:	4302      	orrs	r2, r0
 c008dba:	601a      	str	r2, [r3, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 c008dbc:	685a      	ldr	r2, [r3, #4]
 c008dbe:	6a21      	ldr	r1, [r4, #32]
 c008dc0:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 c008dc4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c008dc8:	605a      	str	r2, [r3, #4]
          if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 c008dca:	2e00      	cmp	r6, #0
 c008dcc:	d1e0      	bne.n	c008d90 <HAL_RCC_OscConfig+0x7c>
            if (RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 c008dce:	f7ff ff01 	bl	c008bd4 <RCC_SetFlashLatencyFromMSIRange>
 c008dd2:	2800      	cmp	r0, #0
 c008dd4:	d0dc      	beq.n	c008d90 <HAL_RCC_OscConfig+0x7c>
 c008dd6:	e7a1      	b.n	c008d1c <HAL_RCC_OscConfig+0x8>
      if (RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 c008dd8:	69e3      	ldr	r3, [r4, #28]
 c008dda:	4d6c      	ldr	r5, [pc, #432]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008ddc:	2b00      	cmp	r3, #0
 c008dde:	d03d      	beq.n	c008e5c <HAL_RCC_OscConfig+0x148>
        __HAL_RCC_MSI_ENABLE();
 c008de0:	682b      	ldr	r3, [r5, #0]
 c008de2:	f043 0301 	orr.w	r3, r3, #1
 c008de6:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 c008de8:	f7fa fb5c 	bl	c0034a4 <HAL_GetTick>
 c008dec:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 c008dee:	682b      	ldr	r3, [r5, #0]
 c008df0:	079b      	lsls	r3, r3, #30
 c008df2:	d528      	bpl.n	c008e46 <HAL_RCC_OscConfig+0x132>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 c008df4:	682b      	ldr	r3, [r5, #0]
 c008df6:	f043 0308 	orr.w	r3, r3, #8
 c008dfa:	602b      	str	r3, [r5, #0]
 c008dfc:	682b      	ldr	r3, [r5, #0]
 c008dfe:	6a62      	ldr	r2, [r4, #36]	; 0x24
 c008e00:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 c008e04:	4313      	orrs	r3, r2
 c008e06:	602b      	str	r3, [r5, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 c008e08:	686b      	ldr	r3, [r5, #4]
 c008e0a:	6a22      	ldr	r2, [r4, #32]
 c008e0c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 c008e10:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c008e14:	606b      	str	r3, [r5, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 c008e16:	6823      	ldr	r3, [r4, #0]
 c008e18:	07da      	lsls	r2, r3, #31
 c008e1a:	d433      	bmi.n	c008e84 <HAL_RCC_OscConfig+0x170>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 c008e1c:	6823      	ldr	r3, [r4, #0]
 c008e1e:	079b      	lsls	r3, r3, #30
 c008e20:	d47e      	bmi.n	c008f20 <HAL_RCC_OscConfig+0x20c>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 c008e22:	6823      	ldr	r3, [r4, #0]
 c008e24:	071d      	lsls	r5, r3, #28
 c008e26:	f100 80cd 	bmi.w	c008fc4 <HAL_RCC_OscConfig+0x2b0>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 c008e2a:	6823      	ldr	r3, [r4, #0]
 c008e2c:	0758      	lsls	r0, r3, #29
 c008e2e:	f100 810c 	bmi.w	c00904a <HAL_RCC_OscConfig+0x336>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 c008e32:	6823      	ldr	r3, [r4, #0]
 c008e34:	069b      	lsls	r3, r3, #26
 c008e36:	f100 81d4 	bmi.w	c0091e2 <HAL_RCC_OscConfig+0x4ce>
  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 c008e3a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 c008e3c:	2800      	cmp	r0, #0
 c008e3e:	f040 8209 	bne.w	c009254 <HAL_RCC_OscConfig+0x540>
  return HAL_OK;
 c008e42:	2000      	movs	r0, #0
 c008e44:	e7ae      	b.n	c008da4 <HAL_RCC_OscConfig+0x90>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 c008e46:	f7fa fb2d 	bl	c0034a4 <HAL_GetTick>
 c008e4a:	eba0 0008 	sub.w	r0, r0, r8
 c008e4e:	2802      	cmp	r0, #2
 c008e50:	d9cd      	bls.n	c008dee <HAL_RCC_OscConfig+0xda>
            if (READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 c008e52:	682b      	ldr	r3, [r5, #0]
 c008e54:	079a      	lsls	r2, r3, #30
 c008e56:	d4ca      	bmi.n	c008dee <HAL_RCC_OscConfig+0xda>
              return HAL_TIMEOUT;
 c008e58:	2003      	movs	r0, #3
 c008e5a:	e7a3      	b.n	c008da4 <HAL_RCC_OscConfig+0x90>
        __HAL_RCC_MSI_DISABLE();
 c008e5c:	682b      	ldr	r3, [r5, #0]
 c008e5e:	f023 0301 	bic.w	r3, r3, #1
 c008e62:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 c008e64:	f7fa fb1e 	bl	c0034a4 <HAL_GetTick>
 c008e68:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 c008e6a:	682b      	ldr	r3, [r5, #0]
 c008e6c:	0799      	lsls	r1, r3, #30
 c008e6e:	d5d2      	bpl.n	c008e16 <HAL_RCC_OscConfig+0x102>
          if ((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 c008e70:	f7fa fb18 	bl	c0034a4 <HAL_GetTick>
 c008e74:	eba0 0008 	sub.w	r0, r0, r8
 c008e78:	2802      	cmp	r0, #2
 c008e7a:	d9f6      	bls.n	c008e6a <HAL_RCC_OscConfig+0x156>
            if (READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 c008e7c:	682b      	ldr	r3, [r5, #0]
 c008e7e:	0798      	lsls	r0, r3, #30
 c008e80:	d4ea      	bmi.n	c008e58 <HAL_RCC_OscConfig+0x144>
 c008e82:	e7f2      	b.n	c008e6a <HAL_RCC_OscConfig+0x156>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE) ||
 c008e84:	2e08      	cmp	r6, #8
 c008e86:	4a41      	ldr	r2, [pc, #260]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008e88:	d003      	beq.n	c008e92 <HAL_RCC_OscConfig+0x17e>
 c008e8a:	2e0c      	cmp	r6, #12
 c008e8c:	d108      	bne.n	c008ea0 <HAL_RCC_OscConfig+0x18c>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSE)))
 c008e8e:	2f03      	cmp	r7, #3
 c008e90:	d106      	bne.n	c008ea0 <HAL_RCC_OscConfig+0x18c>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 c008e92:	6813      	ldr	r3, [r2, #0]
 c008e94:	039d      	lsls	r5, r3, #14
 c008e96:	d5c1      	bpl.n	c008e1c <HAL_RCC_OscConfig+0x108>
 c008e98:	6863      	ldr	r3, [r4, #4]
 c008e9a:	2b00      	cmp	r3, #0
 c008e9c:	d1be      	bne.n	c008e1c <HAL_RCC_OscConfig+0x108>
 c008e9e:	e73d      	b.n	c008d1c <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 c008ea0:	6863      	ldr	r3, [r4, #4]
 c008ea2:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 c008ea6:	d114      	bne.n	c008ed2 <HAL_RCC_OscConfig+0x1be>
 c008ea8:	6813      	ldr	r3, [r2, #0]
 c008eaa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c008eae:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 c008eb0:	f7fa faf8 	bl	c0034a4 <HAL_GetTick>
 c008eb4:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 c008eb6:	4d35      	ldr	r5, [pc, #212]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008eb8:	682b      	ldr	r3, [r5, #0]
 c008eba:	0399      	lsls	r1, r3, #14
 c008ebc:	d4ae      	bmi.n	c008e1c <HAL_RCC_OscConfig+0x108>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 c008ebe:	f7fa faf1 	bl	c0034a4 <HAL_GetTick>
 c008ec2:	eba0 0008 	sub.w	r0, r0, r8
 c008ec6:	2864      	cmp	r0, #100	; 0x64
 c008ec8:	d9f6      	bls.n	c008eb8 <HAL_RCC_OscConfig+0x1a4>
            if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 c008eca:	682b      	ldr	r3, [r5, #0]
 c008ecc:	0398      	lsls	r0, r3, #14
 c008ece:	d5c3      	bpl.n	c008e58 <HAL_RCC_OscConfig+0x144>
 c008ed0:	e7f2      	b.n	c008eb8 <HAL_RCC_OscConfig+0x1a4>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 c008ed2:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 c008ed6:	4d2d      	ldr	r5, [pc, #180]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008ed8:	d108      	bne.n	c008eec <HAL_RCC_OscConfig+0x1d8>
 c008eda:	682b      	ldr	r3, [r5, #0]
 c008edc:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 c008ee0:	602b      	str	r3, [r5, #0]
 c008ee2:	682b      	ldr	r3, [r5, #0]
 c008ee4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c008ee8:	602b      	str	r3, [r5, #0]
 c008eea:	e7e1      	b.n	c008eb0 <HAL_RCC_OscConfig+0x19c>
 c008eec:	682a      	ldr	r2, [r5, #0]
 c008eee:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 c008ef2:	602a      	str	r2, [r5, #0]
 c008ef4:	682a      	ldr	r2, [r5, #0]
 c008ef6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 c008efa:	602a      	str	r2, [r5, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 c008efc:	2b00      	cmp	r3, #0
 c008efe:	d1d7      	bne.n	c008eb0 <HAL_RCC_OscConfig+0x19c>
        tickstart = HAL_GetTick();
 c008f00:	f7fa fad0 	bl	c0034a4 <HAL_GetTick>
 c008f04:	4680      	mov	r8, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 c008f06:	682b      	ldr	r3, [r5, #0]
 c008f08:	039b      	lsls	r3, r3, #14
 c008f0a:	d587      	bpl.n	c008e1c <HAL_RCC_OscConfig+0x108>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 c008f0c:	f7fa faca 	bl	c0034a4 <HAL_GetTick>
 c008f10:	eba0 0008 	sub.w	r0, r0, r8
 c008f14:	2864      	cmp	r0, #100	; 0x64
 c008f16:	d9f6      	bls.n	c008f06 <HAL_RCC_OscConfig+0x1f2>
            if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 c008f18:	682b      	ldr	r3, [r5, #0]
 c008f1a:	039a      	lsls	r2, r3, #14
 c008f1c:	d49c      	bmi.n	c008e58 <HAL_RCC_OscConfig+0x144>
 c008f1e:	e7f2      	b.n	c008f06 <HAL_RCC_OscConfig+0x1f2>
    if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI) ||
 c008f20:	2e04      	cmp	r6, #4
 c008f22:	4b1a      	ldr	r3, [pc, #104]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008f24:	d003      	beq.n	c008f2e <HAL_RCC_OscConfig+0x21a>
 c008f26:	2e0c      	cmp	r6, #12
 c008f28:	d111      	bne.n	c008f4e <HAL_RCC_OscConfig+0x23a>
        ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_config == RCC_PLLSOURCE_HSI)))
 c008f2a:	2f02      	cmp	r7, #2
 c008f2c:	d10f      	bne.n	c008f4e <HAL_RCC_OscConfig+0x23a>
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 c008f2e:	681b      	ldr	r3, [r3, #0]
 c008f30:	0558      	lsls	r0, r3, #21
 c008f32:	d503      	bpl.n	c008f3c <HAL_RCC_OscConfig+0x228>
 c008f34:	68e3      	ldr	r3, [r4, #12]
 c008f36:	2b00      	cmp	r3, #0
 c008f38:	f43f aef0 	beq.w	c008d1c <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 c008f3c:	4a13      	ldr	r2, [pc, #76]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
 c008f3e:	6921      	ldr	r1, [r4, #16]
 c008f40:	6853      	ldr	r3, [r2, #4]
 c008f42:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 c008f46:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 c008f4a:	6053      	str	r3, [r2, #4]
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 c008f4c:	e769      	b.n	c008e22 <HAL_RCC_OscConfig+0x10e>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 c008f4e:	68e2      	ldr	r2, [r4, #12]
 c008f50:	b312      	cbz	r2, c008f98 <HAL_RCC_OscConfig+0x284>
        __HAL_RCC_HSI_ENABLE();
 c008f52:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c008f54:	4d0d      	ldr	r5, [pc, #52]	; (c008f8c <HAL_RCC_OscConfig+0x278>)
        __HAL_RCC_HSI_ENABLE();
 c008f56:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c008f5a:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 c008f5c:	f7fa faa2 	bl	c0034a4 <HAL_GetTick>
 c008f60:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c008f62:	682b      	ldr	r3, [r5, #0]
 c008f64:	055a      	lsls	r2, r3, #21
 c008f66:	d507      	bpl.n	c008f78 <HAL_RCC_OscConfig+0x264>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 c008f68:	686b      	ldr	r3, [r5, #4]
 c008f6a:	6922      	ldr	r2, [r4, #16]
 c008f6c:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 c008f70:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 c008f74:	606b      	str	r3, [r5, #4]
 c008f76:	e754      	b.n	c008e22 <HAL_RCC_OscConfig+0x10e>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 c008f78:	f7fa fa94 	bl	c0034a4 <HAL_GetTick>
 c008f7c:	1b80      	subs	r0, r0, r6
 c008f7e:	2802      	cmp	r0, #2
 c008f80:	d9ef      	bls.n	c008f62 <HAL_RCC_OscConfig+0x24e>
            if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 c008f82:	682b      	ldr	r3, [r5, #0]
 c008f84:	0559      	lsls	r1, r3, #21
 c008f86:	f57f af67 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c008f8a:	e7ea      	b.n	c008f62 <HAL_RCC_OscConfig+0x24e>
 c008f8c:	50021000 	.word	0x50021000
 c008f90:	300300a0 	.word	0x300300a0
 c008f94:	300300b0 	.word	0x300300b0
        __HAL_RCC_HSI_DISABLE();
 c008f98:	681a      	ldr	r2, [r3, #0]
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 c008f9a:	4dac      	ldr	r5, [pc, #688]	; (c00924c <HAL_RCC_OscConfig+0x538>)
        __HAL_RCC_HSI_DISABLE();
 c008f9c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 c008fa0:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 c008fa2:	f7fa fa7f 	bl	c0034a4 <HAL_GetTick>
 c008fa6:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 c008fa8:	682b      	ldr	r3, [r5, #0]
 c008faa:	055f      	lsls	r7, r3, #21
 c008fac:	f57f af39 	bpl.w	c008e22 <HAL_RCC_OscConfig+0x10e>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 c008fb0:	f7fa fa78 	bl	c0034a4 <HAL_GetTick>
 c008fb4:	1b80      	subs	r0, r0, r6
 c008fb6:	2802      	cmp	r0, #2
 c008fb8:	d9f6      	bls.n	c008fa8 <HAL_RCC_OscConfig+0x294>
            if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 c008fba:	682b      	ldr	r3, [r5, #0]
 c008fbc:	055b      	lsls	r3, r3, #21
 c008fbe:	f53f af4b 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c008fc2:	e7f1      	b.n	c008fa8 <HAL_RCC_OscConfig+0x294>
    if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 c008fc4:	6963      	ldr	r3, [r4, #20]
 c008fc6:	4da1      	ldr	r5, [pc, #644]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c008fc8:	b333      	cbz	r3, c009018 <HAL_RCC_OscConfig+0x304>
      if (RCC_OscInitStruct->LSIDiv == RCC_LSI_DIV1)
 c008fca:	69a3      	ldr	r3, [r4, #24]
 c008fcc:	b9fb      	cbnz	r3, c00900e <HAL_RCC_OscConfig+0x2fa>
        CLEAR_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 c008fce:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c008fd2:	f023 0310 	bic.w	r3, r3, #16
        SET_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 c008fd6:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      __HAL_RCC_LSI_ENABLE();
 c008fda:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c008fde:	f043 0301 	orr.w	r3, r3, #1
 c008fe2:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 c008fe6:	f7fa fa5d 	bl	c0034a4 <HAL_GetTick>
 c008fea:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 c008fec:	4d97      	ldr	r5, [pc, #604]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c008fee:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c008ff2:	079a      	lsls	r2, r3, #30
 c008ff4:	f53f af19 	bmi.w	c008e2a <HAL_RCC_OscConfig+0x116>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 c008ff8:	f7fa fa54 	bl	c0034a4 <HAL_GetTick>
 c008ffc:	1b80      	subs	r0, r0, r6
 c008ffe:	2807      	cmp	r0, #7
 c009000:	d9f5      	bls.n	c008fee <HAL_RCC_OscConfig+0x2da>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 c009002:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c009006:	0799      	lsls	r1, r3, #30
 c009008:	f57f af26 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c00900c:	e7ef      	b.n	c008fee <HAL_RCC_OscConfig+0x2da>
        SET_BIT(RCC->CSR, RCC_CSR_LSIPRE);
 c00900e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c009012:	f043 0310 	orr.w	r3, r3, #16
 c009016:	e7de      	b.n	c008fd6 <HAL_RCC_OscConfig+0x2c2>
      __HAL_RCC_LSI_DISABLE();
 c009018:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c00901c:	f023 0301 	bic.w	r3, r3, #1
 c009020:	f8c5 3094 	str.w	r3, [r5, #148]	; 0x94
      tickstart = HAL_GetTick();
 c009024:	f7fa fa3e 	bl	c0034a4 <HAL_GetTick>
 c009028:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 c00902a:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c00902e:	079f      	lsls	r7, r3, #30
 c009030:	f57f aefb 	bpl.w	c008e2a <HAL_RCC_OscConfig+0x116>
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 c009034:	f7fa fa36 	bl	c0034a4 <HAL_GetTick>
 c009038:	1b80      	subs	r0, r0, r6
 c00903a:	2807      	cmp	r0, #7
 c00903c:	d9f5      	bls.n	c00902a <HAL_RCC_OscConfig+0x316>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 c00903e:	f8d5 3094 	ldr.w	r3, [r5, #148]	; 0x94
 c009042:	079b      	lsls	r3, r3, #30
 c009044:	f53f af08 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c009048:	e7ef      	b.n	c00902a <HAL_RCC_OscConfig+0x316>
    if (HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 c00904a:	4b80      	ldr	r3, [pc, #512]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c00904c:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c00904e:	00d0      	lsls	r0, r2, #3
 c009050:	d446      	bmi.n	c0090e0 <HAL_RCC_OscConfig+0x3cc>
      pwrclkchanged = SET;
 c009052:	2601      	movs	r6, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 c009054:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c009056:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c00905a:	659a      	str	r2, [r3, #88]	; 0x58
 c00905c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c00905e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c009062:	9301      	str	r3, [sp, #4]
 c009064:	9b01      	ldr	r3, [sp, #4]
    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 c009066:	4d7a      	ldr	r5, [pc, #488]	; (c009250 <HAL_RCC_OscConfig+0x53c>)
 c009068:	682b      	ldr	r3, [r5, #0]
 c00906a:	05d9      	lsls	r1, r3, #23
 c00906c:	d53a      	bpl.n	c0090e4 <HAL_RCC_OscConfig+0x3d0>
    if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEON) != 0U)
 c00906e:	68a3      	ldr	r3, [r4, #8]
 c009070:	4d76      	ldr	r5, [pc, #472]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c009072:	f013 0f01 	tst.w	r3, #1
 c009076:	d149      	bne.n	c00910c <HAL_RCC_OscConfig+0x3f8>
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 c009078:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 c00907c:	f022 0201 	bic.w	r2, r2, #1
 c009080:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
      CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 c009084:	f8d5 2090 	ldr.w	r2, [r5, #144]	; 0x90
 c009088:	f022 0204 	bic.w	r2, r2, #4
 c00908c:	f8c5 2090 	str.w	r2, [r5, #144]	; 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 c009090:	2b00      	cmp	r3, #0
 c009092:	d14a      	bne.n	c00912a <HAL_RCC_OscConfig+0x416>
      tickstart = HAL_GetTick();
 c009094:	f7fa fa06 	bl	c0034a4 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c009098:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 c00909c:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 c00909e:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0090a2:	079b      	lsls	r3, r3, #30
 c0090a4:	f100 8091 	bmi.w	c0091ca <HAL_RCC_OscConfig+0x4b6>
      if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN) != 0U)
 c0090a8:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0090ac:	0618      	lsls	r0, r3, #24
 c0090ae:	d557      	bpl.n	c009160 <HAL_RCC_OscConfig+0x44c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0090b0:	f241 3888 	movw	r8, #5000	; 0x1388
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c0090b4:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0090b8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c0090bc:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 c0090c0:	4d62      	ldr	r5, [pc, #392]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c0090c2:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0090c6:	051a      	lsls	r2, r3, #20
 c0090c8:	d54a      	bpl.n	c009160 <HAL_RCC_OscConfig+0x44c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0090ca:	f7fa f9eb 	bl	c0034a4 <HAL_GetTick>
 c0090ce:	1bc0      	subs	r0, r0, r7
 c0090d0:	4540      	cmp	r0, r8
 c0090d2:	d9f6      	bls.n	c0090c2 <HAL_RCC_OscConfig+0x3ae>
            if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 c0090d4:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0090d8:	0519      	lsls	r1, r3, #20
 c0090da:	f53f aebd 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c0090de:	e7f0      	b.n	c0090c2 <HAL_RCC_OscConfig+0x3ae>
    FlagStatus       pwrclkchanged = RESET;
 c0090e0:	2600      	movs	r6, #0
 c0090e2:	e7c0      	b.n	c009066 <HAL_RCC_OscConfig+0x352>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 c0090e4:	682b      	ldr	r3, [r5, #0]
 c0090e6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c0090ea:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 c0090ec:	f7fa f9da 	bl	c0034a4 <HAL_GetTick>
 c0090f0:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 c0090f2:	682b      	ldr	r3, [r5, #0]
 c0090f4:	05db      	lsls	r3, r3, #23
 c0090f6:	d4ba      	bmi.n	c00906e <HAL_RCC_OscConfig+0x35a>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 c0090f8:	f7fa f9d4 	bl	c0034a4 <HAL_GetTick>
 c0090fc:	1bc0      	subs	r0, r0, r7
 c0090fe:	2802      	cmp	r0, #2
 c009100:	d9f7      	bls.n	c0090f2 <HAL_RCC_OscConfig+0x3de>
          if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 c009102:	682b      	ldr	r3, [r5, #0]
 c009104:	05da      	lsls	r2, r3, #23
 c009106:	f57f aea7 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c00910a:	e7f2      	b.n	c0090f2 <HAL_RCC_OscConfig+0x3de>
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSEBYP) != 0U)
 c00910c:	f013 0f04 	tst.w	r3, #4
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEBYP);
 c009110:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c009114:	bf1e      	ittt	ne
 c009116:	f043 0304 	orrne.w	r3, r3, #4
 c00911a:	f8c5 3090 	strne.w	r3, [r5, #144]	; 0x90
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 c00911e:	f8d5 3090 	ldrne.w	r3, [r5, #144]	; 0x90
        SET_BIT(RCC->BDCR, RCC_BDCR_LSEON);
 c009122:	f043 0301 	orr.w	r3, r3, #1
 c009126:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
      tickstart = HAL_GetTick();
 c00912a:	f7fa f9bb 	bl	c0034a4 <HAL_GetTick>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c00912e:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 c009132:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 c009134:	4d45      	ldr	r5, [pc, #276]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c009136:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c00913a:	0799      	lsls	r1, r3, #30
 c00913c:	d519      	bpl.n	c009172 <HAL_RCC_OscConfig+0x45e>
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 c00913e:	68a3      	ldr	r3, [r4, #8]
 c009140:	f013 0f80 	tst.w	r3, #128	; 0x80
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c009144:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
      if ((RCC_OscInitStruct->LSEState & RCC_BDCR_LSESYSEN) != 0U)
 c009148:	d029      	beq.n	c00919e <HAL_RCC_OscConfig+0x48a>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c00914a:	f241 3888 	movw	r8, #5000	; 0x1388
        SET_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c00914e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c009152:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 c009156:	4d3d      	ldr	r5, [pc, #244]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c009158:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c00915c:	051b      	lsls	r3, r3, #20
 c00915e:	d513      	bpl.n	c009188 <HAL_RCC_OscConfig+0x474>
    if (pwrclkchanged == SET)
 c009160:	2e00      	cmp	r6, #0
 c009162:	f43f ae66 	beq.w	c008e32 <HAL_RCC_OscConfig+0x11e>
      __HAL_RCC_PWR_CLK_DISABLE();
 c009166:	4a39      	ldr	r2, [pc, #228]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c009168:	6d93      	ldr	r3, [r2, #88]	; 0x58
 c00916a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c00916e:	6593      	str	r3, [r2, #88]	; 0x58
 c009170:	e65f      	b.n	c008e32 <HAL_RCC_OscConfig+0x11e>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c009172:	f7fa f997 	bl	c0034a4 <HAL_GetTick>
 c009176:	1bc0      	subs	r0, r0, r7
 c009178:	4540      	cmp	r0, r8
 c00917a:	d9dc      	bls.n	c009136 <HAL_RCC_OscConfig+0x422>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 c00917c:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c009180:	0798      	lsls	r0, r3, #30
 c009182:	f57f ae69 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c009186:	e7d6      	b.n	c009136 <HAL_RCC_OscConfig+0x422>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c009188:	f7fa f98c 	bl	c0034a4 <HAL_GetTick>
 c00918c:	1bc0      	subs	r0, r0, r7
 c00918e:	4540      	cmp	r0, r8
 c009190:	d9e2      	bls.n	c009158 <HAL_RCC_OscConfig+0x444>
            if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) == 0U)
 c009192:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c009196:	051a      	lsls	r2, r3, #20
 c009198:	f57f ae5e 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c00919c:	e7dc      	b.n	c009158 <HAL_RCC_OscConfig+0x444>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c00919e:	f241 3888 	movw	r8, #5000	; 0x1388
        CLEAR_BIT(RCC->BDCR, RCC_BDCR_LSESYSEN);
 c0091a2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c0091a6:	f8c5 3090 	str.w	r3, [r5, #144]	; 0x90
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 c0091aa:	4d28      	ldr	r5, [pc, #160]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c0091ac:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0091b0:	0519      	lsls	r1, r3, #20
 c0091b2:	d5d5      	bpl.n	c009160 <HAL_RCC_OscConfig+0x44c>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0091b4:	f7fa f976 	bl	c0034a4 <HAL_GetTick>
 c0091b8:	1bc0      	subs	r0, r0, r7
 c0091ba:	4540      	cmp	r0, r8
 c0091bc:	d9f6      	bls.n	c0091ac <HAL_RCC_OscConfig+0x498>
            if (READ_BIT(RCC->BDCR, RCC_BDCR_LSESYSRDY) != 0U)
 c0091be:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0091c2:	0518      	lsls	r0, r3, #20
 c0091c4:	f53f ae48 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c0091c8:	e7f0      	b.n	c0091ac <HAL_RCC_OscConfig+0x498>
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0091ca:	f7fa f96b 	bl	c0034a4 <HAL_GetTick>
 c0091ce:	1bc0      	subs	r0, r0, r7
 c0091d0:	4540      	cmp	r0, r8
 c0091d2:	f67f af64 	bls.w	c00909e <HAL_RCC_OscConfig+0x38a>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 c0091d6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
 c0091da:	079a      	lsls	r2, r3, #30
 c0091dc:	f53f ae3c 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c0091e0:	e75d      	b.n	c00909e <HAL_RCC_OscConfig+0x38a>
    if (RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 c0091e2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c0091e4:	4d19      	ldr	r5, [pc, #100]	; (c00924c <HAL_RCC_OscConfig+0x538>)
 c0091e6:	b1c3      	cbz	r3, c00921a <HAL_RCC_OscConfig+0x506>
      __HAL_RCC_HSI48_ENABLE();
 c0091e8:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c0091ec:	f043 0301 	orr.w	r3, r3, #1
 c0091f0:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
      tickstart = HAL_GetTick();
 c0091f4:	f7fa f956 	bl	c0034a4 <HAL_GetTick>
 c0091f8:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 c0091fa:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c0091fe:	0798      	lsls	r0, r3, #30
 c009200:	f53f ae1b 	bmi.w	c008e3a <HAL_RCC_OscConfig+0x126>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 c009204:	f7fa f94e 	bl	c0034a4 <HAL_GetTick>
 c009208:	1b80      	subs	r0, r0, r6
 c00920a:	2802      	cmp	r0, #2
 c00920c:	d9f5      	bls.n	c0091fa <HAL_RCC_OscConfig+0x4e6>
          if (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 c00920e:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c009212:	079f      	lsls	r7, r3, #30
 c009214:	f57f ae20 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c009218:	e7ef      	b.n	c0091fa <HAL_RCC_OscConfig+0x4e6>
      __HAL_RCC_HSI48_DISABLE();
 c00921a:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c00921e:	f023 0301 	bic.w	r3, r3, #1
 c009222:	f8c5 3098 	str.w	r3, [r5, #152]	; 0x98
      tickstart = HAL_GetTick();
 c009226:	f7fa f93d 	bl	c0034a4 <HAL_GetTick>
 c00922a:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 c00922c:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c009230:	079a      	lsls	r2, r3, #30
 c009232:	f57f ae02 	bpl.w	c008e3a <HAL_RCC_OscConfig+0x126>
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 c009236:	f7fa f935 	bl	c0034a4 <HAL_GetTick>
 c00923a:	1b80      	subs	r0, r0, r6
 c00923c:	2802      	cmp	r0, #2
 c00923e:	d9f5      	bls.n	c00922c <HAL_RCC_OscConfig+0x518>
          if (READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 c009240:	f8d5 3098 	ldr.w	r3, [r5, #152]	; 0x98
 c009244:	0799      	lsls	r1, r3, #30
 c009246:	f53f ae07 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c00924a:	e7ef      	b.n	c00922c <HAL_RCC_OscConfig+0x518>
 c00924c:	50021000 	.word	0x50021000
 c009250:	50007000 	.word	0x50007000
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 c009254:	4d51      	ldr	r5, [pc, #324]	; (c00939c <HAL_RCC_OscConfig+0x688>)
 c009256:	68ab      	ldr	r3, [r5, #8]
 c009258:	f003 030c 	and.w	r3, r3, #12
 c00925c:	2b0c      	cmp	r3, #12
 c00925e:	d069      	beq.n	c009334 <HAL_RCC_OscConfig+0x620>
        __HAL_RCC_PLL_DISABLE();
 c009260:	682b      	ldr	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 c009262:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 c009264:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 c009268:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 c00926a:	d143      	bne.n	c0092f4 <HAL_RCC_OscConfig+0x5e0>
        tickstart = HAL_GetTick();
 c00926c:	f7fa f91a 	bl	c0034a4 <HAL_GetTick>
 c009270:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 c009272:	682b      	ldr	r3, [r5, #0]
 c009274:	019f      	lsls	r7, r3, #6
 c009276:	d433      	bmi.n	c0092e0 <HAL_RCC_OscConfig+0x5cc>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 c009278:	68ea      	ldr	r2, [r5, #12]
 c00927a:	4b49      	ldr	r3, [pc, #292]	; (c0093a0 <HAL_RCC_OscConfig+0x68c>)
 c00927c:	4013      	ands	r3, r2
 c00927e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 c009280:	4313      	orrs	r3, r2
 c009282:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 c009284:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c009288:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 c00928a:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 c00928e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 c009290:	3a01      	subs	r2, #1
 c009292:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 c009296:	6c22      	ldr	r2, [r4, #64]	; 0x40
 c009298:	0852      	lsrs	r2, r2, #1
 c00929a:	3a01      	subs	r2, #1
 c00929c:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 c0092a0:	6c62      	ldr	r2, [r4, #68]	; 0x44
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 c0092a2:	4c3e      	ldr	r4, [pc, #248]	; (c00939c <HAL_RCC_OscConfig+0x688>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 c0092a4:	0852      	lsrs	r2, r2, #1
 c0092a6:	3a01      	subs	r2, #1
 c0092a8:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 c0092ac:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 c0092ae:	682b      	ldr	r3, [r5, #0]
 c0092b0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 c0092b4:	602b      	str	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 c0092b6:	68eb      	ldr	r3, [r5, #12]
 c0092b8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 c0092bc:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 c0092be:	f7fa f8f1 	bl	c0034a4 <HAL_GetTick>
 c0092c2:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 c0092c4:	6823      	ldr	r3, [r4, #0]
 c0092c6:	0199      	lsls	r1, r3, #6
 c0092c8:	f53f adbb 	bmi.w	c008e42 <HAL_RCC_OscConfig+0x12e>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 c0092cc:	f7fa f8ea 	bl	c0034a4 <HAL_GetTick>
 c0092d0:	1b40      	subs	r0, r0, r5
 c0092d2:	2802      	cmp	r0, #2
 c0092d4:	d9f6      	bls.n	c0092c4 <HAL_RCC_OscConfig+0x5b0>
            if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 c0092d6:	6823      	ldr	r3, [r4, #0]
 c0092d8:	0198      	lsls	r0, r3, #6
 c0092da:	f57f adbd 	bpl.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c0092de:	e7f1      	b.n	c0092c4 <HAL_RCC_OscConfig+0x5b0>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 c0092e0:	f7fa f8e0 	bl	c0034a4 <HAL_GetTick>
 c0092e4:	1b80      	subs	r0, r0, r6
 c0092e6:	2802      	cmp	r0, #2
 c0092e8:	d9c3      	bls.n	c009272 <HAL_RCC_OscConfig+0x55e>
            if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 c0092ea:	682b      	ldr	r3, [r5, #0]
 c0092ec:	019b      	lsls	r3, r3, #6
 c0092ee:	f53f adb3 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c0092f2:	e7be      	b.n	c009272 <HAL_RCC_OscConfig+0x55e>
        if (READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 c0092f4:	682b      	ldr	r3, [r5, #0]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 c0092f6:	4c29      	ldr	r4, [pc, #164]	; (c00939c <HAL_RCC_OscConfig+0x688>)
        if (READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 c0092f8:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 c0092fc:	bf02      	ittt	eq
 c0092fe:	68eb      	ldreq	r3, [r5, #12]
 c009300:	f023 0303 	biceq.w	r3, r3, #3
 c009304:	60eb      	streq	r3, [r5, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 c009306:	68e3      	ldr	r3, [r4, #12]
 c009308:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 c00930c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 c009310:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 c009312:	f7fa f8c7 	bl	c0034a4 <HAL_GetTick>
 c009316:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 c009318:	6823      	ldr	r3, [r4, #0]
 c00931a:	019b      	lsls	r3, r3, #6
 c00931c:	f57f ad91 	bpl.w	c008e42 <HAL_RCC_OscConfig+0x12e>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 c009320:	f7fa f8c0 	bl	c0034a4 <HAL_GetTick>
 c009324:	1b40      	subs	r0, r0, r5
 c009326:	2802      	cmp	r0, #2
 c009328:	d9f6      	bls.n	c009318 <HAL_RCC_OscConfig+0x604>
            if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 c00932a:	6823      	ldr	r3, [r4, #0]
 c00932c:	019a      	lsls	r2, r3, #6
 c00932e:	f53f ad93 	bmi.w	c008e58 <HAL_RCC_OscConfig+0x144>
 c009332:	e7f1      	b.n	c009318 <HAL_RCC_OscConfig+0x604>
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_OFF)
 c009334:	2801      	cmp	r0, #1
 c009336:	f43f ad35 	beq.w	c008da4 <HAL_RCC_OscConfig+0x90>
        pll_config = RCC->PLLCFGR;
 c00933a:	68eb      	ldr	r3, [r5, #12]
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 c00933c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 c00933e:	f003 0103 	and.w	r1, r3, #3
 c009342:	4291      	cmp	r1, r2
 c009344:	f47f acea 	bne.w	c008d1c <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 c009348:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c00934a:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 c00934e:	3901      	subs	r1, #1
        if ((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 c009350:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 c009354:	f47f ace2 	bne.w	c008d1c <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 c009358:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 c00935a:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 c00935e:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 c009362:	f47f acdb 	bne.w	c008d1c <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 c009366:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 c009368:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 c00936c:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 c009370:	f47f acd4 	bne.w	c008d1c <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 c009374:	6c22      	ldr	r2, [r4, #64]	; 0x40
 c009376:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 c00937a:	0852      	lsrs	r2, r2, #1
 c00937c:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 c00937e:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 c009382:	f47f accb 	bne.w	c008d1c <HAL_RCC_OscConfig+0x8>
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 c009386:	6c62      	ldr	r2, [r4, #68]	; 0x44
 c009388:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 c00938c:	0852      	lsrs	r2, r2, #1
 c00938e:	3a01      	subs	r2, #1
            (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 c009390:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
    return HAL_ERROR;
 c009394:	bf14      	ite	ne
 c009396:	2001      	movne	r0, #1
 c009398:	2000      	moveq	r0, #0
 c00939a:	e503      	b.n	c008da4 <HAL_RCC_OscConfig+0x90>
 c00939c:	50021000 	.word	0x50021000
 c0093a0:	019f800c 	.word	0x019f800c

0c0093a4 <HAL_RCC_GetPCLK1Freq>:
{
 c0093a4:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 c0093a6:	f7ff fca5 	bl	c008cf4 <HAL_RCC_GetHCLKFreq>
 c0093aa:	4b04      	ldr	r3, [pc, #16]	; (c0093bc <HAL_RCC_GetPCLK1Freq+0x18>)
 c0093ac:	4a04      	ldr	r2, [pc, #16]	; (c0093c0 <HAL_RCC_GetPCLK1Freq+0x1c>)
 c0093ae:	689b      	ldr	r3, [r3, #8]
 c0093b0:	f3c3 2302 	ubfx	r3, r3, #8, #3
 c0093b4:	5cd3      	ldrb	r3, [r2, r3]
}
 c0093b6:	40d8      	lsrs	r0, r3
 c0093b8:	bd08      	pop	{r3, pc}
 c0093ba:	bf00      	nop
 c0093bc:	50021000 	.word	0x50021000
 c0093c0:	0c00fb54 	.word	0x0c00fb54

0c0093c4 <HAL_RCC_GetPCLK2Freq>:
{
 c0093c4:	b508      	push	{r3, lr}
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 c0093c6:	f7ff fc95 	bl	c008cf4 <HAL_RCC_GetHCLKFreq>
 c0093ca:	4b04      	ldr	r3, [pc, #16]	; (c0093dc <HAL_RCC_GetPCLK2Freq+0x18>)
 c0093cc:	4a04      	ldr	r2, [pc, #16]	; (c0093e0 <HAL_RCC_GetPCLK2Freq+0x1c>)
 c0093ce:	689b      	ldr	r3, [r3, #8]
 c0093d0:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 c0093d4:	5cd3      	ldrb	r3, [r2, r3]
}
 c0093d6:	40d8      	lsrs	r0, r3
 c0093d8:	bd08      	pop	{r3, pc}
 c0093da:	bf00      	nop
 c0093dc:	50021000 	.word	0x50021000
 c0093e0:	0c00fb54 	.word	0x0c00fb54

0c0093e4 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *pPllSai1, uint32_t Divider)
{
 c0093e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c0093e6:	4604      	mov	r4, r0
  assert_param(IS_RCC_PLLSAI1M_VALUE(pPllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(pPllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(pPllSai1->PLLSAI1ClockOut));

  /* Check PLLSAI1 clock source availability */
  switch (pPllSai1->PLLSAI1Source)
 c0093e8:	6800      	ldr	r0, [r0, #0]
{
 c0093ea:	460f      	mov	r7, r1
  switch (pPllSai1->PLLSAI1Source)
 c0093ec:	2802      	cmp	r0, #2
 c0093ee:	d008      	beq.n	c009402 <RCCEx_PLLSAI1_Config+0x1e>
 c0093f0:	2803      	cmp	r0, #3
 c0093f2:	d036      	beq.n	c009462 <RCCEx_PLLSAI1_Config+0x7e>
 c0093f4:	2801      	cmp	r0, #1
 c0093f6:	d16d      	bne.n	c0094d4 <RCCEx_PLLSAI1_Config+0xf0>
  {
    case RCC_PLLSOURCE_MSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 c0093f8:	4b37      	ldr	r3, [pc, #220]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
 c0093fa:	681b      	ldr	r3, [r3, #0]
 c0093fc:	079d      	lsls	r5, r3, #30
 c0093fe:	d405      	bmi.n	c00940c <RCCEx_PLLSAI1_Config+0x28>
      }
    }
  }

  return status;
}
 c009400:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 c009402:	4b35      	ldr	r3, [pc, #212]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
 c009404:	681b      	ldr	r3, [r3, #0]
 c009406:	f413 6f80 	tst.w	r3, #1024	; 0x400
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c00940a:	d063      	beq.n	c0094d4 <RCCEx_PLLSAI1_Config+0xf0>
    __HAL_RCC_PLLSAI1_DISABLE();
 c00940c:	4d32      	ldr	r5, [pc, #200]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
 c00940e:	682b      	ldr	r3, [r5, #0]
 c009410:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 c009414:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 c009416:	f7fa f845 	bl	c0034a4 <HAL_GetTick>
 c00941a:	4606      	mov	r6, r0
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 c00941c:	682b      	ldr	r3, [r5, #0]
 c00941e:	0119      	lsls	r1, r3, #4
 c009420:	d507      	bpl.n	c009432 <RCCEx_PLLSAI1_Config+0x4e>
      if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 c009422:	f7fa f83f 	bl	c0034a4 <HAL_GetTick>
 c009426:	1b80      	subs	r0, r0, r6
 c009428:	2802      	cmp	r0, #2
 c00942a:	d9f7      	bls.n	c00941c <RCCEx_PLLSAI1_Config+0x38>
        if (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 c00942c:	682b      	ldr	r3, [r5, #0]
 c00942e:	0118      	lsls	r0, r3, #4
 c009430:	d41c      	bmi.n	c00946c <RCCEx_PLLSAI1_Config+0x88>
 c009432:	68a3      	ldr	r3, [r4, #8]
 c009434:	f8d4 c000 	ldr.w	ip, [r4]
 c009438:	021e      	lsls	r6, r3, #8
 c00943a:	6863      	ldr	r3, [r4, #4]
 c00943c:	4826      	ldr	r0, [pc, #152]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
 c00943e:	3b01      	subs	r3, #1
 c009440:	011d      	lsls	r5, r3, #4
      if (Divider == DIVIDER_P_UPDATE)
 c009442:	b1af      	cbz	r7, c009470 <RCCEx_PLLSAI1_Config+0x8c>
      else if (Divider == DIVIDER_Q_UPDATE)
 c009444:	2f01      	cmp	r7, #1
 c009446:	d138      	bne.n	c0094ba <RCCEx_PLLSAI1_Config+0xd6>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c009448:	6903      	ldr	r3, [r0, #16]
 c00944a:	4a24      	ldr	r2, [pc, #144]	; (c0094dc <RCCEx_PLLSAI1_Config+0xf8>)
 c00944c:	6927      	ldr	r7, [r4, #16]
 c00944e:	401a      	ands	r2, r3
 c009450:	ea42 030c 	orr.w	r3, r2, ip
 c009454:	087f      	lsrs	r7, r7, #1
 c009456:	4333      	orrs	r3, r6
 c009458:	3f01      	subs	r7, #1
 c00945a:	432b      	orrs	r3, r5
 c00945c:	ea43 5347 	orr.w	r3, r3, r7, lsl #21
 c009460:	e010      	b.n	c009484 <RCCEx_PLLSAI1_Config+0xa0>
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c009462:	4b1d      	ldr	r3, [pc, #116]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
 c009464:	681b      	ldr	r3, [r3, #0]
 c009466:	f413 2fc0 	tst.w	r3, #393216	; 0x60000
 c00946a:	e7ce      	b.n	c00940a <RCCEx_PLLSAI1_Config+0x26>
          status = HAL_TIMEOUT;
 c00946c:	2003      	movs	r0, #3
 c00946e:	e7c7      	b.n	c009400 <RCCEx_PLLSAI1_Config+0x1c>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c009470:	6903      	ldr	r3, [r0, #16]
 c009472:	491b      	ldr	r1, [pc, #108]	; (c0094e0 <RCCEx_PLLSAI1_Config+0xfc>)
 c009474:	4019      	ands	r1, r3
 c009476:	ea41 030c 	orr.w	r3, r1, ip
 c00947a:	68e1      	ldr	r1, [r4, #12]
 c00947c:	4333      	orrs	r3, r6
 c00947e:	ea43 63c1 	orr.w	r3, r3, r1, lsl #27
 c009482:	432b      	orrs	r3, r5
      __HAL_RCC_PLLSAI1_ENABLE();
 c009484:	4d14      	ldr	r5, [pc, #80]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c009486:	6103      	str	r3, [r0, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 c009488:	682b      	ldr	r3, [r5, #0]
 c00948a:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 c00948e:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 c009490:	f7fa f808 	bl	c0034a4 <HAL_GetTick>
 c009494:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 c009496:	682b      	ldr	r3, [r5, #0]
 c009498:	011b      	lsls	r3, r3, #4
 c00949a:	d407      	bmi.n	c0094ac <RCCEx_PLLSAI1_Config+0xc8>
        if ((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 c00949c:	f7fa f802 	bl	c0034a4 <HAL_GetTick>
 c0094a0:	1b80      	subs	r0, r0, r6
 c0094a2:	2802      	cmp	r0, #2
 c0094a4:	d9f7      	bls.n	c009496 <RCCEx_PLLSAI1_Config+0xb2>
          if (READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 c0094a6:	682b      	ldr	r3, [r5, #0]
 c0094a8:	011a      	lsls	r2, r3, #4
 c0094aa:	d5df      	bpl.n	c00946c <RCCEx_PLLSAI1_Config+0x88>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(pPllSai1->PLLSAI1ClockOut);
 c0094ac:	4a0a      	ldr	r2, [pc, #40]	; (c0094d8 <RCCEx_PLLSAI1_Config+0xf4>)
 c0094ae:	69a1      	ldr	r1, [r4, #24]
 c0094b0:	6913      	ldr	r3, [r2, #16]
 c0094b2:	2000      	movs	r0, #0
 c0094b4:	430b      	orrs	r3, r1
 c0094b6:	6113      	str	r3, [r2, #16]
 c0094b8:	e7a2      	b.n	c009400 <RCCEx_PLLSAI1_Config+0x1c>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 c0094ba:	6902      	ldr	r2, [r0, #16]
 c0094bc:	4b09      	ldr	r3, [pc, #36]	; (c0094e4 <RCCEx_PLLSAI1_Config+0x100>)
 c0094be:	4013      	ands	r3, r2
 c0094c0:	6962      	ldr	r2, [r4, #20]
 c0094c2:	ea43 030c 	orr.w	r3, r3, ip
 c0094c6:	4333      	orrs	r3, r6
 c0094c8:	0852      	lsrs	r2, r2, #1
 c0094ca:	432b      	orrs	r3, r5
 c0094cc:	3a01      	subs	r2, #1
 c0094ce:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 c0094d2:	e7d7      	b.n	c009484 <RCCEx_PLLSAI1_Config+0xa0>
        status = HAL_ERROR;
 c0094d4:	2001      	movs	r0, #1
 c0094d6:	e793      	b.n	c009400 <RCCEx_PLLSAI1_Config+0x1c>
 c0094d8:	50021000 	.word	0x50021000
 c0094dc:	ff9f800c 	.word	0xff9f800c
 c0094e0:	07ff800c 	.word	0x07ff800c
 c0094e4:	f9ff800c 	.word	0xf9ff800c

0c0094e8 <RCCEx_PLLSAI2_Config.constprop.4>:
  *
  * @note   PLLSAI2 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *pPllSai2, uint32_t Divider)
 c0094e8:	b570      	push	{r4, r5, r6, lr}
 c0094ea:	4605      	mov	r5, r0
  assert_param(IS_RCC_PLLSAI2M_VALUE(pPllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(pPllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(pPllSai2->PLLSAI2ClockOut));

  /* Check PLLSAI2 clock source availability */
  switch (pPllSai2->PLLSAI2Source)
 c0094ec:	6800      	ldr	r0, [r0, #0]
 c0094ee:	2802      	cmp	r0, #2
 c0094f0:	d008      	beq.n	c009504 <RCCEx_PLLSAI2_Config.constprop.4+0x1c>
 c0094f2:	2803      	cmp	r0, #3
 c0094f4:	d048      	beq.n	c009588 <RCCEx_PLLSAI2_Config.constprop.4+0xa0>
 c0094f6:	2801      	cmp	r0, #1
 c0094f8:	d14d      	bne.n	c009596 <RCCEx_PLLSAI2_Config.constprop.4+0xae>
  {
    case RCC_PLLSOURCE_MSI:
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 c0094fa:	4b28      	ldr	r3, [pc, #160]	; (c00959c <RCCEx_PLLSAI2_Config.constprop.4+0xb4>)
 c0094fc:	681b      	ldr	r3, [r3, #0]
 c0094fe:	079c      	lsls	r4, r3, #30
 c009500:	d405      	bmi.n	c00950e <RCCEx_PLLSAI2_Config.constprop.4+0x26>
      }
    }
  }

  return status;
}
 c009502:	bd70      	pop	{r4, r5, r6, pc}
      if (HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 c009504:	4b25      	ldr	r3, [pc, #148]	; (c00959c <RCCEx_PLLSAI2_Config.constprop.4+0xb4>)
 c009506:	681b      	ldr	r3, [r3, #0]
 c009508:	f413 6f80 	tst.w	r3, #1024	; 0x400
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c00950c:	d043      	beq.n	c009596 <RCCEx_PLLSAI2_Config.constprop.4+0xae>
    __HAL_RCC_PLLSAI2_DISABLE();
 c00950e:	4c23      	ldr	r4, [pc, #140]	; (c00959c <RCCEx_PLLSAI2_Config.constprop.4+0xb4>)
 c009510:	6823      	ldr	r3, [r4, #0]
 c009512:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c009516:	6023      	str	r3, [r4, #0]
    tickstart = HAL_GetTick();
 c009518:	f7f9 ffc4 	bl	c0034a4 <HAL_GetTick>
 c00951c:	4606      	mov	r6, r0
    while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 c00951e:	6823      	ldr	r3, [r4, #0]
 c009520:	0099      	lsls	r1, r3, #2
 c009522:	d507      	bpl.n	c009534 <RCCEx_PLLSAI2_Config.constprop.4+0x4c>
      if ((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 c009524:	f7f9 ffbe 	bl	c0034a4 <HAL_GetTick>
 c009528:	1b80      	subs	r0, r0, r6
 c00952a:	2802      	cmp	r0, #2
 c00952c:	d9f7      	bls.n	c00951e <RCCEx_PLLSAI2_Config.constprop.4+0x36>
        if (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 c00952e:	6823      	ldr	r3, [r4, #0]
 c009530:	0098      	lsls	r0, r3, #2
 c009532:	d42e      	bmi.n	c009592 <RCCEx_PLLSAI2_Config.constprop.4+0xaa>
        MODIFY_REG(RCC->PLLSAI2CFGR,
 c009534:	4c19      	ldr	r4, [pc, #100]	; (c00959c <RCCEx_PLLSAI2_Config.constprop.4+0xb4>)
 c009536:	4b1a      	ldr	r3, [pc, #104]	; (c0095a0 <RCCEx_PLLSAI2_Config.constprop.4+0xb8>)
 c009538:	6962      	ldr	r2, [r4, #20]
 c00953a:	4013      	ands	r3, r2
 c00953c:	682a      	ldr	r2, [r5, #0]
 c00953e:	4313      	orrs	r3, r2
 c009540:	68aa      	ldr	r2, [r5, #8]
 c009542:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 c009546:	68ea      	ldr	r2, [r5, #12]
 c009548:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 c00954c:	686a      	ldr	r2, [r5, #4]
 c00954e:	3a01      	subs	r2, #1
 c009550:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 c009554:	6163      	str	r3, [r4, #20]
      __HAL_RCC_PLLSAI2_ENABLE();
 c009556:	6823      	ldr	r3, [r4, #0]
 c009558:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 c00955c:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 c00955e:	f7f9 ffa1 	bl	c0034a4 <HAL_GetTick>
 c009562:	4606      	mov	r6, r0
      while (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 c009564:	6823      	ldr	r3, [r4, #0]
 c009566:	009b      	lsls	r3, r3, #2
 c009568:	d407      	bmi.n	c00957a <RCCEx_PLLSAI2_Config.constprop.4+0x92>
        if ((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 c00956a:	f7f9 ff9b 	bl	c0034a4 <HAL_GetTick>
 c00956e:	1b80      	subs	r0, r0, r6
 c009570:	2802      	cmp	r0, #2
 c009572:	d9f7      	bls.n	c009564 <RCCEx_PLLSAI2_Config.constprop.4+0x7c>
          if (READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 c009574:	6823      	ldr	r3, [r4, #0]
 c009576:	009a      	lsls	r2, r3, #2
 c009578:	d50b      	bpl.n	c009592 <RCCEx_PLLSAI2_Config.constprop.4+0xaa>
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(pPllSai2->PLLSAI2ClockOut);
 c00957a:	4a08      	ldr	r2, [pc, #32]	; (c00959c <RCCEx_PLLSAI2_Config.constprop.4+0xb4>)
 c00957c:	6929      	ldr	r1, [r5, #16]
 c00957e:	6953      	ldr	r3, [r2, #20]
 c009580:	2000      	movs	r0, #0
 c009582:	430b      	orrs	r3, r1
 c009584:	6153      	str	r3, [r2, #20]
 c009586:	e7bc      	b.n	c009502 <RCCEx_PLLSAI2_Config.constprop.4+0x1a>
      if (HAL_IS_BIT_CLR(RCC->CR, (RCC_CR_HSERDY | RCC_CR_HSEBYP)))
 c009588:	4b04      	ldr	r3, [pc, #16]	; (c00959c <RCCEx_PLLSAI2_Config.constprop.4+0xb4>)
 c00958a:	681b      	ldr	r3, [r3, #0]
 c00958c:	f413 2fc0 	tst.w	r3, #393216	; 0x60000
 c009590:	e7bc      	b.n	c00950c <RCCEx_PLLSAI2_Config.constprop.4+0x24>
          status = HAL_TIMEOUT;
 c009592:	2003      	movs	r0, #3
 c009594:	e7b5      	b.n	c009502 <RCCEx_PLLSAI2_Config.constprop.4+0x1a>
        status = HAL_ERROR;
 c009596:	2001      	movs	r0, #1
 c009598:	e7b3      	b.n	c009502 <RCCEx_PLLSAI2_Config.constprop.4+0x1a>
 c00959a:	bf00      	nop
 c00959c:	50021000 	.word	0x50021000
 c0095a0:	07ff800c 	.word	0x07ff800c

0c0095a4 <HAL_RCCEx_PeriphCLKConfig>:
{
 c0095a4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 c0095a8:	6805      	ldr	r5, [r0, #0]
{
 c0095aa:	4604      	mov	r4, r0
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 c0095ac:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
 c0095b0:	d023      	beq.n	c0095fa <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch (PeriphClkInit->Sai1ClockSelection)
 c0095b2:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 c0095b4:	2940      	cmp	r1, #64	; 0x40
 c0095b6:	d014      	beq.n	c0095e2 <HAL_RCCEx_PeriphCLKConfig+0x3e>
 c0095b8:	d804      	bhi.n	c0095c4 <HAL_RCCEx_PeriphCLKConfig+0x20>
 c0095ba:	b1c1      	cbz	r1, c0095ee <HAL_RCCEx_PeriphCLKConfig+0x4a>
 c0095bc:	2920      	cmp	r1, #32
 c0095be:	d02c      	beq.n	c00961a <HAL_RCCEx_PeriphCLKConfig+0x76>
        ret = HAL_ERROR;
 c0095c0:	2501      	movs	r5, #1
 c0095c2:	e01a      	b.n	c0095fa <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch (PeriphClkInit->Sai1ClockSelection)
 c0095c4:	2960      	cmp	r1, #96	; 0x60
 c0095c6:	d001      	beq.n	c0095cc <HAL_RCCEx_PeriphCLKConfig+0x28>
 c0095c8:	2980      	cmp	r1, #128	; 0x80
 c0095ca:	d1f9      	bne.n	c0095c0 <HAL_RCCEx_PeriphCLKConfig+0x1c>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 c0095cc:	4aac      	ldr	r2, [pc, #688]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0095ce:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 c0095d0:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 c0095d4:	2500      	movs	r5, #0
 c0095d6:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 c0095da:	430b      	orrs	r3, r1
 c0095dc:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 c0095e0:	e00b      	b.n	c0095fa <HAL_RCCEx_PeriphCLKConfig+0x56>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 c0095e2:	4aa7      	ldr	r2, [pc, #668]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0095e4:	68d3      	ldr	r3, [r2, #12]
 c0095e6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c0095ea:	60d3      	str	r3, [r2, #12]
 c0095ec:	e7ee      	b.n	c0095cc <HAL_RCCEx_PeriphCLKConfig+0x28>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 c0095ee:	3004      	adds	r0, #4
 c0095f0:	f7ff fef8 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c0095f4:	4605      	mov	r5, r0
    if (ret == HAL_OK)
 c0095f6:	2800      	cmp	r0, #0
 c0095f8:	d0e8      	beq.n	c0095cc <HAL_RCCEx_PeriphCLKConfig+0x28>
  if ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 c0095fa:	6823      	ldr	r3, [r4, #0]
 c0095fc:	04db      	lsls	r3, r3, #19
 c0095fe:	d50a      	bpl.n	c009616 <HAL_RCCEx_PeriphCLKConfig+0x72>
    switch (PeriphClkInit->Sai2ClockSelection)
 c009600:	6f21      	ldr	r1, [r4, #112]	; 0x70
 c009602:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 c009606:	d014      	beq.n	c009632 <HAL_RCCEx_PeriphCLKConfig+0x8e>
 c009608:	d80b      	bhi.n	c009622 <HAL_RCCEx_PeriphCLKConfig+0x7e>
 c00960a:	b1c1      	cbz	r1, c00963e <HAL_RCCEx_PeriphCLKConfig+0x9a>
 c00960c:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 c009610:	f000 812d 	beq.w	c00986e <HAL_RCCEx_PeriphCLKConfig+0x2ca>
        ret = HAL_ERROR;
 c009614:	2501      	movs	r5, #1
 c009616:	462e      	mov	r6, r5
 c009618:	e021      	b.n	c00965e <HAL_RCCEx_PeriphCLKConfig+0xba>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c00961a:	3020      	adds	r0, #32
 c00961c:	f7ff ff64 	bl	c0094e8 <RCCEx_PLLSAI2_Config.constprop.4>
 c009620:	e7e8      	b.n	c0095f4 <HAL_RCCEx_PeriphCLKConfig+0x50>
    switch (PeriphClkInit->Sai2ClockSelection)
 c009622:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 c009626:	d002      	beq.n	c00962e <HAL_RCCEx_PeriphCLKConfig+0x8a>
 c009628:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 c00962c:	d1f2      	bne.n	c009614 <HAL_RCCEx_PeriphCLKConfig+0x70>
 c00962e:	462e      	mov	r6, r5
 c009630:	e009      	b.n	c009646 <HAL_RCCEx_PeriphCLKConfig+0xa2>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 c009632:	4a93      	ldr	r2, [pc, #588]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009634:	68d3      	ldr	r3, [r2, #12]
 c009636:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 c00963a:	60d3      	str	r3, [r2, #12]
 c00963c:	e7f7      	b.n	c00962e <HAL_RCCEx_PeriphCLKConfig+0x8a>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 c00963e:	1d20      	adds	r0, r4, #4
 c009640:	f7ff fed0 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c009644:	4606      	mov	r6, r0
    if (ret == HAL_OK)
 c009646:	2e00      	cmp	r6, #0
 c009648:	f040 8116 	bne.w	c009878 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 c00964c:	4a8c      	ldr	r2, [pc, #560]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c00964e:	6f21      	ldr	r1, [r4, #112]	; 0x70
 c009650:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 c009654:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 c009658:	430b      	orrs	r3, r1
 c00965a:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 c00965e:	6823      	ldr	r3, [r4, #0]
 c009660:	039f      	lsls	r7, r3, #14
 c009662:	d532      	bpl.n	c0096ca <HAL_RCCEx_PeriphCLKConfig+0x126>
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
 c009664:	4b86      	ldr	r3, [pc, #536]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009666:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c009668:	00d0      	lsls	r0, r2, #3
 c00966a:	f100 8107 	bmi.w	c00987c <HAL_RCCEx_PeriphCLKConfig+0x2d8>
      pwrclkchanged = SET;
 c00966e:	2701      	movs	r7, #1
      __HAL_RCC_PWR_CLK_ENABLE();
 c009670:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 c009672:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c009676:	659a      	str	r2, [r3, #88]	; 0x58
 c009678:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 c00967a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 c00967e:	9301      	str	r3, [sp, #4]
 c009680:	9b01      	ldr	r3, [sp, #4]
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 c009682:	f8df 8200 	ldr.w	r8, [pc, #512]	; c009884 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
 c009686:	f8d8 3000 	ldr.w	r3, [r8]
 c00968a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 c00968e:	f8c8 3000 	str.w	r3, [r8]
    tickstart = HAL_GetTick();
 c009692:	f7f9 ff07 	bl	c0034a4 <HAL_GetTick>
 c009696:	4681      	mov	r9, r0
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 c009698:	f8d8 3000 	ldr.w	r3, [r8]
 c00969c:	05da      	lsls	r2, r3, #23
 c00969e:	d40a      	bmi.n	c0096b6 <HAL_RCCEx_PeriphCLKConfig+0x112>
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 c0096a0:	f7f9 ff00 	bl	c0034a4 <HAL_GetTick>
 c0096a4:	eba0 0009 	sub.w	r0, r0, r9
 c0096a8:	2802      	cmp	r0, #2
 c0096aa:	d9f5      	bls.n	c009698 <HAL_RCCEx_PeriphCLKConfig+0xf4>
        if ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 c0096ac:	f8d8 3000 	ldr.w	r3, [r8]
 c0096b0:	05d9      	lsls	r1, r3, #23
 c0096b2:	f140 8127 	bpl.w	c009904 <HAL_RCCEx_PeriphCLKConfig+0x360>
    if (ret == HAL_OK)
 c0096b6:	2e00      	cmp	r6, #0
 c0096b8:	f000 80e6 	beq.w	c009888 <HAL_RCCEx_PeriphCLKConfig+0x2e4>
 c0096bc:	4635      	mov	r5, r6
    if (pwrclkchanged == SET)
 c0096be:	b127      	cbz	r7, c0096ca <HAL_RCCEx_PeriphCLKConfig+0x126>
      __HAL_RCC_PWR_CLK_DISABLE();
 c0096c0:	4a6f      	ldr	r2, [pc, #444]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0096c2:	6d93      	ldr	r3, [r2, #88]	; 0x58
 c0096c4:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 c0096c8:	6593      	str	r3, [r2, #88]	; 0x58
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 c0096ca:	6823      	ldr	r3, [r4, #0]
 c0096cc:	07da      	lsls	r2, r3, #31
 c0096ce:	d508      	bpl.n	c0096e2 <HAL_RCCEx_PeriphCLKConfig+0x13e>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 c0096d0:	496b      	ldr	r1, [pc, #428]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0096d2:	6b60      	ldr	r0, [r4, #52]	; 0x34
 c0096d4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c0096d8:	f022 0203 	bic.w	r2, r2, #3
 c0096dc:	4302      	orrs	r2, r0
 c0096de:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 c0096e2:	079f      	lsls	r7, r3, #30
 c0096e4:	d508      	bpl.n	c0096f8 <HAL_RCCEx_PeriphCLKConfig+0x154>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 c0096e6:	4966      	ldr	r1, [pc, #408]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0096e8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 c0096ea:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c0096ee:	f022 020c 	bic.w	r2, r2, #12
 c0096f2:	4302      	orrs	r2, r0
 c0096f4:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 c0096f8:	0758      	lsls	r0, r3, #29
 c0096fa:	d508      	bpl.n	c00970e <HAL_RCCEx_PeriphCLKConfig+0x16a>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 c0096fc:	4960      	ldr	r1, [pc, #384]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0096fe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 c009700:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c009704:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 c009708:	4302      	orrs	r2, r0
 c00970a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 c00970e:	0719      	lsls	r1, r3, #28
 c009710:	d508      	bpl.n	c009724 <HAL_RCCEx_PeriphCLKConfig+0x180>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 c009712:	495b      	ldr	r1, [pc, #364]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009714:	6c20      	ldr	r0, [r4, #64]	; 0x40
 c009716:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c00971a:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 c00971e:	4302      	orrs	r2, r0
 c009720:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 c009724:	06da      	lsls	r2, r3, #27
 c009726:	d508      	bpl.n	c00973a <HAL_RCCEx_PeriphCLKConfig+0x196>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 c009728:	4955      	ldr	r1, [pc, #340]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c00972a:	6c60      	ldr	r0, [r4, #68]	; 0x44
 c00972c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c009730:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 c009734:	4302      	orrs	r2, r0
 c009736:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 c00973a:	069f      	lsls	r7, r3, #26
 c00973c:	d508      	bpl.n	c009750 <HAL_RCCEx_PeriphCLKConfig+0x1ac>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 c00973e:	4950      	ldr	r1, [pc, #320]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009740:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 c009742:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c009746:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 c00974a:	4302      	orrs	r2, r0
 c00974c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 c009750:	0598      	lsls	r0, r3, #22
 c009752:	d508      	bpl.n	c009766 <HAL_RCCEx_PeriphCLKConfig+0x1c2>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 c009754:	494a      	ldr	r1, [pc, #296]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009756:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 c009758:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c00975c:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 c009760:	4302      	orrs	r2, r0
 c009762:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 c009766:	0559      	lsls	r1, r3, #21
 c009768:	d508      	bpl.n	c00977c <HAL_RCCEx_PeriphCLKConfig+0x1d8>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 c00976a:	4945      	ldr	r1, [pc, #276]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c00976c:	6e20      	ldr	r0, [r4, #96]	; 0x60
 c00976e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c009772:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 c009776:	4302      	orrs	r2, r0
 c009778:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM3) == (RCC_PERIPHCLK_LPTIM3))
 c00977c:	025a      	lsls	r2, r3, #9
 c00977e:	d508      	bpl.n	c009792 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
    __HAL_RCC_LPTIM3_CONFIG(PeriphClkInit->Lptim3ClockSelection);
 c009780:	493f      	ldr	r1, [pc, #252]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009782:	6e60      	ldr	r0, [r4, #100]	; 0x64
 c009784:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c009788:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 c00978c:	4302      	orrs	r2, r0
 c00978e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == (RCC_PERIPHCLK_FDCAN))
 c009792:	019b      	lsls	r3, r3, #6
 c009794:	d517      	bpl.n	c0097c6 <HAL_RCCEx_PeriphCLKConfig+0x222>
    switch (PeriphClkInit->FdcanClockSelection)
 c009796:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 c009798:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 c00979c:	f000 80b5 	beq.w	c00990a <HAL_RCCEx_PeriphCLKConfig+0x366>
 c0097a0:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 c0097a4:	f000 80b7 	beq.w	c009916 <HAL_RCCEx_PeriphCLKConfig+0x372>
 c0097a8:	2b00      	cmp	r3, #0
 c0097aa:	f040 80ba 	bne.w	c009922 <HAL_RCCEx_PeriphCLKConfig+0x37e>
    if (ret == HAL_OK)
 c0097ae:	2e00      	cmp	r6, #0
 c0097b0:	f040 80b9 	bne.w	c009926 <HAL_RCCEx_PeriphCLKConfig+0x382>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 c0097b4:	4a32      	ldr	r2, [pc, #200]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0097b6:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 c0097b8:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 c0097bc:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
 c0097c0:	430b      	orrs	r3, r1
 c0097c2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 c0097c6:	6823      	ldr	r3, [r4, #0]
 c0097c8:	065f      	lsls	r7, r3, #25
 c0097ca:	d508      	bpl.n	c0097de <HAL_RCCEx_PeriphCLKConfig+0x23a>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 c0097cc:	492c      	ldr	r1, [pc, #176]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0097ce:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 c0097d0:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c0097d4:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 c0097d8:	4302      	orrs	r2, r0
 c0097da:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 c0097de:	061e      	lsls	r6, r3, #24
 c0097e0:	d508      	bpl.n	c0097f4 <HAL_RCCEx_PeriphCLKConfig+0x250>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 c0097e2:	4927      	ldr	r1, [pc, #156]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0097e4:	6d20      	ldr	r0, [r4, #80]	; 0x50
 c0097e6:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c0097ea:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 c0097ee:	4302      	orrs	r2, r0
 c0097f0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 c0097f4:	05d8      	lsls	r0, r3, #23
 c0097f6:	d508      	bpl.n	c00980a <HAL_RCCEx_PeriphCLKConfig+0x266>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 c0097f8:	4921      	ldr	r1, [pc, #132]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c0097fa:	6d60      	ldr	r0, [r4, #84]	; 0x54
 c0097fc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 c009800:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 c009804:	4302      	orrs	r2, r0
 c009806:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 c00980a:	02d9      	lsls	r1, r3, #11
 c00980c:	d508      	bpl.n	c009820 <HAL_RCCEx_PeriphCLKConfig+0x27c>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 c00980e:	491c      	ldr	r1, [pc, #112]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009810:	6da0      	ldr	r0, [r4, #88]	; 0x58
 c009812:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 c009816:	f022 0203 	bic.w	r2, r2, #3
 c00981a:	4302      	orrs	r2, r0
 c00981c:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 c009820:	049a      	lsls	r2, r3, #18
 c009822:	d510      	bpl.n	c009846 <HAL_RCCEx_PeriphCLKConfig+0x2a2>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 c009824:	4a16      	ldr	r2, [pc, #88]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009826:	6f61      	ldr	r1, [r4, #116]	; 0x74
 c009828:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 c00982c:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 c009830:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 c009834:	ea43 0301 	orr.w	r3, r3, r1
 c009838:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 c00983c:	d175      	bne.n	c00992a <HAL_RCCEx_PeriphCLKConfig+0x386>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c00983e:	68d3      	ldr	r3, [r2, #12]
 c009840:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c009844:	60d3      	str	r3, [r2, #12]
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 c009846:	6823      	ldr	r3, [r4, #0]
 c009848:	031b      	lsls	r3, r3, #12
 c00984a:	f140 8091 	bpl.w	c009970 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 c00984e:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 c009850:	4b0b      	ldr	r3, [pc, #44]	; (c009880 <HAL_RCCEx_PeriphCLKConfig+0x2dc>)
 c009852:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 c009856:	d173      	bne.n	c009940 <HAL_RCCEx_PeriphCLKConfig+0x39c>
 c009858:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 c00985c:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 c009860:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 c009864:	68da      	ldr	r2, [r3, #12]
 c009866:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c00986a:	60da      	str	r2, [r3, #12]
 c00986c:	e080      	b.n	c009970 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
        ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 c00986e:	f104 0020 	add.w	r0, r4, #32
 c009872:	f7ff fe39 	bl	c0094e8 <RCCEx_PLLSAI2_Config.constprop.4>
 c009876:	e6e5      	b.n	c009644 <HAL_RCCEx_PeriphCLKConfig+0xa0>
 c009878:	4635      	mov	r5, r6
 c00987a:	e6f0      	b.n	c00965e <HAL_RCCEx_PeriphCLKConfig+0xba>
    FlagStatus       pwrclkchanged = RESET;
 c00987c:	2700      	movs	r7, #0
 c00987e:	e700      	b.n	c009682 <HAL_RCCEx_PeriphCLKConfig+0xde>
 c009880:	50021000 	.word	0x50021000
 c009884:	50007000 	.word	0x50007000
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 c009888:	4a71      	ldr	r2, [pc, #452]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c00988a:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
      if ((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 c00988e:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 c009892:	d015      	beq.n	c0098c0 <HAL_RCCEx_PeriphCLKConfig+0x31c>
 c009894:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 c009898:	4299      	cmp	r1, r3
 c00989a:	d011      	beq.n	c0098c0 <HAL_RCCEx_PeriphCLKConfig+0x31c>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 c00989c:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 c0098a0:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 c0098a4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 c0098a8:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 c0098ac:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 c0098b0:	f8d2 1090 	ldr.w	r1, [r2, #144]	; 0x90
 c0098b4:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 c0098b8:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
        RCC->BDCR = tmpregister;
 c0098bc:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 c0098c0:	07db      	lsls	r3, r3, #31
 c0098c2:	d40a      	bmi.n	c0098da <HAL_RCCEx_PeriphCLKConfig+0x336>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 c0098c4:	4a62      	ldr	r2, [pc, #392]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c0098c6:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 c0098ca:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 c0098ce:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 c0098d2:	430b      	orrs	r3, r1
 c0098d4:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
 c0098d8:	e6f1      	b.n	c0096be <HAL_RCCEx_PeriphCLKConfig+0x11a>
        tickstart = HAL_GetTick();
 c0098da:	f7f9 fde3 	bl	c0034a4 <HAL_GetTick>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0098de:	f241 3a88 	movw	sl, #5000	; 0x1388
        tickstart = HAL_GetTick();
 c0098e2:	4681      	mov	r9, r0
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 c0098e4:	f8df 8168 	ldr.w	r8, [pc, #360]	; c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>
 c0098e8:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 c0098ec:	0799      	lsls	r1, r3, #30
 c0098ee:	d4e9      	bmi.n	c0098c4 <HAL_RCCEx_PeriphCLKConfig+0x320>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 c0098f0:	f7f9 fdd8 	bl	c0034a4 <HAL_GetTick>
 c0098f4:	eba0 0009 	sub.w	r0, r0, r9
 c0098f8:	4550      	cmp	r0, sl
 c0098fa:	d9f5      	bls.n	c0098e8 <HAL_RCCEx_PeriphCLKConfig+0x344>
            if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 c0098fc:	f8d8 3090 	ldr.w	r3, [r8, #144]	; 0x90
 c009900:	0798      	lsls	r0, r3, #30
 c009902:	d4df      	bmi.n	c0098c4 <HAL_RCCEx_PeriphCLKConfig+0x320>
          ret = HAL_TIMEOUT;
 c009904:	2503      	movs	r5, #3
 c009906:	462e      	mov	r6, r5
 c009908:	e6d9      	b.n	c0096be <HAL_RCCEx_PeriphCLKConfig+0x11a>
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c00990a:	4a51      	ldr	r2, [pc, #324]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c00990c:	68d3      	ldr	r3, [r2, #12]
 c00990e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c009912:	60d3      	str	r3, [r2, #12]
        break;
 c009914:	e74b      	b.n	c0097ae <HAL_RCCEx_PeriphCLKConfig+0x20a>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 c009916:	2100      	movs	r1, #0
 c009918:	1d20      	adds	r0, r4, #4
 c00991a:	f7ff fd63 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
 c00991e:	4606      	mov	r6, r0
        break;
 c009920:	e745      	b.n	c0097ae <HAL_RCCEx_PeriphCLKConfig+0x20a>
        ret = HAL_ERROR;
 c009922:	2501      	movs	r5, #1
 c009924:	e74f      	b.n	c0097c6 <HAL_RCCEx_PeriphCLKConfig+0x222>
 c009926:	4635      	mov	r5, r6
 c009928:	e74d      	b.n	c0097c6 <HAL_RCCEx_PeriphCLKConfig+0x222>
      if (PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 c00992a:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 c00992e:	d18a      	bne.n	c009846 <HAL_RCCEx_PeriphCLKConfig+0x2a2>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 c009930:	2101      	movs	r1, #1
 c009932:	1d20      	adds	r0, r4, #4
 c009934:	f7ff fd56 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
 c009938:	2800      	cmp	r0, #0
 c00993a:	bf18      	it	ne
 c00993c:	4605      	movne	r5, r0
 c00993e:	e782      	b.n	c009846 <HAL_RCCEx_PeriphCLKConfig+0x2a2>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 c009940:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 c009944:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 c009948:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 c00994c:	ea42 0201 	orr.w	r2, r2, r1
 c009950:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 c009954:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 c009958:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 c00995c:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 c009960:	d163      	bne.n	c009a2a <HAL_RCCEx_PeriphCLKConfig+0x486>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 c009962:	2101      	movs	r1, #1
 c009964:	1d20      	adds	r0, r4, #4
 c009966:	f7ff fd3d 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
 c00996a:	2800      	cmp	r0, #0
 c00996c:	bf18      	it	ne
 c00996e:	4605      	movne	r5, r0
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 c009970:	6823      	ldr	r3, [r4, #0]
 c009972:	035f      	lsls	r7, r3, #13
 c009974:	d510      	bpl.n	c009998 <HAL_RCCEx_PeriphCLKConfig+0x3f4>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 c009976:	4a36      	ldr	r2, [pc, #216]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c009978:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 c00997a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 c00997e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 c009982:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 c009986:	ea43 0301 	orr.w	r3, r3, r1
 c00998a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 c00998e:	d153      	bne.n	c009a38 <HAL_RCCEx_PeriphCLKConfig+0x494>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c009990:	68d3      	ldr	r3, [r2, #12]
 c009992:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 c009996:	60d3      	str	r3, [r2, #12]
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 c009998:	6823      	ldr	r3, [r4, #0]
 c00999a:	045e      	lsls	r6, r3, #17
 c00999c:	d514      	bpl.n	c0099c8 <HAL_RCCEx_PeriphCLKConfig+0x424>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 c00999e:	492c      	ldr	r1, [pc, #176]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c0099a0:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 c0099a4:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 c0099a8:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 c0099ac:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 c0099b0:	ea43 0302 	orr.w	r3, r3, r2
 c0099b4:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if (PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 c0099b8:	d106      	bne.n	c0099c8 <HAL_RCCEx_PeriphCLKConfig+0x424>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 c0099ba:	2102      	movs	r1, #2
 c0099bc:	1d20      	adds	r0, r4, #4
 c0099be:	f7ff fd11 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
 c0099c2:	2800      	cmp	r0, #0
 c0099c4:	bf18      	it	ne
 c0099c6:	4605      	movne	r5, r0
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 c0099c8:	6822      	ldr	r2, [r4, #0]
 c0099ca:	03d0      	lsls	r0, r2, #15
 c0099cc:	d509      	bpl.n	c0099e2 <HAL_RCCEx_PeriphCLKConfig+0x43e>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 c0099ce:	4920      	ldr	r1, [pc, #128]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c0099d0:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 c0099d4:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 c0099d8:	f023 0304 	bic.w	r3, r3, #4
 c0099dc:	4303      	orrs	r3, r0
 c0099de:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 c0099e2:	0291      	lsls	r1, r2, #10
 c0099e4:	d509      	bpl.n	c0099fa <HAL_RCCEx_PeriphCLKConfig+0x456>
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 c0099e6:	491a      	ldr	r1, [pc, #104]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c0099e8:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 c0099ec:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 c0099f0:	f023 0318 	bic.w	r3, r3, #24
 c0099f4:	4303      	orrs	r3, r0
 c0099f6:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 c0099fa:	01d3      	lsls	r3, r2, #7
 c0099fc:	d511      	bpl.n	c009a22 <HAL_RCCEx_PeriphCLKConfig+0x47e>
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 c0099fe:	4a14      	ldr	r2, [pc, #80]	; (c009a50 <HAL_RCCEx_PeriphCLKConfig+0x4ac>)
 c009a00:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 c009a04:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
    if (PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 c009a08:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 c009a0c:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 c009a10:	ea43 0301 	orr.w	r3, r3, r1
 c009a14:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c009a18:	bf02      	ittt	eq
 c009a1a:	68d3      	ldreq	r3, [r2, #12]
 c009a1c:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 c009a20:	60d3      	streq	r3, [r2, #12]
}
 c009a22:	4628      	mov	r0, r5
 c009a24:	b002      	add	sp, #8
 c009a26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if (PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)
 c009a2a:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
 c009a2e:	d19f      	bne.n	c009970 <HAL_RCCEx_PeriphCLKConfig+0x3cc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 c009a30:	68da      	ldr	r2, [r3, #12]
 c009a32:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 c009a36:	e718      	b.n	c00986a <HAL_RCCEx_PeriphCLKConfig+0x2c6>
    else if (PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 c009a38:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 c009a3c:	d1ac      	bne.n	c009998 <HAL_RCCEx_PeriphCLKConfig+0x3f4>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 c009a3e:	2101      	movs	r1, #1
 c009a40:	1d20      	adds	r0, r4, #4
 c009a42:	f7ff fccf 	bl	c0093e4 <RCCEx_PLLSAI1_Config>
 c009a46:	2800      	cmp	r0, #0
 c009a48:	bf18      	it	ne
 c009a4a:	4605      	movne	r5, r0
 c009a4c:	e7a4      	b.n	c009998 <HAL_RCCEx_PeriphCLKConfig+0x3f4>
 c009a4e:	bf00      	nop
 c009a50:	50021000 	.word	0x50021000

0c009a54 <HAL_RNG_MspInit>:
  /* Prevent unused argument(s) compilation warning */
  UNUSED(hrng);
  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_RNG_MspInit must be implemented in the user file.
   */
}
 c009a54:	4770      	bx	lr
	...

0c009a58 <HAL_RNG_Init>:
{
 c009a58:	b538      	push	{r3, r4, r5, lr}
  if (hrng == NULL)
 c009a5a:	4604      	mov	r4, r0
 c009a5c:	2800      	cmp	r0, #0
 c009a5e:	d030      	beq.n	c009ac2 <HAL_RNG_Init+0x6a>
  if (hrng->State == HAL_RNG_STATE_RESET)
 c009a60:	7a43      	ldrb	r3, [r0, #9]
 c009a62:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c009a66:	b913      	cbnz	r3, c009a6e <HAL_RNG_Init+0x16>
    hrng->Lock = HAL_UNLOCKED;
 c009a68:	7202      	strb	r2, [r0, #8]
    HAL_RNG_MspInit(hrng);
 c009a6a:	f7ff fff3 	bl	c009a54 <HAL_RNG_MspInit>
  hrng->State = HAL_RNG_STATE_BUSY;
 c009a6e:	2302      	movs	r3, #2
 c009a70:	7263      	strb	r3, [r4, #9]
  __HAL_RNG_DISABLE(hrng);
 c009a72:	6823      	ldr	r3, [r4, #0]
 c009a74:	681a      	ldr	r2, [r3, #0]
 c009a76:	f022 0204 	bic.w	r2, r2, #4
 c009a7a:	601a      	str	r2, [r3, #0]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, hrng->Init.ClockErrorDetection | RNG_CR_CONDRST);
 c009a7c:	6819      	ldr	r1, [r3, #0]
 c009a7e:	6862      	ldr	r2, [r4, #4]
 c009a80:	f021 4180 	bic.w	r1, r1, #1073741824	; 0x40000000
 c009a84:	f021 0120 	bic.w	r1, r1, #32
 c009a88:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 c009a8c:	430a      	orrs	r2, r1
 c009a8e:	601a      	str	r2, [r3, #0]
  WRITE_REG(hrng->Instance->HTCR, RNG_HTCFG_1);
 c009a90:	4a21      	ldr	r2, [pc, #132]	; (c009b18 <HAL_RNG_Init+0xc0>)
 c009a92:	611a      	str	r2, [r3, #16]
  WRITE_REG(hrng->Instance->HTCR, RNG_HTCFG);
 c009a94:	f24a 22b3 	movw	r2, #41651	; 0xa2b3
 c009a98:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c009a9a:	681a      	ldr	r2, [r3, #0]
 c009a9c:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 c009aa0:	601a      	str	r2, [r3, #0]
  tickstart = HAL_GetTick();
 c009aa2:	f7f9 fcff 	bl	c0034a4 <HAL_GetTick>
 c009aa6:	4605      	mov	r5, r0
  while (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c009aa8:	6823      	ldr	r3, [r4, #0]
 c009aaa:	681a      	ldr	r2, [r3, #0]
 c009aac:	0051      	lsls	r1, r2, #1
 c009aae:	d40a      	bmi.n	c009ac6 <HAL_RNG_Init+0x6e>
  __HAL_RNG_ENABLE(hrng);
 c009ab0:	681a      	ldr	r2, [r3, #0]
 c009ab2:	f042 0204 	orr.w	r2, r2, #4
 c009ab6:	601a      	str	r2, [r3, #0]
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c009ab8:	685b      	ldr	r3, [r3, #4]
 c009aba:	065a      	lsls	r2, r3, #25
 c009abc:	d511      	bpl.n	c009ae2 <HAL_RNG_Init+0x8a>
    hrng->State = HAL_RNG_STATE_ERROR;
 c009abe:	2304      	movs	r3, #4
 c009ac0:	7263      	strb	r3, [r4, #9]
    return HAL_ERROR;
 c009ac2:	2001      	movs	r0, #1
 c009ac4:	e00c      	b.n	c009ae0 <HAL_RNG_Init+0x88>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c009ac6:	f7f9 fced 	bl	c0034a4 <HAL_GetTick>
 c009aca:	1b40      	subs	r0, r0, r5
 c009acc:	2802      	cmp	r0, #2
 c009ace:	d9eb      	bls.n	c009aa8 <HAL_RNG_Init+0x50>
      if (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c009ad0:	6823      	ldr	r3, [r4, #0]
 c009ad2:	681b      	ldr	r3, [r3, #0]
 c009ad4:	0058      	lsls	r0, r3, #1
 c009ad6:	d5e7      	bpl.n	c009aa8 <HAL_RNG_Init+0x50>
        hrng->State = HAL_RNG_STATE_READY;
 c009ad8:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009ada:	2302      	movs	r3, #2
        hrng->State = HAL_RNG_STATE_READY;
 c009adc:	7260      	strb	r0, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009ade:	60e3      	str	r3, [r4, #12]
}
 c009ae0:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
 c009ae2:	f7f9 fcdf 	bl	c0034a4 <HAL_GetTick>
 c009ae6:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 c009ae8:	6823      	ldr	r3, [r4, #0]
 c009aea:	6858      	ldr	r0, [r3, #4]
 c009aec:	f010 0004 	ands.w	r0, r0, #4
 c009af0:	d103      	bne.n	c009afa <HAL_RNG_Init+0xa2>
  hrng->State = HAL_RNG_STATE_READY;
 c009af2:	2301      	movs	r3, #1
 c009af4:	7263      	strb	r3, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 c009af6:	60e0      	str	r0, [r4, #12]
  return HAL_OK;
 c009af8:	e7f2      	b.n	c009ae0 <HAL_RNG_Init+0x88>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c009afa:	f7f9 fcd3 	bl	c0034a4 <HAL_GetTick>
 c009afe:	1b40      	subs	r0, r0, r5
 c009b00:	2802      	cmp	r0, #2
 c009b02:	d9f1      	bls.n	c009ae8 <HAL_RNG_Init+0x90>
      if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 c009b04:	6823      	ldr	r3, [r4, #0]
 c009b06:	685b      	ldr	r3, [r3, #4]
 c009b08:	075b      	lsls	r3, r3, #29
 c009b0a:	d5ed      	bpl.n	c009ae8 <HAL_RNG_Init+0x90>
        hrng->State = HAL_RNG_STATE_ERROR;
 c009b0c:	2304      	movs	r3, #4
 c009b0e:	7263      	strb	r3, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009b10:	2302      	movs	r3, #2
 c009b12:	60e3      	str	r3, [r4, #12]
 c009b14:	e7d5      	b.n	c009ac2 <HAL_RNG_Init+0x6a>
 c009b16:	bf00      	nop
 c009b18:	17590abc 	.word	0x17590abc

0c009b1c <HAL_RNG_MspDeInit>:
 c009b1c:	4770      	bx	lr

0c009b1e <HAL_RNG_DeInit>:
{
 c009b1e:	b570      	push	{r4, r5, r6, lr}
  if (hrng == NULL)
 c009b20:	4605      	mov	r5, r0
 c009b22:	2800      	cmp	r0, #0
 c009b24:	d034      	beq.n	c009b90 <HAL_RNG_DeInit+0x72>
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED | RNG_CR_CONDRST, RNG_CED_ENABLE | RNG_CR_CONDRST);
 c009b26:	6802      	ldr	r2, [r0, #0]
 c009b28:	6813      	ldr	r3, [r2, #0]
 c009b2a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 c009b2e:	f023 0320 	bic.w	r3, r3, #32
 c009b32:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 c009b36:	6013      	str	r3, [r2, #0]
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c009b38:	6813      	ldr	r3, [r2, #0]
 c009b3a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 c009b3e:	6013      	str	r3, [r2, #0]
  tickstart = HAL_GetTick();
 c009b40:	f7f9 fcb0 	bl	c0034a4 <HAL_GetTick>
 c009b44:	4606      	mov	r6, r0
  while (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c009b46:	682b      	ldr	r3, [r5, #0]
 c009b48:	681c      	ldr	r4, [r3, #0]
 c009b4a:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
 c009b4e:	d10f      	bne.n	c009b70 <HAL_RNG_DeInit+0x52>
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 c009b50:	681a      	ldr	r2, [r3, #0]
  HAL_RNG_MspDeInit(hrng);
 c009b52:	4628      	mov	r0, r5
  CLEAR_BIT(hrng->Instance->CR, RNG_CR_IE | RNG_CR_RNGEN);
 c009b54:	f022 020c 	bic.w	r2, r2, #12
 c009b58:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(hrng->Instance->SR, RNG_SR_CEIS | RNG_SR_SEIS);
 c009b5a:	685a      	ldr	r2, [r3, #4]
 c009b5c:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 c009b60:	605a      	str	r2, [r3, #4]
  HAL_RNG_MspDeInit(hrng);
 c009b62:	f7ff ffdb 	bl	c009b1c <HAL_RNG_MspDeInit>
  hrng->State = HAL_RNG_STATE_RESET;
 c009b66:	726c      	strb	r4, [r5, #9]
  __HAL_UNLOCK(hrng);
 c009b68:	722c      	strb	r4, [r5, #8]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 c009b6a:	60ec      	str	r4, [r5, #12]
  return HAL_OK;
 c009b6c:	4620      	mov	r0, r4
 c009b6e:	e00e      	b.n	c009b8e <HAL_RNG_DeInit+0x70>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c009b70:	f7f9 fc98 	bl	c0034a4 <HAL_GetTick>
 c009b74:	1b80      	subs	r0, r0, r6
 c009b76:	2802      	cmp	r0, #2
 c009b78:	d9e5      	bls.n	c009b46 <HAL_RNG_DeInit+0x28>
      if (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST))
 c009b7a:	682b      	ldr	r3, [r5, #0]
 c009b7c:	681b      	ldr	r3, [r3, #0]
 c009b7e:	005b      	lsls	r3, r3, #1
 c009b80:	d5e1      	bpl.n	c009b46 <HAL_RNG_DeInit+0x28>
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009b82:	2302      	movs	r3, #2
        hrng->State = HAL_RNG_STATE_READY;
 c009b84:	2001      	movs	r0, #1
 c009b86:	7268      	strb	r0, [r5, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009b88:	60eb      	str	r3, [r5, #12]
        __HAL_UNLOCK(hrng);
 c009b8a:	2300      	movs	r3, #0
 c009b8c:	722b      	strb	r3, [r5, #8]
}
 c009b8e:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 c009b90:	2001      	movs	r0, #1
 c009b92:	e7fc      	b.n	c009b8e <HAL_RNG_DeInit+0x70>

0c009b94 <HAL_RNG_ErrorCallback>:
 c009b94:	4770      	bx	lr

0c009b96 <RNG_RecoverSeedError>:
  * @param  hrng pointer to a RNG_HandleTypeDef structure.
  * @retval HAL status
  */
HAL_StatusTypeDef RNG_RecoverSeedError(RNG_HandleTypeDef *hrng)
{
  __IO uint32_t count = 0U;
 c009b96:	2300      	movs	r3, #0
{
 c009b98:	b513      	push	{r0, r1, r4, lr}
  __IO uint32_t count = 0U;
 c009b9a:	9301      	str	r3, [sp, #4]

  /*Check if seed error current status (SECS)is set */
  if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) == RESET)
 c009b9c:	6803      	ldr	r3, [r0, #0]
 c009b9e:	685a      	ldr	r2, [r3, #4]
 c009ba0:	0752      	lsls	r2, r2, #29
 c009ba2:	d409      	bmi.n	c009bb8 <RNG_RecoverSeedError+0x22>
  {
    /* RNG performed the reset automatically (auto-reset) */
    /* Clear bit SEIS */
    CLEAR_BIT(hrng->Instance->SR, RNG_IT_SEI);
 c009ba4:	685a      	ldr	r2, [r3, #4]
 c009ba6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 c009baa:	605a      	str	r2, [r3, #4]
      }
    }
    while (HAL_IS_BIT_SET(hrng->Instance->SR, RNG_FLAG_SECS));
  }
  /* Update the error code */
  hrng->ErrorCode &= ~ HAL_RNG_ERROR_SEED;
 c009bac:	68c3      	ldr	r3, [r0, #12]
 c009bae:	f023 0308 	bic.w	r3, r3, #8
 c009bb2:	60c3      	str	r3, [r0, #12]
  return HAL_OK;
 c009bb4:	2000      	movs	r0, #0
 c009bb6:	e018      	b.n	c009bea <RNG_RecoverSeedError+0x54>
    SET_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c009bb8:	681a      	ldr	r2, [r3, #0]
 c009bba:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 c009bbe:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(hrng->Instance->CR, RNG_CR_CONDRST);
 c009bc0:	681a      	ldr	r2, [r3, #0]
 c009bc2:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 c009bc6:	601a      	str	r2, [r3, #0]
    count = RNG_TIMEOUT_VALUE;
 c009bc8:	2202      	movs	r2, #2
 c009bca:	9201      	str	r2, [sp, #4]
      count-- ;
 c009bcc:	9a01      	ldr	r2, [sp, #4]
 c009bce:	3a01      	subs	r2, #1
 c009bd0:	9201      	str	r2, [sp, #4]
      if (count == 0U)
 c009bd2:	9a01      	ldr	r2, [sp, #4]
 c009bd4:	b95a      	cbnz	r2, c009bee <RNG_RecoverSeedError+0x58>
        hrng->State = HAL_RNG_STATE_READY;
 c009bd6:	2401      	movs	r4, #1
 c009bd8:	7244      	strb	r4, [r0, #9]
        hrng->ErrorCode |= HAL_RNG_ERROR_TIMEOUT;
 c009bda:	68c3      	ldr	r3, [r0, #12]
        __HAL_UNLOCK(hrng);
 c009bdc:	7202      	strb	r2, [r0, #8]
        hrng->ErrorCode |= HAL_RNG_ERROR_TIMEOUT;
 c009bde:	f043 0302 	orr.w	r3, r3, #2
 c009be2:	60c3      	str	r3, [r0, #12]
        HAL_RNG_ErrorCallback(hrng);
 c009be4:	f7ff ffd6 	bl	c009b94 <HAL_RNG_ErrorCallback>
        return HAL_ERROR;
 c009be8:	4620      	mov	r0, r4
}
 c009bea:	b002      	add	sp, #8
 c009bec:	bd10      	pop	{r4, pc}
    while (HAL_IS_BIT_SET(hrng->Instance->CR, RNG_CR_CONDRST));
 c009bee:	681a      	ldr	r2, [r3, #0]
 c009bf0:	0054      	lsls	r4, r2, #1
 c009bf2:	d4eb      	bmi.n	c009bcc <RNG_RecoverSeedError+0x36>
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c009bf4:	685a      	ldr	r2, [r3, #4]
 c009bf6:	0651      	lsls	r1, r2, #25
      CLEAR_BIT(hrng->Instance->SR, RNG_IT_SEI);
 c009bf8:	bf42      	ittt	mi
 c009bfa:	685a      	ldrmi	r2, [r3, #4]
 c009bfc:	f022 0240 	bicmi.w	r2, r2, #64	; 0x40
 c009c00:	605a      	strmi	r2, [r3, #4]
    count = RNG_TIMEOUT_VALUE;
 c009c02:	2202      	movs	r2, #2
 c009c04:	9201      	str	r2, [sp, #4]
      count-- ;
 c009c06:	9a01      	ldr	r2, [sp, #4]
 c009c08:	3a01      	subs	r2, #1
 c009c0a:	9201      	str	r2, [sp, #4]
      if (count == 0U)
 c009c0c:	9a01      	ldr	r2, [sp, #4]
 c009c0e:	2a00      	cmp	r2, #0
 c009c10:	d0e1      	beq.n	c009bd6 <RNG_RecoverSeedError+0x40>
    while (HAL_IS_BIT_SET(hrng->Instance->SR, RNG_FLAG_SECS));
 c009c12:	685a      	ldr	r2, [r3, #4]
 c009c14:	0752      	lsls	r2, r2, #29
 c009c16:	d4f6      	bmi.n	c009c06 <RNG_RecoverSeedError+0x70>
 c009c18:	e7c8      	b.n	c009bac <RNG_RecoverSeedError+0x16>

0c009c1a <HAL_RNG_GenerateRandomNumber>:
{
 c009c1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrng);
 c009c1c:	7a03      	ldrb	r3, [r0, #8]
{
 c009c1e:	4605      	mov	r5, r0
  __HAL_LOCK(hrng);
 c009c20:	2b01      	cmp	r3, #1
{
 c009c22:	460e      	mov	r6, r1
  __HAL_LOCK(hrng);
 c009c24:	d03e      	beq.n	c009ca4 <HAL_RNG_GenerateRandomNumber+0x8a>
 c009c26:	2401      	movs	r4, #1
  if (hrng->State == HAL_RNG_STATE_READY)
 c009c28:	7a43      	ldrb	r3, [r0, #9]
  __HAL_LOCK(hrng);
 c009c2a:	7204      	strb	r4, [r0, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
 c009c2c:	42a3      	cmp	r3, r4
 c009c2e:	d136      	bne.n	c009c9e <HAL_RNG_GenerateRandomNumber+0x84>
    hrng->State = HAL_RNG_STATE_BUSY;
 c009c30:	2302      	movs	r3, #2
 c009c32:	7243      	strb	r3, [r0, #9]
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c009c34:	6803      	ldr	r3, [r0, #0]
 c009c36:	685c      	ldr	r4, [r3, #4]
 c009c38:	f014 0440 	ands.w	r4, r4, #64	; 0x40
 c009c3c:	d006      	beq.n	c009c4c <HAL_RNG_GenerateRandomNumber+0x32>
      hrng->ErrorCode = HAL_RNG_ERROR_SEED;
 c009c3e:	2308      	movs	r3, #8
 c009c40:	60c3      	str	r3, [r0, #12]
      status = RNG_RecoverSeedError(hrng);
 c009c42:	f7ff ffa8 	bl	c009b96 <RNG_RecoverSeedError>
      if (status == HAL_ERROR)
 c009c46:	2801      	cmp	r0, #1
      status = RNG_RecoverSeedError(hrng);
 c009c48:	4604      	mov	r4, r0
      if (status == HAL_ERROR)
 c009c4a:	d026      	beq.n	c009c9a <HAL_RNG_GenerateRandomNumber+0x80>
    tickstart = HAL_GetTick();
 c009c4c:	f7f9 fc2a 	bl	c0034a4 <HAL_GetTick>
 c009c50:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 c009c52:	682b      	ldr	r3, [r5, #0]
 c009c54:	685a      	ldr	r2, [r3, #4]
 c009c56:	07d0      	lsls	r0, r2, #31
 c009c58:	d510      	bpl.n	c009c7c <HAL_RNG_GenerateRandomNumber+0x62>
    hrng->RandomNumber = hrng->Instance->DR;
 c009c5a:	689a      	ldr	r2, [r3, #8]
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c009c5c:	6859      	ldr	r1, [r3, #4]
    hrng->RandomNumber = hrng->Instance->DR;
 c009c5e:	612a      	str	r2, [r5, #16]
    if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 c009c60:	0649      	lsls	r1, r1, #25
      hrng->ErrorCode = HAL_RNG_ERROR_SEED;
 c009c62:	bf43      	ittte	mi
 c009c64:	2208      	movmi	r2, #8
 c009c66:	60ea      	strmi	r2, [r5, #12]
      CLEAR_BIT(hrng->Instance->SR, RNG_FLAG_DRDY);
 c009c68:	685a      	ldrmi	r2, [r3, #4]
      *random32bit = hrng->RandomNumber;
 c009c6a:	6032      	strpl	r2, [r6, #0]
      CLEAR_BIT(hrng->Instance->SR, RNG_FLAG_DRDY);
 c009c6c:	bf44      	itt	mi
 c009c6e:	f022 0201 	bicmi.w	r2, r2, #1
 c009c72:	605a      	strmi	r2, [r3, #4]
    hrng->State = HAL_RNG_STATE_READY;
 c009c74:	2301      	movs	r3, #1
 c009c76:	726b      	strb	r3, [r5, #9]
  __HAL_UNLOCK(hrng);
 c009c78:	2300      	movs	r3, #0
 c009c7a:	e00d      	b.n	c009c98 <HAL_RNG_GenerateRandomNumber+0x7e>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 c009c7c:	f7f9 fc12 	bl	c0034a4 <HAL_GetTick>
 c009c80:	1bc0      	subs	r0, r0, r7
 c009c82:	2802      	cmp	r0, #2
 c009c84:	d9e5      	bls.n	c009c52 <HAL_RNG_GenerateRandomNumber+0x38>
        if (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 c009c86:	682b      	ldr	r3, [r5, #0]
 c009c88:	685b      	ldr	r3, [r3, #4]
 c009c8a:	f013 0301 	ands.w	r3, r3, #1
 c009c8e:	d1e0      	bne.n	c009c52 <HAL_RNG_GenerateRandomNumber+0x38>
          hrng->State = HAL_RNG_STATE_READY;
 c009c90:	2401      	movs	r4, #1
          hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009c92:	2202      	movs	r2, #2
          hrng->State = HAL_RNG_STATE_READY;
 c009c94:	726c      	strb	r4, [r5, #9]
          hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 c009c96:	60ea      	str	r2, [r5, #12]
  __HAL_UNLOCK(hrng);
 c009c98:	722b      	strb	r3, [r5, #8]
}
 c009c9a:	4620      	mov	r0, r4
 c009c9c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 c009c9e:	2304      	movs	r3, #4
 c009ca0:	60c3      	str	r3, [r0, #12]
 c009ca2:	e7e9      	b.n	c009c78 <HAL_RNG_GenerateRandomNumber+0x5e>
  __HAL_LOCK(hrng);
 c009ca4:	2402      	movs	r4, #2
 c009ca6:	e7f8      	b.n	c009c9a <HAL_RNG_GenerateRandomNumber+0x80>

0c009ca8 <HAL_RTC_WaitForSynchro>:
  *         correctly copied into the RTC_TR and RTC_DR shadow registers.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef *hrtc)
{
 c009ca8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  UNUSED(hrtc);
  /* Clear RSF flag */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_RSF);
 c009caa:	4c0a      	ldr	r4, [pc, #40]	; (c009cd4 <HAL_RTC_WaitForSynchro+0x2c>)
 c009cac:	68e3      	ldr	r3, [r4, #12]
 c009cae:	f023 0320 	bic.w	r3, r3, #32
 c009cb2:	60e3      	str	r3, [r4, #12]

  tickstart = HAL_GetTick();
 c009cb4:	f7f9 fbf6 	bl	c0034a4 <HAL_GetTick>
 c009cb8:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while (READ_BIT(RTC->ICSR, RTC_ICSR_RSF) == 0U)
 c009cba:	68e3      	ldr	r3, [r4, #12]
 c009cbc:	069b      	lsls	r3, r3, #26
 c009cbe:	d501      	bpl.n	c009cc4 <HAL_RTC_WaitForSynchro+0x1c>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 c009cc0:	2000      	movs	r0, #0
}
 c009cc2:	bd38      	pop	{r3, r4, r5, pc}
    if ((HAL_GetTick() - tickstart) > RTC_TIMEOUT_VALUE)
 c009cc4:	f7f9 fbee 	bl	c0034a4 <HAL_GetTick>
 c009cc8:	1b40      	subs	r0, r0, r5
 c009cca:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 c009cce:	d9f4      	bls.n	c009cba <HAL_RTC_WaitForSynchro+0x12>
      return HAL_TIMEOUT;
 c009cd0:	2003      	movs	r0, #3
 c009cd2:	e7f6      	b.n	c009cc2 <HAL_RTC_WaitForSynchro+0x1a>
 c009cd4:	50002800 	.word	0x50002800

0c009cd8 <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef *hrtc)
{
 c009cd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  UNUSED(hrtc);
  /* Check if the Initialization mode is set */
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 c009cdc:	4d11      	ldr	r5, [pc, #68]	; (c009d24 <RTC_EnterInitMode+0x4c>)
{
 c009cde:	4606      	mov	r6, r0
  if (READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U)
 c009ce0:	68ec      	ldr	r4, [r5, #12]
 c009ce2:	f014 0440 	ands.w	r4, r4, #64	; 0x40
 c009ce6:	d11a      	bne.n	c009d1e <RTC_EnterInitMode+0x46>
  {
    /* Set the Initialization mode */
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c009ce8:	68eb      	ldr	r3, [r5, #12]
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
    {
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
      {
        status = HAL_TIMEOUT;
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c009cea:	f04f 0803 	mov.w	r8, #3
    SET_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c009cee:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c009cf2:	60eb      	str	r3, [r5, #12]
    tickstart = HAL_GetTick();
 c009cf4:	f7f9 fbd6 	bl	c0034a4 <HAL_GetTick>
 c009cf8:	4607      	mov	r7, r0
    while ((READ_BIT(RTC->ICSR, RTC_ICSR_INITF) == 0U) && (status != HAL_TIMEOUT))
 c009cfa:	68eb      	ldr	r3, [r5, #12]
 c009cfc:	065b      	lsls	r3, r3, #25
 c009cfe:	d401      	bmi.n	c009d04 <RTC_EnterInitMode+0x2c>
 c009d00:	2c03      	cmp	r4, #3
 c009d02:	d102      	bne.n	c009d0a <RTC_EnterInitMode+0x32>
      }
    }
  }

  return status;
}
 c009d04:	4620      	mov	r0, r4
 c009d06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((HAL_GetTick()  - tickstart) > RTC_TIMEOUT_VALUE)
 c009d0a:	f7f9 fbcb 	bl	c0034a4 <HAL_GetTick>
 c009d0e:	1bc0      	subs	r0, r0, r7
 c009d10:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c009d14:	bf84      	itt	hi
 c009d16:	f886 8025 	strbhi.w	r8, [r6, #37]	; 0x25
        status = HAL_TIMEOUT;
 c009d1a:	2403      	movhi	r4, #3
 c009d1c:	e7ed      	b.n	c009cfa <RTC_EnterInitMode+0x22>
  HAL_StatusTypeDef status = HAL_OK;
 c009d1e:	2400      	movs	r4, #0
 c009d20:	e7f0      	b.n	c009d04 <RTC_EnterInitMode+0x2c>
 c009d22:	bf00      	nop
 c009d24:	50002800 	.word	0x50002800

0c009d28 <RTC_ExitInitMode>:
  * @brief  Exit the RTC Initialization mode.
  * @param  hrtc RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_ExitInitMode(RTC_HandleTypeDef *hrtc)
{
 c009d28:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef status = HAL_OK;

  /* Exit Initialization mode */
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c009d2a:	4c0f      	ldr	r4, [pc, #60]	; (c009d68 <RTC_ExitInitMode+0x40>)
{
 c009d2c:	4605      	mov	r5, r0
  CLEAR_BIT(RTC->ICSR, RTC_ICSR_INIT);
 c009d2e:	68e3      	ldr	r3, [r4, #12]
 c009d30:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 c009d34:	60e3      	str	r3, [r4, #12]

  /* If CR_BYPSHAD bit = 0, wait for synchro */
  if (READ_BIT(RTC->CR, RTC_CR_BYPSHAD) == 0U)
 c009d36:	69a3      	ldr	r3, [r4, #24]
 c009d38:	069b      	lsls	r3, r3, #26
 c009d3a:	d406      	bmi.n	c009d4a <RTC_ExitInitMode+0x22>
  {
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 c009d3c:	f7ff ffb4 	bl	c009ca8 <HAL_RTC_WaitForSynchro>
 c009d40:	b110      	cbz	r0, c009d48 <RTC_ExitInitMode+0x20>
    {
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c009d42:	2003      	movs	r0, #3
 c009d44:	f885 0025 	strb.w	r0, [r5, #37]	; 0x25
    /* Restore BYPSHAD bit */
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
  }

  return status;
}
 c009d48:	bd38      	pop	{r3, r4, r5, pc}
    CLEAR_BIT(RTC->CR, RTC_CR_BYPSHAD);
 c009d4a:	69a3      	ldr	r3, [r4, #24]
 c009d4c:	f023 0320 	bic.w	r3, r3, #32
 c009d50:	61a3      	str	r3, [r4, #24]
    if (HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 c009d52:	f7ff ffa9 	bl	c009ca8 <HAL_RTC_WaitForSynchro>
 c009d56:	b110      	cbz	r0, c009d5e <RTC_ExitInitMode+0x36>
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 c009d58:	2003      	movs	r0, #3
 c009d5a:	f885 0025 	strb.w	r0, [r5, #37]	; 0x25
    SET_BIT(RTC->CR, RTC_CR_BYPSHAD);
 c009d5e:	69a3      	ldr	r3, [r4, #24]
 c009d60:	f043 0320 	orr.w	r3, r3, #32
 c009d64:	61a3      	str	r3, [r4, #24]
 c009d66:	e7ef      	b.n	c009d48 <RTC_ExitInitMode+0x20>
 c009d68:	50002800 	.word	0x50002800

0c009d6c <HAL_RTC_Init>:
{
 c009d6c:	b538      	push	{r3, r4, r5, lr}
  if (hrtc != NULL)
 c009d6e:	4604      	mov	r4, r0
 c009d70:	2800      	cmp	r0, #0
 c009d72:	d03f      	beq.n	c009df4 <HAL_RTC_Init+0x88>
    if (hrtc->State == HAL_RTC_STATE_RESET)
 c009d74:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 c009d78:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 c009d7c:	b91b      	cbnz	r3, c009d86 <HAL_RTC_Init+0x1a>
      hrtc->Lock = HAL_UNLOCKED;
 c009d7e:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
      HAL_RTC_MspInit(hrtc);
 c009d82:	f7fa fdc5 	bl	c004910 <HAL_RTC_MspInit>
    hrtc->State = HAL_RTC_STATE_BUSY;
 c009d86:	2302      	movs	r3, #2
 c009d88:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 c009d8c:	23ca      	movs	r3, #202	; 0xca
 c009d8e:	4d1a      	ldr	r5, [pc, #104]	; (c009df8 <HAL_RTC_Init+0x8c>)
    status = RTC_EnterInitMode(hrtc);
 c009d90:	4620      	mov	r0, r4
    __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 c009d92:	626b      	str	r3, [r5, #36]	; 0x24
 c009d94:	2353      	movs	r3, #83	; 0x53
 c009d96:	626b      	str	r3, [r5, #36]	; 0x24
    status = RTC_EnterInitMode(hrtc);
 c009d98:	f7ff ff9e 	bl	c009cd8 <RTC_EnterInitMode>
    if (status == HAL_OK)
 c009d9c:	bb30      	cbnz	r0, c009dec <HAL_RTC_Init+0x80>
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 c009d9e:	69ab      	ldr	r3, [r5, #24]
      status = RTC_ExitInitMode(hrtc);
 c009da0:	4620      	mov	r0, r4
      CLEAR_BIT(RTC->CR, (RTC_CR_FMT | RTC_CR_POL | RTC_CR_OSEL | RTC_CR_TAMPOE));
 c009da2:	f023 638e 	bic.w	r3, r3, #74448896	; 0x4700000
 c009da6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 c009daa:	61ab      	str	r3, [r5, #24]
      SET_BIT(RTC->CR, (hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity));
 c009dac:	6863      	ldr	r3, [r4, #4]
 c009dae:	6921      	ldr	r1, [r4, #16]
 c009db0:	69aa      	ldr	r2, [r5, #24]
 c009db2:	430b      	orrs	r3, r1
 c009db4:	4313      	orrs	r3, r2
 c009db6:	69a2      	ldr	r2, [r4, #24]
 c009db8:	4313      	orrs	r3, r2
 c009dba:	61ab      	str	r3, [r5, #24]
      WRITE_REG(RTC->PRER, ((hrtc->Init.SynchPrediv) | (hrtc->Init.AsynchPrediv << RTC_PRER_PREDIV_A_Pos)));
 c009dbc:	e9d4 2302 	ldrd	r2, r3, [r4, #8]
 c009dc0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 c009dc4:	612b      	str	r3, [r5, #16]
      status = RTC_ExitInitMode(hrtc);
 c009dc6:	f7ff ffaf 	bl	c009d28 <RTC_ExitInitMode>
      if (status == HAL_OK)
 c009dca:	b978      	cbnz	r0, c009dec <HAL_RTC_Init+0x80>
        MODIFY_REG(RTC->CR, \
 c009dcc:	e9d4 1307 	ldrd	r1, r3, [r4, #28]
 c009dd0:	69aa      	ldr	r2, [r5, #24]
 c009dd2:	430b      	orrs	r3, r1
 c009dd4:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
 c009dd8:	4313      	orrs	r3, r2
 c009dda:	6962      	ldr	r2, [r4, #20]
 c009ddc:	4313      	orrs	r3, r2
 c009dde:	61ab      	str	r3, [r5, #24]
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 c009de0:	23ff      	movs	r3, #255	; 0xff
 c009de2:	626b      	str	r3, [r5, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_READY;
 c009de4:	2301      	movs	r3, #1
 c009de6:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
}
 c009dea:	bd38      	pop	{r3, r4, r5, pc}
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 c009dec:	22ff      	movs	r2, #255	; 0xff
 c009dee:	4b02      	ldr	r3, [pc, #8]	; (c009df8 <HAL_RTC_Init+0x8c>)
 c009df0:	625a      	str	r2, [r3, #36]	; 0x24
 c009df2:	e7fa      	b.n	c009dea <HAL_RTC_Init+0x7e>
  HAL_StatusTypeDef status = HAL_ERROR;
 c009df4:	2001      	movs	r0, #1
 c009df6:	e7f8      	b.n	c009dea <HAL_RTC_Init+0x7e>
 c009df8:	50002800 	.word	0x50002800

0c009dfc <HAL_RTCEx_BKUPWrite>:
  UNUSED(hrtc);
  /* Check the parameters */
  assert_param(IS_RTC_BKP(BackupRegister));

  tmp = (uint32_t) & (TAMP->BKP0R);
  tmp += (BackupRegister * 4U);
 c009dfc:	0089      	lsls	r1, r1, #2
 c009dfe:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
 c009e02:	f501 5154 	add.w	r1, r1, #13568	; 0x3500

  /* Write the specified register */
  *(__IO uint32_t *)tmp = (uint32_t)Data;
 c009e06:	600a      	str	r2, [r1, #0]
}
 c009e08:	4770      	bx	lr

0c009e0a <HAL_UART_MspInit>:
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UART_MspInit can be implemented in the user file
   */
}
 c009e0a:	4770      	bx	lr

0c009e0c <HAL_UART_RxCpltCallback>:
 c009e0c:	4770      	bx	lr

0c009e0e <HAL_UART_ErrorCallback>:
 c009e0e:	4770      	bx	lr

0c009e10 <HAL_UARTEx_RxEventCallback>:
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
 c009e10:	4770      	bx	lr

0c009e12 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009e12:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
{
 c009e16:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009e18:	2a22      	cmp	r2, #34	; 0x22
{
 c009e1a:	4604      	mov	r4, r0
 c009e1c:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009e1e:	d130      	bne.n	c009e82 <UART_RxISR_8BIT+0x70>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c009e20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c009e22:	f890 1060 	ldrb.w	r1, [r0, #96]	; 0x60
 c009e26:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c009e28:	400b      	ands	r3, r1
 c009e2a:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
 c009e2c:	6d83      	ldr	r3, [r0, #88]	; 0x58
 c009e2e:	3301      	adds	r3, #1
 c009e30:	6583      	str	r3, [r0, #88]	; 0x58
    huart->RxXferCount--;
 c009e32:	f8b0 305e 	ldrh.w	r3, [r0, #94]	; 0x5e
 c009e36:	3b01      	subs	r3, #1
 c009e38:	b29b      	uxth	r3, r3
 c009e3a:	f8a0 305e 	strh.w	r3, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 c009e3e:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c009e42:	b292      	uxth	r2, r2
 c009e44:	b9ca      	cbnz	r2, c009e7a <UART_RxISR_8BIT+0x68>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c009e46:	6803      	ldr	r3, [r0, #0]
 c009e48:	6819      	ldr	r1, [r3, #0]
 c009e4a:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 c009e4e:	6019      	str	r1, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c009e50:	6899      	ldr	r1, [r3, #8]
 c009e52:	f021 0101 	bic.w	r1, r1, #1
 c009e56:	6099      	str	r1, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c009e58:	2120      	movs	r1, #32
 c009e5a:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 c009e5e:	6702      	str	r2, [r0, #112]	; 0x70

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c009e60:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 c009e62:	2a01      	cmp	r2, #1
 c009e64:	d10a      	bne.n	c009e7c <UART_RxISR_8BIT+0x6a>
      {
        /* Disable IDLE interrupt */
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c009e66:	681a      	ldr	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c009e68:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c009e6c:	f022 0210 	bic.w	r2, r2, #16
 c009e70:	601a      	str	r2, [r3, #0]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c009e72:	f7ff ffcd 	bl	c009e10 <HAL_UARTEx_RxEventCallback>
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c009e76:	2300      	movs	r3, #0
 c009e78:	66e3      	str	r3, [r4, #108]	; 0x6c
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c009e7a:	bd10      	pop	{r4, pc}
        HAL_UART_RxCpltCallback(huart);
 c009e7c:	f7ff ffc6 	bl	c009e0c <HAL_UART_RxCpltCallback>
 c009e80:	e7f9      	b.n	c009e76 <UART_RxISR_8BIT+0x64>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c009e82:	699a      	ldr	r2, [r3, #24]
 c009e84:	f042 0208 	orr.w	r2, r2, #8
 c009e88:	619a      	str	r2, [r3, #24]
}
 c009e8a:	e7f6      	b.n	c009e7a <UART_RxISR_8BIT+0x68>

0c009e8c <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009e8c:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
{
 c009e90:	b510      	push	{r4, lr}
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009e92:	2a22      	cmp	r2, #34	; 0x22
{
 c009e94:	4604      	mov	r4, r0
 c009e96:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009e98:	d12e      	bne.n	c009ef8 <UART_RxISR_16BIT+0x6c>
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c009e9a:	6a59      	ldr	r1, [r3, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 c009e9c:	f8b0 2060 	ldrh.w	r2, [r0, #96]	; 0x60
 c009ea0:	4011      	ands	r1, r2
 c009ea2:	6d82      	ldr	r2, [r0, #88]	; 0x58
 c009ea4:	f822 1b02 	strh.w	r1, [r2], #2
    huart->pRxBuffPtr += 2U;
 c009ea8:	6582      	str	r2, [r0, #88]	; 0x58
    huart->RxXferCount--;
 c009eaa:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c009eae:	3a01      	subs	r2, #1
 c009eb0:	b292      	uxth	r2, r2
 c009eb2:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e

    if (huart->RxXferCount == 0U)
 c009eb6:	f8b0 205e 	ldrh.w	r2, [r0, #94]	; 0x5e
 c009eba:	b292      	uxth	r2, r2
 c009ebc:	b9c2      	cbnz	r2, c009ef0 <UART_RxISR_16BIT+0x64>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 c009ebe:	6819      	ldr	r1, [r3, #0]
 c009ec0:	f421 7190 	bic.w	r1, r1, #288	; 0x120
 c009ec4:	6019      	str	r1, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c009ec6:	6899      	ldr	r1, [r3, #8]
 c009ec8:	f021 0101 	bic.w	r1, r1, #1
 c009ecc:	6099      	str	r1, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 c009ece:	2120      	movs	r1, #32
 c009ed0:	f8c0 1088 	str.w	r1, [r0, #136]	; 0x88

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 c009ed4:	6702      	str	r2, [r0, #112]	; 0x70

      /* Check current reception Mode :
         If Reception till IDLE event has been selected : */
      if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c009ed6:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 c009ed8:	2a01      	cmp	r2, #1
 c009eda:	d10a      	bne.n	c009ef2 <UART_RxISR_16BIT+0x66>
      {
        /* Disable IDLE interrupt */
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c009edc:	681a      	ldr	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, huart->RxXferSize);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c009ede:	f8b0 105c 	ldrh.w	r1, [r0, #92]	; 0x5c
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c009ee2:	f022 0210 	bic.w	r2, r2, #16
 c009ee6:	601a      	str	r2, [r3, #0]
        HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c009ee8:	f7ff ff92 	bl	c009e10 <HAL_UARTEx_RxEventCallback>
#else
        /*Call legacy weak Rx complete callback*/
        HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      }
      huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c009eec:	2300      	movs	r3, #0
 c009eee:	66e3      	str	r3, [r4, #108]	; 0x6c
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c009ef0:	bd10      	pop	{r4, pc}
        HAL_UART_RxCpltCallback(huart);
 c009ef2:	f7ff ff8b 	bl	c009e0c <HAL_UART_RxCpltCallback>
 c009ef6:	e7f9      	b.n	c009eec <UART_RxISR_16BIT+0x60>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c009ef8:	699a      	ldr	r2, [r3, #24]
 c009efa:	f042 0208 	orr.w	r2, r2, #8
 c009efe:	619a      	str	r2, [r3, #24]
}
 c009f00:	e7f6      	b.n	c009ef0 <UART_RxISR_16BIT+0x64>
	...

0c009f04 <UART_RxISR_8BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_8BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 c009f04:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c009f08:	6803      	ldr	r3, [r0, #0]
{
 c009f0a:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c009f0c:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 c009f0e:	f8d3 9000 	ldr.w	r9, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 c009f12:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c009f14:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 c009f18:	2a22      	cmp	r2, #34	; 0x22
 c009f1a:	f040 8085 	bne.w	c00a028 <UART_RxISR_8BIT_FIFOEN+0x124>
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c009f1e:	2700      	movs	r7, #0
  uint16_t  uhMask = huart->Mask;
 c009f20:	f8b0 8060 	ldrh.w	r8, [r0, #96]	; 0x60
    nb_rx_data = huart->NbRxDataToProcess;
 c009f24:	f8b0 a068 	ldrh.w	sl, [r0, #104]	; 0x68
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c009f28:	f8df b10c 	ldr.w	fp, [pc, #268]	; c00a038 <UART_RxISR_8BIT_FIFOEN+0x134>
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c009f2c:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c009f30:	f1ba 0f00 	cmp.w	sl, #0
 c009f34:	d001      	beq.n	c009f3a <UART_RxISR_8BIT_FIFOEN+0x36>
 c009f36:	06ab      	lsls	r3, r5, #26
 c009f38:	d414      	bmi.n	c009f64 <UART_RxISR_8BIT_FIFOEN+0x60>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c009f3a:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c009f3e:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c009f40:	b173      	cbz	r3, c009f60 <UART_RxISR_8BIT_FIFOEN+0x5c>
 c009f42:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 c009f46:	429a      	cmp	r2, r3
 c009f48:	d90a      	bls.n	c009f60 <UART_RxISR_8BIT_FIFOEN+0x5c>
    {
      /* Disable the UART RXFT interrupt*/
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c009f4a:	6823      	ldr	r3, [r4, #0]
 c009f4c:	689a      	ldr	r2, [r3, #8]
 c009f4e:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 c009f52:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_8BIT;
 c009f54:	4a37      	ldr	r2, [pc, #220]	; (c00a034 <UART_RxISR_8BIT_FIFOEN+0x130>)
 c009f56:	6722      	str	r2, [r4, #112]	; 0x70

      /* Enable the UART Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c009f58:	681a      	ldr	r2, [r3, #0]
 c009f5a:	f042 0220 	orr.w	r2, r2, #32
 c009f5e:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c009f60:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c009f64:	6823      	ldr	r3, [r4, #0]
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c009f66:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c009f68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 c009f6a:	ea03 0308 	and.w	r3, r3, r8
 c009f6e:	7013      	strb	r3, [r2, #0]
      huart->pRxBuffPtr++;
 c009f70:	6da3      	ldr	r3, [r4, #88]	; 0x58
 c009f72:	3301      	adds	r3, #1
 c009f74:	65a3      	str	r3, [r4, #88]	; 0x58
      huart->RxXferCount--;
 c009f76:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c009f7a:	3b01      	subs	r3, #1
 c009f7c:	b29b      	uxth	r3, r3
 c009f7e:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 c009f82:	6823      	ldr	r3, [r4, #0]
 c009f84:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 c009f86:	076a      	lsls	r2, r5, #29
 c009f88:	d02a      	beq.n	c009fe0 <UART_RxISR_8BIT_FIFOEN+0xdc>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 c009f8a:	07e8      	lsls	r0, r5, #31
 c009f8c:	d50a      	bpl.n	c009fa4 <UART_RxISR_8BIT_FIFOEN+0xa0>
 c009f8e:	f419 7f80 	tst.w	r9, #256	; 0x100
 c009f92:	d007      	beq.n	c009fa4 <UART_RxISR_8BIT_FIFOEN+0xa0>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 c009f94:	2201      	movs	r2, #1
 c009f96:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 c009f98:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c009f9c:	f042 0201 	orr.w	r2, r2, #1
 c009fa0:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c009fa4:	07a9      	lsls	r1, r5, #30
 c009fa6:	d508      	bpl.n	c009fba <UART_RxISR_8BIT_FIFOEN+0xb6>
 c009fa8:	b13e      	cbz	r6, c009fba <UART_RxISR_8BIT_FIFOEN+0xb6>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 c009faa:	2202      	movs	r2, #2
 c009fac:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 c009fae:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c009fb2:	f042 0204 	orr.w	r2, r2, #4
 c009fb6:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c009fba:	076a      	lsls	r2, r5, #29
 c009fbc:	d508      	bpl.n	c009fd0 <UART_RxISR_8BIT_FIFOEN+0xcc>
 c009fbe:	b13e      	cbz	r6, c009fd0 <UART_RxISR_8BIT_FIFOEN+0xcc>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 c009fc0:	2204      	movs	r2, #4
 c009fc2:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 c009fc4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c009fc8:	f043 0302 	orr.w	r3, r3, #2
 c009fcc:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 c009fd0:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c009fd4:	b123      	cbz	r3, c009fe0 <UART_RxISR_8BIT_FIFOEN+0xdc>
          HAL_UART_ErrorCallback(huart);
 c009fd6:	4620      	mov	r0, r4
 c009fd8:	f7ff ff19 	bl	c009e0e <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c009fdc:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 c009fe0:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c009fe4:	b292      	uxth	r2, r2
 c009fe6:	2a00      	cmp	r2, #0
 c009fe8:	d1a2      	bne.n	c009f30 <UART_RxISR_8BIT_FIFOEN+0x2c>
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c009fea:	6823      	ldr	r3, [r4, #0]
 c009fec:	6819      	ldr	r1, [r3, #0]
 c009fee:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 c009ff2:	6019      	str	r1, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c009ff4:	6899      	ldr	r1, [r3, #8]
 c009ff6:	ea01 010b 	and.w	r1, r1, fp
 c009ffa:	6099      	str	r1, [r3, #8]
        huart->RxState = HAL_UART_STATE_READY;
 c009ffc:	2120      	movs	r1, #32
 c009ffe:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 c00a002:	6722      	str	r2, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c00a004:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 c00a006:	2a01      	cmp	r2, #1
 c00a008:	d10a      	bne.n	c00a020 <UART_RxISR_8BIT_FIFOEN+0x11c>
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c00a00a:	681a      	ldr	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c00a00c:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c00a010:	f022 0210 	bic.w	r2, r2, #16
 c00a014:	601a      	str	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c00a016:	4620      	mov	r0, r4
 c00a018:	f7ff fefa 	bl	c009e10 <HAL_UARTEx_RxEventCallback>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00a01c:	66e7      	str	r7, [r4, #108]	; 0x6c
 c00a01e:	e787      	b.n	c009f30 <UART_RxISR_8BIT_FIFOEN+0x2c>
          HAL_UART_RxCpltCallback(huart);
 c00a020:	4620      	mov	r0, r4
 c00a022:	f7ff fef3 	bl	c009e0c <HAL_UART_RxCpltCallback>
 c00a026:	e7f9      	b.n	c00a01c <UART_RxISR_8BIT_FIFOEN+0x118>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c00a028:	699a      	ldr	r2, [r3, #24]
 c00a02a:	f042 0208 	orr.w	r2, r2, #8
 c00a02e:	619a      	str	r2, [r3, #24]
}
 c00a030:	e796      	b.n	c009f60 <UART_RxISR_8BIT_FIFOEN+0x5c>
 c00a032:	bf00      	nop
 c00a034:	0c009e13 	.word	0x0c009e13
 c00a038:	effffffe 	.word	0xeffffffe

0c00a03c <UART_RxISR_16BIT_FIFOEN>:
  *         interruptions have been enabled by HAL_UART_Receive_IT()
  * @param huart UART handle.
  * @retval None
  */
static void UART_RxISR_16BIT_FIFOEN(UART_HandleTypeDef *huart)
{
 c00a03c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint16_t *tmp;
  uint16_t  uhMask = huart->Mask;
  uint16_t  uhdata;
  uint16_t  nb_rx_data;
  uint16_t  rxdatacount;
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c00a040:	6803      	ldr	r3, [r0, #0]
{
 c00a042:	4604      	mov	r4, r0
  uint32_t  isrflags = READ_REG(huart->Instance->ISR);
 c00a044:	69dd      	ldr	r5, [r3, #28]
  uint32_t  cr1its   = READ_REG(huart->Instance->CR1);
 c00a046:	f8d3 9000 	ldr.w	r9, [r3]
  uint32_t  cr3its   = READ_REG(huart->Instance->CR3);
 c00a04a:	689e      	ldr	r6, [r3, #8]

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 c00a04c:	f8d0 2088 	ldr.w	r2, [r0, #136]	; 0x88
 c00a050:	2a22      	cmp	r2, #34	; 0x22
 c00a052:	f040 8083 	bne.w	c00a15c <UART_RxISR_16BIT_FIFOEN+0x120>
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a056:	2700      	movs	r7, #0
  uint16_t  uhMask = huart->Mask;
 c00a058:	f8b0 8060 	ldrh.w	r8, [r0, #96]	; 0x60
    nb_rx_data = huart->NbRxDataToProcess;
 c00a05c:	f8b0 a068 	ldrh.w	sl, [r0, #104]	; 0x68
      {
        /* Disable the UART Parity Error Interrupt and RXFT interrupt*/
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) and RX FIFO Threshold interrupt */
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c00a060:	f8df b108 	ldr.w	fp, [pc, #264]	; c00a16c <UART_RxISR_16BIT_FIFOEN+0x130>
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c00a064:	f006 0601 	and.w	r6, r6, #1
    while ((nb_rx_data > 0U) && ((isrflags & USART_ISR_RXNE_RXFNE) != 0U))
 c00a068:	f1ba 0f00 	cmp.w	sl, #0
 c00a06c:	d001      	beq.n	c00a072 <UART_RxISR_16BIT_FIFOEN+0x36>
 c00a06e:	06ab      	lsls	r3, r5, #26
 c00a070:	d414      	bmi.n	c00a09c <UART_RxISR_16BIT_FIFOEN+0x60>

    /* When remaining number of bytes to receive is less than the RX FIFO
    threshold, next incoming frames are processed as if FIFO mode was
    disabled (i.e. one interrupt per received frame).
    */
    rxdatacount = huart->RxXferCount;
 c00a072:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 c00a076:	b29b      	uxth	r3, r3
    if ((rxdatacount != 0U) && (rxdatacount < huart->NbRxDataToProcess))
 c00a078:	b173      	cbz	r3, c00a098 <UART_RxISR_16BIT_FIFOEN+0x5c>
 c00a07a:	f8b4 2068 	ldrh.w	r2, [r4, #104]	; 0x68
 c00a07e:	429a      	cmp	r2, r3
 c00a080:	d90a      	bls.n	c00a098 <UART_RxISR_16BIT_FIFOEN+0x5c>
    {
      /* Disable the UART RXFT interrupt*/
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c00a082:	6823      	ldr	r3, [r4, #0]
 c00a084:	689a      	ldr	r2, [r3, #8]
 c00a086:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 c00a08a:	609a      	str	r2, [r3, #8]

      /* Update the RxISR function pointer */
      huart->RxISR = UART_RxISR_16BIT;
 c00a08c:	4a36      	ldr	r2, [pc, #216]	; (c00a168 <UART_RxISR_16BIT_FIFOEN+0x12c>)
 c00a08e:	6722      	str	r2, [r4, #112]	; 0x70

      /* Enable the UART Data Register Not Empty interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RXNEIE_RXFNEIE);
 c00a090:	681a      	ldr	r2, [r3, #0]
 c00a092:	f042 0220 	orr.w	r2, r2, #32
 c00a096:	601a      	str	r2, [r3, #0]
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 c00a098:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c00a09c:	6823      	ldr	r3, [r4, #0]
      *tmp = (uint16_t)(uhdata & uhMask);
 c00a09e:	6da2      	ldr	r2, [r4, #88]	; 0x58
      uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 c00a0a0:	6a59      	ldr	r1, [r3, #36]	; 0x24
      *tmp = (uint16_t)(uhdata & uhMask);
 c00a0a2:	ea08 0101 	and.w	r1, r8, r1
 c00a0a6:	f822 1b02 	strh.w	r1, [r2], #2
      huart->pRxBuffPtr += 2U;
 c00a0aa:	65a2      	str	r2, [r4, #88]	; 0x58
      huart->RxXferCount--;
 c00a0ac:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c00a0b0:	3a01      	subs	r2, #1
 c00a0b2:	b292      	uxth	r2, r2
 c00a0b4:	f8a4 205e 	strh.w	r2, [r4, #94]	; 0x5e
      isrflags = READ_REG(huart->Instance->ISR);
 c00a0b8:	69dd      	ldr	r5, [r3, #28]
      if ((isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_NE)) != 0U)
 c00a0ba:	076a      	lsls	r2, r5, #29
 c00a0bc:	d02a      	beq.n	c00a114 <UART_RxISR_16BIT_FIFOEN+0xd8>
        if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 c00a0be:	07e8      	lsls	r0, r5, #31
 c00a0c0:	d50a      	bpl.n	c00a0d8 <UART_RxISR_16BIT_FIFOEN+0x9c>
 c00a0c2:	f419 7f80 	tst.w	r9, #256	; 0x100
 c00a0c6:	d007      	beq.n	c00a0d8 <UART_RxISR_16BIT_FIFOEN+0x9c>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 c00a0c8:	2201      	movs	r2, #1
 c00a0ca:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_PE;
 c00a0cc:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c00a0d0:	f042 0201 	orr.w	r2, r2, #1
 c00a0d4:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c00a0d8:	07a9      	lsls	r1, r5, #30
 c00a0da:	d508      	bpl.n	c00a0ee <UART_RxISR_16BIT_FIFOEN+0xb2>
 c00a0dc:	b13e      	cbz	r6, c00a0ee <UART_RxISR_16BIT_FIFOEN+0xb2>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 c00a0de:	2202      	movs	r2, #2
 c00a0e0:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_FE;
 c00a0e2:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 c00a0e6:	f042 0204 	orr.w	r2, r2, #4
 c00a0ea:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
        if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 c00a0ee:	076a      	lsls	r2, r5, #29
 c00a0f0:	d508      	bpl.n	c00a104 <UART_RxISR_16BIT_FIFOEN+0xc8>
 c00a0f2:	b13e      	cbz	r6, c00a104 <UART_RxISR_16BIT_FIFOEN+0xc8>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 c00a0f4:	2204      	movs	r2, #4
 c00a0f6:	621a      	str	r2, [r3, #32]
          huart->ErrorCode |= HAL_UART_ERROR_NE;
 c00a0f8:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c00a0fc:	f043 0302 	orr.w	r3, r3, #2
 c00a100:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
        if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 c00a104:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
 c00a108:	b123      	cbz	r3, c00a114 <UART_RxISR_16BIT_FIFOEN+0xd8>
          HAL_UART_ErrorCallback(huart);
 c00a10a:	4620      	mov	r0, r4
 c00a10c:	f7ff fe7f 	bl	c009e0e <HAL_UART_ErrorCallback>
          huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a110:	f8c4 708c 	str.w	r7, [r4, #140]	; 0x8c
      if (huart->RxXferCount == 0U)
 c00a114:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
 c00a118:	b292      	uxth	r2, r2
 c00a11a:	2a00      	cmp	r2, #0
 c00a11c:	d1a4      	bne.n	c00a068 <UART_RxISR_16BIT_FIFOEN+0x2c>
        CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c00a11e:	6823      	ldr	r3, [r4, #0]
 c00a120:	6819      	ldr	r1, [r3, #0]
 c00a122:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 c00a126:	6019      	str	r1, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 c00a128:	6899      	ldr	r1, [r3, #8]
 c00a12a:	ea01 010b 	and.w	r1, r1, fp
 c00a12e:	6099      	str	r1, [r3, #8]
        huart->RxState = HAL_UART_STATE_READY;
 c00a130:	2120      	movs	r1, #32
 c00a132:	f8c4 1088 	str.w	r1, [r4, #136]	; 0x88
        huart->RxISR = NULL;
 c00a136:	6722      	str	r2, [r4, #112]	; 0x70
        if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 c00a138:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 c00a13a:	2a01      	cmp	r2, #1
 c00a13c:	d10a      	bne.n	c00a154 <UART_RxISR_16BIT_FIFOEN+0x118>
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c00a13e:	681a      	ldr	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c00a140:	f8b4 105c 	ldrh.w	r1, [r4, #92]	; 0x5c
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 c00a144:	f022 0210 	bic.w	r2, r2, #16
 c00a148:	601a      	str	r2, [r3, #0]
          HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
 c00a14a:	4620      	mov	r0, r4
 c00a14c:	f7ff fe60 	bl	c009e10 <HAL_UARTEx_RxEventCallback>
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00a150:	66e7      	str	r7, [r4, #108]	; 0x6c
 c00a152:	e789      	b.n	c00a068 <UART_RxISR_16BIT_FIFOEN+0x2c>
          HAL_UART_RxCpltCallback(huart);
 c00a154:	4620      	mov	r0, r4
 c00a156:	f7ff fe59 	bl	c009e0c <HAL_UART_RxCpltCallback>
 c00a15a:	e7f9      	b.n	c00a150 <UART_RxISR_16BIT_FIFOEN+0x114>
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 c00a15c:	699a      	ldr	r2, [r3, #24]
 c00a15e:	f042 0208 	orr.w	r2, r2, #8
 c00a162:	619a      	str	r2, [r3, #24]
}
 c00a164:	e798      	b.n	c00a098 <UART_RxISR_16BIT_FIFOEN+0x5c>
 c00a166:	bf00      	nop
 c00a168:	0c009e8d 	.word	0x0c009e8d
 c00a16c:	effffffe 	.word	0xeffffffe

0c00a170 <UART_SetConfig>:
{
 c00a170:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 c00a174:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c00a176:	6921      	ldr	r1, [r4, #16]
 c00a178:	68a2      	ldr	r2, [r4, #8]
  if (UART_INSTANCE_LOWPOWER(huart))
 c00a17a:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c00a17c:	430a      	orrs	r2, r1
 c00a17e:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c00a180:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c00a182:	69c0      	ldr	r0, [r0, #28]
 c00a184:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c00a186:	49a6      	ldr	r1, [pc, #664]	; (c00a420 <UART_SetConfig+0x2b0>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 c00a188:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 c00a18a:	4029      	ands	r1, r5
 c00a18c:	430a      	orrs	r2, r1
 c00a18e:	601a      	str	r2, [r3, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 c00a190:	685a      	ldr	r2, [r3, #4]
 c00a192:	68e1      	ldr	r1, [r4, #12]
 c00a194:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 c00a198:	430a      	orrs	r2, r1
 c00a19a:	605a      	str	r2, [r3, #4]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c00a19c:	4aa1      	ldr	r2, [pc, #644]	; (c00a424 <UART_SetConfig+0x2b4>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 c00a19e:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 c00a1a0:	4293      	cmp	r3, r2
    tmpreg |= huart->Init.OneBitSampling;
 c00a1a2:	bf1c      	itt	ne
 c00a1a4:	6a22      	ldrne	r2, [r4, #32]
 c00a1a6:	4311      	orrne	r1, r2
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 c00a1a8:	689a      	ldr	r2, [r3, #8]
 c00a1aa:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 c00a1ae:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 c00a1b2:	430a      	orrs	r2, r1
 c00a1b4:	609a      	str	r2, [r3, #8]
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 c00a1b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 c00a1b8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c00a1ba:	f022 020f 	bic.w	r2, r2, #15
 c00a1be:	430a      	orrs	r2, r1
 c00a1c0:	62da      	str	r2, [r3, #44]	; 0x2c
  UART_GETCLOCKSOURCE(huart, clocksource);
 c00a1c2:	4a99      	ldr	r2, [pc, #612]	; (c00a428 <UART_SetConfig+0x2b8>)
 c00a1c4:	4293      	cmp	r3, r2
 c00a1c6:	d117      	bne.n	c00a1f8 <UART_SetConfig+0x88>
 c00a1c8:	4b98      	ldr	r3, [pc, #608]	; (c00a42c <UART_SetConfig+0x2bc>)
 c00a1ca:	4a99      	ldr	r2, [pc, #612]	; (c00a430 <UART_SetConfig+0x2c0>)
 c00a1cc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c00a1d0:	f003 0303 	and.w	r3, r3, #3
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00a1d4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00a1d8:	5cd3      	ldrb	r3, [r2, r3]
 c00a1da:	f040 80a8 	bne.w	c00a32e <UART_SetConfig+0x1be>
    switch (clocksource)
 c00a1de:	2b08      	cmp	r3, #8
 c00a1e0:	d839      	bhi.n	c00a256 <UART_SetConfig+0xe6>
 c00a1e2:	e8df f013 	tbh	[pc, r3, lsl #1]
 c00a1e6:	00fa      	.short	0x00fa
 c00a1e8:	00a2009c 	.word	0x00a2009c
 c00a1ec:	00ee0038 	.word	0x00ee0038
 c00a1f0:	00380038 	.word	0x00380038
 c00a1f4:	009f0038 	.word	0x009f0038
  UART_GETCLOCKSOURCE(huart, clocksource);
 c00a1f8:	4a8e      	ldr	r2, [pc, #568]	; (c00a434 <UART_SetConfig+0x2c4>)
 c00a1fa:	4293      	cmp	r3, r2
 c00a1fc:	d106      	bne.n	c00a20c <UART_SetConfig+0x9c>
 c00a1fe:	4b8b      	ldr	r3, [pc, #556]	; (c00a42c <UART_SetConfig+0x2bc>)
 c00a200:	4a8d      	ldr	r2, [pc, #564]	; (c00a438 <UART_SetConfig+0x2c8>)
 c00a202:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 c00a206:	f003 030c 	and.w	r3, r3, #12
 c00a20a:	e7e3      	b.n	c00a1d4 <UART_SetConfig+0x64>
 c00a20c:	4a8b      	ldr	r2, [pc, #556]	; (c00a43c <UART_SetConfig+0x2cc>)
 c00a20e:	4293      	cmp	r3, r2
 c00a210:	d123      	bne.n	c00a25a <UART_SetConfig+0xea>
 c00a212:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 c00a216:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c00a21a:	f002 0230 	and.w	r2, r2, #48	; 0x30
 c00a21e:	2a10      	cmp	r2, #16
 c00a220:	f000 80c6 	beq.w	c00a3b0 <UART_SetConfig+0x240>
 c00a224:	d811      	bhi.n	c00a24a <UART_SetConfig+0xda>
 c00a226:	b9b2      	cbnz	r2, c00a256 <UART_SetConfig+0xe6>
  if (UART_INSTANCE_LOWPOWER(huart))
 c00a228:	4a7e      	ldr	r2, [pc, #504]	; (c00a424 <UART_SetConfig+0x2b4>)
 c00a22a:	4293      	cmp	r3, r2
 c00a22c:	f040 80d2 	bne.w	c00a3d4 <UART_SetConfig+0x264>
        pclk = HAL_RCC_GetPCLK1Freq();
 c00a230:	f7ff f8b8 	bl	c0093a4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 c00a234:	2800      	cmp	r0, #0
 c00a236:	d149      	bne.n	c00a2cc <UART_SetConfig+0x15c>
 c00a238:	2000      	movs	r0, #0
  huart->NbRxDataToProcess = 1;
 c00a23a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 c00a23e:	66a3      	str	r3, [r4, #104]	; 0x68
  huart->RxISR = NULL;
 c00a240:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 c00a242:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70
}
 c00a246:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 c00a24a:	2a20      	cmp	r2, #32
 c00a24c:	f000 80a2 	beq.w	c00a394 <UART_SetConfig+0x224>
 c00a250:	2a30      	cmp	r2, #48	; 0x30
 c00a252:	f000 80a7 	beq.w	c00a3a4 <UART_SetConfig+0x234>
        ret = HAL_ERROR;
 c00a256:	2001      	movs	r0, #1
 c00a258:	e7ef      	b.n	c00a23a <UART_SetConfig+0xca>
  UART_GETCLOCKSOURCE(huart, clocksource);
 c00a25a:	4a79      	ldr	r2, [pc, #484]	; (c00a440 <UART_SetConfig+0x2d0>)
 c00a25c:	4293      	cmp	r3, r2
 c00a25e:	d10e      	bne.n	c00a27e <UART_SetConfig+0x10e>
 c00a260:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 c00a264:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c00a268:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 c00a26c:	2a40      	cmp	r2, #64	; 0x40
 c00a26e:	f000 809f 	beq.w	c00a3b0 <UART_SetConfig+0x240>
 c00a272:	d9d8      	bls.n	c00a226 <UART_SetConfig+0xb6>
 c00a274:	2a80      	cmp	r2, #128	; 0x80
 c00a276:	f000 808d 	beq.w	c00a394 <UART_SetConfig+0x224>
 c00a27a:	2ac0      	cmp	r2, #192	; 0xc0
 c00a27c:	e7e9      	b.n	c00a252 <UART_SetConfig+0xe2>
 c00a27e:	f1b3 2f50 	cmp.w	r3, #1342197760	; 0x50005000
 c00a282:	d10f      	bne.n	c00a2a4 <UART_SetConfig+0x134>
 c00a284:	4a69      	ldr	r2, [pc, #420]	; (c00a42c <UART_SetConfig+0x2bc>)
 c00a286:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c00a28a:	f402 7240 	and.w	r2, r2, #768	; 0x300
 c00a28e:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 c00a292:	f000 808d 	beq.w	c00a3b0 <UART_SetConfig+0x240>
 c00a296:	d9c6      	bls.n	c00a226 <UART_SetConfig+0xb6>
 c00a298:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 c00a29c:	d07a      	beq.n	c00a394 <UART_SetConfig+0x224>
 c00a29e:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 c00a2a2:	e7d6      	b.n	c00a252 <UART_SetConfig+0xe2>
 c00a2a4:	4a5f      	ldr	r2, [pc, #380]	; (c00a424 <UART_SetConfig+0x2b4>)
 c00a2a6:	4293      	cmp	r3, r2
 c00a2a8:	d1d5      	bne.n	c00a256 <UART_SetConfig+0xe6>
 c00a2aa:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 c00a2ae:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 c00a2b2:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 c00a2b6:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 c00a2ba:	d079      	beq.n	c00a3b0 <UART_SetConfig+0x240>
 c00a2bc:	d9b3      	bls.n	c00a226 <UART_SetConfig+0xb6>
 c00a2be:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 c00a2c2:	d067      	beq.n	c00a394 <UART_SetConfig+0x224>
 c00a2c4:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 c00a2c8:	e7c3      	b.n	c00a252 <UART_SetConfig+0xe2>
        pclk = (uint32_t) HSI_VALUE;
 c00a2ca:	485e      	ldr	r0, [pc, #376]	; (c00a444 <UART_SetConfig+0x2d4>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c00a2cc:	4b5e      	ldr	r3, [pc, #376]	; (c00a448 <UART_SetConfig+0x2d8>)
 c00a2ce:	6a62      	ldr	r2, [r4, #36]	; 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c00a2d0:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c00a2d2:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c00a2d6:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 c00a2da:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 c00a2de:	4299      	cmp	r1, r3
 c00a2e0:	d8b9      	bhi.n	c00a256 <UART_SetConfig+0xe6>
 c00a2e2:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 c00a2e6:	d8b6      	bhi.n	c00a256 <UART_SetConfig+0xe6>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c00a2e8:	2300      	movs	r3, #0
 c00a2ea:	2100      	movs	r1, #0
 c00a2ec:	f005 f816 	bl	c00f31c <__aeabi_uldivmod>
 c00a2f0:	020f      	lsls	r7, r1, #8
 c00a2f2:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 c00a2f6:	0206      	lsls	r6, r0, #8
 c00a2f8:	0868      	lsrs	r0, r5, #1
 c00a2fa:	eb16 0b00 	adds.w	fp, r6, r0
 c00a2fe:	f147 0c00 	adc.w	ip, r7, #0
 c00a302:	462a      	mov	r2, r5
 c00a304:	2300      	movs	r3, #0
 c00a306:	4658      	mov	r0, fp
 c00a308:	4661      	mov	r1, ip
 c00a30a:	f005 f807 	bl	c00f31c <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 c00a30e:	4b4f      	ldr	r3, [pc, #316]	; (c00a44c <UART_SetConfig+0x2dc>)
 c00a310:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c00a314:	429a      	cmp	r2, r3
 c00a316:	d89e      	bhi.n	c00a256 <UART_SetConfig+0xe6>
        huart->Instance->BRR = usartdiv;
 c00a318:	6823      	ldr	r3, [r4, #0]
 c00a31a:	60d8      	str	r0, [r3, #12]
 c00a31c:	e78c      	b.n	c00a238 <UART_SetConfig+0xc8>
        pclk = HAL_RCC_GetPCLK2Freq();
 c00a31e:	f7ff f851 	bl	c0093c4 <HAL_RCC_GetPCLK2Freq>
        break;
 c00a322:	e05c      	b.n	c00a3de <UART_SetConfig+0x26e>
        pclk = (uint32_t) LSE_VALUE;
 c00a324:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 c00a328:	e05c      	b.n	c00a3e4 <UART_SetConfig+0x274>
        pclk = (uint32_t) HSI_VALUE;
 c00a32a:	4846      	ldr	r0, [pc, #280]	; (c00a444 <UART_SetConfig+0x2d4>)
 c00a32c:	e05a      	b.n	c00a3e4 <UART_SetConfig+0x274>
    switch (clocksource)
 c00a32e:	2b08      	cmp	r3, #8
 c00a330:	d891      	bhi.n	c00a256 <UART_SetConfig+0xe6>
 c00a332:	a201      	add	r2, pc, #4	; (adr r2, c00a338 <UART_SetConfig+0x1c8>)
 c00a334:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 c00a338:	0c00a35d 	.word	0x0c00a35d
 c00a33c:	0c00a389 	.word	0x0c00a389
 c00a340:	0c00a3a1 	.word	0x0c00a3a1
 c00a344:	0c00a257 	.word	0x0c00a257
 c00a348:	0c00a38f 	.word	0x0c00a38f
 c00a34c:	0c00a257 	.word	0x0c00a257
 c00a350:	0c00a257 	.word	0x0c00a257
 c00a354:	0c00a257 	.word	0x0c00a257
 c00a358:	0c00a3cf 	.word	0x0c00a3cf
        pclk = HAL_RCC_GetPCLK1Freq();
 c00a35c:	f7ff f822 	bl	c0093a4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 c00a360:	2800      	cmp	r0, #0
 c00a362:	f43f af69 	beq.w	c00a238 <UART_SetConfig+0xc8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c00a366:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c00a368:	4a37      	ldr	r2, [pc, #220]	; (c00a448 <UART_SetConfig+0x2d8>)
 c00a36a:	6863      	ldr	r3, [r4, #4]
 c00a36c:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 c00a370:	fbb0 f0f2 	udiv	r0, r0, r2
 c00a374:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 c00a378:	fbb0 f0f3 	udiv	r0, r0, r3
 c00a37c:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c00a37e:	f1a0 0210 	sub.w	r2, r0, #16
 c00a382:	f64f 73ef 	movw	r3, #65519	; 0xffef
 c00a386:	e7c5      	b.n	c00a314 <UART_SetConfig+0x1a4>
        pclk = HAL_RCC_GetPCLK2Freq();
 c00a388:	f7ff f81c 	bl	c0093c4 <HAL_RCC_GetPCLK2Freq>
        break;
 c00a38c:	e7e8      	b.n	c00a360 <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetSysClockFreq();
 c00a38e:	f7fe fc61 	bl	c008c54 <HAL_RCC_GetSysClockFreq>
        break;
 c00a392:	e7e5      	b.n	c00a360 <UART_SetConfig+0x1f0>
  if (UART_INSTANCE_LOWPOWER(huart))
 c00a394:	4a23      	ldr	r2, [pc, #140]	; (c00a424 <UART_SetConfig+0x2b4>)
 c00a396:	4293      	cmp	r3, r2
 c00a398:	d097      	beq.n	c00a2ca <UART_SetConfig+0x15a>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00a39a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00a39e:	d0c4      	beq.n	c00a32a <UART_SetConfig+0x1ba>
        pclk = (uint32_t) HSI_VALUE;
 c00a3a0:	4828      	ldr	r0, [pc, #160]	; (c00a444 <UART_SetConfig+0x2d4>)
 c00a3a2:	e7e0      	b.n	c00a366 <UART_SetConfig+0x1f6>
  if (UART_INSTANCE_LOWPOWER(huart))
 c00a3a4:	4a1f      	ldr	r2, [pc, #124]	; (c00a424 <UART_SetConfig+0x2b4>)
 c00a3a6:	4293      	cmp	r3, r2
 c00a3a8:	d10e      	bne.n	c00a3c8 <UART_SetConfig+0x258>
        pclk = (uint32_t) LSE_VALUE;
 c00a3aa:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 c00a3ae:	e78d      	b.n	c00a2cc <UART_SetConfig+0x15c>
  if (UART_INSTANCE_LOWPOWER(huart))
 c00a3b0:	4a1c      	ldr	r2, [pc, #112]	; (c00a424 <UART_SetConfig+0x2b4>)
 c00a3b2:	4293      	cmp	r3, r2
 c00a3b4:	d102      	bne.n	c00a3bc <UART_SetConfig+0x24c>
        pclk = HAL_RCC_GetSysClockFreq();
 c00a3b6:	f7fe fc4d 	bl	c008c54 <HAL_RCC_GetSysClockFreq>
        break;
 c00a3ba:	e73b      	b.n	c00a234 <UART_SetConfig+0xc4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00a3bc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00a3c0:	d1e5      	bne.n	c00a38e <UART_SetConfig+0x21e>
        pclk = HAL_RCC_GetSysClockFreq();
 c00a3c2:	f7fe fc47 	bl	c008c54 <HAL_RCC_GetSysClockFreq>
        break;
 c00a3c6:	e00a      	b.n	c00a3de <UART_SetConfig+0x26e>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00a3c8:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00a3cc:	d00a      	beq.n	c00a3e4 <UART_SetConfig+0x274>
        pclk = (uint32_t) LSE_VALUE;
 c00a3ce:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 c00a3d2:	e7c8      	b.n	c00a366 <UART_SetConfig+0x1f6>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 c00a3d4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 c00a3d8:	d1c0      	bne.n	c00a35c <UART_SetConfig+0x1ec>
        pclk = HAL_RCC_GetPCLK1Freq();
 c00a3da:	f7fe ffe3 	bl	c0093a4 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 c00a3de:	2800      	cmp	r0, #0
 c00a3e0:	f43f af2a 	beq.w	c00a238 <UART_SetConfig+0xc8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 c00a3e4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 c00a3e6:	4b18      	ldr	r3, [pc, #96]	; (c00a448 <UART_SetConfig+0x2d8>)
 c00a3e8:	6862      	ldr	r2, [r4, #4]
 c00a3ea:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 c00a3ee:	fbb0 f3f3 	udiv	r3, r0, r3
 c00a3f2:	0850      	lsrs	r0, r2, #1
 c00a3f4:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 c00a3f8:	fbb0 f0f2 	udiv	r0, r0, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 c00a3fc:	f64f 72ef 	movw	r2, #65519	; 0xffef
 c00a400:	b283      	uxth	r3, r0
 c00a402:	f1a3 0110 	sub.w	r1, r3, #16
 c00a406:	4291      	cmp	r1, r2
 c00a408:	f63f af25 	bhi.w	c00a256 <UART_SetConfig+0xe6>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 c00a40c:	f020 000f 	bic.w	r0, r0, #15
 c00a410:	b280      	uxth	r0, r0
        huart->Instance->BRR = brrtemp;
 c00a412:	6822      	ldr	r2, [r4, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 c00a414:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 c00a418:	4318      	orrs	r0, r3
 c00a41a:	60d0      	str	r0, [r2, #12]
 c00a41c:	e70c      	b.n	c00a238 <UART_SetConfig+0xc8>
 c00a41e:	bf00      	nop
 c00a420:	cfff69f3 	.word	0xcfff69f3
 c00a424:	50008000 	.word	0x50008000
 c00a428:	50013800 	.word	0x50013800
 c00a42c:	50021000 	.word	0x50021000
 c00a430:	0c010190 	.word	0x0c010190
 c00a434:	50004400 	.word	0x50004400
 c00a438:	0c010194 	.word	0x0c010194
 c00a43c:	50004800 	.word	0x50004800
 c00a440:	50004c00 	.word	0x50004c00
 c00a444:	00f42400 	.word	0x00f42400
 c00a448:	0c0101a2 	.word	0x0c0101a2
 c00a44c:	000ffcff 	.word	0x000ffcff

0c00a450 <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c00a450:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 c00a452:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 c00a454:	07da      	lsls	r2, r3, #31
 c00a456:	d506      	bpl.n	c00a466 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 c00a458:	6801      	ldr	r1, [r0, #0]
 c00a45a:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 c00a45c:	684a      	ldr	r2, [r1, #4]
 c00a45e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 c00a462:	4322      	orrs	r2, r4
 c00a464:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 c00a466:	079c      	lsls	r4, r3, #30
 c00a468:	d506      	bpl.n	c00a478 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 c00a46a:	6801      	ldr	r1, [r0, #0]
 c00a46c:	6b04      	ldr	r4, [r0, #48]	; 0x30
 c00a46e:	684a      	ldr	r2, [r1, #4]
 c00a470:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 c00a474:	4322      	orrs	r2, r4
 c00a476:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 c00a478:	0759      	lsls	r1, r3, #29
 c00a47a:	d506      	bpl.n	c00a48a <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 c00a47c:	6801      	ldr	r1, [r0, #0]
 c00a47e:	6b44      	ldr	r4, [r0, #52]	; 0x34
 c00a480:	684a      	ldr	r2, [r1, #4]
 c00a482:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 c00a486:	4322      	orrs	r2, r4
 c00a488:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 c00a48a:	071a      	lsls	r2, r3, #28
 c00a48c:	d506      	bpl.n	c00a49c <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 c00a48e:	6801      	ldr	r1, [r0, #0]
 c00a490:	6b84      	ldr	r4, [r0, #56]	; 0x38
 c00a492:	684a      	ldr	r2, [r1, #4]
 c00a494:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 c00a498:	4322      	orrs	r2, r4
 c00a49a:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 c00a49c:	06dc      	lsls	r4, r3, #27
 c00a49e:	d506      	bpl.n	c00a4ae <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 c00a4a0:	6801      	ldr	r1, [r0, #0]
 c00a4a2:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 c00a4a4:	688a      	ldr	r2, [r1, #8]
 c00a4a6:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 c00a4aa:	4322      	orrs	r2, r4
 c00a4ac:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 c00a4ae:	0699      	lsls	r1, r3, #26
 c00a4b0:	d506      	bpl.n	c00a4c0 <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 c00a4b2:	6801      	ldr	r1, [r0, #0]
 c00a4b4:	6c04      	ldr	r4, [r0, #64]	; 0x40
 c00a4b6:	688a      	ldr	r2, [r1, #8]
 c00a4b8:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 c00a4bc:	4322      	orrs	r2, r4
 c00a4be:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 c00a4c0:	065a      	lsls	r2, r3, #25
 c00a4c2:	d510      	bpl.n	c00a4e6 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c00a4c4:	6801      	ldr	r1, [r0, #0]
 c00a4c6:	6c44      	ldr	r4, [r0, #68]	; 0x44
 c00a4c8:	684a      	ldr	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c00a4ca:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 c00a4ce:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 c00a4d2:	ea42 0204 	orr.w	r2, r2, r4
 c00a4d6:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 c00a4d8:	d105      	bne.n	c00a4e6 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 c00a4da:	684a      	ldr	r2, [r1, #4]
 c00a4dc:	6c84      	ldr	r4, [r0, #72]	; 0x48
 c00a4de:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 c00a4e2:	4322      	orrs	r2, r4
 c00a4e4:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 c00a4e6:	061b      	lsls	r3, r3, #24
 c00a4e8:	d506      	bpl.n	c00a4f8 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 c00a4ea:	6802      	ldr	r2, [r0, #0]
 c00a4ec:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 c00a4ee:	6853      	ldr	r3, [r2, #4]
 c00a4f0:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 c00a4f4:	430b      	orrs	r3, r1
 c00a4f6:	6053      	str	r3, [r2, #4]
}
 c00a4f8:	bd10      	pop	{r4, pc}

0c00a4fa <UART_WaitOnFlagUntilTimeout>:
{
 c00a4fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00a4fe:	4604      	mov	r4, r0
 c00a500:	460f      	mov	r7, r1
 c00a502:	4616      	mov	r6, r2
 c00a504:	4698      	mov	r8, r3
 c00a506:	9d06      	ldr	r5, [sp, #24]
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 c00a508:	6821      	ldr	r1, [r4, #0]
 c00a50a:	69ca      	ldr	r2, [r1, #28]
 c00a50c:	ea37 0302 	bics.w	r3, r7, r2
 c00a510:	bf0c      	ite	eq
 c00a512:	2201      	moveq	r2, #1
 c00a514:	2200      	movne	r2, #0
 c00a516:	42b2      	cmp	r2, r6
 c00a518:	d001      	beq.n	c00a51e <UART_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
 c00a51a:	2000      	movs	r0, #0
 c00a51c:	e01a      	b.n	c00a554 <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
 c00a51e:	1c68      	adds	r0, r5, #1
 c00a520:	d0f3      	beq.n	c00a50a <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c00a522:	f7f8 ffbf 	bl	c0034a4 <HAL_GetTick>
 c00a526:	eba0 0008 	sub.w	r0, r0, r8
 c00a52a:	42a8      	cmp	r0, r5
 c00a52c:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c00a52e:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 c00a530:	d800      	bhi.n	c00a534 <UART_WaitOnFlagUntilTimeout+0x3a>
 c00a532:	b98d      	cbnz	r5, c00a558 <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c00a534:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 c00a538:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c00a53a:	6883      	ldr	r3, [r0, #8]
 c00a53c:	f023 0301 	bic.w	r3, r3, #1
 c00a540:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 c00a542:	2320      	movs	r3, #32
 c00a544:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 c00a548:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 c00a54c:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 c00a54e:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 c00a550:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 c00a554:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 c00a558:	075a      	lsls	r2, r3, #29
 c00a55a:	d5d5      	bpl.n	c00a508 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 c00a55c:	69c3      	ldr	r3, [r0, #28]
 c00a55e:	051b      	lsls	r3, r3, #20
 c00a560:	d5d2      	bpl.n	c00a508 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 c00a562:	f44f 6300 	mov.w	r3, #2048	; 0x800
 c00a566:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 c00a568:	6803      	ldr	r3, [r0, #0]
 c00a56a:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 c00a56e:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c00a570:	6883      	ldr	r3, [r0, #8]
 c00a572:	f023 0301 	bic.w	r3, r3, #1
 c00a576:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 c00a578:	2320      	movs	r3, #32
 c00a57a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 c00a57e:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 c00a582:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 c00a586:	e7e1      	b.n	c00a54c <UART_WaitOnFlagUntilTimeout+0x52>

0c00a588 <HAL_UART_Transmit>:
{
 c00a588:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c00a58c:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 c00a58e:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 c00a592:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 c00a594:	2b20      	cmp	r3, #32
{
 c00a596:	460e      	mov	r6, r1
 c00a598:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
 c00a59a:	d14f      	bne.n	c00a63c <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 c00a59c:	2900      	cmp	r1, #0
 c00a59e:	d04b      	beq.n	c00a638 <HAL_UART_Transmit+0xb0>
 c00a5a0:	2a00      	cmp	r2, #0
 c00a5a2:	d049      	beq.n	c00a638 <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 c00a5a4:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 c00a5a8:	2b01      	cmp	r3, #1
 c00a5aa:	d047      	beq.n	c00a63c <HAL_UART_Transmit+0xb4>
 c00a5ac:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a5ae:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
 c00a5b0:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c00a5b4:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a5b6:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 c00a5ba:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 c00a5be:	f7f8 ff71 	bl	c0034a4 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c00a5c2:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 c00a5c4:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c00a5c6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
 c00a5ca:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
 c00a5ce:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c00a5d2:	d103      	bne.n	c00a5dc <HAL_UART_Transmit+0x54>
 c00a5d4:	6923      	ldr	r3, [r4, #16]
 c00a5d6:	b90b      	cbnz	r3, c00a5dc <HAL_UART_Transmit+0x54>
 c00a5d8:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 c00a5da:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 c00a5dc:	2300      	movs	r3, #0
 c00a5de:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->TxXferCount > 0U)
 c00a5e2:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c00a5e6:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 c00a5ea:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c00a5ec:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
 c00a5ee:	b942      	cbnz	r2, c00a602 <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 c00a5f0:	2140      	movs	r1, #64	; 0x40
 c00a5f2:	4620      	mov	r0, r4
 c00a5f4:	f7ff ff81 	bl	c00a4fa <UART_WaitOnFlagUntilTimeout>
 c00a5f8:	b948      	cbnz	r0, c00a60e <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 c00a5fa:	2320      	movs	r3, #32
 c00a5fc:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    return HAL_OK;
 c00a600:	e006      	b.n	c00a610 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 c00a602:	2200      	movs	r2, #0
 c00a604:	2180      	movs	r1, #128	; 0x80
 c00a606:	4620      	mov	r0, r4
 c00a608:	f7ff ff77 	bl	c00a4fa <UART_WaitOnFlagUntilTimeout>
 c00a60c:	b118      	cbz	r0, c00a616 <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 c00a60e:	2003      	movs	r0, #3
}
 c00a610:	b003      	add	sp, #12
 c00a612:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c00a616:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 c00a618:	b95e      	cbnz	r6, c00a632 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 c00a61a:	f835 3b02 	ldrh.w	r3, [r5], #2
 c00a61e:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c00a622:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 c00a624:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 c00a628:	3b01      	subs	r3, #1
 c00a62a:	b29b      	uxth	r3, r3
 c00a62c:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
 c00a630:	e7d7      	b.n	c00a5e2 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 c00a632:	f816 3b01 	ldrb.w	r3, [r6], #1
 c00a636:	e7f4      	b.n	c00a622 <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 c00a638:	2001      	movs	r0, #1
 c00a63a:	e7e9      	b.n	c00a610 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 c00a63c:	2002      	movs	r0, #2
 c00a63e:	e7e7      	b.n	c00a610 <HAL_UART_Transmit+0x88>

0c00a640 <UART_CheckIdleState>:
{
 c00a640:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a642:	2600      	movs	r6, #0
{
 c00a644:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a646:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 c00a64a:	f7f8 ff2b 	bl	c0034a4 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c00a64e:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 c00a650:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 c00a652:	681b      	ldr	r3, [r3, #0]
 c00a654:	071a      	lsls	r2, r3, #28
 c00a656:	d418      	bmi.n	c00a68a <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 c00a658:	6823      	ldr	r3, [r4, #0]
 c00a65a:	681b      	ldr	r3, [r3, #0]
 c00a65c:	075b      	lsls	r3, r3, #29
 c00a65e:	d50a      	bpl.n	c00a676 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c00a660:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 c00a664:	2200      	movs	r2, #0
 c00a666:	9300      	str	r3, [sp, #0]
 c00a668:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 c00a66c:	462b      	mov	r3, r5
 c00a66e:	4620      	mov	r0, r4
 c00a670:	f7ff ff43 	bl	c00a4fa <UART_WaitOnFlagUntilTimeout>
 c00a674:	b9a8      	cbnz	r0, c00a6a2 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 c00a676:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00a678:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 c00a67a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 c00a67e:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 c00a682:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00a686:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 c00a688:	e00c      	b.n	c00a6a4 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 c00a68a:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 c00a68e:	4632      	mov	r2, r6
 c00a690:	9300      	str	r3, [sp, #0]
 c00a692:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 c00a696:	4603      	mov	r3, r0
 c00a698:	4620      	mov	r0, r4
 c00a69a:	f7ff ff2e 	bl	c00a4fa <UART_WaitOnFlagUntilTimeout>
 c00a69e:	2800      	cmp	r0, #0
 c00a6a0:	d0da      	beq.n	c00a658 <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 c00a6a2:	2003      	movs	r0, #3
}
 c00a6a4:	b002      	add	sp, #8
 c00a6a6:	bd70      	pop	{r4, r5, r6, pc}

0c00a6a8 <HAL_UART_Init>:
{
 c00a6a8:	b510      	push	{r4, lr}
  if (huart == NULL)
 c00a6aa:	4604      	mov	r4, r0
 c00a6ac:	b350      	cbz	r0, c00a704 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 c00a6ae:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 c00a6b2:	b91b      	cbnz	r3, c00a6bc <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 c00a6b4:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 c00a6b8:	f7ff fba7 	bl	c009e0a <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 c00a6bc:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 c00a6be:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 c00a6c0:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 c00a6c4:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c00a6c6:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 c00a6c8:	f023 0301 	bic.w	r3, r3, #1
 c00a6cc:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 c00a6ce:	f7ff fd4f 	bl	c00a170 <UART_SetConfig>
 c00a6d2:	2801      	cmp	r0, #1
 c00a6d4:	d016      	beq.n	c00a704 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 c00a6d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c00a6d8:	b113      	cbz	r3, c00a6e0 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 c00a6da:	4620      	mov	r0, r4
 c00a6dc:	f7ff feb8 	bl	c00a450 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c00a6e0:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 c00a6e2:	4620      	mov	r0, r4
}
 c00a6e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 c00a6e8:	685a      	ldr	r2, [r3, #4]
 c00a6ea:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 c00a6ee:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 c00a6f0:	689a      	ldr	r2, [r3, #8]
 c00a6f2:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 c00a6f6:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 c00a6f8:	681a      	ldr	r2, [r3, #0]
 c00a6fa:	f042 0201 	orr.w	r2, r2, #1
 c00a6fe:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 c00a700:	f7ff bf9e 	b.w	c00a640 <UART_CheckIdleState>
}
 c00a704:	2001      	movs	r0, #1
 c00a706:	bd10      	pop	{r4, pc}

0c00a708 <UART_Start_Receive_IT>:
  huart->RxISR       = NULL;
 c00a708:	2300      	movs	r3, #0
{
 c00a70a:	b510      	push	{r4, lr}
  huart->pRxBuffPtr  = pData;
 c00a70c:	6581      	str	r1, [r0, #88]	; 0x58
  UART_MASK_COMPUTATION(huart);
 c00a70e:	6881      	ldr	r1, [r0, #8]
  huart->RxXferSize  = Size;
 c00a710:	f8a0 205c 	strh.w	r2, [r0, #92]	; 0x5c
  UART_MASK_COMPUTATION(huart);
 c00a714:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
  huart->RxXferCount = Size;
 c00a718:	f8a0 205e 	strh.w	r2, [r0, #94]	; 0x5e
  huart->RxISR       = NULL;
 c00a71c:	6703      	str	r3, [r0, #112]	; 0x70
  UART_MASK_COMPUTATION(huart);
 c00a71e:	d12e      	bne.n	c00a77e <UART_Start_Receive_IT+0x76>
 c00a720:	6903      	ldr	r3, [r0, #16]
 c00a722:	bb53      	cbnz	r3, c00a77a <UART_Start_Receive_IT+0x72>
 c00a724:	f240 13ff 	movw	r3, #511	; 0x1ff
 c00a728:	f8a0 3060 	strh.w	r3, [r0, #96]	; 0x60
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 c00a72c:	2300      	movs	r3, #0
 c00a72e:	f8c0 308c 	str.w	r3, [r0, #140]	; 0x8c
  huart->RxState = HAL_UART_STATE_BUSY_RX;
 c00a732:	2322      	movs	r3, #34	; 0x22
 c00a734:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 c00a738:	6803      	ldr	r3, [r0, #0]
 c00a73a:	689c      	ldr	r4, [r3, #8]
 c00a73c:	f044 0401 	orr.w	r4, r4, #1
 c00a740:	609c      	str	r4, [r3, #8]
  if ((huart->FifoMode == UART_FIFOMODE_ENABLE) && (Size >= huart->NbRxDataToProcess))
 c00a742:	6e44      	ldr	r4, [r0, #100]	; 0x64
 c00a744:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
 c00a748:	d129      	bne.n	c00a79e <UART_Start_Receive_IT+0x96>
 c00a74a:	f8b0 4068 	ldrh.w	r4, [r0, #104]	; 0x68
 c00a74e:	4294      	cmp	r4, r2
 c00a750:	d825      	bhi.n	c00a79e <UART_Start_Receive_IT+0x96>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c00a752:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c00a756:	d120      	bne.n	c00a79a <UART_Start_Receive_IT+0x92>
 c00a758:	6902      	ldr	r2, [r0, #16]
 c00a75a:	b9f2      	cbnz	r2, c00a79a <UART_Start_Receive_IT+0x92>
      huart->RxISR = UART_RxISR_16BIT_FIFOEN;
 c00a75c:	4a18      	ldr	r2, [pc, #96]	; (c00a7c0 <UART_Start_Receive_IT+0xb8>)
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 c00a75e:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 c00a760:	2200      	movs	r2, #0
 c00a762:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
 c00a766:	681a      	ldr	r2, [r3, #0]
 c00a768:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 c00a76c:	601a      	str	r2, [r3, #0]
    SET_BIT(huart->Instance->CR3, USART_CR3_RXFTIE);
 c00a76e:	689a      	ldr	r2, [r3, #8]
 c00a770:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 c00a774:	609a      	str	r2, [r3, #8]
}
 c00a776:	2000      	movs	r0, #0
 c00a778:	bd10      	pop	{r4, pc}
  UART_MASK_COMPUTATION(huart);
 c00a77a:	23ff      	movs	r3, #255	; 0xff
 c00a77c:	e7d4      	b.n	c00a728 <UART_Start_Receive_IT+0x20>
 c00a77e:	b921      	cbnz	r1, c00a78a <UART_Start_Receive_IT+0x82>
 c00a780:	6903      	ldr	r3, [r0, #16]
 c00a782:	2b00      	cmp	r3, #0
 c00a784:	d0f9      	beq.n	c00a77a <UART_Start_Receive_IT+0x72>
 c00a786:	237f      	movs	r3, #127	; 0x7f
 c00a788:	e7ce      	b.n	c00a728 <UART_Start_Receive_IT+0x20>
 c00a78a:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
 c00a78e:	d1cb      	bne.n	c00a728 <UART_Start_Receive_IT+0x20>
 c00a790:	6903      	ldr	r3, [r0, #16]
 c00a792:	2b00      	cmp	r3, #0
 c00a794:	d0f7      	beq.n	c00a786 <UART_Start_Receive_IT+0x7e>
 c00a796:	233f      	movs	r3, #63	; 0x3f
 c00a798:	e7c6      	b.n	c00a728 <UART_Start_Receive_IT+0x20>
      huart->RxISR = UART_RxISR_8BIT_FIFOEN;
 c00a79a:	4a0a      	ldr	r2, [pc, #40]	; (c00a7c4 <UART_Start_Receive_IT+0xbc>)
 c00a79c:	e7df      	b.n	c00a75e <UART_Start_Receive_IT+0x56>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 c00a79e:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c00a7a2:	d10b      	bne.n	c00a7bc <UART_Start_Receive_IT+0xb4>
 c00a7a4:	6902      	ldr	r2, [r0, #16]
 c00a7a6:	b94a      	cbnz	r2, c00a7bc <UART_Start_Receive_IT+0xb4>
      huart->RxISR = UART_RxISR_16BIT;
 c00a7a8:	4a07      	ldr	r2, [pc, #28]	; (c00a7c8 <UART_Start_Receive_IT+0xc0>)
      huart->RxISR = UART_RxISR_8BIT;
 c00a7aa:	6702      	str	r2, [r0, #112]	; 0x70
    __HAL_UNLOCK(huart);
 c00a7ac:	2200      	movs	r2, #0
 c00a7ae:	f880 2080 	strb.w	r2, [r0, #128]	; 0x80
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE_RXFNEIE);
 c00a7b2:	681a      	ldr	r2, [r3, #0]
 c00a7b4:	f442 7290 	orr.w	r2, r2, #288	; 0x120
 c00a7b8:	601a      	str	r2, [r3, #0]
 c00a7ba:	e7dc      	b.n	c00a776 <UART_Start_Receive_IT+0x6e>
      huart->RxISR = UART_RxISR_8BIT;
 c00a7bc:	4a03      	ldr	r2, [pc, #12]	; (c00a7cc <UART_Start_Receive_IT+0xc4>)
 c00a7be:	e7f4      	b.n	c00a7aa <UART_Start_Receive_IT+0xa2>
 c00a7c0:	0c00a03d 	.word	0x0c00a03d
 c00a7c4:	0c009f05 	.word	0x0c009f05
 c00a7c8:	0c009e8d 	.word	0x0c009e8d
 c00a7cc:	0c009e13 	.word	0x0c009e13

0c00a7d0 <HAL_UART_Receive_IT>:
  if (huart->RxState == HAL_UART_STATE_READY)
 c00a7d0:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
{
 c00a7d4:	b410      	push	{r4}
  if (huart->RxState == HAL_UART_STATE_READY)
 c00a7d6:	2b20      	cmp	r3, #32
 c00a7d8:	d11d      	bne.n	c00a816 <HAL_UART_Receive_IT+0x46>
    if ((pData == NULL) || (Size == 0U))
 c00a7da:	b1c1      	cbz	r1, c00a80e <HAL_UART_Receive_IT+0x3e>
 c00a7dc:	b1ba      	cbz	r2, c00a80e <HAL_UART_Receive_IT+0x3e>
    __HAL_LOCK(huart);
 c00a7de:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 c00a7e2:	2b01      	cmp	r3, #1
 c00a7e4:	d017      	beq.n	c00a816 <HAL_UART_Receive_IT+0x46>
 c00a7e6:	2301      	movs	r3, #1
 c00a7e8:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00a7ec:	2300      	movs	r3, #0
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c00a7ee:	4c0b      	ldr	r4, [pc, #44]	; (c00a81c <HAL_UART_Receive_IT+0x4c>)
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 c00a7f0:	66c3      	str	r3, [r0, #108]	; 0x6c
    if (!(IS_LPUART_INSTANCE(huart->Instance)))
 c00a7f2:	6803      	ldr	r3, [r0, #0]
 c00a7f4:	42a3      	cmp	r3, r4
 c00a7f6:	d006      	beq.n	c00a806 <HAL_UART_Receive_IT+0x36>
      if(READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
 c00a7f8:	685c      	ldr	r4, [r3, #4]
 c00a7fa:	0224      	lsls	r4, r4, #8
        SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
 c00a7fc:	bf42      	ittt	mi
 c00a7fe:	681c      	ldrmi	r4, [r3, #0]
 c00a800:	f044 6480 	orrmi.w	r4, r4, #67108864	; 0x4000000
 c00a804:	601c      	strmi	r4, [r3, #0]
}
 c00a806:	f85d 4b04 	ldr.w	r4, [sp], #4
    return(UART_Start_Receive_IT(huart, pData, Size));
 c00a80a:	f7ff bf7d 	b.w	c00a708 <UART_Start_Receive_IT>
      return HAL_ERROR;
 c00a80e:	2001      	movs	r0, #1
}
 c00a810:	f85d 4b04 	ldr.w	r4, [sp], #4
 c00a814:	4770      	bx	lr
    return HAL_BUSY;
 c00a816:	2002      	movs	r0, #2
 c00a818:	e7fa      	b.n	c00a810 <HAL_UART_Receive_IT+0x40>
 c00a81a:	bf00      	nop
 c00a81c:	50008000 	.word	0x50008000

0c00a820 <mbedtls_asn1_get_len>:
 */
int mbedtls_asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len )
{
    if( ( end - *p ) < 1 )
 c00a820:	6803      	ldr	r3, [r0, #0]
{
 c00a822:	b530      	push	{r4, r5, lr}
    if( ( end - *p ) < 1 )
 c00a824:	1acd      	subs	r5, r1, r3
 c00a826:	2d00      	cmp	r5, #0
 c00a828:	dc02      	bgt.n	c00a830 <mbedtls_asn1_get_len+0x10>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c00a82a:	f06f 005f 	mvn.w	r0, #95	; 0x5f

    if( *len > (size_t) ( end - *p ) )
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    return( 0 );
}
 c00a82e:	bd30      	pop	{r4, r5, pc}
    if( ( **p & 0x80 ) == 0 )
 c00a830:	781c      	ldrb	r4, [r3, #0]
 c00a832:	f014 0f80 	tst.w	r4, #128	; 0x80
 c00a836:	d10a      	bne.n	c00a84e <mbedtls_asn1_get_len+0x2e>
        *len = *(*p)++;
 c00a838:	1c5c      	adds	r4, r3, #1
 c00a83a:	6004      	str	r4, [r0, #0]
 c00a83c:	781b      	ldrb	r3, [r3, #0]
 c00a83e:	6013      	str	r3, [r2, #0]
    if( *len > (size_t) ( end - *p ) )
 c00a840:	6803      	ldr	r3, [r0, #0]
 c00a842:	1ac9      	subs	r1, r1, r3
 c00a844:	6813      	ldr	r3, [r2, #0]
 c00a846:	428b      	cmp	r3, r1
 c00a848:	d8ef      	bhi.n	c00a82a <mbedtls_asn1_get_len+0xa>
    return( 0 );
 c00a84a:	2000      	movs	r0, #0
 c00a84c:	e7ef      	b.n	c00a82e <mbedtls_asn1_get_len+0xe>
        switch( **p & 0x7F )
 c00a84e:	f004 047f 	and.w	r4, r4, #127	; 0x7f
 c00a852:	3c01      	subs	r4, #1
 c00a854:	2c03      	cmp	r4, #3
 c00a856:	d827      	bhi.n	c00a8a8 <mbedtls_asn1_get_len+0x88>
 c00a858:	e8df f004 	tbb	[pc, r4]
 c00a85c:	1e120902 	.word	0x1e120902
            if( ( end - *p ) < 2 )
 c00a860:	2d01      	cmp	r5, #1
 c00a862:	d0e2      	beq.n	c00a82a <mbedtls_asn1_get_len+0xa>
            *len = (*p)[1];
 c00a864:	785c      	ldrb	r4, [r3, #1]
            (*p) += 2;
 c00a866:	3302      	adds	r3, #2
            *len = (*p)[1];
 c00a868:	6014      	str	r4, [r2, #0]
            (*p) += 5;
 c00a86a:	6003      	str	r3, [r0, #0]
            break;
 c00a86c:	e7e8      	b.n	c00a840 <mbedtls_asn1_get_len+0x20>
            if( ( end - *p ) < 3 )
 c00a86e:	2d02      	cmp	r5, #2
 c00a870:	dddb      	ble.n	c00a82a <mbedtls_asn1_get_len+0xa>
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c00a872:	f8b3 4001 	ldrh.w	r4, [r3, #1]
            (*p) += 3;
 c00a876:	3303      	adds	r3, #3
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
 c00a878:	ba64      	rev16	r4, r4
 c00a87a:	b2a4      	uxth	r4, r4
 c00a87c:	6014      	str	r4, [r2, #0]
 c00a87e:	e7f4      	b.n	c00a86a <mbedtls_asn1_get_len+0x4a>
            if( ( end - *p ) < 4 )
 c00a880:	2d03      	cmp	r5, #3
 c00a882:	ddd2      	ble.n	c00a82a <mbedtls_asn1_get_len+0xa>
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c00a884:	789c      	ldrb	r4, [r3, #2]
            *len = ( (size_t)(*p)[1] << 16 ) |
 c00a886:	785d      	ldrb	r5, [r3, #1]
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c00a888:	0224      	lsls	r4, r4, #8
            *len = ( (size_t)(*p)[1] << 16 ) |
 c00a88a:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c00a88e:	78dd      	ldrb	r5, [r3, #3]
            (*p) += 4;
 c00a890:	3304      	adds	r3, #4
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
 c00a892:	432c      	orrs	r4, r5
            *len = ( (size_t)(*p)[1] << 16 ) |
 c00a894:	6014      	str	r4, [r2, #0]
 c00a896:	e7e8      	b.n	c00a86a <mbedtls_asn1_get_len+0x4a>
            if( ( end - *p ) < 5 )
 c00a898:	2d04      	cmp	r5, #4
 c00a89a:	ddc6      	ble.n	c00a82a <mbedtls_asn1_get_len+0xa>
 c00a89c:	f8d3 4001 	ldr.w	r4, [r3, #1]
            (*p) += 5;
 c00a8a0:	3305      	adds	r3, #5
 c00a8a2:	ba24      	rev	r4, r4
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
 c00a8a4:	6014      	str	r4, [r2, #0]
 c00a8a6:	e7e0      	b.n	c00a86a <mbedtls_asn1_get_len+0x4a>
            return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 c00a8a8:	f06f 0063 	mvn.w	r0, #99	; 0x63
 c00a8ac:	e7bf      	b.n	c00a82e <mbedtls_asn1_get_len+0xe>

0c00a8ae <mbedtls_asn1_get_tag>:

int mbedtls_asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag )
{
 c00a8ae:	b470      	push	{r4, r5, r6}
    if( ( end - *p ) < 1 )
 c00a8b0:	6804      	ldr	r4, [r0, #0]
 c00a8b2:	1b0e      	subs	r6, r1, r4
 c00a8b4:	2e00      	cmp	r6, #0
 c00a8b6:	dd07      	ble.n	c00a8c8 <mbedtls_asn1_get_tag+0x1a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( **p != tag )
 c00a8b8:	7826      	ldrb	r6, [r4, #0]
 c00a8ba:	429e      	cmp	r6, r3
 c00a8bc:	d108      	bne.n	c00a8d0 <mbedtls_asn1_get_tag+0x22>
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
 c00a8be:	3401      	adds	r4, #1
 c00a8c0:	6004      	str	r4, [r0, #0]

    return( mbedtls_asn1_get_len( p, end, len ) );
}
 c00a8c2:	bc70      	pop	{r4, r5, r6}
    return( mbedtls_asn1_get_len( p, end, len ) );
 c00a8c4:	f7ff bfac 	b.w	c00a820 <mbedtls_asn1_get_len>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
 c00a8c8:	f06f 005f 	mvn.w	r0, #95	; 0x5f
}
 c00a8cc:	bc70      	pop	{r4, r5, r6}
 c00a8ce:	4770      	bx	lr
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
 c00a8d0:	f06f 0061 	mvn.w	r0, #97	; 0x61
 c00a8d4:	e7fa      	b.n	c00a8cc <mbedtls_asn1_get_tag+0x1e>

0c00a8d6 <mbedtls_asn1_get_int>:
}

int mbedtls_asn1_get_int( unsigned char **p,
                  const unsigned char *end,
                  int *val )
{
 c00a8d6:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00a8d8:	2302      	movs	r3, #2
{
 c00a8da:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00a8dc:	aa01      	add	r2, sp, #4
{
 c00a8de:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00a8e0:	f7ff ffe5 	bl	c00a8ae <mbedtls_asn1_get_tag>
 c00a8e4:	b968      	cbnz	r0, c00a902 <mbedtls_asn1_get_int+0x2c>
        return( ret );

    if( len == 0 || len > sizeof( int ) || ( **p & 0x80 ) != 0 )
 c00a8e6:	9b01      	ldr	r3, [sp, #4]
 c00a8e8:	3b01      	subs	r3, #1
 c00a8ea:	2b03      	cmp	r3, #3
 c00a8ec:	d814      	bhi.n	c00a918 <mbedtls_asn1_get_int+0x42>
 c00a8ee:	6823      	ldr	r3, [r4, #0]
 c00a8f0:	f993 3000 	ldrsb.w	r3, [r3]
 c00a8f4:	2b00      	cmp	r3, #0
 c00a8f6:	db0f      	blt.n	c00a918 <mbedtls_asn1_get_int+0x42>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );

    *val = 0;
 c00a8f8:	6028      	str	r0, [r5, #0]

    while( len-- > 0 )
 c00a8fa:	9b01      	ldr	r3, [sp, #4]
 c00a8fc:	1e5a      	subs	r2, r3, #1
 c00a8fe:	9201      	str	r2, [sp, #4]
 c00a900:	b90b      	cbnz	r3, c00a906 <mbedtls_asn1_get_int+0x30>
        *val = ( *val << 8 ) | **p;
        (*p)++;
    }

    return( 0 );
}
 c00a902:	b003      	add	sp, #12
 c00a904:	bd30      	pop	{r4, r5, pc}
        *val = ( *val << 8 ) | **p;
 c00a906:	6823      	ldr	r3, [r4, #0]
 c00a908:	6829      	ldr	r1, [r5, #0]
 c00a90a:	f813 2b01 	ldrb.w	r2, [r3], #1
 c00a90e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 c00a912:	602a      	str	r2, [r5, #0]
        (*p)++;
 c00a914:	6023      	str	r3, [r4, #0]
 c00a916:	e7f0      	b.n	c00a8fa <mbedtls_asn1_get_int+0x24>
        return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
 c00a918:	f06f 0063 	mvn.w	r0, #99	; 0x63
 c00a91c:	e7f1      	b.n	c00a902 <mbedtls_asn1_get_int+0x2c>

0c00a91e <mbedtls_asn1_get_mpi>:

#if defined(MBEDTLS_BIGNUM_C)
int mbedtls_asn1_get_mpi( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_mpi *X )
{
 c00a91e:	b537      	push	{r0, r1, r2, r4, r5, lr}
    int ret;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00a920:	2302      	movs	r3, #2
{
 c00a922:	4615      	mov	r5, r2
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00a924:	aa01      	add	r2, sp, #4
{
 c00a926:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
 c00a928:	f7ff ffc1 	bl	c00a8ae <mbedtls_asn1_get_tag>
 c00a92c:	b940      	cbnz	r0, c00a940 <mbedtls_asn1_get_mpi+0x22>
        return( ret );

    ret = mbedtls_mpi_read_binary( X, *p, len );
 c00a92e:	9a01      	ldr	r2, [sp, #4]
 c00a930:	6821      	ldr	r1, [r4, #0]
 c00a932:	4628      	mov	r0, r5
 c00a934:	f000 f9e8 	bl	c00ad08 <mbedtls_mpi_read_binary>

    *p += len;
 c00a938:	6823      	ldr	r3, [r4, #0]
 c00a93a:	9a01      	ldr	r2, [sp, #4]
 c00a93c:	4413      	add	r3, r2
 c00a93e:	6023      	str	r3, [r4, #0]

    return( ret );
}
 c00a940:	b003      	add	sp, #12
 c00a942:	bd30      	pop	{r4, r5, pc}

0c00a944 <mpi_sub_hlp>:
static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
{
    size_t i;
    mbedtls_mpi_uint c, z;

    for( i = c = 0; i < n; i++, s++, d++ )
 c00a944:	2300      	movs	r3, #0
{
 c00a946:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = c = 0; i < n; i++, s++, d++ )
 c00a948:	461c      	mov	r4, r3
 c00a94a:	1f16      	subs	r6, r2, #4
 c00a94c:	4284      	cmp	r4, r0
 c00a94e:	d103      	bne.n	c00a958 <mpi_sub_hlp+0x14>
 c00a950:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    {
        z = ( *d <  c );     *d -=  c;
        c = ( *d < *s ) + z; *d -= *s;
    }

    while( c != 0 )
 c00a954:	b9bb      	cbnz	r3, c00a986 <mpi_sub_hlp+0x42>
    {
        z = ( *d < c ); *d -= c;
        c = z; d++;
    }
}
 c00a956:	bdf0      	pop	{r4, r5, r6, r7, pc}
        z = ( *d <  c );     *d -=  c;
 c00a958:	f8d6 c004 	ldr.w	ip, [r6, #4]
 c00a95c:	ebac 0503 	sub.w	r5, ip, r3
 c00a960:	f846 5f04 	str.w	r5, [r6, #4]!
        c = ( *d < *s ) + z; *d -= *s;
 c00a964:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
    for( i = c = 0; i < n; i++, s++, d++ )
 c00a968:	3401      	adds	r4, #1
        c = ( *d < *s ) + z; *d -= *s;
 c00a96a:	42bd      	cmp	r5, r7
 c00a96c:	bf2c      	ite	cs
 c00a96e:	f04f 0e00 	movcs.w	lr, #0
 c00a972:	f04f 0e01 	movcc.w	lr, #1
 c00a976:	1bed      	subs	r5, r5, r7
 c00a978:	459c      	cmp	ip, r3
 c00a97a:	bf2c      	ite	cs
 c00a97c:	4673      	movcs	r3, lr
 c00a97e:	f10e 0301 	addcc.w	r3, lr, #1
 c00a982:	6035      	str	r5, [r6, #0]
 c00a984:	e7e2      	b.n	c00a94c <mpi_sub_hlp+0x8>
        z = ( *d < c ); *d -= c;
 c00a986:	6811      	ldr	r1, [r2, #0]
 c00a988:	1ac8      	subs	r0, r1, r3
        c = z; d++;
 c00a98a:	4299      	cmp	r1, r3
        z = ( *d < c ); *d -= c;
 c00a98c:	f842 0b04 	str.w	r0, [r2], #4
        c = z; d++;
 c00a990:	bf2c      	ite	cs
 c00a992:	2300      	movcs	r3, #0
 c00a994:	2301      	movcc	r3, #1
 c00a996:	e7dd      	b.n	c00a954 <mpi_sub_hlp+0x10>

0c00a998 <mpi_mul_hlp>:
 * appears to need this to prevent bad ARM code generation at -O3.
 */
__attribute__ ((noinline))
#endif
void mpi_mul_hlp( size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b )
{
 c00a998:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00a99a:	4607      	mov	r7, r0
 c00a99c:	460e      	mov	r6, r1
        MULADDC_INIT
        MULADDC_CORE
        MULADDC_STOP
    }
#else /* MULADDC_HUIT */
    for( ; i >= 16; i -= 16 )
 c00a99e:	4605      	mov	r5, r0
    mbedtls_mpi_uint c = 0, t = 0;
 c00a9a0:	2400      	movs	r4, #0
    for( ; i >= 16; i -= 16 )
 c00a9a2:	2d0f      	cmp	r5, #15
 c00a9a4:	d84c      	bhi.n	c00aa40 <mpi_mul_hlp+0xa8>
 c00a9a6:	f06f 010f 	mvn.w	r1, #15
 c00a9aa:	093d      	lsrs	r5, r7, #4
 c00a9ac:	fb01 7505 	mla	r5, r1, r5, r7
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i >= 8; i -= 8 )
 c00a9b0:	2d07      	cmp	r5, #7
 c00a9b2:	d938      	bls.n	c00aa26 <mpi_mul_hlp+0x8e>
    {
        MULADDC_INIT
 c00a9b4:	f856 0b04 	ldr.w	r0, [r6], #4
 c00a9b8:	6811      	ldr	r1, [r2, #0]
 c00a9ba:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00a9be:	f842 1b04 	str.w	r1, [r2], #4
 c00a9c2:	f856 0b04 	ldr.w	r0, [r6], #4
 c00a9c6:	6811      	ldr	r1, [r2, #0]
 c00a9c8:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00a9cc:	f842 1b04 	str.w	r1, [r2], #4
 c00a9d0:	f856 0b04 	ldr.w	r0, [r6], #4
 c00a9d4:	6811      	ldr	r1, [r2, #0]
 c00a9d6:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00a9da:	f842 1b04 	str.w	r1, [r2], #4
 c00a9de:	f856 0b04 	ldr.w	r0, [r6], #4
 c00a9e2:	6811      	ldr	r1, [r2, #0]
 c00a9e4:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00a9e8:	f842 1b04 	str.w	r1, [r2], #4
 c00a9ec:	f856 0b04 	ldr.w	r0, [r6], #4
 c00a9f0:	6811      	ldr	r1, [r2, #0]
 c00a9f2:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00a9f6:	f842 1b04 	str.w	r1, [r2], #4
 c00a9fa:	f856 0b04 	ldr.w	r0, [r6], #4
 c00a9fe:	6811      	ldr	r1, [r2, #0]
 c00aa00:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa04:	f842 1b04 	str.w	r1, [r2], #4
 c00aa08:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa0c:	6811      	ldr	r1, [r2, #0]
 c00aa0e:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa12:	f842 1b04 	str.w	r1, [r2], #4
 c00aa16:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa1a:	6811      	ldr	r1, [r2, #0]
 c00aa1c:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa20:	f842 1b04 	str.w	r1, [r2], #4
    for( ; i >= 8; i -= 8 )
 c00aa24:	3d08      	subs	r5, #8
        MULADDC_CORE   MULADDC_CORE
        MULADDC_CORE   MULADDC_CORE
        MULADDC_STOP
    }

    for( ; i > 0; i-- )
 c00aa26:	2d00      	cmp	r5, #0
 c00aa28:	d17c      	bne.n	c00ab24 <mpi_mul_hlp+0x18c>
 c00aa2a:	6813      	ldr	r3, [r2, #0]
 c00aa2c:	2100      	movs	r1, #0
 c00aa2e:	191c      	adds	r4, r3, r4
 c00aa30:	bf28      	it	cs
 c00aa32:	2101      	movcs	r1, #1
#endif /* MULADDC_HUIT */

    t++;

    do {
        *d += c; c = ( *d < c ); d++;
 c00aa34:	f842 4b04 	str.w	r4, [r2], #4
 c00aa38:	2401      	movs	r4, #1
    }
    while( c != 0 );
 c00aa3a:	2900      	cmp	r1, #0
 c00aa3c:	d1f5      	bne.n	c00aa2a <mpi_mul_hlp+0x92>
}
 c00aa3e:	bdf0      	pop	{r4, r5, r6, r7, pc}
        MULADDC_INIT
 c00aa40:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa44:	6811      	ldr	r1, [r2, #0]
 c00aa46:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa4a:	f842 1b04 	str.w	r1, [r2], #4
 c00aa4e:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa52:	6811      	ldr	r1, [r2, #0]
 c00aa54:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa58:	f842 1b04 	str.w	r1, [r2], #4
 c00aa5c:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa60:	6811      	ldr	r1, [r2, #0]
 c00aa62:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa66:	f842 1b04 	str.w	r1, [r2], #4
 c00aa6a:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa6e:	6811      	ldr	r1, [r2, #0]
 c00aa70:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa74:	f842 1b04 	str.w	r1, [r2], #4
 c00aa78:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa7c:	6811      	ldr	r1, [r2, #0]
 c00aa7e:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa82:	f842 1b04 	str.w	r1, [r2], #4
 c00aa86:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa8a:	6811      	ldr	r1, [r2, #0]
 c00aa8c:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa90:	f842 1b04 	str.w	r1, [r2], #4
 c00aa94:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aa98:	6811      	ldr	r1, [r2, #0]
 c00aa9a:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aa9e:	f842 1b04 	str.w	r1, [r2], #4
 c00aaa2:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aaa6:	6811      	ldr	r1, [r2, #0]
 c00aaa8:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aaac:	f842 1b04 	str.w	r1, [r2], #4
 c00aab0:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aab4:	6811      	ldr	r1, [r2, #0]
 c00aab6:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aaba:	f842 1b04 	str.w	r1, [r2], #4
 c00aabe:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aac2:	6811      	ldr	r1, [r2, #0]
 c00aac4:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aac8:	f842 1b04 	str.w	r1, [r2], #4
 c00aacc:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aad0:	6811      	ldr	r1, [r2, #0]
 c00aad2:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aad6:	f842 1b04 	str.w	r1, [r2], #4
 c00aada:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aade:	6811      	ldr	r1, [r2, #0]
 c00aae0:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aae4:	f842 1b04 	str.w	r1, [r2], #4
 c00aae8:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aaec:	6811      	ldr	r1, [r2, #0]
 c00aaee:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00aaf2:	f842 1b04 	str.w	r1, [r2], #4
 c00aaf6:	f856 0b04 	ldr.w	r0, [r6], #4
 c00aafa:	6811      	ldr	r1, [r2, #0]
 c00aafc:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00ab00:	f842 1b04 	str.w	r1, [r2], #4
 c00ab04:	f856 0b04 	ldr.w	r0, [r6], #4
 c00ab08:	6811      	ldr	r1, [r2, #0]
 c00ab0a:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00ab0e:	f842 1b04 	str.w	r1, [r2], #4
 c00ab12:	f856 0b04 	ldr.w	r0, [r6], #4
 c00ab16:	6811      	ldr	r1, [r2, #0]
 c00ab18:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00ab1c:	f842 1b04 	str.w	r1, [r2], #4
    for( ; i >= 16; i -= 16 )
 c00ab20:	3d10      	subs	r5, #16
 c00ab22:	e73e      	b.n	c00a9a2 <mpi_mul_hlp+0xa>
        MULADDC_INIT
 c00ab24:	f856 0b04 	ldr.w	r0, [r6], #4
 c00ab28:	6811      	ldr	r1, [r2, #0]
 c00ab2a:	fbe3 1460 	umaal	r1, r4, r3, r0
 c00ab2e:	f842 1b04 	str.w	r1, [r2], #4
    for( ; i > 0; i-- )
 c00ab32:	3d01      	subs	r5, #1
 c00ab34:	e777      	b.n	c00aa26 <mpi_mul_hlp+0x8e>

0c00ab36 <mpi_bigendian_to_host.part.1>:
    for( cur_limb_left = p, cur_limb_right = p + ( limbs - 1 );
 c00ab36:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 c00ab3a:	3901      	subs	r1, #1
 c00ab3c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 c00ab40:	4288      	cmp	r0, r1
 c00ab42:	4603      	mov	r3, r0
 c00ab44:	d900      	bls.n	c00ab48 <mpi_bigendian_to_host.part.1+0x12>
}
 c00ab46:	4770      	bx	lr
            return( __builtin_bswap32(x) );
 c00ab48:	681b      	ldr	r3, [r3, #0]
 c00ab4a:	680a      	ldr	r2, [r1, #0]
 c00ab4c:	ba1b      	rev	r3, r3
 c00ab4e:	ba12      	rev	r2, r2
        *cur_limb_left  = mpi_uint_bigendian_to_host( *cur_limb_right );
 c00ab50:	f840 2b04 	str.w	r2, [r0], #4
        *cur_limb_right = tmp;
 c00ab54:	f841 3904 	str.w	r3, [r1], #-4
 c00ab58:	e7f2      	b.n	c00ab40 <mpi_bigendian_to_host.part.1+0xa>

0c00ab5a <mbedtls_mpi_init>:
    X->n = 0;
 c00ab5a:	2300      	movs	r3, #0
 c00ab5c:	2201      	movs	r2, #1
    X->p = NULL;
 c00ab5e:	6083      	str	r3, [r0, #8]
    X->n = 0;
 c00ab60:	e9c0 2300 	strd	r2, r3, [r0]
}
 c00ab64:	4770      	bx	lr

0c00ab66 <mbedtls_mpi_free>:
{
 c00ab66:	b510      	push	{r4, lr}
    if( X == NULL )
 c00ab68:	4604      	mov	r4, r0
 c00ab6a:	b168      	cbz	r0, c00ab88 <mbedtls_mpi_free+0x22>
    if( X->p != NULL )
 c00ab6c:	6880      	ldr	r0, [r0, #8]
 c00ab6e:	b130      	cbz	r0, c00ab7e <mbedtls_mpi_free+0x18>
    mbedtls_platform_zeroize( v, ciL * n );
 c00ab70:	6861      	ldr	r1, [r4, #4]
 c00ab72:	0089      	lsls	r1, r1, #2
 c00ab74:	f001 f9b6 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( X->p );
 c00ab78:	68a0      	ldr	r0, [r4, #8]
 c00ab7a:	f001 f9a3 	bl	c00bec4 <mbedtls_free>
    X->n = 0;
 c00ab7e:	2300      	movs	r3, #0
 c00ab80:	2201      	movs	r2, #1
 c00ab82:	e9c4 2300 	strd	r2, r3, [r4]
    X->p = NULL;
 c00ab86:	60a3      	str	r3, [r4, #8]
}
 c00ab88:	bd10      	pop	{r4, pc}

0c00ab8a <mbedtls_mpi_grow>:
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c00ab8a:	f242 7310 	movw	r3, #10000	; 0x2710
 c00ab8e:	4299      	cmp	r1, r3
{
 c00ab90:	b570      	push	{r4, r5, r6, lr}
 c00ab92:	4604      	mov	r4, r0
 c00ab94:	460d      	mov	r5, r1
    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
 c00ab96:	d902      	bls.n	c00ab9e <mbedtls_mpi_grow+0x14>
        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
 c00ab98:	f06f 000f 	mvn.w	r0, #15
}
 c00ab9c:	bd70      	pop	{r4, r5, r6, pc}
    if( X->n < nblimbs )
 c00ab9e:	6843      	ldr	r3, [r0, #4]
 c00aba0:	428b      	cmp	r3, r1
 c00aba2:	d216      	bcs.n	c00abd2 <mbedtls_mpi_grow+0x48>
        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
 c00aba4:	2104      	movs	r1, #4
 c00aba6:	4628      	mov	r0, r5
 c00aba8:	f001 f986 	bl	c00beb8 <mbedtls_calloc>
 c00abac:	4606      	mov	r6, r0
 c00abae:	2800      	cmp	r0, #0
 c00abb0:	d0f2      	beq.n	c00ab98 <mbedtls_mpi_grow+0xe>
        if( X->p != NULL )
 c00abb2:	68a1      	ldr	r1, [r4, #8]
 c00abb4:	b159      	cbz	r1, c00abce <mbedtls_mpi_grow+0x44>
            memcpy( p, X->p, X->n * ciL );
 c00abb6:	6862      	ldr	r2, [r4, #4]
 c00abb8:	0092      	lsls	r2, r2, #2
 c00abba:	f003 fa42 	bl	c00e042 <memcpy>
    mbedtls_platform_zeroize( v, ciL * n );
 c00abbe:	6861      	ldr	r1, [r4, #4]
 c00abc0:	68a0      	ldr	r0, [r4, #8]
 c00abc2:	0089      	lsls	r1, r1, #2
 c00abc4:	f001 f98e 	bl	c00bee4 <mbedtls_platform_zeroize>
            mbedtls_free( X->p );
 c00abc8:	68a0      	ldr	r0, [r4, #8]
 c00abca:	f001 f97b 	bl	c00bec4 <mbedtls_free>
        X->p = p;
 c00abce:	e9c4 5601 	strd	r5, r6, [r4, #4]
    return( 0 );
 c00abd2:	2000      	movs	r0, #0
 c00abd4:	e7e2      	b.n	c00ab9c <mbedtls_mpi_grow+0x12>

0c00abd6 <mbedtls_mpi_copy>:
    if( X == Y )
 c00abd6:	4288      	cmp	r0, r1
{
 c00abd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00abda:	4606      	mov	r6, r0
 c00abdc:	460f      	mov	r7, r1
    if( X == Y )
 c00abde:	d003      	beq.n	c00abe8 <mbedtls_mpi_copy+0x12>
    if( Y->p == NULL )
 c00abe0:	688d      	ldr	r5, [r1, #8]
 c00abe2:	b91d      	cbnz	r5, c00abec <mbedtls_mpi_copy+0x16>
        mbedtls_mpi_free( X );
 c00abe4:	f7ff ffbf 	bl	c00ab66 <mbedtls_mpi_free>
        return( 0 );
 c00abe8:	2000      	movs	r0, #0
 c00abea:	e011      	b.n	c00ac10 <mbedtls_mpi_copy+0x3a>
    for( i = Y->n - 1; i > 0; i-- )
 c00abec:	684c      	ldr	r4, [r1, #4]
 c00abee:	3c01      	subs	r4, #1
 c00abf0:	b11c      	cbz	r4, c00abfa <mbedtls_mpi_copy+0x24>
        if( Y->p[i] != 0 )
 c00abf2:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 c00abf6:	2b00      	cmp	r3, #0
 c00abf8:	d0f9      	beq.n	c00abee <mbedtls_mpi_copy+0x18>
    if( X->n < i )
 c00abfa:	6872      	ldr	r2, [r6, #4]
    i++;
 c00abfc:	3401      	adds	r4, #1
    X->s = Y->s;
 c00abfe:	683b      	ldr	r3, [r7, #0]
    if( X->n < i )
 c00ac00:	42a2      	cmp	r2, r4
    X->s = Y->s;
 c00ac02:	6033      	str	r3, [r6, #0]
    if( X->n < i )
 c00ac04:	d205      	bcs.n	c00ac12 <mbedtls_mpi_copy+0x3c>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
 c00ac06:	4621      	mov	r1, r4
 c00ac08:	4630      	mov	r0, r6
 c00ac0a:	f7ff ffbe 	bl	c00ab8a <mbedtls_mpi_grow>
 c00ac0e:	b140      	cbz	r0, c00ac22 <mbedtls_mpi_copy+0x4c>
}
 c00ac10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        memset( X->p + i, 0, ( X->n - i ) * ciL );
 c00ac12:	68b0      	ldr	r0, [r6, #8]
 c00ac14:	1b12      	subs	r2, r2, r4
 c00ac16:	0092      	lsls	r2, r2, #2
 c00ac18:	2100      	movs	r1, #0
 c00ac1a:	eb00 0084 	add.w	r0, r0, r4, lsl #2
 c00ac1e:	f003 fa34 	bl	c00e08a <memset>
    memcpy( X->p, Y->p, i * ciL );
 c00ac22:	00a2      	lsls	r2, r4, #2
 c00ac24:	68b9      	ldr	r1, [r7, #8]
 c00ac26:	68b0      	ldr	r0, [r6, #8]
 c00ac28:	f003 fa0b 	bl	c00e042 <memcpy>
 c00ac2c:	e7dc      	b.n	c00abe8 <mbedtls_mpi_copy+0x12>

0c00ac2e <mbedtls_mpi_lset>:
{
 c00ac2e:	b570      	push	{r4, r5, r6, lr}
 c00ac30:	460e      	mov	r6, r1
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c00ac32:	2101      	movs	r1, #1
{
 c00ac34:	4604      	mov	r4, r0
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
 c00ac36:	f7ff ffa8 	bl	c00ab8a <mbedtls_mpi_grow>
 c00ac3a:	4605      	mov	r5, r0
 c00ac3c:	b988      	cbnz	r0, c00ac62 <mbedtls_mpi_lset+0x34>
    memset( X->p, 0, X->n * ciL );
 c00ac3e:	6862      	ldr	r2, [r4, #4]
 c00ac40:	4601      	mov	r1, r0
 c00ac42:	0092      	lsls	r2, r2, #2
 c00ac44:	68a0      	ldr	r0, [r4, #8]
 c00ac46:	f003 fa20 	bl	c00e08a <memset>
    X->p[0] = ( z < 0 ) ? -z : z;
 c00ac4a:	68a3      	ldr	r3, [r4, #8]
 c00ac4c:	ea86 72e6 	eor.w	r2, r6, r6, asr #31
    X->s    = ( z < 0 ) ? -1 : 1;
 c00ac50:	2e00      	cmp	r6, #0
    X->p[0] = ( z < 0 ) ? -z : z;
 c00ac52:	eba2 72e6 	sub.w	r2, r2, r6, asr #31
 c00ac56:	601a      	str	r2, [r3, #0]
    X->s    = ( z < 0 ) ? -1 : 1;
 c00ac58:	bfb4      	ite	lt
 c00ac5a:	f04f 33ff 	movlt.w	r3, #4294967295
 c00ac5e:	2301      	movge	r3, #1
 c00ac60:	6023      	str	r3, [r4, #0]
}
 c00ac62:	4628      	mov	r0, r5
 c00ac64:	bd70      	pop	{r4, r5, r6, pc}

0c00ac66 <mbedtls_mpi_get_bit>:
    if( X->n * biL <= pos )
 c00ac66:	6843      	ldr	r3, [r0, #4]
 c00ac68:	ebb1 1f43 	cmp.w	r1, r3, lsl #5
    return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
 c00ac6c:	bf3f      	itttt	cc
 c00ac6e:	6883      	ldrcc	r3, [r0, #8]
 c00ac70:	094a      	lsrcc	r2, r1, #5
 c00ac72:	f853 0022 	ldrcc.w	r0, [r3, r2, lsl #2]
 c00ac76:	f001 011f 	andcc.w	r1, r1, #31
 c00ac7a:	bf3a      	itte	cc
 c00ac7c:	40c8      	lsrcc	r0, r1
 c00ac7e:	f000 0001 	andcc.w	r0, r0, #1
        return( 0 );
 c00ac82:	2000      	movcs	r0, #0
}
 c00ac84:	4770      	bx	lr

0c00ac86 <mbedtls_mpi_lsb>:
    size_t i, j, count = 0;
 c00ac86:	2100      	movs	r1, #0
{
 c00ac88:	b5f0      	push	{r4, r5, r6, r7, lr}
    for( i = 0; i < X->n; i++ )
 c00ac8a:	460a      	mov	r2, r1
{
 c00ac8c:	4604      	mov	r4, r0
    for( i = 0; i < X->n; i++ )
 c00ac8e:	6845      	ldr	r5, [r0, #4]
 c00ac90:	4295      	cmp	r5, r2
 c00ac92:	d101      	bne.n	c00ac98 <mbedtls_mpi_lsb+0x12>
    return( 0 );
 c00ac94:	2000      	movs	r0, #0
}
 c00ac96:	bdf0      	pop	{r4, r5, r6, r7, pc}
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 c00ac98:	68a3      	ldr	r3, [r4, #8]
 c00ac9a:	f853 6022 	ldr.w	r6, [r3, r2, lsl #2]
        for( j = 0; j < biL; j++, count++ )
 c00ac9e:	2300      	movs	r3, #0
            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
 c00aca0:	fa26 f703 	lsr.w	r7, r6, r3
 c00aca4:	07ff      	lsls	r7, r7, #31
 c00aca6:	eb01 0003 	add.w	r0, r1, r3
 c00acaa:	d4f4      	bmi.n	c00ac96 <mbedtls_mpi_lsb+0x10>
        for( j = 0; j < biL; j++, count++ )
 c00acac:	3301      	adds	r3, #1
 c00acae:	2b20      	cmp	r3, #32
 c00acb0:	eb01 0003 	add.w	r0, r1, r3
 c00acb4:	d1f4      	bne.n	c00aca0 <mbedtls_mpi_lsb+0x1a>
    for( i = 0; i < X->n; i++ )
 c00acb6:	3201      	adds	r2, #1
        for( j = 0; j < biL; j++, count++ )
 c00acb8:	4601      	mov	r1, r0
 c00acba:	e7e9      	b.n	c00ac90 <mbedtls_mpi_lsb+0xa>

0c00acbc <mbedtls_mpi_bitlen>:
    if( X->n == 0 )
 c00acbc:	6843      	ldr	r3, [r0, #4]
 c00acbe:	b1db      	cbz	r3, c00acf8 <mbedtls_mpi_bitlen+0x3c>
 c00acc0:	6881      	ldr	r1, [r0, #8]
    for( i = X->n - 1; i > 0; i-- )
 c00acc2:	1e5a      	subs	r2, r3, #1
 c00acc4:	009b      	lsls	r3, r3, #2
 c00acc6:	b97a      	cbnz	r2, c00ace8 <mbedtls_mpi_bitlen+0x2c>
    for( j = 0; j < biL; j++ )
 c00acc8:	2000      	movs	r0, #0
    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
 c00acca:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    j = biL - mbedtls_clz( X->p[i] );
 c00acce:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
        if( x & mask ) break;
 c00acd2:	4219      	tst	r1, r3
 c00acd4:	d104      	bne.n	c00ace0 <mbedtls_mpi_bitlen+0x24>
    for( j = 0; j < biL; j++ )
 c00acd6:	3001      	adds	r0, #1
 c00acd8:	2820      	cmp	r0, #32
        mask >>= 1;
 c00acda:	ea4f 0353 	mov.w	r3, r3, lsr #1
    for( j = 0; j < biL; j++ )
 c00acde:	d1f8      	bne.n	c00acd2 <mbedtls_mpi_bitlen+0x16>
    return( ( i * biL ) + j );
 c00ace0:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 c00ace4:	3020      	adds	r0, #32
 c00ace6:	4770      	bx	lr
        if( X->p[i] != 0 )
 c00ace8:	18c8      	adds	r0, r1, r3
 c00acea:	f850 0c04 	ldr.w	r0, [r0, #-4]
 c00acee:	3b04      	subs	r3, #4
 c00acf0:	2800      	cmp	r0, #0
 c00acf2:	d1e9      	bne.n	c00acc8 <mbedtls_mpi_bitlen+0xc>
    for( i = X->n - 1; i > 0; i-- )
 c00acf4:	3a01      	subs	r2, #1
 c00acf6:	e7e6      	b.n	c00acc6 <mbedtls_mpi_bitlen+0xa>
        return( 0 );
 c00acf8:	4618      	mov	r0, r3
}
 c00acfa:	4770      	bx	lr

0c00acfc <mbedtls_mpi_size>:
{
 c00acfc:	b508      	push	{r3, lr}
    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
 c00acfe:	f7ff ffdd 	bl	c00acbc <mbedtls_mpi_bitlen>
 c00ad02:	3007      	adds	r0, #7
}
 c00ad04:	08c0      	lsrs	r0, r0, #3
 c00ad06:	bd08      	pop	{r3, pc}

0c00ad08 <mbedtls_mpi_read_binary>:
{
 c00ad08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 c00ad0c:	f012 0403 	ands.w	r4, r2, #3
 c00ad10:	bf18      	it	ne
 c00ad12:	2401      	movne	r4, #1
    if( X->n != limbs )
 c00ad14:	6843      	ldr	r3, [r0, #4]
    size_t const limbs    = CHARS_TO_LIMBS( buflen );
 c00ad16:	eb04 0492 	add.w	r4, r4, r2, lsr #2
    if( X->n != limbs )
 c00ad1a:	42a3      	cmp	r3, r4
{
 c00ad1c:	4607      	mov	r7, r0
 c00ad1e:	4688      	mov	r8, r1
 c00ad20:	4615      	mov	r5, r2
    if( X->n != limbs )
 c00ad22:	d108      	bne.n	c00ad36 <mbedtls_mpi_read_binary+0x2e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c00ad24:	2100      	movs	r1, #0
 c00ad26:	4638      	mov	r0, r7
 c00ad28:	f7ff ff81 	bl	c00ac2e <mbedtls_mpi_lset>
 c00ad2c:	4606      	mov	r6, r0
 c00ad2e:	b188      	cbz	r0, c00ad54 <mbedtls_mpi_read_binary+0x4c>
}
 c00ad30:	4630      	mov	r0, r6
 c00ad32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        mbedtls_mpi_free( X );
 c00ad36:	f7ff ff16 	bl	c00ab66 <mbedtls_mpi_free>
    X->n = 0;
 c00ad3a:	2300      	movs	r3, #0
 c00ad3c:	2201      	movs	r2, #1
    X->p = NULL;
 c00ad3e:	60bb      	str	r3, [r7, #8]
    X->n = 0;
 c00ad40:	e9c7 2300 	strd	r2, r3, [r7]
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
 c00ad44:	4621      	mov	r1, r4
 c00ad46:	4638      	mov	r0, r7
 c00ad48:	f7ff ff1f 	bl	c00ab8a <mbedtls_mpi_grow>
 c00ad4c:	4606      	mov	r6, r0
 c00ad4e:	2800      	cmp	r0, #0
 c00ad50:	d0e8      	beq.n	c00ad24 <mbedtls_mpi_read_binary+0x1c>
 c00ad52:	e7ed      	b.n	c00ad30 <mbedtls_mpi_read_binary+0x28>
    if( buf != NULL )
 c00ad54:	f1b8 0f00 	cmp.w	r8, #0
 c00ad58:	d0ea      	beq.n	c00ad30 <mbedtls_mpi_read_binary+0x28>
        memcpy( Xp + overhead, buf, buflen );
 c00ad5a:	68bb      	ldr	r3, [r7, #8]
    size_t const overhead = ( limbs * ciL ) - buflen;
 c00ad5c:	ebc5 0084 	rsb	r0, r5, r4, lsl #2
        memcpy( Xp + overhead, buf, buflen );
 c00ad60:	462a      	mov	r2, r5
 c00ad62:	4641      	mov	r1, r8
 c00ad64:	4418      	add	r0, r3
 c00ad66:	f003 f96c 	bl	c00e042 <memcpy>
    if( limbs == 0 )
 c00ad6a:	2c00      	cmp	r4, #0
 c00ad6c:	d0e0      	beq.n	c00ad30 <mbedtls_mpi_read_binary+0x28>
 c00ad6e:	4621      	mov	r1, r4
 c00ad70:	68b8      	ldr	r0, [r7, #8]
 c00ad72:	f7ff fee0 	bl	c00ab36 <mpi_bigendian_to_host.part.1>
    return( ret );
 c00ad76:	e7db      	b.n	c00ad30 <mbedtls_mpi_read_binary+0x28>

0c00ad78 <mbedtls_mpi_write_binary>:
{
 c00ad78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00ad7a:	4605      	mov	r5, r0
    stored_bytes = X->n * ciL;
 c00ad7c:	686c      	ldr	r4, [r5, #4]
{
 c00ad7e:	4608      	mov	r0, r1
    stored_bytes = X->n * ciL;
 c00ad80:	00a4      	lsls	r4, r4, #2
    if( stored_bytes < buflen )
 c00ad82:	4294      	cmp	r4, r2
 c00ad84:	d21c      	bcs.n	c00adc0 <mbedtls_mpi_write_binary+0x48>
        p = buf + buflen - stored_bytes;
 c00ad86:	1b12      	subs	r2, r2, r4
 c00ad88:	188e      	adds	r6, r1, r2
        memset( buf, 0, buflen - stored_bytes );
 c00ad8a:	2100      	movs	r1, #0
 c00ad8c:	f003 f97d 	bl	c00e08a <memset>
        p = buf + buflen - stored_bytes;
 c00ad90:	4630      	mov	r0, r6
 c00ad92:	4622      	mov	r2, r4
    for( i = 0; i < bytes_to_copy; i++ )
 c00ad94:	2300      	movs	r3, #0
 c00ad96:	4410      	add	r0, r2
 c00ad98:	429a      	cmp	r2, r3
 c00ad9a:	d113      	bne.n	c00adc4 <mbedtls_mpi_write_binary+0x4c>
    return( 0 );
 c00ad9c:	2000      	movs	r0, #0
}
 c00ad9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            if( GET_BYTE( X, i ) != 0 )
 c00ada0:	68af      	ldr	r7, [r5, #8]
 c00ada2:	f003 0103 	and.w	r1, r3, #3
 c00ada6:	f023 0c03 	bic.w	ip, r3, #3
 c00adaa:	00ce      	lsls	r6, r1, #3
 c00adac:	f857 100c 	ldr.w	r1, [r7, ip]
 c00adb0:	40f1      	lsrs	r1, r6
 c00adb2:	f011 0fff 	tst.w	r1, #255	; 0xff
 c00adb6:	d111      	bne.n	c00addc <mbedtls_mpi_write_binary+0x64>
        for( i = bytes_to_copy; i < stored_bytes; i++ )
 c00adb8:	3301      	adds	r3, #1
 c00adba:	42a3      	cmp	r3, r4
 c00adbc:	d1f0      	bne.n	c00ada0 <mbedtls_mpi_write_binary+0x28>
 c00adbe:	e7e9      	b.n	c00ad94 <mbedtls_mpi_write_binary+0x1c>
 c00adc0:	4613      	mov	r3, r2
 c00adc2:	e7fa      	b.n	c00adba <mbedtls_mpi_write_binary+0x42>
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c00adc4:	68af      	ldr	r7, [r5, #8]
 c00adc6:	f003 0103 	and.w	r1, r3, #3
 c00adca:	f023 0603 	bic.w	r6, r3, #3
 c00adce:	00cc      	lsls	r4, r1, #3
 c00add0:	59b9      	ldr	r1, [r7, r6]
    for( i = 0; i < bytes_to_copy; i++ )
 c00add2:	3301      	adds	r3, #1
        p[bytes_to_copy - i - 1] = GET_BYTE( X, i );
 c00add4:	40e1      	lsrs	r1, r4
 c00add6:	f800 1d01 	strb.w	r1, [r0, #-1]!
 c00adda:	e7dd      	b.n	c00ad98 <mbedtls_mpi_write_binary+0x20>
                return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
 c00addc:	f06f 0007 	mvn.w	r0, #7
 c00ade0:	e7dd      	b.n	c00ad9e <mbedtls_mpi_write_binary+0x26>

0c00ade2 <mbedtls_mpi_shift_l>:
{
 c00ade2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00ade4:	4606      	mov	r6, r0
 c00ade6:	460d      	mov	r5, r1
    v0 = count / (biL    );
 c00ade8:	094c      	lsrs	r4, r1, #5
    t1 = count & (biL - 1);
 c00adea:	f001 071f 	and.w	r7, r1, #31
    i = mbedtls_mpi_bitlen( X ) + count;
 c00adee:	f7ff ff65 	bl	c00acbc <mbedtls_mpi_bitlen>
    if( X->n * biL < i )
 c00adf2:	6873      	ldr	r3, [r6, #4]
    i = mbedtls_mpi_bitlen( X ) + count;
 c00adf4:	4428      	add	r0, r5
    if( X->n * biL < i )
 c00adf6:	ebb0 1f43 	cmp.w	r0, r3, lsl #5
 c00adfa:	d803      	bhi.n	c00ae04 <mbedtls_mpi_shift_l+0x22>
    if( v0 > 0 )
 c00adfc:	b974      	cbnz	r4, c00ae1c <mbedtls_mpi_shift_l+0x3a>
    if( t1 > 0 )
 c00adfe:	bb2f      	cbnz	r7, c00ae4c <mbedtls_mpi_shift_l+0x6a>
    ret = 0;
 c00ae00:	2000      	movs	r0, #0
 c00ae02:	e00a      	b.n	c00ae1a <mbedtls_mpi_shift_l+0x38>
        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
 c00ae04:	f010 011f 	ands.w	r1, r0, #31
 c00ae08:	bf18      	it	ne
 c00ae0a:	2101      	movne	r1, #1
 c00ae0c:	eb01 1150 	add.w	r1, r1, r0, lsr #5
 c00ae10:	4630      	mov	r0, r6
 c00ae12:	f7ff feba 	bl	c00ab8a <mbedtls_mpi_grow>
 c00ae16:	2800      	cmp	r0, #0
 c00ae18:	d0f0      	beq.n	c00adfc <mbedtls_mpi_shift_l+0x1a>
}
 c00ae1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        for( i = X->n; i > v0; i-- )
 c00ae1c:	6873      	ldr	r3, [r6, #4]
 c00ae1e:	00a0      	lsls	r0, r4, #2
 c00ae20:	f103 4280 	add.w	r2, r3, #1073741824	; 0x40000000
 c00ae24:	3a01      	subs	r2, #1
 c00ae26:	1b12      	subs	r2, r2, r4
 c00ae28:	0092      	lsls	r2, r2, #2
 c00ae2a:	42a3      	cmp	r3, r4
 c00ae2c:	d807      	bhi.n	c00ae3e <mbedtls_mpi_shift_l+0x5c>
            X->p[i - 1] = 0;
 c00ae2e:	2200      	movs	r2, #0
 c00ae30:	009b      	lsls	r3, r3, #2
 c00ae32:	3b04      	subs	r3, #4
        for( ; i > 0; i-- )
 c00ae34:	1d19      	adds	r1, r3, #4
 c00ae36:	d0e2      	beq.n	c00adfe <mbedtls_mpi_shift_l+0x1c>
            X->p[i - 1] = 0;
 c00ae38:	68b1      	ldr	r1, [r6, #8]
 c00ae3a:	50ca      	str	r2, [r1, r3]
 c00ae3c:	e7f9      	b.n	c00ae32 <mbedtls_mpi_shift_l+0x50>
            X->p[i - 1] = X->p[i - v0 - 1];
 c00ae3e:	68b1      	ldr	r1, [r6, #8]
        for( i = X->n; i > v0; i-- )
 c00ae40:	3b01      	subs	r3, #1
            X->p[i - 1] = X->p[i - v0 - 1];
 c00ae42:	588d      	ldr	r5, [r1, r2]
 c00ae44:	4411      	add	r1, r2
 c00ae46:	500d      	str	r5, [r1, r0]
 c00ae48:	3a04      	subs	r2, #4
 c00ae4a:	e7ee      	b.n	c00ae2a <mbedtls_mpi_shift_l+0x48>
    mbedtls_mpi_uint r0 = 0, r1;
 c00ae4c:	2100      	movs	r1, #0
        for( i = v0; i < X->n; i++ )
 c00ae4e:	f8d6 c004 	ldr.w	ip, [r6, #4]
 c00ae52:	00a3      	lsls	r3, r4, #2
            r1 = X->p[i] >> (biL - t1);
 c00ae54:	f1c7 0e20 	rsb	lr, r7, #32
        for( i = v0; i < X->n; i++ )
 c00ae58:	45a4      	cmp	ip, r4
 c00ae5a:	d9d1      	bls.n	c00ae00 <mbedtls_mpi_shift_l+0x1e>
            r1 = X->p[i] >> (biL - t1);
 c00ae5c:	68b5      	ldr	r5, [r6, #8]
        for( i = v0; i < X->n; i++ )
 c00ae5e:	3401      	adds	r4, #1
            r1 = X->p[i] >> (biL - t1);
 c00ae60:	58e8      	ldr	r0, [r5, r3]
            X->p[i] <<= t1;
 c00ae62:	fa00 f207 	lsl.w	r2, r0, r7
            X->p[i] |= r0;
 c00ae66:	430a      	orrs	r2, r1
 c00ae68:	50ea      	str	r2, [r5, r3]
            r1 = X->p[i] >> (biL - t1);
 c00ae6a:	fa20 f10e 	lsr.w	r1, r0, lr
 c00ae6e:	3304      	adds	r3, #4
 c00ae70:	e7f2      	b.n	c00ae58 <mbedtls_mpi_shift_l+0x76>

0c00ae72 <mbedtls_mpi_shift_r>:
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c00ae72:	6843      	ldr	r3, [r0, #4]
{
 c00ae74:	b4f0      	push	{r4, r5, r6, r7}
    v0 = count /  biL;
 c00ae76:	094d      	lsrs	r5, r1, #5
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c00ae78:	42ab      	cmp	r3, r5
 c00ae7a:	d303      	bcc.n	c00ae84 <mbedtls_mpi_shift_r+0x12>
    v1 = count & (biL - 1);
 c00ae7c:	f001 011f 	and.w	r1, r1, #31
    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
 c00ae80:	d104      	bne.n	c00ae8c <mbedtls_mpi_shift_r+0x1a>
 c00ae82:	b369      	cbz	r1, c00aee0 <mbedtls_mpi_shift_r+0x6e>
}
 c00ae84:	bcf0      	pop	{r4, r5, r6, r7}
        return mbedtls_mpi_lset( X, 0 );
 c00ae86:	2100      	movs	r1, #0
 c00ae88:	f7ff bed1 	b.w	c00ac2e <mbedtls_mpi_lset>
    if( v0 > 0 )
 c00ae8c:	b9e5      	cbnz	r5, c00aec8 <mbedtls_mpi_shift_r+0x56>
    if( v1 > 0 )
 c00ae8e:	b129      	cbz	r1, c00ae9c <mbedtls_mpi_shift_r+0x2a>
    mbedtls_mpi_uint r0 = 0, r1;
 c00ae90:	2500      	movs	r5, #0
 c00ae92:	009a      	lsls	r2, r3, #2
            r1 = X->p[i - 1] << (biL - v1);
 c00ae94:	f1c1 0c20 	rsb	ip, r1, #32
 c00ae98:	3a04      	subs	r2, #4
        for( i = X->n; i > 0; i-- )
 c00ae9a:	b9bb      	cbnz	r3, c00aecc <mbedtls_mpi_shift_r+0x5a>
}
 c00ae9c:	bcf0      	pop	{r4, r5, r6, r7}
 c00ae9e:	2000      	movs	r0, #0
 c00aea0:	4770      	bx	lr
            X->p[i] = X->p[i + v0];
 c00aea2:	6884      	ldr	r4, [r0, #8]
 c00aea4:	1956      	adds	r6, r2, r5
 c00aea6:	f854 6026 	ldr.w	r6, [r4, r6, lsl #2]
 c00aeaa:	f844 6022 	str.w	r6, [r4, r2, lsl #2]
        for( i = 0; i < X->n - v0; i++ )
 c00aeae:	3201      	adds	r2, #1
 c00aeb0:	1b5c      	subs	r4, r3, r5
 c00aeb2:	4294      	cmp	r4, r2
 c00aeb4:	d8f5      	bhi.n	c00aea2 <mbedtls_mpi_shift_r+0x30>
            X->p[i] = 0;
 c00aeb6:	2500      	movs	r5, #0
 c00aeb8:	00a2      	lsls	r2, r4, #2
        for( ; i < X->n; i++ )
 c00aeba:	42a3      	cmp	r3, r4
 c00aebc:	d9e7      	bls.n	c00ae8e <mbedtls_mpi_shift_r+0x1c>
            X->p[i] = 0;
 c00aebe:	6886      	ldr	r6, [r0, #8]
        for( ; i < X->n; i++ )
 c00aec0:	3401      	adds	r4, #1
            X->p[i] = 0;
 c00aec2:	50b5      	str	r5, [r6, r2]
 c00aec4:	3204      	adds	r2, #4
 c00aec6:	e7f8      	b.n	c00aeba <mbedtls_mpi_shift_r+0x48>
 c00aec8:	2200      	movs	r2, #0
 c00aeca:	e7f1      	b.n	c00aeb0 <mbedtls_mpi_shift_r+0x3e>
            r1 = X->p[i - 1] << (biL - v1);
 c00aecc:	6887      	ldr	r7, [r0, #8]
        for( i = X->n; i > 0; i-- )
 c00aece:	3b01      	subs	r3, #1
            r1 = X->p[i - 1] << (biL - v1);
 c00aed0:	58be      	ldr	r6, [r7, r2]
            X->p[i - 1] >>= v1;
 c00aed2:	fa26 f401 	lsr.w	r4, r6, r1
            X->p[i - 1] |= r0;
 c00aed6:	432c      	orrs	r4, r5
 c00aed8:	50bc      	str	r4, [r7, r2]
            r1 = X->p[i - 1] << (biL - v1);
 c00aeda:	fa06 f50c 	lsl.w	r5, r6, ip
 c00aede:	e7db      	b.n	c00ae98 <mbedtls_mpi_shift_r+0x26>
    if( v0 > 0 )
 c00aee0:	2b00      	cmp	r3, #0
 c00aee2:	d0db      	beq.n	c00ae9c <mbedtls_mpi_shift_r+0x2a>
 c00aee4:	460a      	mov	r2, r1
 c00aee6:	e7e3      	b.n	c00aeb0 <mbedtls_mpi_shift_r+0x3e>

0c00aee8 <mbedtls_mpi_cmp_abs>:
{
 c00aee8:	b570      	push	{r4, r5, r6, lr}
    for( i = X->n; i > 0; i-- )
 c00aeea:	6843      	ldr	r3, [r0, #4]
 c00aeec:	009a      	lsls	r2, r3, #2
 c00aeee:	b933      	cbnz	r3, c00aefe <mbedtls_mpi_cmp_abs+0x16>
    for( j = Y->n; j > 0; j-- )
 c00aef0:	684a      	ldr	r2, [r1, #4]
 c00aef2:	0094      	lsls	r4, r2, #2
 c00aef4:	b962      	cbnz	r2, c00af10 <mbedtls_mpi_cmp_abs+0x28>
    if( i == 0 && j == 0 )
 c00aef6:	1c18      	adds	r0, r3, #0
 c00aef8:	bf18      	it	ne
 c00aefa:	2001      	movne	r0, #1
 c00aefc:	e016      	b.n	c00af2c <mbedtls_mpi_cmp_abs+0x44>
        if( X->p[i - 1] != 0 )
 c00aefe:	6884      	ldr	r4, [r0, #8]
 c00af00:	4414      	add	r4, r2
 c00af02:	f854 4c04 	ldr.w	r4, [r4, #-4]
 c00af06:	3a04      	subs	r2, #4
 c00af08:	2c00      	cmp	r4, #0
 c00af0a:	d1f1      	bne.n	c00aef0 <mbedtls_mpi_cmp_abs+0x8>
    for( i = X->n; i > 0; i-- )
 c00af0c:	3b01      	subs	r3, #1
 c00af0e:	e7ee      	b.n	c00aeee <mbedtls_mpi_cmp_abs+0x6>
        if( Y->p[j - 1] != 0 )
 c00af10:	688d      	ldr	r5, [r1, #8]
 c00af12:	192e      	adds	r6, r5, r4
 c00af14:	f856 6c04 	ldr.w	r6, [r6, #-4]
 c00af18:	3c04      	subs	r4, #4
 c00af1a:	b90e      	cbnz	r6, c00af20 <mbedtls_mpi_cmp_abs+0x38>
    for( j = Y->n; j > 0; j-- )
 c00af1c:	3a01      	subs	r2, #1
 c00af1e:	e7e9      	b.n	c00aef4 <mbedtls_mpi_cmp_abs+0xc>
    if( i > j ) return(  1 );
 c00af20:	4293      	cmp	r3, r2
 c00af22:	d80d      	bhi.n	c00af40 <mbedtls_mpi_cmp_abs+0x58>
    if( j > i ) return( -1 );
 c00af24:	d30e      	bcc.n	c00af44 <mbedtls_mpi_cmp_abs+0x5c>
 c00af26:	009a      	lsls	r2, r3, #2
    for( ; i > 0; i-- )
 c00af28:	b90b      	cbnz	r3, c00af2e <mbedtls_mpi_cmp_abs+0x46>
    return( 0 );
 c00af2a:	4618      	mov	r0, r3
}
 c00af2c:	bd70      	pop	{r4, r5, r6, pc}
        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
 c00af2e:	6881      	ldr	r1, [r0, #8]
 c00af30:	3a04      	subs	r2, #4
 c00af32:	588c      	ldr	r4, [r1, r2]
 c00af34:	58a9      	ldr	r1, [r5, r2]
 c00af36:	428c      	cmp	r4, r1
 c00af38:	d802      	bhi.n	c00af40 <mbedtls_mpi_cmp_abs+0x58>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
 c00af3a:	d303      	bcc.n	c00af44 <mbedtls_mpi_cmp_abs+0x5c>
    for( ; i > 0; i-- )
 c00af3c:	3b01      	subs	r3, #1
 c00af3e:	e7f3      	b.n	c00af28 <mbedtls_mpi_cmp_abs+0x40>
    if( i > j ) return(  1 );
 c00af40:	2001      	movs	r0, #1
 c00af42:	e7f3      	b.n	c00af2c <mbedtls_mpi_cmp_abs+0x44>
    if( j > i ) return( -1 );
 c00af44:	f04f 30ff 	mov.w	r0, #4294967295
 c00af48:	e7f0      	b.n	c00af2c <mbedtls_mpi_cmp_abs+0x44>

0c00af4a <mbedtls_mpi_cmp_mpi>:
{
 c00af4a:	b570      	push	{r4, r5, r6, lr}
    for( i = X->n; i > 0; i-- )
 c00af4c:	6843      	ldr	r3, [r0, #4]
 c00af4e:	009a      	lsls	r2, r3, #2
 c00af50:	b923      	cbnz	r3, c00af5c <mbedtls_mpi_cmp_mpi+0x12>
    for( j = Y->n; j > 0; j-- )
 c00af52:	684a      	ldr	r2, [r1, #4]
 c00af54:	0094      	lsls	r4, r2, #2
 c00af56:	b952      	cbnz	r2, c00af6e <mbedtls_mpi_cmp_mpi+0x24>
    if( i == 0 && j == 0 )
 c00af58:	b99b      	cbnz	r3, c00af82 <mbedtls_mpi_cmp_mpi+0x38>
 c00af5a:	e024      	b.n	c00afa6 <mbedtls_mpi_cmp_mpi+0x5c>
        if( X->p[i - 1] != 0 )
 c00af5c:	6884      	ldr	r4, [r0, #8]
 c00af5e:	4414      	add	r4, r2
 c00af60:	f854 4c04 	ldr.w	r4, [r4, #-4]
 c00af64:	3a04      	subs	r2, #4
 c00af66:	2c00      	cmp	r4, #0
 c00af68:	d1f3      	bne.n	c00af52 <mbedtls_mpi_cmp_mpi+0x8>
    for( i = X->n; i > 0; i-- )
 c00af6a:	3b01      	subs	r3, #1
 c00af6c:	e7f0      	b.n	c00af50 <mbedtls_mpi_cmp_mpi+0x6>
        if( Y->p[j - 1] != 0 )
 c00af6e:	688d      	ldr	r5, [r1, #8]
 c00af70:	192e      	adds	r6, r5, r4
 c00af72:	f856 6c04 	ldr.w	r6, [r6, #-4]
 c00af76:	3c04      	subs	r4, #4
 c00af78:	b90e      	cbnz	r6, c00af7e <mbedtls_mpi_cmp_mpi+0x34>
    for( j = Y->n; j > 0; j-- )
 c00af7a:	3a01      	subs	r2, #1
 c00af7c:	e7eb      	b.n	c00af56 <mbedtls_mpi_cmp_mpi+0xc>
    if( i > j ) return(  X->s );
 c00af7e:	4293      	cmp	r3, r2
 c00af80:	d902      	bls.n	c00af88 <mbedtls_mpi_cmp_mpi+0x3e>
 c00af82:	6802      	ldr	r2, [r0, #0]
}
 c00af84:	4610      	mov	r0, r2
 c00af86:	bd70      	pop	{r4, r5, r6, pc}
 c00af88:	6809      	ldr	r1, [r1, #0]
    if( j > i ) return( -Y->s );
 c00af8a:	d201      	bcs.n	c00af90 <mbedtls_mpi_cmp_mpi+0x46>
 c00af8c:	424a      	negs	r2, r1
 c00af8e:	e7f9      	b.n	c00af84 <mbedtls_mpi_cmp_mpi+0x3a>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 c00af90:	6802      	ldr	r2, [r0, #0]
 c00af92:	2a00      	cmp	r2, #0
 c00af94:	dd01      	ble.n	c00af9a <mbedtls_mpi_cmp_mpi+0x50>
 c00af96:	2900      	cmp	r1, #0
 c00af98:	db12      	blt.n	c00afc0 <mbedtls_mpi_cmp_mpi+0x76>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 c00af9a:	2900      	cmp	r1, #0
 c00af9c:	dd01      	ble.n	c00afa2 <mbedtls_mpi_cmp_mpi+0x58>
 c00af9e:	2a00      	cmp	r2, #0
 c00afa0:	db10      	blt.n	c00afc4 <mbedtls_mpi_cmp_mpi+0x7a>
 c00afa2:	0099      	lsls	r1, r3, #2
    for( ; i > 0; i-- )
 c00afa4:	b90b      	cbnz	r3, c00afaa <mbedtls_mpi_cmp_mpi+0x60>
    return( 0 );
 c00afa6:	461a      	mov	r2, r3
 c00afa8:	e7ec      	b.n	c00af84 <mbedtls_mpi_cmp_mpi+0x3a>
        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
 c00afaa:	6884      	ldr	r4, [r0, #8]
 c00afac:	3904      	subs	r1, #4
 c00afae:	5866      	ldr	r6, [r4, r1]
 c00afb0:	586c      	ldr	r4, [r5, r1]
 c00afb2:	42a6      	cmp	r6, r4
 c00afb4:	d8e6      	bhi.n	c00af84 <mbedtls_mpi_cmp_mpi+0x3a>
        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
 c00afb6:	d201      	bcs.n	c00afbc <mbedtls_mpi_cmp_mpi+0x72>
 c00afb8:	4252      	negs	r2, r2
 c00afba:	e7e3      	b.n	c00af84 <mbedtls_mpi_cmp_mpi+0x3a>
    for( ; i > 0; i-- )
 c00afbc:	3b01      	subs	r3, #1
 c00afbe:	e7f1      	b.n	c00afa4 <mbedtls_mpi_cmp_mpi+0x5a>
    if( X->s > 0 && Y->s < 0 ) return(  1 );
 c00afc0:	2201      	movs	r2, #1
 c00afc2:	e7df      	b.n	c00af84 <mbedtls_mpi_cmp_mpi+0x3a>
    if( Y->s > 0 && X->s < 0 ) return( -1 );
 c00afc4:	f04f 32ff 	mov.w	r2, #4294967295
 c00afc8:	e7dc      	b.n	c00af84 <mbedtls_mpi_cmp_mpi+0x3a>

0c00afca <mbedtls_mpi_cmp_int>:
{
 c00afca:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    *p  = ( z < 0 ) ? -z : z;
 c00afcc:	ea81 73e1 	eor.w	r3, r1, r1, asr #31
 c00afd0:	eba3 73e1 	sub.w	r3, r3, r1, asr #31
    Y.s = ( z < 0 ) ? -1 : 1;
 c00afd4:	2900      	cmp	r1, #0
    *p  = ( z < 0 ) ? -z : z;
 c00afd6:	9300      	str	r3, [sp, #0]
    Y.s = ( z < 0 ) ? -1 : 1;
 c00afd8:	bfb4      	ite	lt
 c00afda:	f04f 33ff 	movlt.w	r3, #4294967295
 c00afde:	2301      	movge	r3, #1
 c00afe0:	9301      	str	r3, [sp, #4]
    Y.n = 1;
 c00afe2:	2301      	movs	r3, #1
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c00afe4:	a901      	add	r1, sp, #4
    Y.n = 1;
 c00afe6:	9302      	str	r3, [sp, #8]
    Y.p = p;
 c00afe8:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
 c00afec:	f7ff ffad 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
}
 c00aff0:	b005      	add	sp, #20
 c00aff2:	f85d fb04 	ldr.w	pc, [sp], #4

0c00aff6 <mbedtls_mpi_add_abs>:
    if( X == B )
 c00aff6:	4290      	cmp	r0, r2
{
 c00aff8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00affc:	4606      	mov	r6, r0
 c00affe:	460c      	mov	r4, r1
 c00b000:	4615      	mov	r5, r2
    if( X == B )
 c00b002:	d002      	beq.n	c00b00a <mbedtls_mpi_add_abs+0x14>
    if( X != A )
 c00b004:	4288      	cmp	r0, r1
 c00b006:	d131      	bne.n	c00b06c <mbedtls_mpi_add_abs+0x76>
{
 c00b008:	462c      	mov	r4, r5
    X->s = 1;
 c00b00a:	2301      	movs	r3, #1
    for( j = B->n; j > 0; j-- )
 c00b00c:	f8d4 8004 	ldr.w	r8, [r4, #4]
    X->s = 1;
 c00b010:	6033      	str	r3, [r6, #0]
 c00b012:	ea4f 0388 	mov.w	r3, r8, lsl #2
    for( j = B->n; j > 0; j-- )
 c00b016:	f1b8 0f00 	cmp.w	r8, #0
 c00b01a:	d12f      	bne.n	c00b07c <mbedtls_mpi_add_abs+0x86>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
 c00b01c:	4641      	mov	r1, r8
 c00b01e:	4630      	mov	r0, r6
 c00b020:	f7ff fdb3 	bl	c00ab8a <mbedtls_mpi_grow>
 c00b024:	4607      	mov	r7, r0
 c00b026:	bb30      	cbnz	r0, c00b076 <mbedtls_mpi_add_abs+0x80>
    o = B->p; p = X->p; c = 0;
 c00b028:	68b3      	ldr	r3, [r6, #8]
 c00b02a:	f8d4 e008 	ldr.w	lr, [r4, #8]
 c00b02e:	4619      	mov	r1, r3
 c00b030:	4604      	mov	r4, r0
    for( i = 0; i < j; i++, o++, p++ )
 c00b032:	4605      	mov	r5, r0
 c00b034:	45a8      	cmp	r8, r5
 c00b036:	d12b      	bne.n	c00b090 <mbedtls_mpi_add_abs+0x9a>
 c00b038:	eb03 0385 	add.w	r3, r3, r5, lsl #2
    while( c != 0 )
 c00b03c:	b1dc      	cbz	r4, c00b076 <mbedtls_mpi_add_abs+0x80>
        if( i >= X->n )
 c00b03e:	6872      	ldr	r2, [r6, #4]
 c00b040:	f105 0801 	add.w	r8, r5, #1
 c00b044:	42aa      	cmp	r2, r5
 c00b046:	d807      	bhi.n	c00b058 <mbedtls_mpi_add_abs+0x62>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c00b048:	4641      	mov	r1, r8
 c00b04a:	4630      	mov	r0, r6
 c00b04c:	f7ff fd9d 	bl	c00ab8a <mbedtls_mpi_grow>
 c00b050:	bb80      	cbnz	r0, c00b0b4 <mbedtls_mpi_add_abs+0xbe>
            p = X->p + i;
 c00b052:	68b3      	ldr	r3, [r6, #8]
 c00b054:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 c00b058:	681a      	ldr	r2, [r3, #0]
 c00b05a:	2100      	movs	r1, #0
 c00b05c:	1914      	adds	r4, r2, r4
 c00b05e:	bf28      	it	cs
 c00b060:	2101      	movcs	r1, #1
        *p += c; c = ( *p < c ); i++; p++;
 c00b062:	f843 4b04 	str.w	r4, [r3], #4
 c00b066:	4645      	mov	r5, r8
 c00b068:	460c      	mov	r4, r1
 c00b06a:	e7e7      	b.n	c00b03c <mbedtls_mpi_add_abs+0x46>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c00b06c:	f7ff fdb3 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b070:	4607      	mov	r7, r0
 c00b072:	2800      	cmp	r0, #0
 c00b074:	d0c8      	beq.n	c00b008 <mbedtls_mpi_add_abs+0x12>
}
 c00b076:	4638      	mov	r0, r7
 c00b078:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if( B->p[j - 1] != 0 )
 c00b07c:	68a2      	ldr	r2, [r4, #8]
 c00b07e:	441a      	add	r2, r3
 c00b080:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c00b084:	3b04      	subs	r3, #4
 c00b086:	2a00      	cmp	r2, #0
 c00b088:	d1c8      	bne.n	c00b01c <mbedtls_mpi_add_abs+0x26>
    for( j = B->n; j > 0; j-- )
 c00b08a:	f108 38ff 	add.w	r8, r8, #4294967295
 c00b08e:	e7c2      	b.n	c00b016 <mbedtls_mpi_add_abs+0x20>
 c00b090:	680a      	ldr	r2, [r1, #0]
        tmp= *o;
 c00b092:	f85e 0025 	ldr.w	r0, [lr, r5, lsl #2]
 c00b096:	1914      	adds	r4, r2, r4
 c00b098:	f04f 0c00 	mov.w	ip, #0
 c00b09c:	bf28      	it	cs
 c00b09e:	f04f 0c01 	movcs.w	ip, #1
 c00b0a2:	1824      	adds	r4, r4, r0
        *p += tmp; c += ( *p < tmp );
 c00b0a4:	f841 4b04 	str.w	r4, [r1], #4
 c00b0a8:	bf2c      	ite	cs
 c00b0aa:	2401      	movcs	r4, #1
 c00b0ac:	2400      	movcc	r4, #0
    for( i = 0; i < j; i++, o++, p++ )
 c00b0ae:	3501      	adds	r5, #1
        *p += tmp; c += ( *p < tmp );
 c00b0b0:	4464      	add	r4, ip
 c00b0b2:	e7bf      	b.n	c00b034 <mbedtls_mpi_add_abs+0x3e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
 c00b0b4:	4607      	mov	r7, r0
    return( ret );
 c00b0b6:	e7de      	b.n	c00b076 <mbedtls_mpi_add_abs+0x80>

0c00b0b8 <mbedtls_mpi_sub_abs>:
{
 c00b0b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00b0ba:	460f      	mov	r7, r1
 c00b0bc:	b085      	sub	sp, #20
 c00b0be:	4606      	mov	r6, r0
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c00b0c0:	4611      	mov	r1, r2
 c00b0c2:	4638      	mov	r0, r7
{
 c00b0c4:	4615      	mov	r5, r2
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c00b0c6:	f7ff ff0f 	bl	c00aee8 <mbedtls_mpi_cmp_abs>
 c00b0ca:	2800      	cmp	r0, #0
 c00b0cc:	db2f      	blt.n	c00b12e <mbedtls_mpi_sub_abs+0x76>
    X->n = 0;
 c00b0ce:	2300      	movs	r3, #0
 c00b0d0:	2201      	movs	r2, #1
    if( X == B )
 c00b0d2:	42b5      	cmp	r5, r6
    X->n = 0;
 c00b0d4:	e9cd 2301 	strd	r2, r3, [sp, #4]
    X->p = NULL;
 c00b0d8:	9303      	str	r3, [sp, #12]
    if( X == B )
 c00b0da:	d106      	bne.n	c00b0ea <mbedtls_mpi_sub_abs+0x32>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 c00b0dc:	4629      	mov	r1, r5
 c00b0de:	a801      	add	r0, sp, #4
 c00b0e0:	f7ff fd79 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b0e4:	4604      	mov	r4, r0
 c00b0e6:	b9a0      	cbnz	r0, c00b112 <mbedtls_mpi_sub_abs+0x5a>
        B = &TB;
 c00b0e8:	ad01      	add	r5, sp, #4
    if( X != A )
 c00b0ea:	42b7      	cmp	r7, r6
 c00b0ec:	d10a      	bne.n	c00b104 <mbedtls_mpi_sub_abs+0x4c>
    X->s = 1;
 c00b0ee:	2301      	movs	r3, #1
    for( n = B->n; n > 0; n-- )
 c00b0f0:	6868      	ldr	r0, [r5, #4]
 c00b0f2:	68a9      	ldr	r1, [r5, #8]
    X->s = 1;
 c00b0f4:	6033      	str	r3, [r6, #0]
 c00b0f6:	0083      	lsls	r3, r0, #2
    for( n = B->n; n > 0; n-- )
 c00b0f8:	b988      	cbnz	r0, c00b11e <mbedtls_mpi_sub_abs+0x66>
    mpi_sub_hlp( n, B->p, X->p );
 c00b0fa:	68b2      	ldr	r2, [r6, #8]
 c00b0fc:	f7ff fc22 	bl	c00a944 <mpi_sub_hlp>
    ret = 0;
 c00b100:	2400      	movs	r4, #0
 c00b102:	e006      	b.n	c00b112 <mbedtls_mpi_sub_abs+0x5a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
 c00b104:	4639      	mov	r1, r7
 c00b106:	4630      	mov	r0, r6
 c00b108:	f7ff fd65 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b10c:	4604      	mov	r4, r0
 c00b10e:	2800      	cmp	r0, #0
 c00b110:	d0ed      	beq.n	c00b0ee <mbedtls_mpi_sub_abs+0x36>
    mbedtls_mpi_free( &TB );
 c00b112:	a801      	add	r0, sp, #4
 c00b114:	f7ff fd27 	bl	c00ab66 <mbedtls_mpi_free>
}
 c00b118:	4620      	mov	r0, r4
 c00b11a:	b005      	add	sp, #20
 c00b11c:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if( B->p[n - 1] != 0 )
 c00b11e:	18ca      	adds	r2, r1, r3
 c00b120:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c00b124:	3b04      	subs	r3, #4
 c00b126:	2a00      	cmp	r2, #0
 c00b128:	d1e7      	bne.n	c00b0fa <mbedtls_mpi_sub_abs+0x42>
    for( n = B->n; n > 0; n-- )
 c00b12a:	3801      	subs	r0, #1
 c00b12c:	e7e4      	b.n	c00b0f8 <mbedtls_mpi_sub_abs+0x40>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c00b12e:	f06f 0409 	mvn.w	r4, #9
 c00b132:	e7f1      	b.n	c00b118 <mbedtls_mpi_sub_abs+0x60>

0c00b134 <mbedtls_mpi_add_mpi>:
{
 c00b134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    s = A->s;
 c00b136:	680c      	ldr	r4, [r1, #0]
    if( A->s * B->s < 0 )
 c00b138:	6813      	ldr	r3, [r2, #0]
{
 c00b13a:	4605      	mov	r5, r0
    if( A->s * B->s < 0 )
 c00b13c:	4363      	muls	r3, r4
{
 c00b13e:	460f      	mov	r7, r1
 c00b140:	4616      	mov	r6, r2
    if( A->s * B->s < 0 )
 c00b142:	d516      	bpl.n	c00b172 <mbedtls_mpi_add_mpi+0x3e>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c00b144:	4611      	mov	r1, r2
 c00b146:	4638      	mov	r0, r7
 c00b148:	f7ff fece 	bl	c00aee8 <mbedtls_mpi_cmp_abs>
 c00b14c:	2800      	cmp	r0, #0
 c00b14e:	db06      	blt.n	c00b15e <mbedtls_mpi_add_mpi+0x2a>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c00b150:	4632      	mov	r2, r6
 c00b152:	4639      	mov	r1, r7
 c00b154:	4628      	mov	r0, r5
 c00b156:	f7ff ffaf 	bl	c00b0b8 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c00b15a:	b140      	cbz	r0, c00b16e <mbedtls_mpi_add_mpi+0x3a>
}
 c00b15c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c00b15e:	463a      	mov	r2, r7
 c00b160:	4631      	mov	r1, r6
 c00b162:	4628      	mov	r0, r5
 c00b164:	f7ff ffa8 	bl	c00b0b8 <mbedtls_mpi_sub_abs>
 c00b168:	2800      	cmp	r0, #0
 c00b16a:	d1f7      	bne.n	c00b15c <mbedtls_mpi_add_mpi+0x28>
            X->s = -s;
 c00b16c:	4264      	negs	r4, r4
        X->s = s;
 c00b16e:	602c      	str	r4, [r5, #0]
    return( ret );
 c00b170:	e7f4      	b.n	c00b15c <mbedtls_mpi_add_mpi+0x28>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c00b172:	f7ff ff40 	bl	c00aff6 <mbedtls_mpi_add_abs>
 c00b176:	e7f0      	b.n	c00b15a <mbedtls_mpi_add_mpi+0x26>

0c00b178 <mbedtls_mpi_sub_mpi>:
{
 c00b178:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    s = A->s;
 c00b17a:	680c      	ldr	r4, [r1, #0]
    if( A->s * B->s > 0 )
 c00b17c:	6813      	ldr	r3, [r2, #0]
{
 c00b17e:	4605      	mov	r5, r0
    if( A->s * B->s > 0 )
 c00b180:	4363      	muls	r3, r4
 c00b182:	2b00      	cmp	r3, #0
{
 c00b184:	460f      	mov	r7, r1
 c00b186:	4616      	mov	r6, r2
    if( A->s * B->s > 0 )
 c00b188:	dd16      	ble.n	c00b1b8 <mbedtls_mpi_sub_mpi+0x40>
        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
 c00b18a:	4611      	mov	r1, r2
 c00b18c:	4638      	mov	r0, r7
 c00b18e:	f7ff feab 	bl	c00aee8 <mbedtls_mpi_cmp_abs>
 c00b192:	2800      	cmp	r0, #0
 c00b194:	db06      	blt.n	c00b1a4 <mbedtls_mpi_sub_mpi+0x2c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
 c00b196:	4632      	mov	r2, r6
 c00b198:	4639      	mov	r1, r7
 c00b19a:	4628      	mov	r0, r5
 c00b19c:	f7ff ff8c 	bl	c00b0b8 <mbedtls_mpi_sub_abs>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c00b1a0:	b140      	cbz	r0, c00b1b4 <mbedtls_mpi_sub_mpi+0x3c>
}
 c00b1a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
 c00b1a4:	463a      	mov	r2, r7
 c00b1a6:	4631      	mov	r1, r6
 c00b1a8:	4628      	mov	r0, r5
 c00b1aa:	f7ff ff85 	bl	c00b0b8 <mbedtls_mpi_sub_abs>
 c00b1ae:	2800      	cmp	r0, #0
 c00b1b0:	d1f7      	bne.n	c00b1a2 <mbedtls_mpi_sub_mpi+0x2a>
            X->s = -s;
 c00b1b2:	4264      	negs	r4, r4
        X->s = s;
 c00b1b4:	602c      	str	r4, [r5, #0]
    return( ret );
 c00b1b6:	e7f4      	b.n	c00b1a2 <mbedtls_mpi_sub_mpi+0x2a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
 c00b1b8:	f7ff ff1d 	bl	c00aff6 <mbedtls_mpi_add_abs>
 c00b1bc:	e7f0      	b.n	c00b1a0 <mbedtls_mpi_sub_mpi+0x28>

0c00b1be <mbedtls_mpi_sub_int>:
{
 c00b1be:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    p[0] = ( b < 0 ) ? -b : b;
 c00b1c0:	ea82 73e2 	eor.w	r3, r2, r2, asr #31
 c00b1c4:	eba3 73e2 	sub.w	r3, r3, r2, asr #31
    _B.s = ( b < 0 ) ? -1 : 1;
 c00b1c8:	2a00      	cmp	r2, #0
    p[0] = ( b < 0 ) ? -b : b;
 c00b1ca:	9300      	str	r3, [sp, #0]
    _B.s = ( b < 0 ) ? -1 : 1;
 c00b1cc:	bfb4      	ite	lt
 c00b1ce:	f04f 33ff 	movlt.w	r3, #4294967295
 c00b1d2:	2301      	movge	r3, #1
 c00b1d4:	9301      	str	r3, [sp, #4]
    _B.n = 1;
 c00b1d6:	2301      	movs	r3, #1
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 c00b1d8:	aa01      	add	r2, sp, #4
    _B.n = 1;
 c00b1da:	9302      	str	r3, [sp, #8]
    _B.p = p;
 c00b1dc:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
 c00b1e0:	f7ff ffca 	bl	c00b178 <mbedtls_mpi_sub_mpi>
}
 c00b1e4:	b005      	add	sp, #20
 c00b1e6:	f85d fb04 	ldr.w	pc, [sp], #4

0c00b1ea <mbedtls_mpi_mul_mpi>:

/*
 * Baseline multiplication: X = A * B  (HAC 14.12)
 */
int mbedtls_mpi_mul_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
{
 c00b1ea:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    X->n = 0;
 c00b1ee:	2300      	movs	r3, #0
{
 c00b1f0:	4615      	mov	r5, r2
    X->n = 0;
 c00b1f2:	2201      	movs	r2, #1
{
 c00b1f4:	b086      	sub	sp, #24
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( B != NULL );

    mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );

    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c00b1f6:	4288      	cmp	r0, r1
{
 c00b1f8:	4680      	mov	r8, r0
 c00b1fa:	460e      	mov	r6, r1
    X->n = 0;
 c00b1fc:	e9cd 2300 	strd	r2, r3, [sp]
    X->s = 1;
 c00b200:	e9cd 3202 	strd	r3, r2, [sp, #8]
    X->p = NULL;
 c00b204:	e9cd 3304 	strd	r3, r3, [sp, #16]
    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
 c00b208:	d105      	bne.n	c00b216 <mbedtls_mpi_mul_mpi+0x2c>
 c00b20a:	4668      	mov	r0, sp
 c00b20c:	f7ff fce3 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b210:	4604      	mov	r4, r0
 c00b212:	bb50      	cbnz	r0, c00b26a <mbedtls_mpi_mul_mpi+0x80>
 c00b214:	466e      	mov	r6, sp
    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
 c00b216:	45a8      	cmp	r8, r5
 c00b218:	d106      	bne.n	c00b228 <mbedtls_mpi_mul_mpi+0x3e>
 c00b21a:	4641      	mov	r1, r8
 c00b21c:	a803      	add	r0, sp, #12
 c00b21e:	f7ff fcda 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b222:	4604      	mov	r4, r0
 c00b224:	bb08      	cbnz	r0, c00b26a <mbedtls_mpi_mul_mpi+0x80>
 c00b226:	ad03      	add	r5, sp, #12

    for( i = A->n; i > 0; i-- )
 c00b228:	f8d6 9004 	ldr.w	r9, [r6, #4]
 c00b22c:	ea4f 0389 	mov.w	r3, r9, lsl #2
 c00b230:	f1b9 0f00 	cmp.w	r9, #0
 c00b234:	d123      	bne.n	c00b27e <mbedtls_mpi_mul_mpi+0x94>
        if( A->p[i - 1] != 0 )
            break;

    for( j = B->n; j > 0; j-- )
 c00b236:	686f      	ldr	r7, [r5, #4]
 c00b238:	00bb      	lsls	r3, r7, #2
 c00b23a:	bb57      	cbnz	r7, c00b292 <mbedtls_mpi_mul_mpi+0xa8>
        if( B->p[j - 1] != 0 )
            break;

    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
 c00b23c:	eb09 0107 	add.w	r1, r9, r7
 c00b240:	4640      	mov	r0, r8
 c00b242:	f7ff fca2 	bl	c00ab8a <mbedtls_mpi_grow>
 c00b246:	4604      	mov	r4, r0
 c00b248:	b978      	cbnz	r0, c00b26a <mbedtls_mpi_mul_mpi+0x80>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
 c00b24a:	4601      	mov	r1, r0
 c00b24c:	4640      	mov	r0, r8
 c00b24e:	f7ff fcee 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b252:	4604      	mov	r4, r0
 c00b254:	b948      	cbnz	r0, c00b26a <mbedtls_mpi_mul_mpi+0x80>
 c00b256:	ea4f 0a87 	mov.w	sl, r7, lsl #2
 c00b25a:	f1aa 0a04 	sub.w	sl, sl, #4

    for( ; j > 0; j-- )
 c00b25e:	bb0f      	cbnz	r7, c00b2a4 <mbedtls_mpi_mul_mpi+0xba>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );

    X->s = A->s * B->s;
 c00b260:	6832      	ldr	r2, [r6, #0]
 c00b262:	682b      	ldr	r3, [r5, #0]
 c00b264:	4353      	muls	r3, r2
 c00b266:	f8c8 3000 	str.w	r3, [r8]

cleanup:

    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
 c00b26a:	a803      	add	r0, sp, #12
 c00b26c:	f7ff fc7b 	bl	c00ab66 <mbedtls_mpi_free>
 c00b270:	4668      	mov	r0, sp
 c00b272:	f7ff fc78 	bl	c00ab66 <mbedtls_mpi_free>

    return( ret );
}
 c00b276:	4620      	mov	r0, r4
 c00b278:	b006      	add	sp, #24
 c00b27a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if( A->p[i - 1] != 0 )
 c00b27e:	68b2      	ldr	r2, [r6, #8]
 c00b280:	441a      	add	r2, r3
 c00b282:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c00b286:	3b04      	subs	r3, #4
 c00b288:	2a00      	cmp	r2, #0
 c00b28a:	d1d4      	bne.n	c00b236 <mbedtls_mpi_mul_mpi+0x4c>
    for( i = A->n; i > 0; i-- )
 c00b28c:	f109 39ff 	add.w	r9, r9, #4294967295
 c00b290:	e7ce      	b.n	c00b230 <mbedtls_mpi_mul_mpi+0x46>
        if( B->p[j - 1] != 0 )
 c00b292:	68aa      	ldr	r2, [r5, #8]
 c00b294:	441a      	add	r2, r3
 c00b296:	f852 2c04 	ldr.w	r2, [r2, #-4]
 c00b29a:	3b04      	subs	r3, #4
 c00b29c:	2a00      	cmp	r2, #0
 c00b29e:	d1cd      	bne.n	c00b23c <mbedtls_mpi_mul_mpi+0x52>
    for( j = B->n; j > 0; j-- )
 c00b2a0:	3f01      	subs	r7, #1
 c00b2a2:	e7ca      	b.n	c00b23a <mbedtls_mpi_mul_mpi+0x50>
        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
 c00b2a4:	68ab      	ldr	r3, [r5, #8]
 c00b2a6:	f8d8 2008 	ldr.w	r2, [r8, #8]
 c00b2aa:	f853 300a 	ldr.w	r3, [r3, sl]
 c00b2ae:	4452      	add	r2, sl
 c00b2b0:	68b1      	ldr	r1, [r6, #8]
 c00b2b2:	4648      	mov	r0, r9
 c00b2b4:	f7ff fb70 	bl	c00a998 <mpi_mul_hlp>
    for( ; j > 0; j-- )
 c00b2b8:	3f01      	subs	r7, #1
 c00b2ba:	e7ce      	b.n	c00b25a <mbedtls_mpi_mul_mpi+0x70>

0c00b2bc <mbedtls_mpi_mul_int>:

/*
 * Baseline multiplication: X = A * b
 */
int mbedtls_mpi_mul_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b )
{
 c00b2bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    mbedtls_mpi _B;
    mbedtls_mpi_uint p[1];
    MPI_VALIDATE_RET( X != NULL );
    MPI_VALIDATE_RET( A != NULL );

    _B.s = 1;
 c00b2be:	2301      	movs	r3, #1
    _B.n = 1;
    _B.p = p;
    p[0] = b;
 c00b2c0:	9200      	str	r2, [sp, #0]

    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 c00b2c2:	aa01      	add	r2, sp, #4
    _B.n = 1;
 c00b2c4:	e9cd 3301 	strd	r3, r3, [sp, #4]
    _B.p = p;
 c00b2c8:	f8cd d00c 	str.w	sp, [sp, #12]
    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
 c00b2cc:	f7ff ff8d 	bl	c00b1ea <mbedtls_mpi_mul_mpi>
}
 c00b2d0:	b005      	add	sp, #20
 c00b2d2:	f85d fb04 	ldr.w	pc, [sp], #4

0c00b2d6 <mbedtls_mpi_div_mpi>:
/*
 * Division by mbedtls_mpi: A = Q * B + R  (HAC 14.20)
 */
int mbedtls_mpi_div_mpi( mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A,
                         const mbedtls_mpi *B )
{
 c00b2d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00b2da:	b099      	sub	sp, #100	; 0x64
 c00b2dc:	9001      	str	r0, [sp, #4]
 c00b2de:	460f      	mov	r7, r1
    size_t i, n, t, k;
    mbedtls_mpi X, Y, Z, T1, T2;
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( B != NULL );

    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c00b2e0:	4618      	mov	r0, r3
 c00b2e2:	2100      	movs	r1, #0
{
 c00b2e4:	4690      	mov	r8, r2
 c00b2e6:	9303      	str	r3, [sp, #12]
    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
 c00b2e8:	f7ff fe6f 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b2ec:	2800      	cmp	r0, #0
 c00b2ee:	f000 81a5 	beq.w	c00b63c <mbedtls_mpi_div_mpi+0x366>
    X->n = 0;
 c00b2f2:	2400      	movs	r4, #0
 c00b2f4:	2501      	movs	r5, #1
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );

    mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &Z );
    mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 );

    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c00b2f6:	9903      	ldr	r1, [sp, #12]
 c00b2f8:	4640      	mov	r0, r8
    X->n = 0;
 c00b2fa:	e9cd 5409 	strd	r5, r4, [sp, #36]	; 0x24
    X->s = 1;
 c00b2fe:	e9cd 450b 	strd	r4, r5, [sp, #44]	; 0x2c
    X->p = NULL;
 c00b302:	e9cd 440d 	strd	r4, r4, [sp, #52]	; 0x34
    X->n = 0;
 c00b306:	e9cd 540f 	strd	r5, r4, [sp, #60]	; 0x3c
    X->s = 1;
 c00b30a:	e9cd 4511 	strd	r4, r5, [sp, #68]	; 0x44
    X->p = NULL;
 c00b30e:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
    X->n = 0;
 c00b312:	e9cd 5415 	strd	r5, r4, [sp, #84]	; 0x54
    X->p = NULL;
 c00b316:	9417      	str	r4, [sp, #92]	; 0x5c
    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
 c00b318:	f7ff fde6 	bl	c00aee8 <mbedtls_mpi_cmp_abs>
 c00b31c:	42a0      	cmp	r0, r4
 c00b31e:	da26      	bge.n	c00b36e <mbedtls_mpi_div_mpi+0x98>
    {
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c00b320:	9b01      	ldr	r3, [sp, #4]
 c00b322:	b92b      	cbnz	r3, c00b330 <mbedtls_mpi_div_mpi+0x5a>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c00b324:	b9df      	cbnz	r7, c00b35e <mbedtls_mpi_div_mpi+0x88>
        return( 0 );
 c00b326:	2400      	movs	r4, #0

    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );

    return( ret );
}
 c00b328:	4620      	mov	r0, r4
 c00b32a:	b019      	add	sp, #100	; 0x64
 c00b32c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
 c00b330:	4621      	mov	r1, r4
 c00b332:	9801      	ldr	r0, [sp, #4]
 c00b334:	f7ff fc7b 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b338:	4604      	mov	r4, r0
 c00b33a:	2800      	cmp	r0, #0
 c00b33c:	d0f2      	beq.n	c00b324 <mbedtls_mpi_div_mpi+0x4e>
    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
 c00b33e:	a809      	add	r0, sp, #36	; 0x24
 c00b340:	f7ff fc11 	bl	c00ab66 <mbedtls_mpi_free>
 c00b344:	a80c      	add	r0, sp, #48	; 0x30
 c00b346:	f7ff fc0e 	bl	c00ab66 <mbedtls_mpi_free>
 c00b34a:	a80f      	add	r0, sp, #60	; 0x3c
 c00b34c:	f7ff fc0b 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
 c00b350:	a812      	add	r0, sp, #72	; 0x48
 c00b352:	f7ff fc08 	bl	c00ab66 <mbedtls_mpi_free>
 c00b356:	a815      	add	r0, sp, #84	; 0x54
 c00b358:	f7ff fc05 	bl	c00ab66 <mbedtls_mpi_free>
    return( ret );
 c00b35c:	e7e4      	b.n	c00b328 <mbedtls_mpi_div_mpi+0x52>
        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
 c00b35e:	4641      	mov	r1, r8
 c00b360:	4638      	mov	r0, r7
 c00b362:	f7ff fc38 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b366:	4604      	mov	r4, r0
 c00b368:	2800      	cmp	r0, #0
 c00b36a:	d1e8      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
 c00b36c:	e7db      	b.n	c00b326 <mbedtls_mpi_div_mpi+0x50>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
 c00b36e:	4641      	mov	r1, r8
 c00b370:	a809      	add	r0, sp, #36	; 0x24
 c00b372:	f7ff fc30 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b376:	4604      	mov	r4, r0
 c00b378:	2800      	cmp	r0, #0
 c00b37a:	d1e0      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
 c00b37c:	ae0c      	add	r6, sp, #48	; 0x30
 c00b37e:	9903      	ldr	r1, [sp, #12]
 c00b380:	4630      	mov	r0, r6
 c00b382:	f7ff fc28 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b386:	4604      	mov	r4, r0
 c00b388:	2800      	cmp	r0, #0
 c00b38a:	d1d8      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c00b38c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 c00b390:	a80f      	add	r0, sp, #60	; 0x3c
 c00b392:	3102      	adds	r1, #2
    X.s = Y.s = 1;
 c00b394:	950c      	str	r5, [sp, #48]	; 0x30
 c00b396:	9509      	str	r5, [sp, #36]	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
 c00b398:	f7ff fbf7 	bl	c00ab8a <mbedtls_mpi_grow>
 c00b39c:	4604      	mov	r4, r0
 c00b39e:	2800      	cmp	r0, #0
 c00b3a0:	d1cd      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
 c00b3a2:	4601      	mov	r1, r0
 c00b3a4:	a80f      	add	r0, sp, #60	; 0x3c
 c00b3a6:	f7ff fc42 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b3aa:	4604      	mov	r4, r0
 c00b3ac:	2800      	cmp	r0, #0
 c00b3ae:	d1c6      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
 c00b3b0:	2102      	movs	r1, #2
 c00b3b2:	a812      	add	r0, sp, #72	; 0x48
 c00b3b4:	f7ff fbe9 	bl	c00ab8a <mbedtls_mpi_grow>
 c00b3b8:	4604      	mov	r4, r0
 c00b3ba:	2800      	cmp	r0, #0
 c00b3bc:	d1bf      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T2, 3 ) );
 c00b3be:	2103      	movs	r1, #3
 c00b3c0:	a815      	add	r0, sp, #84	; 0x54
 c00b3c2:	f7ff fbe2 	bl	c00ab8a <mbedtls_mpi_grow>
 c00b3c6:	4604      	mov	r4, r0
 c00b3c8:	2800      	cmp	r0, #0
 c00b3ca:	d1b8      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    k = mbedtls_mpi_bitlen( &Y ) % biL;
 c00b3cc:	4630      	mov	r0, r6
 c00b3ce:	f7ff fc75 	bl	c00acbc <mbedtls_mpi_bitlen>
 c00b3d2:	f000 001f 	and.w	r0, r0, #31
    if( k < biL - 1 )
 c00b3d6:	281f      	cmp	r0, #31
 c00b3d8:	d076      	beq.n	c00b4c8 <mbedtls_mpi_div_mpi+0x1f2>
        k = biL - 1 - k;
 c00b3da:	f1c0 031f 	rsb	r3, r0, #31
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c00b3de:	4619      	mov	r1, r3
 c00b3e0:	a809      	add	r0, sp, #36	; 0x24
        k = biL - 1 - k;
 c00b3e2:	9302      	str	r3, [sp, #8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
 c00b3e4:	f7ff fcfd 	bl	c00ade2 <mbedtls_mpi_shift_l>
 c00b3e8:	4604      	mov	r4, r0
 c00b3ea:	2800      	cmp	r0, #0
 c00b3ec:	d1a7      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
 c00b3ee:	9902      	ldr	r1, [sp, #8]
 c00b3f0:	4630      	mov	r0, r6
 c00b3f2:	f7ff fcf6 	bl	c00ade2 <mbedtls_mpi_shift_l>
 c00b3f6:	4604      	mov	r4, r0
 c00b3f8:	2800      	cmp	r0, #0
 c00b3fa:	d1a0      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    n = X.n - 1;
 c00b3fc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    t = Y.n - 1;
 c00b3fe:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    n = X.n - 1;
 c00b402:	f105 39ff 	add.w	r9, r5, #4294967295
    t = Y.n - 1;
 c00b406:	f10a 33ff 	add.w	r3, sl, #4294967295
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 c00b40a:	eba9 0b03 	sub.w	fp, r9, r3
    t = Y.n - 1;
 c00b40e:	9300      	str	r3, [sp, #0]
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
 c00b410:	ea4f 134b 	mov.w	r3, fp, lsl #5
 c00b414:	4619      	mov	r1, r3
 c00b416:	4630      	mov	r0, r6
 c00b418:	9304      	str	r3, [sp, #16]
 c00b41a:	f7ff fce2 	bl	c00ade2 <mbedtls_mpi_shift_l>
 c00b41e:	4604      	mov	r4, r0
 c00b420:	2800      	cmp	r0, #0
 c00b422:	d18c      	bne.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
        Z.p[n - t]++;
 c00b424:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
 c00b428:	4631      	mov	r1, r6
 c00b42a:	a809      	add	r0, sp, #36	; 0x24
 c00b42c:	f7ff fd8d 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c00b430:	2800      	cmp	r0, #0
 c00b432:	da4b      	bge.n	c00b4cc <mbedtls_mpi_div_mpi+0x1f6>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
 c00b434:	9904      	ldr	r1, [sp, #16]
 c00b436:	4630      	mov	r0, r6
 c00b438:	f7ff fd1b 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b43c:	4604      	mov	r4, r0
 c00b43e:	2800      	cmp	r0, #0
 c00b440:	f47f af7d 	bne.w	c00b33e <mbedtls_mpi_div_mpi+0x68>
        if( X.p[i] >= Y.p[t] )
 c00b444:	9b00      	ldr	r3, [sp, #0]
 c00b446:	f105 4580 	add.w	r5, r5, #1073741824	; 0x40000000
 c00b44a:	009b      	lsls	r3, r3, #2
 c00b44c:	9304      	str	r3, [sp, #16]
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c00b44e:	f10a 4380 	add.w	r3, sl, #1073741824	; 0x40000000
 c00b452:	3b02      	subs	r3, #2
 c00b454:	009b      	lsls	r3, r3, #2
 c00b456:	9307      	str	r3, [sp, #28]
 c00b458:	f06f 0303 	mvn.w	r3, #3
 c00b45c:	fb03 f30a 	mul.w	r3, r3, sl
 c00b460:	3d01      	subs	r5, #1
 c00b462:	9306      	str	r3, [sp, #24]
 c00b464:	ebca 63ca 	rsb	r3, sl, sl, lsl #27
 c00b468:	00ad      	lsls	r5, r5, #2
 c00b46a:	9305      	str	r3, [sp, #20]
    for( i = n; i > t ; i-- )
 c00b46c:	9b00      	ldr	r3, [sp, #0]
 c00b46e:	4599      	cmp	r9, r3
 c00b470:	d83b      	bhi.n	c00b4ea <mbedtls_mpi_div_mpi+0x214>
    if( Q != NULL )
 c00b472:	9b01      	ldr	r3, [sp, #4]
 c00b474:	b15b      	cbz	r3, c00b48e <mbedtls_mpi_div_mpi+0x1b8>
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
 c00b476:	a90f      	add	r1, sp, #60	; 0x3c
 c00b478:	4618      	mov	r0, r3
 c00b47a:	f7ff fbac 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b47e:	bb08      	cbnz	r0, c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
        Q->s = A->s * B->s;
 c00b480:	9b03      	ldr	r3, [sp, #12]
 c00b482:	f8d8 2000 	ldr.w	r2, [r8]
 c00b486:	681b      	ldr	r3, [r3, #0]
 c00b488:	4353      	muls	r3, r2
 c00b48a:	9a01      	ldr	r2, [sp, #4]
 c00b48c:	6013      	str	r3, [r2, #0]
    if( R != NULL )
 c00b48e:	2f00      	cmp	r7, #0
 c00b490:	f43f af55 	beq.w	c00b33e <mbedtls_mpi_div_mpi+0x68>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
 c00b494:	9902      	ldr	r1, [sp, #8]
 c00b496:	a809      	add	r0, sp, #36	; 0x24
 c00b498:	f7ff fceb 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b49c:	b990      	cbnz	r0, c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
        X.s = A->s;
 c00b49e:	f8d8 3000 	ldr.w	r3, [r8]
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c00b4a2:	a909      	add	r1, sp, #36	; 0x24
 c00b4a4:	4638      	mov	r0, r7
        X.s = A->s;
 c00b4a6:	9309      	str	r3, [sp, #36]	; 0x24
        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
 c00b4a8:	f7ff fb95 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b4ac:	4601      	mov	r1, r0
 c00b4ae:	2800      	cmp	r0, #0
 c00b4b0:	f040 80c2 	bne.w	c00b638 <mbedtls_mpi_div_mpi+0x362>
        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
 c00b4b4:	4638      	mov	r0, r7
 c00b4b6:	f7ff fd88 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b4ba:	2800      	cmp	r0, #0
 c00b4bc:	f47f af3f 	bne.w	c00b33e <mbedtls_mpi_div_mpi+0x68>
            R->s = 1;
 c00b4c0:	2301      	movs	r3, #1
 c00b4c2:	603b      	str	r3, [r7, #0]
cleanup:
 c00b4c4:	4604      	mov	r4, r0
 c00b4c6:	e73a      	b.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
    else k = 0;
 c00b4c8:	9402      	str	r4, [sp, #8]
 c00b4ca:	e797      	b.n	c00b3fc <mbedtls_mpi_div_mpi+0x126>
        Z.p[n - t]++;
 c00b4cc:	9911      	ldr	r1, [sp, #68]	; 0x44
 c00b4ce:	f851 200b 	ldr.w	r2, [r1, fp]
 c00b4d2:	3201      	adds	r2, #1
 c00b4d4:	f841 200b 	str.w	r2, [r1, fp]
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
 c00b4d8:	a909      	add	r1, sp, #36	; 0x24
 c00b4da:	4632      	mov	r2, r6
 c00b4dc:	4608      	mov	r0, r1
 c00b4de:	f7ff fe4b 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b4e2:	4604      	mov	r4, r0
 c00b4e4:	2800      	cmp	r0, #0
 c00b4e6:	d09f      	beq.n	c00b428 <mbedtls_mpi_div_mpi+0x152>
cleanup:
 c00b4e8:	e729      	b.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
        if( X.p[i] >= Y.p[t] )
 c00b4ea:	9804      	ldr	r0, [sp, #16]
 c00b4ec:	990b      	ldr	r1, [sp, #44]	; 0x2c
 c00b4ee:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 c00b4f0:	594b      	ldr	r3, [r1, r5]
 c00b4f2:	5812      	ldr	r2, [r2, r0]
 c00b4f4:	9806      	ldr	r0, [sp, #24]
 c00b4f6:	4293      	cmp	r3, r2
 c00b4f8:	eb00 0605 	add.w	r6, r0, r5
 c00b4fc:	f1a5 0b04 	sub.w	fp, r5, #4
 c00b500:	f8dd a044 	ldr.w	sl, [sp, #68]	; 0x44
 c00b504:	d37e      	bcc.n	c00b604 <mbedtls_mpi_div_mpi+0x32e>
            Z.p[i - t - 1] = ~0;
 c00b506:	f04f 33ff 	mov.w	r3, #4294967295
 c00b50a:	f84a 3006 	str.w	r3, [sl, r6]
        Z.p[i - t - 1]++;
 c00b50e:	f85a 3006 	ldr.w	r3, [sl, r6]
 c00b512:	3301      	adds	r3, #1
 c00b514:	f84a 3006 	str.w	r3, [sl, r6]
 c00b518:	f1a5 0a08 	sub.w	sl, r5, #8
            Z.p[i - t - 1]--;
 c00b51c:	9a11      	ldr	r2, [sp, #68]	; 0x44
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c00b51e:	2100      	movs	r1, #0
            Z.p[i - t - 1]--;
 c00b520:	5993      	ldr	r3, [r2, r6]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c00b522:	a812      	add	r0, sp, #72	; 0x48
            Z.p[i - t - 1]--;
 c00b524:	3b01      	subs	r3, #1
 c00b526:	5193      	str	r3, [r2, r6]
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
 c00b528:	f7ff fb81 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b52c:	2800      	cmp	r0, #0
 c00b52e:	d1c9      	bne.n	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c00b530:	9b00      	ldr	r3, [sp, #0]
 c00b532:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 c00b534:	2b00      	cmp	r3, #0
 c00b536:	d07d      	beq.n	c00b634 <mbedtls_mpi_div_mpi+0x35e>
 c00b538:	9b07      	ldr	r3, [sp, #28]
 c00b53a:	58d1      	ldr	r1, [r2, r3]
 c00b53c:	9b14      	ldr	r3, [sp, #80]	; 0x50
 c00b53e:	6019      	str	r1, [r3, #0]
            T1.p[1] = Y.p[t];
 c00b540:	9904      	ldr	r1, [sp, #16]
 c00b542:	5852      	ldr	r2, [r2, r1]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c00b544:	a912      	add	r1, sp, #72	; 0x48
            T1.p[1] = Y.p[t];
 c00b546:	605a      	str	r2, [r3, #4]
            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
 c00b548:	9b11      	ldr	r3, [sp, #68]	; 0x44
 c00b54a:	4608      	mov	r0, r1
 c00b54c:	599a      	ldr	r2, [r3, r6]
 c00b54e:	f7ff feb5 	bl	c00b2bc <mbedtls_mpi_mul_int>
 c00b552:	4601      	mov	r1, r0
 c00b554:	2800      	cmp	r0, #0
 c00b556:	d16f      	bne.n	c00b638 <mbedtls_mpi_div_mpi+0x362>
            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T2, 0 ) );
 c00b558:	a815      	add	r0, sp, #84	; 0x54
 c00b55a:	f7ff fb68 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b55e:	2800      	cmp	r0, #0
 c00b560:	d1b0      	bne.n	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
 c00b562:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
 c00b564:	f1b9 0f01 	cmp.w	r9, #1
 c00b568:	bf18      	it	ne
 c00b56a:	f852 000a 	ldrne.w	r0, [r2, sl]
 c00b56e:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 c00b570:	6018      	str	r0, [r3, #0]
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c00b572:	f852 100b 	ldr.w	r1, [r2, fp]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c00b576:	a812      	add	r0, sp, #72	; 0x48
            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
 c00b578:	6059      	str	r1, [r3, #4]
            T2.p[2] = X.p[i];
 c00b57a:	5952      	ldr	r2, [r2, r5]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c00b57c:	a915      	add	r1, sp, #84	; 0x54
            T2.p[2] = X.p[i];
 c00b57e:	609a      	str	r2, [r3, #8]
        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
 c00b580:	f7ff fce3 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c00b584:	2800      	cmp	r0, #0
 c00b586:	dcc9      	bgt.n	c00b51c <mbedtls_mpi_div_mpi+0x246>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
 c00b588:	9b11      	ldr	r3, [sp, #68]	; 0x44
 c00b58a:	a90c      	add	r1, sp, #48	; 0x30
 c00b58c:	599a      	ldr	r2, [r3, r6]
 c00b58e:	a812      	add	r0, sp, #72	; 0x48
 c00b590:	f7ff fe94 	bl	c00b2bc <mbedtls_mpi_mul_int>
 c00b594:	2800      	cmp	r0, #0
 c00b596:	d195      	bne.n	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
 c00b598:	9b05      	ldr	r3, [sp, #20]
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
 c00b59a:	a812      	add	r0, sp, #72	; 0x48
 c00b59c:	eb03 0a09 	add.w	sl, r3, r9
 c00b5a0:	ea4f 1a4a 	mov.w	sl, sl, lsl #5
 c00b5a4:	4651      	mov	r1, sl
 c00b5a6:	f7ff fc1c 	bl	c00ade2 <mbedtls_mpi_shift_l>
 c00b5aa:	2800      	cmp	r0, #0
 c00b5ac:	d18a      	bne.n	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
 c00b5ae:	a909      	add	r1, sp, #36	; 0x24
 c00b5b0:	4608      	mov	r0, r1
 c00b5b2:	aa12      	add	r2, sp, #72	; 0x48
 c00b5b4:	f7ff fde0 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b5b8:	4601      	mov	r1, r0
 c00b5ba:	2800      	cmp	r0, #0
 c00b5bc:	d13c      	bne.n	c00b638 <mbedtls_mpi_div_mpi+0x362>
        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
 c00b5be:	a809      	add	r0, sp, #36	; 0x24
 c00b5c0:	f7ff fd03 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b5c4:	2800      	cmp	r0, #0
 c00b5c6:	da19      	bge.n	c00b5fc <mbedtls_mpi_div_mpi+0x326>
            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
 c00b5c8:	a90c      	add	r1, sp, #48	; 0x30
 c00b5ca:	a812      	add	r0, sp, #72	; 0x48
 c00b5cc:	f7ff fb03 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b5d0:	2800      	cmp	r0, #0
 c00b5d2:	f47f af77 	bne.w	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
 c00b5d6:	4651      	mov	r1, sl
 c00b5d8:	a812      	add	r0, sp, #72	; 0x48
 c00b5da:	f7ff fc02 	bl	c00ade2 <mbedtls_mpi_shift_l>
 c00b5de:	2800      	cmp	r0, #0
 c00b5e0:	f47f af70 	bne.w	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
 c00b5e4:	a909      	add	r1, sp, #36	; 0x24
 c00b5e6:	aa12      	add	r2, sp, #72	; 0x48
 c00b5e8:	4608      	mov	r0, r1
 c00b5ea:	f7ff fda3 	bl	c00b134 <mbedtls_mpi_add_mpi>
 c00b5ee:	2800      	cmp	r0, #0
 c00b5f0:	f47f af68 	bne.w	c00b4c4 <mbedtls_mpi_div_mpi+0x1ee>
            Z.p[i - t - 1]--;
 c00b5f4:	9a11      	ldr	r2, [sp, #68]	; 0x44
 c00b5f6:	5993      	ldr	r3, [r2, r6]
 c00b5f8:	3b01      	subs	r3, #1
 c00b5fa:	5193      	str	r3, [r2, r6]
    for( i = n; i > t ; i-- )
 c00b5fc:	f109 39ff 	add.w	r9, r9, #4294967295
 c00b600:	3d04      	subs	r5, #4
 c00b602:	e733      	b.n	c00b46c <mbedtls_mpi_div_mpi+0x196>
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c00b604:	f851 c00b 	ldr.w	ip, [r1, fp]
    if( 0 == d || u1 >= d )
 c00b608:	b18a      	cbz	r2, c00b62e <mbedtls_mpi_div_mpi+0x358>
    dividend  = (mbedtls_t_udbl) u1 << biL;
 c00b60a:	4619      	mov	r1, r3
 c00b60c:	2300      	movs	r3, #0
 c00b60e:	4618      	mov	r0, r3
    quotient = dividend / d;
 c00b610:	ea40 000c 	orr.w	r0, r0, ip
 c00b614:	f003 fe82 	bl	c00f31c <__aeabi_uldivmod>
    return (mbedtls_mpi_uint) quotient;
 c00b618:	2300      	movs	r3, #0
 c00b61a:	f04f 32ff 	mov.w	r2, #4294967295
 c00b61e:	428b      	cmp	r3, r1
 c00b620:	bf08      	it	eq
 c00b622:	4282      	cmpeq	r2, r0
 c00b624:	d200      	bcs.n	c00b628 <mbedtls_mpi_div_mpi+0x352>
 c00b626:	4610      	mov	r0, r2
            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
 c00b628:	f84a 0006 	str.w	r0, [sl, r6]
 c00b62c:	e76f      	b.n	c00b50e <mbedtls_mpi_div_mpi+0x238>
        return ( ~0 );
 c00b62e:	f04f 30ff 	mov.w	r0, #4294967295
 c00b632:	e7f9      	b.n	c00b628 <mbedtls_mpi_div_mpi+0x352>
            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
 c00b634:	9900      	ldr	r1, [sp, #0]
 c00b636:	e781      	b.n	c00b53c <mbedtls_mpi_div_mpi+0x266>
cleanup:
 c00b638:	460c      	mov	r4, r1
 c00b63a:	e680      	b.n	c00b33e <mbedtls_mpi_div_mpi+0x68>
        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
 c00b63c:	f06f 040b 	mvn.w	r4, #11
 c00b640:	e672      	b.n	c00b328 <mbedtls_mpi_div_mpi+0x52>

0c00b642 <mbedtls_mpi_mod_mpi>:

/*
 * Modulo: R = A mod B
 */
int mbedtls_mpi_mod_mpi( mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )
{
 c00b642:	b570      	push	{r4, r5, r6, lr}
 c00b644:	4604      	mov	r4, r0
 c00b646:	460d      	mov	r5, r1
    int ret;
    MPI_VALIDATE_RET( R != NULL );
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( B != NULL );

    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c00b648:	4610      	mov	r0, r2
 c00b64a:	2100      	movs	r1, #0
{
 c00b64c:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
 c00b64e:	f7ff fcbc 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b652:	2800      	cmp	r0, #0
 c00b654:	db24      	blt.n	c00b6a0 <mbedtls_mpi_mod_mpi+0x5e>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );

    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
 c00b656:	462a      	mov	r2, r5
 c00b658:	4633      	mov	r3, r6
 c00b65a:	4621      	mov	r1, r4
 c00b65c:	2000      	movs	r0, #0
 c00b65e:	f7ff fe3a 	bl	c00b2d6 <mbedtls_mpi_div_mpi>
 c00b662:	4605      	mov	r5, r0
 c00b664:	b138      	cbz	r0, c00b676 <mbedtls_mpi_mod_mpi+0x34>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );

cleanup:

    return( ret );
}
 c00b666:	4628      	mov	r0, r5
 c00b668:	bd70      	pop	{r4, r5, r6, pc}
      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
 c00b66a:	4632      	mov	r2, r6
 c00b66c:	4621      	mov	r1, r4
 c00b66e:	4620      	mov	r0, r4
 c00b670:	f7ff fd60 	bl	c00b134 <mbedtls_mpi_add_mpi>
 c00b674:	b990      	cbnz	r0, c00b69c <mbedtls_mpi_mod_mpi+0x5a>
    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
 c00b676:	2100      	movs	r1, #0
 c00b678:	4620      	mov	r0, r4
 c00b67a:	f7ff fca6 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b67e:	2800      	cmp	r0, #0
 c00b680:	dbf3      	blt.n	c00b66a <mbedtls_mpi_mod_mpi+0x28>
    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
 c00b682:	4631      	mov	r1, r6
 c00b684:	4620      	mov	r0, r4
 c00b686:	f7ff fc60 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c00b68a:	2800      	cmp	r0, #0
 c00b68c:	dbeb      	blt.n	c00b666 <mbedtls_mpi_mod_mpi+0x24>
      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
 c00b68e:	4632      	mov	r2, r6
 c00b690:	4621      	mov	r1, r4
 c00b692:	4620      	mov	r0, r4
 c00b694:	f7ff fd70 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b698:	2800      	cmp	r0, #0
 c00b69a:	d0f2      	beq.n	c00b682 <mbedtls_mpi_mod_mpi+0x40>
 c00b69c:	4605      	mov	r5, r0
 c00b69e:	e7e2      	b.n	c00b666 <mbedtls_mpi_mod_mpi+0x24>
        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
 c00b6a0:	f06f 0509 	mvn.w	r5, #9
 c00b6a4:	e7df      	b.n	c00b666 <mbedtls_mpi_mod_mpi+0x24>

0c00b6a6 <mbedtls_mpi_gcd>:

/*
 * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
 */
int mbedtls_mpi_gcd( mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B )
{
 c00b6a6:	b5f0      	push	{r4, r5, r6, r7, lr}
    X->n = 0;
 c00b6a8:	2300      	movs	r3, #0
 c00b6aa:	2601      	movs	r6, #1
{
 c00b6ac:	b08b      	sub	sp, #44	; 0x2c
 c00b6ae:	4607      	mov	r7, r0
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( B != NULL );

    mbedtls_mpi_init( &TG ); mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );

    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 c00b6b0:	a804      	add	r0, sp, #16
{
 c00b6b2:	4615      	mov	r5, r2
    X->n = 0;
 c00b6b4:	e9cd 6301 	strd	r6, r3, [sp, #4]
    X->s = 1;
 c00b6b8:	e9cd 3603 	strd	r3, r6, [sp, #12]
    X->p = NULL;
 c00b6bc:	e9cd 3305 	strd	r3, r3, [sp, #20]
    X->n = 0;
 c00b6c0:	e9cd 6307 	strd	r6, r3, [sp, #28]
    X->p = NULL;
 c00b6c4:	9309      	str	r3, [sp, #36]	; 0x24
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
 c00b6c6:	f7ff fa86 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b6ca:	4604      	mov	r4, r0
 c00b6cc:	2800      	cmp	r0, #0
 c00b6ce:	d157      	bne.n	c00b780 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
 c00b6d0:	4629      	mov	r1, r5
 c00b6d2:	a807      	add	r0, sp, #28
 c00b6d4:	f7ff fa7f 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b6d8:	4604      	mov	r4, r0
 c00b6da:	2800      	cmp	r0, #0
 c00b6dc:	d150      	bne.n	c00b780 <mbedtls_mpi_gcd+0xda>

    lz = mbedtls_mpi_lsb( &TA );
 c00b6de:	a804      	add	r0, sp, #16
 c00b6e0:	f7ff fad1 	bl	c00ac86 <mbedtls_mpi_lsb>
 c00b6e4:	4605      	mov	r5, r0
    lzt = mbedtls_mpi_lsb( &TB );
 c00b6e6:	a807      	add	r0, sp, #28
 c00b6e8:	f7ff facd 	bl	c00ac86 <mbedtls_mpi_lsb>
 c00b6ec:	4285      	cmp	r5, r0
 c00b6ee:	bf28      	it	cs
 c00b6f0:	4605      	movcs	r5, r0

    if( lzt < lz )
        lz = lzt;

    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, lz ) );
 c00b6f2:	a804      	add	r0, sp, #16
 c00b6f4:	4629      	mov	r1, r5
 c00b6f6:	f7ff fbbc 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b6fa:	4604      	mov	r4, r0
 c00b6fc:	2800      	cmp	r0, #0
 c00b6fe:	d13f      	bne.n	c00b780 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, lz ) );
 c00b700:	4629      	mov	r1, r5
 c00b702:	a807      	add	r0, sp, #28
 c00b704:	f7ff fbb5 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b708:	4604      	mov	r4, r0
 c00b70a:	2800      	cmp	r0, #0
 c00b70c:	d138      	bne.n	c00b780 <mbedtls_mpi_gcd+0xda>

    TA.s = TB.s = 1;
 c00b70e:	9607      	str	r6, [sp, #28]
 c00b710:	9604      	str	r6, [sp, #16]

    while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
 c00b712:	2100      	movs	r1, #0
 c00b714:	a804      	add	r0, sp, #16
 c00b716:	f7ff fc58 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b71a:	b958      	cbnz	r0, c00b734 <mbedtls_mpi_gcd+0x8e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
        }
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
 c00b71c:	4629      	mov	r1, r5
 c00b71e:	a807      	add	r0, sp, #28
 c00b720:	f7ff fb5f 	bl	c00ade2 <mbedtls_mpi_shift_l>
 c00b724:	4604      	mov	r4, r0
 c00b726:	bb58      	cbnz	r0, c00b780 <mbedtls_mpi_gcd+0xda>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
 c00b728:	a907      	add	r1, sp, #28
 c00b72a:	4638      	mov	r0, r7
 c00b72c:	f7ff fa53 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b730:	4604      	mov	r4, r0

cleanup:
 c00b732:	e025      	b.n	c00b780 <mbedtls_mpi_gcd+0xda>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
 c00b734:	a804      	add	r0, sp, #16
 c00b736:	f7ff faa6 	bl	c00ac86 <mbedtls_mpi_lsb>
 c00b73a:	4601      	mov	r1, r0
 c00b73c:	a804      	add	r0, sp, #16
 c00b73e:	f7ff fb98 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b742:	4604      	mov	r4, r0
 c00b744:	b9e0      	cbnz	r0, c00b780 <mbedtls_mpi_gcd+0xda>
        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
 c00b746:	a807      	add	r0, sp, #28
 c00b748:	f7ff fa9d 	bl	c00ac86 <mbedtls_mpi_lsb>
 c00b74c:	4601      	mov	r1, r0
 c00b74e:	a807      	add	r0, sp, #28
 c00b750:	f7ff fb8f 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b754:	4604      	mov	r4, r0
 c00b756:	b998      	cbnz	r0, c00b780 <mbedtls_mpi_gcd+0xda>
        if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
 c00b758:	a907      	add	r1, sp, #28
 c00b75a:	a804      	add	r0, sp, #16
 c00b75c:	f7ff fbf5 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c00b760:	2800      	cmp	r0, #0
 c00b762:	db19      	blt.n	c00b798 <mbedtls_mpi_gcd+0xf2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
 c00b764:	a904      	add	r1, sp, #16
 c00b766:	aa07      	add	r2, sp, #28
 c00b768:	4608      	mov	r0, r1
 c00b76a:	f7ff fca5 	bl	c00b0b8 <mbedtls_mpi_sub_abs>
 c00b76e:	4604      	mov	r4, r0
 c00b770:	b930      	cbnz	r0, c00b780 <mbedtls_mpi_gcd+0xda>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
 c00b772:	2101      	movs	r1, #1
 c00b774:	a804      	add	r0, sp, #16
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 c00b776:	f7ff fb7c 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b77a:	4604      	mov	r4, r0
 c00b77c:	2800      	cmp	r0, #0
 c00b77e:	d0c8      	beq.n	c00b712 <mbedtls_mpi_gcd+0x6c>

    mbedtls_mpi_free( &TG ); mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
 c00b780:	a801      	add	r0, sp, #4
 c00b782:	f7ff f9f0 	bl	c00ab66 <mbedtls_mpi_free>
 c00b786:	a804      	add	r0, sp, #16
 c00b788:	f7ff f9ed 	bl	c00ab66 <mbedtls_mpi_free>
 c00b78c:	a807      	add	r0, sp, #28
 c00b78e:	f7ff f9ea 	bl	c00ab66 <mbedtls_mpi_free>

    return( ret );
}
 c00b792:	4620      	mov	r0, r4
 c00b794:	b00b      	add	sp, #44	; 0x2c
 c00b796:	bdf0      	pop	{r4, r5, r6, r7, pc}
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
 c00b798:	a907      	add	r1, sp, #28
 c00b79a:	aa04      	add	r2, sp, #16
 c00b79c:	4608      	mov	r0, r1
 c00b79e:	f7ff fc8b 	bl	c00b0b8 <mbedtls_mpi_sub_abs>
 c00b7a2:	4604      	mov	r4, r0
 c00b7a4:	2800      	cmp	r0, #0
 c00b7a6:	d1eb      	bne.n	c00b780 <mbedtls_mpi_gcd+0xda>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
 c00b7a8:	2101      	movs	r1, #1
 c00b7aa:	a807      	add	r0, sp, #28
 c00b7ac:	e7e3      	b.n	c00b776 <mbedtls_mpi_gcd+0xd0>

0c00b7ae <mbedtls_mpi_inv_mod>:

/*
 * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
 */
int mbedtls_mpi_inv_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N )
{
 c00b7ae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00b7b2:	4680      	mov	r8, r0
 c00b7b4:	b09c      	sub	sp, #112	; 0x70
 c00b7b6:	460f      	mov	r7, r1
    mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
    MPI_VALIDATE_RET( X != NULL );
    MPI_VALIDATE_RET( A != NULL );
    MPI_VALIDATE_RET( N != NULL );

    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 c00b7b8:	4610      	mov	r0, r2
 c00b7ba:	2101      	movs	r1, #1
{
 c00b7bc:	4616      	mov	r6, r2
    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
 c00b7be:	f7ff fc04 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b7c2:	2800      	cmp	r0, #0
 c00b7c4:	f340 8143 	ble.w	c00ba4e <mbedtls_mpi_inv_mod+0x2a0>
    X->n = 0;
 c00b7c8:	2300      	movs	r3, #0
 c00b7ca:	2501      	movs	r5, #1

    mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TU ); mbedtls_mpi_init( &U1 ); mbedtls_mpi_init( &U2 );
    mbedtls_mpi_init( &G ); mbedtls_mpi_init( &TB ); mbedtls_mpi_init( &TV );
    mbedtls_mpi_init( &V1 ); mbedtls_mpi_init( &V2 );

    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 c00b7cc:	4632      	mov	r2, r6
 c00b7ce:	4639      	mov	r1, r7
 c00b7d0:	a801      	add	r0, sp, #4
    X->n = 0;
 c00b7d2:	e9cd 5304 	strd	r5, r3, [sp, #16]
    X->s = 1;
 c00b7d6:	e9cd 3506 	strd	r3, r5, [sp, #24]
    X->p = NULL;
 c00b7da:	e9cd 3308 	strd	r3, r3, [sp, #32]
    X->n = 0;
 c00b7de:	e9cd 530a 	strd	r5, r3, [sp, #40]	; 0x28
    X->s = 1;
 c00b7e2:	e9cd 350c 	strd	r3, r5, [sp, #48]	; 0x30
    X->p = NULL;
 c00b7e6:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
    X->n = 0;
 c00b7ea:	e9cd 5301 	strd	r5, r3, [sp, #4]
    X->p = NULL;
 c00b7ee:	9303      	str	r3, [sp, #12]
    X->n = 0;
 c00b7f0:	e9cd 5310 	strd	r5, r3, [sp, #64]	; 0x40
    X->s = 1;
 c00b7f4:	e9cd 3512 	strd	r3, r5, [sp, #72]	; 0x48
    X->p = NULL;
 c00b7f8:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
    X->n = 0;
 c00b7fc:	e9cd 5316 	strd	r5, r3, [sp, #88]	; 0x58
    X->s = 1;
 c00b800:	e9cd 3518 	strd	r3, r5, [sp, #96]	; 0x60
    X->p = NULL;
 c00b804:	e9cd 331a 	strd	r3, r3, [sp, #104]	; 0x68
    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
 c00b808:	f7ff ff4d 	bl	c00b6a6 <mbedtls_mpi_gcd>
 c00b80c:	4604      	mov	r4, r0
 c00b80e:	2800      	cmp	r0, #0
 c00b810:	d154      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>

    if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
 c00b812:	4629      	mov	r1, r5
 c00b814:	a801      	add	r0, sp, #4
 c00b816:	f7ff fbd8 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b81a:	2800      	cmp	r0, #0
 c00b81c:	f040 8114 	bne.w	c00ba48 <mbedtls_mpi_inv_mod+0x29a>
    {
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
        goto cleanup;
    }

    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
 c00b820:	4632      	mov	r2, r6
 c00b822:	4639      	mov	r1, r7
 c00b824:	a804      	add	r0, sp, #16
 c00b826:	f7ff ff0c 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00b82a:	4604      	mov	r4, r0
 c00b82c:	2800      	cmp	r0, #0
 c00b82e:	d145      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
 c00b830:	a904      	add	r1, sp, #16
 c00b832:	a807      	add	r0, sp, #28
 c00b834:	f7ff f9cf 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b838:	4604      	mov	r4, r0
 c00b83a:	2800      	cmp	r0, #0
 c00b83c:	d13e      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
 c00b83e:	4631      	mov	r1, r6
 c00b840:	a810      	add	r0, sp, #64	; 0x40
 c00b842:	f7ff f9c8 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b846:	4604      	mov	r4, r0
 c00b848:	2800      	cmp	r0, #0
 c00b84a:	d137      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
 c00b84c:	4631      	mov	r1, r6
 c00b84e:	a813      	add	r0, sp, #76	; 0x4c
 c00b850:	f7ff f9c1 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b854:	4604      	mov	r4, r0
 c00b856:	2800      	cmp	r0, #0
 c00b858:	d130      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>

    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
 c00b85a:	4629      	mov	r1, r5
 c00b85c:	a80a      	add	r0, sp, #40	; 0x28
 c00b85e:	f7ff f9e6 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b862:	4604      	mov	r4, r0
 c00b864:	bb50      	cbnz	r0, c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
 c00b866:	4601      	mov	r1, r0
 c00b868:	a80d      	add	r0, sp, #52	; 0x34
 c00b86a:	f7ff f9e0 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b86e:	4604      	mov	r4, r0
 c00b870:	bb20      	cbnz	r0, c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
 c00b872:	4601      	mov	r1, r0
 c00b874:	a816      	add	r0, sp, #88	; 0x58
 c00b876:	f7ff f9da 	bl	c00ac2e <mbedtls_mpi_lset>
 c00b87a:	4604      	mov	r4, r0
 c00b87c:	b9f0      	cbnz	r0, c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
 c00b87e:	4629      	mov	r1, r5
 c00b880:	a819      	add	r0, sp, #100	; 0x64
 c00b882:	f7ff f9d4 	bl	c00ac2e <mbedtls_mpi_lset>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
            }

            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 c00b886:	4604      	mov	r4, r0
 c00b888:	b9c0      	cbnz	r0, c00b8bc <mbedtls_mpi_inv_mod+0x10e>
        while( ( TU.p[0] & 1 ) == 0 )
 c00b88a:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00b88c:	681b      	ldr	r3, [r3, #0]
 c00b88e:	07d8      	lsls	r0, r3, #31
 c00b890:	d466      	bmi.n	c00b960 <mbedtls_mpi_inv_mod+0x1b2>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
 c00b892:	2101      	movs	r1, #1
 c00b894:	a807      	add	r0, sp, #28
 c00b896:	f7ff faec 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b89a:	4604      	mov	r4, r0
 c00b89c:	b970      	cbnz	r0, c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
 c00b89e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 c00b8a0:	681b      	ldr	r3, [r3, #0]
 c00b8a2:	07dd      	lsls	r5, r3, #31
 c00b8a4:	d429      	bmi.n	c00b8fa <mbedtls_mpi_inv_mod+0x14c>
 c00b8a6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 c00b8a8:	681b      	ldr	r3, [r3, #0]
 c00b8aa:	07dc      	lsls	r4, r3, #31
 c00b8ac:	d425      	bmi.n	c00b8fa <mbedtls_mpi_inv_mod+0x14c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
 c00b8ae:	2101      	movs	r1, #1
 c00b8b0:	a80a      	add	r0, sp, #40	; 0x28
 c00b8b2:	f7ff fade 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b8b6:	4604      	mov	r4, r0
 c00b8b8:	2800      	cmp	r0, #0
 c00b8ba:	d02f      	beq.n	c00b91c <mbedtls_mpi_inv_mod+0x16e>

    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );

cleanup:

    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
 c00b8bc:	a804      	add	r0, sp, #16
 c00b8be:	f7ff f952 	bl	c00ab66 <mbedtls_mpi_free>
 c00b8c2:	a807      	add	r0, sp, #28
 c00b8c4:	f7ff f94f 	bl	c00ab66 <mbedtls_mpi_free>
 c00b8c8:	a80a      	add	r0, sp, #40	; 0x28
 c00b8ca:	f7ff f94c 	bl	c00ab66 <mbedtls_mpi_free>
 c00b8ce:	a80d      	add	r0, sp, #52	; 0x34
 c00b8d0:	f7ff f949 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
 c00b8d4:	a801      	add	r0, sp, #4
 c00b8d6:	f7ff f946 	bl	c00ab66 <mbedtls_mpi_free>
 c00b8da:	a810      	add	r0, sp, #64	; 0x40
 c00b8dc:	f7ff f943 	bl	c00ab66 <mbedtls_mpi_free>
 c00b8e0:	a813      	add	r0, sp, #76	; 0x4c
 c00b8e2:	f7ff f940 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
 c00b8e6:	a816      	add	r0, sp, #88	; 0x58
 c00b8e8:	f7ff f93d 	bl	c00ab66 <mbedtls_mpi_free>
 c00b8ec:	a819      	add	r0, sp, #100	; 0x64
 c00b8ee:	f7ff f93a 	bl	c00ab66 <mbedtls_mpi_free>

    return( ret );
}
 c00b8f2:	4620      	mov	r0, r4
 c00b8f4:	b01c      	add	sp, #112	; 0x70
 c00b8f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
 c00b8fa:	a90a      	add	r1, sp, #40	; 0x28
 c00b8fc:	aa10      	add	r2, sp, #64	; 0x40
 c00b8fe:	4608      	mov	r0, r1
 c00b900:	f7ff fc18 	bl	c00b134 <mbedtls_mpi_add_mpi>
 c00b904:	4604      	mov	r4, r0
 c00b906:	2800      	cmp	r0, #0
 c00b908:	d1d8      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
 c00b90a:	a90d      	add	r1, sp, #52	; 0x34
 c00b90c:	aa04      	add	r2, sp, #16
 c00b90e:	4608      	mov	r0, r1
 c00b910:	f7ff fc32 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b914:	4604      	mov	r4, r0
 c00b916:	2800      	cmp	r0, #0
 c00b918:	d0c9      	beq.n	c00b8ae <mbedtls_mpi_inv_mod+0x100>
 c00b91a:	e7cf      	b.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
 c00b91c:	2101      	movs	r1, #1
 c00b91e:	a80d      	add	r0, sp, #52	; 0x34
 c00b920:	f7ff faa7 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b924:	e7af      	b.n	c00b886 <mbedtls_mpi_inv_mod+0xd8>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
 c00b926:	2101      	movs	r1, #1
 c00b928:	a813      	add	r0, sp, #76	; 0x4c
 c00b92a:	f7ff faa2 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b92e:	4604      	mov	r4, r0
 c00b930:	2800      	cmp	r0, #0
 c00b932:	d1c3      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
 c00b934:	9b18      	ldr	r3, [sp, #96]	; 0x60
 c00b936:	681b      	ldr	r3, [r3, #0]
 c00b938:	07d9      	lsls	r1, r3, #31
 c00b93a:	d44c      	bmi.n	c00b9d6 <mbedtls_mpi_inv_mod+0x228>
 c00b93c:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 c00b93e:	681b      	ldr	r3, [r3, #0]
 c00b940:	07da      	lsls	r2, r3, #31
 c00b942:	d448      	bmi.n	c00b9d6 <mbedtls_mpi_inv_mod+0x228>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
 c00b944:	2101      	movs	r1, #1
 c00b946:	a816      	add	r0, sp, #88	; 0x58
 c00b948:	f7ff fa93 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b94c:	4604      	mov	r4, r0
 c00b94e:	2800      	cmp	r0, #0
 c00b950:	d1b4      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
 c00b952:	2101      	movs	r1, #1
 c00b954:	a819      	add	r0, sp, #100	; 0x64
 c00b956:	f7ff fa8c 	bl	c00ae72 <mbedtls_mpi_shift_r>
 c00b95a:	4604      	mov	r4, r0
 c00b95c:	2800      	cmp	r0, #0
 c00b95e:	d1ad      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
        while( ( TV.p[0] & 1 ) == 0 )
 c00b960:	9b15      	ldr	r3, [sp, #84]	; 0x54
 c00b962:	681b      	ldr	r3, [r3, #0]
 c00b964:	07db      	lsls	r3, r3, #31
 c00b966:	d5de      	bpl.n	c00b926 <mbedtls_mpi_inv_mod+0x178>
        if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
 c00b968:	a913      	add	r1, sp, #76	; 0x4c
 c00b96a:	a807      	add	r0, sp, #28
 c00b96c:	f7ff faed 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c00b970:	2800      	cmp	r0, #0
 c00b972:	db42      	blt.n	c00b9fa <mbedtls_mpi_inv_mod+0x24c>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
 c00b974:	a907      	add	r1, sp, #28
 c00b976:	aa13      	add	r2, sp, #76	; 0x4c
 c00b978:	4608      	mov	r0, r1
 c00b97a:	f7ff fbfd 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b97e:	4604      	mov	r4, r0
 c00b980:	2800      	cmp	r0, #0
 c00b982:	d19b      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
 c00b984:	a90a      	add	r1, sp, #40	; 0x28
 c00b986:	aa16      	add	r2, sp, #88	; 0x58
 c00b988:	4608      	mov	r0, r1
 c00b98a:	f7ff fbf5 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b98e:	4604      	mov	r4, r0
 c00b990:	2800      	cmp	r0, #0
 c00b992:	d193      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
 c00b994:	aa19      	add	r2, sp, #100	; 0x64
 c00b996:	a90d      	add	r1, sp, #52	; 0x34
 c00b998:	4608      	mov	r0, r1
 c00b99a:	f7ff fbed 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b99e:	4604      	mov	r4, r0
 c00b9a0:	2800      	cmp	r0, #0
 c00b9a2:	d18b      	bne.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
    while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
 c00b9a4:	2100      	movs	r1, #0
 c00b9a6:	a807      	add	r0, sp, #28
 c00b9a8:	f7ff fb0f 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b9ac:	2800      	cmp	r0, #0
 c00b9ae:	f47f af6c 	bne.w	c00b88a <mbedtls_mpi_inv_mod+0xdc>
    while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
 c00b9b2:	2100      	movs	r1, #0
 c00b9b4:	a816      	add	r0, sp, #88	; 0x58
 c00b9b6:	f7ff fb08 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00b9ba:	2800      	cmp	r0, #0
 c00b9bc:	db32      	blt.n	c00ba24 <mbedtls_mpi_inv_mod+0x276>
    while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
 c00b9be:	4631      	mov	r1, r6
 c00b9c0:	a816      	add	r0, sp, #88	; 0x58
 c00b9c2:	f7ff fac2 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
 c00b9c6:	2800      	cmp	r0, #0
 c00b9c8:	da35      	bge.n	c00ba36 <mbedtls_mpi_inv_mod+0x288>
    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
 c00b9ca:	a916      	add	r1, sp, #88	; 0x58
 c00b9cc:	4640      	mov	r0, r8
 c00b9ce:	f7ff f902 	bl	c00abd6 <mbedtls_mpi_copy>
 c00b9d2:	4604      	mov	r4, r0
cleanup:
 c00b9d4:	e772      	b.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
 c00b9d6:	a916      	add	r1, sp, #88	; 0x58
 c00b9d8:	aa10      	add	r2, sp, #64	; 0x40
 c00b9da:	4608      	mov	r0, r1
 c00b9dc:	f7ff fbaa 	bl	c00b134 <mbedtls_mpi_add_mpi>
 c00b9e0:	4604      	mov	r4, r0
 c00b9e2:	2800      	cmp	r0, #0
 c00b9e4:	f47f af6a 	bne.w	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
 c00b9e8:	a919      	add	r1, sp, #100	; 0x64
 c00b9ea:	aa04      	add	r2, sp, #16
 c00b9ec:	4608      	mov	r0, r1
 c00b9ee:	f7ff fbc3 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00b9f2:	4604      	mov	r4, r0
 c00b9f4:	2800      	cmp	r0, #0
 c00b9f6:	d0a5      	beq.n	c00b944 <mbedtls_mpi_inv_mod+0x196>
 c00b9f8:	e760      	b.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
 c00b9fa:	a913      	add	r1, sp, #76	; 0x4c
 c00b9fc:	aa07      	add	r2, sp, #28
 c00b9fe:	4608      	mov	r0, r1
 c00ba00:	f7ff fbba 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00ba04:	4604      	mov	r4, r0
 c00ba06:	2800      	cmp	r0, #0
 c00ba08:	f47f af58 	bne.w	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
 c00ba0c:	a916      	add	r1, sp, #88	; 0x58
 c00ba0e:	aa0a      	add	r2, sp, #40	; 0x28
 c00ba10:	4608      	mov	r0, r1
 c00ba12:	f7ff fbb1 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00ba16:	4604      	mov	r4, r0
 c00ba18:	2800      	cmp	r0, #0
 c00ba1a:	f47f af4f 	bne.w	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
 c00ba1e:	aa0d      	add	r2, sp, #52	; 0x34
 c00ba20:	a919      	add	r1, sp, #100	; 0x64
 c00ba22:	e7b9      	b.n	c00b998 <mbedtls_mpi_inv_mod+0x1ea>
        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
 c00ba24:	a916      	add	r1, sp, #88	; 0x58
 c00ba26:	4632      	mov	r2, r6
 c00ba28:	4608      	mov	r0, r1
 c00ba2a:	f7ff fb83 	bl	c00b134 <mbedtls_mpi_add_mpi>
 c00ba2e:	4604      	mov	r4, r0
 c00ba30:	2800      	cmp	r0, #0
 c00ba32:	d0be      	beq.n	c00b9b2 <mbedtls_mpi_inv_mod+0x204>
cleanup:
 c00ba34:	e742      	b.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
 c00ba36:	a916      	add	r1, sp, #88	; 0x58
 c00ba38:	4632      	mov	r2, r6
 c00ba3a:	4608      	mov	r0, r1
 c00ba3c:	f7ff fb9c 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00ba40:	4604      	mov	r4, r0
 c00ba42:	2800      	cmp	r0, #0
 c00ba44:	d0bb      	beq.n	c00b9be <mbedtls_mpi_inv_mod+0x210>
cleanup:
 c00ba46:	e739      	b.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
 c00ba48:	f06f 040d 	mvn.w	r4, #13
 c00ba4c:	e736      	b.n	c00b8bc <mbedtls_mpi_inv_mod+0x10e>
        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
 c00ba4e:	f06f 0403 	mvn.w	r4, #3
 c00ba52:	e74e      	b.n	c00b8f2 <mbedtls_mpi_inv_mod+0x144>

0c00ba54 <mbedtls_md_info_from_type>:
    return( NULL );
}

const mbedtls_md_info_t *mbedtls_md_info_from_type( mbedtls_md_type_t md_type )
{
    switch( md_type )
 c00ba54:	2805      	cmp	r0, #5
 c00ba56:	d004      	beq.n	c00ba62 <mbedtls_md_info_from_type+0xe>
 c00ba58:	2806      	cmp	r0, #6
            return( &mbedtls_sha384_info );
        case MBEDTLS_MD_SHA512:
            return( &mbedtls_sha512_info );
#endif
        default:
            return( NULL );
 c00ba5a:	4803      	ldr	r0, [pc, #12]	; (c00ba68 <mbedtls_md_info_from_type+0x14>)
 c00ba5c:	bf18      	it	ne
 c00ba5e:	2000      	movne	r0, #0
 c00ba60:	4770      	bx	lr
            return( &mbedtls_sha224_info );
 c00ba62:	4802      	ldr	r0, [pc, #8]	; (c00ba6c <mbedtls_md_info_from_type+0x18>)
    }
}
 c00ba64:	4770      	bx	lr
 c00ba66:	bf00      	nop
 c00ba68:	0c0101ec 	.word	0x0c0101ec
 c00ba6c:	0c0101bc 	.word	0x0c0101bc

0c00ba70 <mbedtls_md_init>:

void mbedtls_md_init( mbedtls_md_context_t *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_md_context_t ) );
 c00ba70:	2300      	movs	r3, #0
 c00ba72:	6003      	str	r3, [r0, #0]
 c00ba74:	6043      	str	r3, [r0, #4]
 c00ba76:	6083      	str	r3, [r0, #8]
}
 c00ba78:	4770      	bx	lr

0c00ba7a <mbedtls_md_free>:

void mbedtls_md_free( mbedtls_md_context_t *ctx )
{
 c00ba7a:	b510      	push	{r4, lr}
    if( ctx == NULL || ctx->md_info == NULL )
 c00ba7c:	4604      	mov	r4, r0
 c00ba7e:	b1a8      	cbz	r0, c00baac <mbedtls_md_free+0x32>
 c00ba80:	6803      	ldr	r3, [r0, #0]
 c00ba82:	b19b      	cbz	r3, c00baac <mbedtls_md_free+0x32>
        return;

    if( ctx->md_ctx != NULL )
 c00ba84:	6840      	ldr	r0, [r0, #4]
 c00ba86:	b108      	cbz	r0, c00ba8c <mbedtls_md_free+0x12>
        ctx->md_info->ctx_free_func( ctx->md_ctx );
 c00ba88:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 c00ba8a:	4798      	blx	r3

    if( ctx->hmac_ctx != NULL )
 c00ba8c:	68a0      	ldr	r0, [r4, #8]
 c00ba8e:	b138      	cbz	r0, c00baa0 <mbedtls_md_free+0x26>
    {
        mbedtls_platform_zeroize( ctx->hmac_ctx,
                                  2 * ctx->md_info->block_size );
 c00ba90:	6823      	ldr	r3, [r4, #0]
 c00ba92:	68d9      	ldr	r1, [r3, #12]
        mbedtls_platform_zeroize( ctx->hmac_ctx,
 c00ba94:	0049      	lsls	r1, r1, #1
 c00ba96:	f000 fa25 	bl	c00bee4 <mbedtls_platform_zeroize>
        mbedtls_free( ctx->hmac_ctx );
 c00ba9a:	68a0      	ldr	r0, [r4, #8]
 c00ba9c:	f000 fa12 	bl	c00bec4 <mbedtls_free>
    }

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 c00baa0:	4620      	mov	r0, r4
}
 c00baa2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_md_context_t ) );
 c00baa6:	210c      	movs	r1, #12
 c00baa8:	f000 ba1c 	b.w	c00bee4 <mbedtls_platform_zeroize>
}
 c00baac:	bd10      	pop	{r4, pc}
	...

0c00bab0 <mbedtls_md_setup>:
    return mbedtls_md_setup( ctx, md_info, 1 );
}
#endif

int mbedtls_md_setup( mbedtls_md_context_t *ctx, const mbedtls_md_info_t *md_info, int hmac )
{
 c00bab0:	b570      	push	{r4, r5, r6, lr}
 c00bab2:	4604      	mov	r4, r0
 c00bab4:	4616      	mov	r6, r2
    if( md_info == NULL || ctx == NULL )
 c00bab6:	460d      	mov	r5, r1
 c00bab8:	b199      	cbz	r1, c00bae2 <mbedtls_md_setup+0x32>
 c00baba:	b190      	cbz	r0, c00bae2 <mbedtls_md_setup+0x32>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    if( ( ctx->md_ctx = md_info->ctx_alloc_func() ) == NULL )
 c00babc:	6a0b      	ldr	r3, [r1, #32]
 c00babe:	4798      	blx	r3
 c00bac0:	6060      	str	r0, [r4, #4]
 c00bac2:	b148      	cbz	r0, c00bad8 <mbedtls_md_setup+0x28>
        return( MBEDTLS_ERR_MD_ALLOC_FAILED );

    if( hmac != 0 )
 c00bac4:	b156      	cbz	r6, c00badc <mbedtls_md_setup+0x2c>
    {
        ctx->hmac_ctx = mbedtls_calloc( 2, md_info->block_size );
 c00bac6:	68e9      	ldr	r1, [r5, #12]
 c00bac8:	2002      	movs	r0, #2
 c00baca:	f000 f9f5 	bl	c00beb8 <mbedtls_calloc>
 c00bace:	60a0      	str	r0, [r4, #8]
        if( ctx->hmac_ctx == NULL )
 c00bad0:	b920      	cbnz	r0, c00badc <mbedtls_md_setup+0x2c>
        {
            md_info->ctx_free_func( ctx->md_ctx );
 c00bad2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 c00bad4:	6860      	ldr	r0, [r4, #4]
 c00bad6:	4798      	blx	r3
        return( MBEDTLS_ERR_MD_ALLOC_FAILED );
 c00bad8:	4803      	ldr	r0, [pc, #12]	; (c00bae8 <mbedtls_md_setup+0x38>)
 c00bada:	e001      	b.n	c00bae0 <mbedtls_md_setup+0x30>
        }
    }

    ctx->md_info = md_info;

    return( 0 );
 c00badc:	2000      	movs	r0, #0
    ctx->md_info = md_info;
 c00bade:	6025      	str	r5, [r4, #0]
}
 c00bae0:	bd70      	pop	{r4, r5, r6, pc}
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c00bae2:	4802      	ldr	r0, [pc, #8]	; (c00baec <mbedtls_md_setup+0x3c>)
 c00bae4:	e7fc      	b.n	c00bae0 <mbedtls_md_setup+0x30>
 c00bae6:	bf00      	nop
 c00bae8:	ffffae80 	.word	0xffffae80
 c00baec:	ffffaf00 	.word	0xffffaf00

0c00baf0 <mbedtls_md_starts>:

int mbedtls_md_starts( mbedtls_md_context_t *ctx )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c00baf0:	b120      	cbz	r0, c00bafc <mbedtls_md_starts+0xc>
 c00baf2:	6803      	ldr	r3, [r0, #0]
 c00baf4:	b113      	cbz	r3, c00bafc <mbedtls_md_starts+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->starts_func( ctx->md_ctx ) );
 c00baf6:	691b      	ldr	r3, [r3, #16]
 c00baf8:	6840      	ldr	r0, [r0, #4]
 c00bafa:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c00bafc:	4800      	ldr	r0, [pc, #0]	; (c00bb00 <mbedtls_md_starts+0x10>)
}
 c00bafe:	4770      	bx	lr
 c00bb00:	ffffaf00 	.word	0xffffaf00

0c00bb04 <mbedtls_md_update>:

int mbedtls_md_update( mbedtls_md_context_t *ctx, const unsigned char *input, size_t ilen )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c00bb04:	b120      	cbz	r0, c00bb10 <mbedtls_md_update+0xc>
 c00bb06:	6803      	ldr	r3, [r0, #0]
 c00bb08:	b113      	cbz	r3, c00bb10 <mbedtls_md_update+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->update_func( ctx->md_ctx, input, ilen ) );
 c00bb0a:	695b      	ldr	r3, [r3, #20]
 c00bb0c:	6840      	ldr	r0, [r0, #4]
 c00bb0e:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c00bb10:	4800      	ldr	r0, [pc, #0]	; (c00bb14 <mbedtls_md_update+0x10>)
}
 c00bb12:	4770      	bx	lr
 c00bb14:	ffffaf00 	.word	0xffffaf00

0c00bb18 <mbedtls_md_finish>:

int mbedtls_md_finish( mbedtls_md_context_t *ctx, unsigned char *output )
{
    if( ctx == NULL || ctx->md_info == NULL )
 c00bb18:	b120      	cbz	r0, c00bb24 <mbedtls_md_finish+0xc>
 c00bb1a:	6803      	ldr	r3, [r0, #0]
 c00bb1c:	b113      	cbz	r3, c00bb24 <mbedtls_md_finish+0xc>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( ctx->md_info->finish_func( ctx->md_ctx, output ) );
 c00bb1e:	699b      	ldr	r3, [r3, #24]
 c00bb20:	6840      	ldr	r0, [r0, #4]
 c00bb22:	4718      	bx	r3
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );
 c00bb24:	4800      	ldr	r0, [pc, #0]	; (c00bb28 <mbedtls_md_finish+0x10>)
}
 c00bb26:	4770      	bx	lr
 c00bb28:	ffffaf00 	.word	0xffffaf00

0c00bb2c <mbedtls_md>:

int mbedtls_md( const mbedtls_md_info_t *md_info, const unsigned char *input, size_t ilen,
            unsigned char *output )
{
 c00bb2c:	b430      	push	{r4, r5}
 c00bb2e:	460d      	mov	r5, r1
 c00bb30:	4611      	mov	r1, r2
    if( md_info == NULL )
 c00bb32:	b128      	cbz	r0, c00bb40 <mbedtls_md+0x14>
        return( MBEDTLS_ERR_MD_BAD_INPUT_DATA );

    return( md_info->digest_func( input, ilen, output ) );
 c00bb34:	69c4      	ldr	r4, [r0, #28]
 c00bb36:	461a      	mov	r2, r3
 c00bb38:	4628      	mov	r0, r5
 c00bb3a:	4623      	mov	r3, r4
}
 c00bb3c:	bc30      	pop	{r4, r5}
    return( md_info->digest_func( input, ilen, output ) );
 c00bb3e:	4718      	bx	r3
}
 c00bb40:	4801      	ldr	r0, [pc, #4]	; (c00bb48 <mbedtls_md+0x1c>)
 c00bb42:	bc30      	pop	{r4, r5}
 c00bb44:	4770      	bx	lr
 c00bb46:	bf00      	nop
 c00bb48:	ffffaf00 	.word	0xffffaf00

0c00bb4c <mbedtls_md_get_size>:
    return( ctx->md_info->process_func( ctx->md_ctx, data ) );
}

unsigned char mbedtls_md_get_size( const mbedtls_md_info_t *md_info )
{
    if( md_info == NULL )
 c00bb4c:	b100      	cbz	r0, c00bb50 <mbedtls_md_get_size+0x4>
        return( 0 );

    return md_info->size;
 c00bb4e:	7a00      	ldrb	r0, [r0, #8]
}
 c00bb50:	4770      	bx	lr

0c00bb52 <sha224_process_wrap>:
                    (const mbedtls_sha256_context *) src );
}

static int sha224_process_wrap( void *ctx, const unsigned char *data )
{
    return( mbedtls_internal_sha256_process( (mbedtls_sha256_context *) ctx,
 c00bb52:	f7f8 be63 	b.w	c00481c <mbedtls_internal_sha256_process>

0c00bb56 <sha224_clone_wrap>:
    mbedtls_sha256_clone( (mbedtls_sha256_context *) dst,
 c00bb56:	f7f8 be47 	b.w	c0047e8 <mbedtls_sha256_clone>

0c00bb5a <sha224_ctx_free>:
{
 c00bb5a:	b510      	push	{r4, lr}
 c00bb5c:	4604      	mov	r4, r0
    mbedtls_sha256_free( (mbedtls_sha256_context *) ctx );
 c00bb5e:	f7f8 fe39 	bl	c0047d4 <mbedtls_sha256_free>
    mbedtls_free( ctx );
 c00bb62:	4620      	mov	r0, r4
}
 c00bb64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 c00bb68:	f000 b9ac 	b.w	c00bec4 <mbedtls_free>

0c00bb6c <sha224_ctx_alloc>:
{
 c00bb6c:	b510      	push	{r4, lr}
    void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_sha256_context ) );
 c00bb6e:	f44f 71b8 	mov.w	r1, #368	; 0x170
 c00bb72:	2001      	movs	r0, #1
 c00bb74:	f000 f9a0 	bl	c00beb8 <mbedtls_calloc>
    if( ctx != NULL )
 c00bb78:	4604      	mov	r4, r0
 c00bb7a:	b108      	cbz	r0, c00bb80 <sha224_ctx_alloc+0x14>
        mbedtls_sha256_init( (mbedtls_sha256_context *) ctx );
 c00bb7c:	f7f8 fe12 	bl	c0047a4 <mbedtls_sha256_init>
}
 c00bb80:	4620      	mov	r0, r4
 c00bb82:	bd10      	pop	{r4, pc}

0c00bb84 <sha224_wrap>:
    return( mbedtls_sha256_ret( input, ilen, output, 1 ) );
 c00bb84:	2301      	movs	r3, #1
 c00bb86:	f000 bb3f 	b.w	c00c208 <mbedtls_sha256_ret>

0c00bb8a <sha256_wrap>:
}

static int sha256_wrap( const unsigned char *input, size_t ilen,
                        unsigned char *output )
{
    return( mbedtls_sha256_ret( input, ilen, output, 0 ) );
 c00bb8a:	2300      	movs	r3, #0
 c00bb8c:	f000 bb3c 	b.w	c00c208 <mbedtls_sha256_ret>

0c00bb90 <sha224_finish_wrap>:
    return( mbedtls_sha256_finish_ret( (mbedtls_sha256_context *) ctx,
 c00bb90:	f7f8 bea4 	b.w	c0048dc <mbedtls_sha256_finish_ret>

0c00bb94 <sha224_update_wrap>:
    return( mbedtls_sha256_update_ret( (mbedtls_sha256_context *) ctx,
 c00bb94:	f7f8 be53 	b.w	c00483e <mbedtls_sha256_update_ret>

0c00bb98 <sha224_starts_wrap>:
    return( mbedtls_sha256_starts_ret( (mbedtls_sha256_context *) ctx, 1 ) );
 c00bb98:	2101      	movs	r1, #1
 c00bb9a:	f7f8 be2b 	b.w	c0047f4 <mbedtls_sha256_starts_ret>

0c00bb9e <sha256_starts_wrap>:
    return( mbedtls_sha256_starts_ret( (mbedtls_sha256_context *) ctx, 0 ) );
 c00bb9e:	2100      	movs	r1, #0
 c00bba0:	f7f8 be28 	b.w	c0047f4 <mbedtls_sha256_starts_ret>

0c00bba4 <verify_header>:
}
#endif /* MBEDTLS_MEMORY_DEBUG */

static int verify_header( memory_header *hdr )
{
    if( hdr->magic1 != MAGIC1 )
 c00bba4:	6802      	ldr	r2, [r0, #0]
 c00bba6:	4b0e      	ldr	r3, [pc, #56]	; (c00bbe0 <verify_header+0x3c>)
 c00bba8:	429a      	cmp	r2, r3
 c00bbaa:	d115      	bne.n	c00bbd8 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: MAGIC1 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->magic2 != MAGIC2 )
 c00bbac:	69c2      	ldr	r2, [r0, #28]
 c00bbae:	f1a3 2310 	sub.w	r3, r3, #268439552	; 0x10001000
 c00bbb2:	f1a3 13ef 	sub.w	r3, r3, #15663343	; 0xef00ef
 c00bbb6:	429a      	cmp	r2, r3
 c00bbb8:	d10e      	bne.n	c00bbd8 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: MAGIC2 mismatch\n" );
#endif
        return( 1 );
    }

    if( hdr->alloc > 1 )
 c00bbba:	6883      	ldr	r3, [r0, #8]
 c00bbbc:	2b01      	cmp	r3, #1
 c00bbbe:	d80b      	bhi.n	c00bbd8 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: alloc has illegal value\n" );
#endif
        return( 1 );
    }

    if( hdr->prev != NULL && hdr->prev == hdr->next )
 c00bbc0:	68c3      	ldr	r3, [r0, #12]
 c00bbc2:	b113      	cbz	r3, c00bbca <verify_header+0x26>
 c00bbc4:	6902      	ldr	r2, [r0, #16]
 c00bbc6:	4293      	cmp	r3, r2
 c00bbc8:	d006      	beq.n	c00bbd8 <verify_header+0x34>
        mbedtls_fprintf( stderr, "FATAL: prev == next\n" );
#endif
        return( 1 );
    }

    if( hdr->prev_free != NULL && hdr->prev_free == hdr->next_free )
 c00bbca:	6943      	ldr	r3, [r0, #20]
 c00bbcc:	b133      	cbz	r3, c00bbdc <verify_header+0x38>
 c00bbce:	6980      	ldr	r0, [r0, #24]
 c00bbd0:	1ac3      	subs	r3, r0, r3
 c00bbd2:	4258      	negs	r0, r3
 c00bbd4:	4158      	adcs	r0, r3
 c00bbd6:	4770      	bx	lr
        return( 1 );
 c00bbd8:	2001      	movs	r0, #1
 c00bbda:	4770      	bx	lr
        mbedtls_fprintf( stderr, "FATAL: prev_free == next_free\n" );
#endif
        return( 1 );
    }

    return( 0 );
 c00bbdc:	4618      	mov	r0, r3
}
 c00bbde:	4770      	bx	lr
 c00bbe0:	ff00aa55 	.word	0xff00aa55

0c00bbe4 <verify_chain>:

static int verify_chain( void )
{
 c00bbe4:	b538      	push	{r3, r4, r5, lr}
    memory_header *prv = heap.first, *cur;
 c00bbe6:	4b0d      	ldr	r3, [pc, #52]	; (c00bc1c <verify_chain+0x38>)
 c00bbe8:	689d      	ldr	r5, [r3, #8]

    if( prv == NULL || verify_header( prv ) != 0 )
 c00bbea:	b1a5      	cbz	r5, c00bc16 <verify_chain+0x32>
 c00bbec:	4628      	mov	r0, r5
 c00bbee:	f7ff ffd9 	bl	c00bba4 <verify_header>
 c00bbf2:	4601      	mov	r1, r0
 c00bbf4:	b978      	cbnz	r0, c00bc16 <verify_chain+0x32>
                                  "failed\n" );
#endif
        return( 1 );
    }

    if( heap.first->prev != NULL )
 c00bbf6:	68eb      	ldr	r3, [r5, #12]
 c00bbf8:	b96b      	cbnz	r3, c00bc16 <verify_chain+0x32>
                                  "first->prev != NULL\n" );
#endif
        return( 1 );
    }

    cur = heap.first->next;
 c00bbfa:	692c      	ldr	r4, [r5, #16]

    while( cur != NULL )
 c00bbfc:	b90c      	cbnz	r4, c00bc02 <verify_chain+0x1e>
        prv = cur;
        cur = cur->next;
    }

    return( 0 );
}
 c00bbfe:	4608      	mov	r0, r1
 c00bc00:	bd38      	pop	{r3, r4, r5, pc}
        if( verify_header( cur ) != 0 )
 c00bc02:	4620      	mov	r0, r4
 c00bc04:	f7ff ffce 	bl	c00bba4 <verify_header>
 c00bc08:	b928      	cbnz	r0, c00bc16 <verify_chain+0x32>
        if( cur->prev != prv )
 c00bc0a:	68e3      	ldr	r3, [r4, #12]
 c00bc0c:	42ab      	cmp	r3, r5
 c00bc0e:	d102      	bne.n	c00bc16 <verify_chain+0x32>
        cur = cur->next;
 c00bc10:	4625      	mov	r5, r4
 c00bc12:	6924      	ldr	r4, [r4, #16]
 c00bc14:	e7f2      	b.n	c00bbfc <verify_chain+0x18>
        return( 1 );
 c00bc16:	2101      	movs	r1, #1
 c00bc18:	e7f1      	b.n	c00bbfe <verify_chain+0x1a>
 c00bc1a:	bf00      	nop
 c00bc1c:	30030344 	.word	0x30030344

0c00bc20 <buffer_alloc_calloc>:

static void *buffer_alloc_calloc( size_t n, size_t size )
{
 c00bc20:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if defined(MBEDTLS_MEMORY_BACKTRACE)
    void *trace_buffer[MAX_BT];
    size_t trace_cnt;
#endif

    if( heap.buf == NULL || heap.first == NULL )
 c00bc24:	4e41      	ldr	r6, [pc, #260]	; (c00bd2c <buffer_alloc_calloc+0x10c>)
 c00bc26:	6834      	ldr	r4, [r6, #0]
 c00bc28:	b1dc      	cbz	r4, c00bc62 <buffer_alloc_calloc+0x42>
 c00bc2a:	68b4      	ldr	r4, [r6, #8]
 c00bc2c:	b1cc      	cbz	r4, c00bc62 <buffer_alloc_calloc+0x42>
        return( NULL );

    original_len = len = n * size;
 c00bc2e:	fb01 f700 	mul.w	r7, r1, r0

    if( n == 0 || size == 0 || len / n != size )
 c00bc32:	2800      	cmp	r0, #0
 c00bc34:	d04c      	beq.n	c00bcd0 <buffer_alloc_calloc+0xb0>
 c00bc36:	2900      	cmp	r1, #0
 c00bc38:	d04a      	beq.n	c00bcd0 <buffer_alloc_calloc+0xb0>
 c00bc3a:	fbb7 f4f0 	udiv	r4, r7, r0
 c00bc3e:	428c      	cmp	r4, r1
 c00bc40:	d146      	bne.n	c00bcd0 <buffer_alloc_calloc+0xb0>
        return( NULL );
    else if( len > (size_t)-MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c00bc42:	1d38      	adds	r0, r7, #4
 c00bc44:	d844      	bhi.n	c00bcd0 <buffer_alloc_calloc+0xb0>
        return( NULL );

    if( len % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c00bc46:	07b9      	lsls	r1, r7, #30
 c00bc48:	d00e      	beq.n	c00bc68 <buffer_alloc_calloc+0x48>
    {
        len -= len % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c00bc4a:	f027 0803 	bic.w	r8, r7, #3
        len += MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c00bc4e:	f108 0804 	add.w	r8, r8, #4
    memory_header *new, *cur = heap.first_free;
 c00bc52:	68f4      	ldr	r4, [r6, #12]
 c00bc54:	e003      	b.n	c00bc5e <buffer_alloc_calloc+0x3e>

    // Find block that fits
    //
    while( cur != NULL )
    {
        if( cur->size >= len )
 c00bc56:	6863      	ldr	r3, [r4, #4]
 c00bc58:	4543      	cmp	r3, r8
 c00bc5a:	d23b      	bcs.n	c00bcd4 <buffer_alloc_calloc+0xb4>
            break;

        cur = cur->next_free;
 c00bc5c:	69a4      	ldr	r4, [r4, #24]
    while( cur != NULL )
 c00bc5e:	2c00      	cmp	r4, #0
 c00bc60:	d1f9      	bne.n	c00bc56 <buffer_alloc_calloc+0x36>

    ret = (unsigned char *) cur + sizeof( memory_header );
    memset( ret, 0, original_len );

    return( ret );
}
 c00bc62:	4620      	mov	r0, r4
 c00bc64:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c00bc68:	46b8      	mov	r8, r7
 c00bc6a:	e7f2      	b.n	c00bc52 <buffer_alloc_calloc+0x32>
            heap.first_free = cur->next_free;
 c00bc6c:	60f0      	str	r0, [r6, #12]
 c00bc6e:	e045      	b.n	c00bcfc <buffer_alloc_calloc+0xdc>
    p = ( (unsigned char *) cur ) + sizeof(memory_header) + len;
 c00bc70:	f108 0c20 	add.w	ip, r8, #32
 c00bc74:	eb04 030c 	add.w	r3, r4, ip
    new->size = cur->size - len - sizeof(memory_header);
 c00bc78:	3920      	subs	r1, #32
 c00bc7a:	6059      	str	r1, [r3, #4]
    new->alloc = 0;
 c00bc7c:	2100      	movs	r1, #0
    new->magic1 = MAGIC1;
 c00bc7e:	f8df e0b4 	ldr.w	lr, [pc, #180]	; c00bd34 <buffer_alloc_calloc+0x114>
    new->prev = cur;
 c00bc82:	e9c3 1402 	strd	r1, r4, [r3, #8]
    new->next = cur->next;
 c00bc86:	6921      	ldr	r1, [r4, #16]
 c00bc88:	6119      	str	r1, [r3, #16]
    new->magic1 = MAGIC1;
 c00bc8a:	f844 e00c 	str.w	lr, [r4, ip]
    new->magic2 = MAGIC2;
 c00bc8e:	f8df c0a8 	ldr.w	ip, [pc, #168]	; c00bd38 <buffer_alloc_calloc+0x118>
 c00bc92:	f8c3 c01c 	str.w	ip, [r3, #28]
    if( new->next != NULL )
 c00bc96:	b101      	cbz	r1, c00bc9a <buffer_alloc_calloc+0x7a>
        new->next->prev = new;
 c00bc98:	60cb      	str	r3, [r1, #12]
    new->next_free = cur->next_free;
 c00bc9a:	e9c3 2005 	strd	r2, r0, [r3, #20]
    if( new->prev_free != NULL )
 c00bc9e:	b1aa      	cbz	r2, c00bccc <buffer_alloc_calloc+0xac>
        new->prev_free->next_free = new;
 c00bca0:	6193      	str	r3, [r2, #24]
    if( new->next_free != NULL )
 c00bca2:	699a      	ldr	r2, [r3, #24]
 c00bca4:	b102      	cbz	r2, c00bca8 <buffer_alloc_calloc+0x88>
        new->next_free->prev_free = new;
 c00bca6:	6153      	str	r3, [r2, #20]
    cur->next = new;
 c00bca8:	6123      	str	r3, [r4, #16]
    cur->prev_free = NULL;
 c00bcaa:	2300      	movs	r3, #0
    cur->alloc = 1;
 c00bcac:	f04f 0901 	mov.w	r9, #1
    cur->next_free = NULL;
 c00bcb0:	e9c4 3305 	strd	r3, r3, [r4, #20]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c00bcb4:	6933      	ldr	r3, [r6, #16]
    cur->size = len;
 c00bcb6:	e9c4 8901 	strd	r8, r9, [r4, #4]
    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c00bcba:	07db      	lsls	r3, r3, #31
 c00bcbc:	d52e      	bpl.n	c00bd1c <buffer_alloc_calloc+0xfc>
 c00bcbe:	f7ff ff91 	bl	c00bbe4 <verify_chain>
 c00bcc2:	b358      	cbz	r0, c00bd1c <buffer_alloc_calloc+0xfc>
        mbedtls_exit( 1 );
 c00bcc4:	4b1a      	ldr	r3, [pc, #104]	; (c00bd30 <buffer_alloc_calloc+0x110>)
 c00bcc6:	4648      	mov	r0, r9
 c00bcc8:	681b      	ldr	r3, [r3, #0]
 c00bcca:	e026      	b.n	c00bd1a <buffer_alloc_calloc+0xfa>
        heap.first_free = new;
 c00bccc:	60f3      	str	r3, [r6, #12]
 c00bcce:	e7e8      	b.n	c00bca2 <buffer_alloc_calloc+0x82>
        return( NULL );
 c00bcd0:	2400      	movs	r4, #0
 c00bcd2:	e7c6      	b.n	c00bc62 <buffer_alloc_calloc+0x42>
    if( cur->alloc != 0 )
 c00bcd4:	68a3      	ldr	r3, [r4, #8]
 c00bcd6:	b11b      	cbz	r3, c00bce0 <buffer_alloc_calloc+0xc0>
        mbedtls_exit( 1 );
 c00bcd8:	4b15      	ldr	r3, [pc, #84]	; (c00bd30 <buffer_alloc_calloc+0x110>)
 c00bcda:	2001      	movs	r0, #1
 c00bcdc:	681b      	ldr	r3, [r3, #0]
 c00bcde:	4798      	blx	r3
 c00bce0:	e9d4 2005 	ldrd	r2, r0, [r4, #20]
    if( cur->size - len < sizeof(memory_header) +
 c00bce4:	6861      	ldr	r1, [r4, #4]
 c00bce6:	f104 0520 	add.w	r5, r4, #32
 c00bcea:	eba1 0108 	sub.w	r1, r1, r8
 c00bcee:	2923      	cmp	r1, #35	; 0x23
 c00bcf0:	d8be      	bhi.n	c00bc70 <buffer_alloc_calloc+0x50>
        cur->alloc = 1;
 c00bcf2:	2301      	movs	r3, #1
 c00bcf4:	60a3      	str	r3, [r4, #8]
        if( cur->prev_free != NULL )
 c00bcf6:	2a00      	cmp	r2, #0
 c00bcf8:	d0b8      	beq.n	c00bc6c <buffer_alloc_calloc+0x4c>
            cur->prev_free->next_free = cur->next_free;
 c00bcfa:	6190      	str	r0, [r2, #24]
        if( cur->next_free != NULL )
 c00bcfc:	69a3      	ldr	r3, [r4, #24]
 c00bcfe:	b103      	cbz	r3, c00bd02 <buffer_alloc_calloc+0xe2>
            cur->next_free->prev_free = cur->prev_free;
 c00bd00:	615a      	str	r2, [r3, #20]
        cur->prev_free = NULL;
 c00bd02:	2300      	movs	r3, #0
        cur->next_free = NULL;
 c00bd04:	e9c4 3305 	strd	r3, r3, [r4, #20]
        if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_ALLOC ) && verify_chain() != 0 )
 c00bd08:	6933      	ldr	r3, [r6, #16]
 c00bd0a:	07da      	lsls	r2, r3, #31
 c00bd0c:	d506      	bpl.n	c00bd1c <buffer_alloc_calloc+0xfc>
 c00bd0e:	f7ff ff69 	bl	c00bbe4 <verify_chain>
 c00bd12:	b118      	cbz	r0, c00bd1c <buffer_alloc_calloc+0xfc>
            mbedtls_exit( 1 );
 c00bd14:	2001      	movs	r0, #1
 c00bd16:	4b06      	ldr	r3, [pc, #24]	; (c00bd30 <buffer_alloc_calloc+0x110>)
 c00bd18:	681b      	ldr	r3, [r3, #0]
        mbedtls_exit( 1 );
 c00bd1a:	4798      	blx	r3
    memset( ret, 0, original_len );
 c00bd1c:	463a      	mov	r2, r7
 c00bd1e:	2100      	movs	r1, #0
 c00bd20:	4628      	mov	r0, r5
    ret = (unsigned char *) cur + sizeof( memory_header );
 c00bd22:	462c      	mov	r4, r5
    memset( ret, 0, original_len );
 c00bd24:	f002 f9b1 	bl	c00e08a <memset>
    return( ret );
 c00bd28:	e79b      	b.n	c00bc62 <buffer_alloc_calloc+0x42>
 c00bd2a:	bf00      	nop
 c00bd2c:	30030344 	.word	0x30030344
 c00bd30:	300300d4 	.word	0x300300d4
 c00bd34:	ff00aa55 	.word	0xff00aa55
 c00bd38:	ee119966 	.word	0xee119966

0c00bd3c <buffer_alloc_free>:

static void buffer_alloc_free( void *ptr )
{
 c00bd3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    memory_header *hdr, *old = NULL;
    unsigned char *p = (unsigned char *) ptr;

    if( ptr == NULL || heap.buf == NULL || heap.first == NULL )
 c00bd40:	4607      	mov	r7, r0
 c00bd42:	2800      	cmp	r0, #0
 c00bd44:	d07c      	beq.n	c00be40 <buffer_alloc_free+0x104>
 c00bd46:	4d3f      	ldr	r5, [pc, #252]	; (c00be44 <buffer_alloc_free+0x108>)
 c00bd48:	682b      	ldr	r3, [r5, #0]
 c00bd4a:	2b00      	cmp	r3, #0
 c00bd4c:	d078      	beq.n	c00be40 <buffer_alloc_free+0x104>
 c00bd4e:	68aa      	ldr	r2, [r5, #8]
 c00bd50:	2a00      	cmp	r2, #0
 c00bd52:	d075      	beq.n	c00be40 <buffer_alloc_free+0x104>
        return;

    if( p < heap.buf || p >= heap.buf + heap.len )
 c00bd54:	4283      	cmp	r3, r0
 c00bd56:	d803      	bhi.n	c00bd60 <buffer_alloc_free+0x24>
 c00bd58:	686a      	ldr	r2, [r5, #4]
 c00bd5a:	4413      	add	r3, r2
 c00bd5c:	4298      	cmp	r0, r3
 c00bd5e:	d303      	bcc.n	c00bd68 <buffer_alloc_free+0x2c>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() outside of managed "
                                  "space\n" );
#endif
        mbedtls_exit( 1 );
 c00bd60:	4b39      	ldr	r3, [pc, #228]	; (c00be48 <buffer_alloc_free+0x10c>)
 c00bd62:	2001      	movs	r0, #1
 c00bd64:	681b      	ldr	r3, [r3, #0]
 c00bd66:	4798      	blx	r3
    }

    p -= sizeof(memory_header);
 c00bd68:	f1a7 0420 	sub.w	r4, r7, #32
    hdr = (memory_header *) p;

    if( verify_header( hdr ) != 0 )
 c00bd6c:	4620      	mov	r0, r4
 c00bd6e:	f7ff ff19 	bl	c00bba4 <verify_header>
 c00bd72:	b118      	cbz	r0, c00bd7c <buffer_alloc_free+0x40>
        mbedtls_exit( 1 );
 c00bd74:	4b34      	ldr	r3, [pc, #208]	; (c00be48 <buffer_alloc_free+0x10c>)
 c00bd76:	2001      	movs	r0, #1
 c00bd78:	681b      	ldr	r3, [r3, #0]
 c00bd7a:	4798      	blx	r3

    if( hdr->alloc != 1 )
 c00bd7c:	f857 3c18 	ldr.w	r3, [r7, #-24]
 c00bd80:	2b01      	cmp	r3, #1
 c00bd82:	d003      	beq.n	c00bd8c <buffer_alloc_free+0x50>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        mbedtls_fprintf( stderr, "FATAL: mbedtls_free() on unallocated "
                                  "data\n" );
#endif
        mbedtls_exit( 1 );
 c00bd84:	4b30      	ldr	r3, [pc, #192]	; (c00be48 <buffer_alloc_free+0x10c>)
 c00bd86:	2001      	movs	r0, #1
 c00bd88:	681b      	ldr	r3, [r3, #0]
 c00bd8a:	4798      	blx	r3
    }

    hdr->alloc = 0;
 c00bd8c:	2300      	movs	r3, #0
    hdr->trace_count = 0;
#endif

    // Regroup with block before
    //
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c00bd8e:	f857 6c14 	ldr.w	r6, [r7, #-20]
    hdr->alloc = 0;
 c00bd92:	f847 3c18 	str.w	r3, [r7, #-24]
    if( hdr->prev != NULL && hdr->prev->alloc == 0 )
 c00bd96:	b1ae      	cbz	r6, c00bdc4 <buffer_alloc_free+0x88>
 c00bd98:	68b2      	ldr	r2, [r6, #8]
 c00bd9a:	b992      	cbnz	r2, c00bdc2 <buffer_alloc_free+0x86>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->prev->size += sizeof(memory_header) + hdr->size;
 c00bd9c:	f857 3c1c 	ldr.w	r3, [r7, #-28]
 c00bda0:	f103 0220 	add.w	r2, r3, #32
 c00bda4:	6873      	ldr	r3, [r6, #4]
 c00bda6:	4413      	add	r3, r2
 c00bda8:	6073      	str	r3, [r6, #4]
        hdr->prev->next = hdr->next;
 c00bdaa:	f857 3c10 	ldr.w	r3, [r7, #-16]
 c00bdae:	6133      	str	r3, [r6, #16]
        old = hdr;
        hdr = hdr->prev;

        if( hdr->next != NULL )
 c00bdb0:	b103      	cbz	r3, c00bdb4 <buffer_alloc_free+0x78>
            hdr->next->prev = hdr;
 c00bdb2:	60de      	str	r6, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c00bdb4:	4620      	mov	r0, r4
 c00bdb6:	2220      	movs	r2, #32
 c00bdb8:	2100      	movs	r1, #0
 c00bdba:	f002 f966 	bl	c00e08a <memset>
 c00bdbe:	4634      	mov	r4, r6
 c00bdc0:	4603      	mov	r3, r0
    memory_header *hdr, *old = NULL;
 c00bdc2:	461e      	mov	r6, r3
    }

    // Regroup with block after
    //
    if( hdr->next != NULL && hdr->next->alloc == 0 )
 c00bdc4:	6920      	ldr	r0, [r4, #16]
 c00bdc6:	2800      	cmp	r0, #0
 c00bdc8:	d032      	beq.n	c00be30 <buffer_alloc_free+0xf4>
 c00bdca:	6883      	ldr	r3, [r0, #8]
 c00bdcc:	2b00      	cmp	r3, #0
 c00bdce:	d12f      	bne.n	c00be30 <buffer_alloc_free+0xf4>
    {
#if defined(MBEDTLS_MEMORY_DEBUG)
        heap.header_count--;
#endif
        hdr->size += sizeof(memory_header) + hdr->next->size;
 c00bdd0:	6863      	ldr	r3, [r4, #4]
 c00bdd2:	6842      	ldr	r2, [r0, #4]
 c00bdd4:	3320      	adds	r3, #32
 c00bdd6:	4413      	add	r3, r2
 c00bdd8:	6063      	str	r3, [r4, #4]
        old = hdr->next;
        hdr->next = hdr->next->next;
 c00bdda:	6903      	ldr	r3, [r0, #16]
 c00bddc:	e9d4 2105 	ldrd	r2, r1, [r4, #20]
 c00bde0:	6123      	str	r3, [r4, #16]

        if( hdr->prev_free != NULL || hdr->next_free != NULL )
 c00bde2:	b9da      	cbnz	r2, c00be1c <buffer_alloc_free+0xe0>
 c00bde4:	bb01      	cbnz	r1, c00be28 <buffer_alloc_free+0xec>

            if( hdr->next_free != NULL )
                hdr->next_free->prev_free = hdr->prev_free;
        }

        hdr->prev_free = old->prev_free;
 c00bde6:	6942      	ldr	r2, [r0, #20]
        hdr->next_free = old->next_free;
 c00bde8:	6981      	ldr	r1, [r0, #24]
        hdr->prev_free = old->prev_free;
 c00bdea:	6162      	str	r2, [r4, #20]
        hdr->next_free = old->next_free;
 c00bdec:	61a1      	str	r1, [r4, #24]

        if( hdr->prev_free != NULL )
 c00bdee:	b1ea      	cbz	r2, c00be2c <buffer_alloc_free+0xf0>
            hdr->prev_free->next_free = hdr;
 c00bdf0:	6194      	str	r4, [r2, #24]
        else
            heap.first_free = hdr;

        if( hdr->next_free != NULL )
 c00bdf2:	69a2      	ldr	r2, [r4, #24]
 c00bdf4:	b102      	cbz	r2, c00bdf8 <buffer_alloc_free+0xbc>
            hdr->next_free->prev_free = hdr;
 c00bdf6:	6154      	str	r4, [r2, #20]

        if( hdr->next != NULL )
 c00bdf8:	b103      	cbz	r3, c00bdfc <buffer_alloc_free+0xc0>
            hdr->next->prev = hdr;
 c00bdfa:	60dc      	str	r4, [r3, #12]

        memset( old, 0, sizeof(memory_header) );
 c00bdfc:	2220      	movs	r2, #32
 c00bdfe:	2100      	movs	r1, #0
 c00be00:	f002 f943 	bl	c00e08a <memset>
        if( heap.first_free != NULL )
            heap.first_free->prev_free = hdr;
        heap.first_free = hdr;
    }

    if( ( heap.verify & MBEDTLS_MEMORY_VERIFY_FREE ) && verify_chain() != 0 )
 c00be04:	692b      	ldr	r3, [r5, #16]
 c00be06:	079b      	lsls	r3, r3, #30
 c00be08:	d51a      	bpl.n	c00be40 <buffer_alloc_free+0x104>
 c00be0a:	f7ff feeb 	bl	c00bbe4 <verify_chain>
 c00be0e:	b1b8      	cbz	r0, c00be40 <buffer_alloc_free+0x104>
        mbedtls_exit( 1 );
}
 c00be10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        mbedtls_exit( 1 );
 c00be14:	4b0c      	ldr	r3, [pc, #48]	; (c00be48 <buffer_alloc_free+0x10c>)
 c00be16:	2001      	movs	r0, #1
 c00be18:	681b      	ldr	r3, [r3, #0]
 c00be1a:	4718      	bx	r3
                hdr->prev_free->next_free = hdr->next_free;
 c00be1c:	6191      	str	r1, [r2, #24]
            if( hdr->next_free != NULL )
 c00be1e:	69a1      	ldr	r1, [r4, #24]
 c00be20:	2900      	cmp	r1, #0
 c00be22:	d0e0      	beq.n	c00bde6 <buffer_alloc_free+0xaa>
                hdr->next_free->prev_free = hdr->prev_free;
 c00be24:	614a      	str	r2, [r1, #20]
 c00be26:	e7de      	b.n	c00bde6 <buffer_alloc_free+0xaa>
                heap.first_free = hdr->next_free;
 c00be28:	60e9      	str	r1, [r5, #12]
 c00be2a:	e7f8      	b.n	c00be1e <buffer_alloc_free+0xe2>
            heap.first_free = hdr;
 c00be2c:	60ec      	str	r4, [r5, #12]
 c00be2e:	e7e0      	b.n	c00bdf2 <buffer_alloc_free+0xb6>
    if( old == NULL )
 c00be30:	2e00      	cmp	r6, #0
 c00be32:	d1e7      	bne.n	c00be04 <buffer_alloc_free+0xc8>
        hdr->next_free = heap.first_free;
 c00be34:	68eb      	ldr	r3, [r5, #12]
 c00be36:	61a3      	str	r3, [r4, #24]
        if( heap.first_free != NULL )
 c00be38:	b103      	cbz	r3, c00be3c <buffer_alloc_free+0x100>
            heap.first_free->prev_free = hdr;
 c00be3a:	615c      	str	r4, [r3, #20]
        heap.first_free = hdr;
 c00be3c:	60ec      	str	r4, [r5, #12]
 c00be3e:	e7e1      	b.n	c00be04 <buffer_alloc_free+0xc8>
}
 c00be40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c00be44:	30030344 	.word	0x30030344
 c00be48:	300300d4 	.word	0x300300d4

0c00be4c <mbedtls_memory_buffer_alloc_init>:
    (void) mbedtls_mutex_unlock( &heap.mutex );
}
#endif /* MBEDTLS_THREADING_C */

void mbedtls_memory_buffer_alloc_init( unsigned char *buf, size_t len )
{
 c00be4c:	b538      	push	{r3, r4, r5, lr}
 c00be4e:	460d      	mov	r5, r1
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c00be50:	2214      	movs	r2, #20
 c00be52:	2100      	movs	r1, #0
{
 c00be54:	4604      	mov	r4, r0
    memset( &heap, 0, sizeof( buffer_alloc_ctx ) );
 c00be56:	4812      	ldr	r0, [pc, #72]	; (c00bea0 <mbedtls_memory_buffer_alloc_init+0x54>)
 c00be58:	f002 f917 	bl	c00e08a <memset>
#if defined(MBEDTLS_THREADING_C)
    mbedtls_mutex_init( &heap.mutex );
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc_mutexed,
                              buffer_alloc_free_mutexed );
#else
    mbedtls_platform_set_calloc_free( buffer_alloc_calloc, buffer_alloc_free );
 c00be5c:	4911      	ldr	r1, [pc, #68]	; (c00bea4 <mbedtls_memory_buffer_alloc_init+0x58>)
 c00be5e:	4812      	ldr	r0, [pc, #72]	; (c00bea8 <mbedtls_memory_buffer_alloc_init+0x5c>)
 c00be60:	f000 f836 	bl	c00bed0 <mbedtls_platform_set_calloc_free>
#endif

    if( len < sizeof( memory_header ) + MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c00be64:	2d23      	cmp	r5, #35	; 0x23
 c00be66:	d91a      	bls.n	c00be9e <mbedtls_memory_buffer_alloc_init+0x52>
        return;
    else if( (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE )
 c00be68:	f014 0303 	ands.w	r3, r4, #3
 c00be6c:	bf1f      	itttt	ne
 c00be6e:	3d04      	subne	r5, #4
    {
        /* Adjust len first since buf is used in the computation */
        len -= MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c00be70:	18ed      	addne	r5, r5, r3
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
             - (size_t)buf % MBEDTLS_MEMORY_ALIGN_MULTIPLE;
 c00be72:	f1c3 0304 	rsbne	r3, r3, #4
        buf += MBEDTLS_MEMORY_ALIGN_MULTIPLE
 c00be76:	18e4      	addne	r4, r4, r3
    }

    memset( buf, 0, len );
 c00be78:	462a      	mov	r2, r5
 c00be7a:	2100      	movs	r1, #0
 c00be7c:	4620      	mov	r0, r4
 c00be7e:	f002 f904 	bl	c00e08a <memset>

    heap.buf = buf;
 c00be82:	4b07      	ldr	r3, [pc, #28]	; (c00bea0 <mbedtls_memory_buffer_alloc_init+0x54>)
    heap.len = len;

    heap.first = (memory_header *)buf;
    heap.first->size = len - sizeof( memory_header );
    heap.first->magic1 = MAGIC1;
 c00be84:	4a09      	ldr	r2, [pc, #36]	; (c00beac <mbedtls_memory_buffer_alloc_init+0x60>)
    heap.len = len;
 c00be86:	e9c3 4500 	strd	r4, r5, [r3]
    heap.first = (memory_header *)buf;
 c00be8a:	609c      	str	r4, [r3, #8]
    heap.first->magic1 = MAGIC1;
 c00be8c:	6022      	str	r2, [r4, #0]
    heap.first->magic2 = MAGIC2;
 c00be8e:	f1a2 2210 	sub.w	r2, r2, #268439552	; 0x10001000
    heap.first->size = len - sizeof( memory_header );
 c00be92:	3d20      	subs	r5, #32
    heap.first->magic2 = MAGIC2;
 c00be94:	f1a2 12ef 	sub.w	r2, r2, #15663343	; 0xef00ef
    heap.first->size = len - sizeof( memory_header );
 c00be98:	6065      	str	r5, [r4, #4]
    heap.first->magic2 = MAGIC2;
 c00be9a:	61e2      	str	r2, [r4, #28]
    heap.first_free = heap.first;
 c00be9c:	60dc      	str	r4, [r3, #12]
}
 c00be9e:	bd38      	pop	{r3, r4, r5, pc}
 c00bea0:	30030344 	.word	0x30030344
 c00bea4:	0c00bd3d 	.word	0x0c00bd3d
 c00bea8:	0c00bc21 	.word	0x0c00bc21
 c00beac:	ff00aa55 	.word	0xff00aa55

0c00beb0 <platform_calloc_uninit>:
static void *platform_calloc_uninit( size_t n, size_t size )
{
    ((void) n);
    ((void) size);
    return( NULL );
}
 c00beb0:	2000      	movs	r0, #0
 c00beb2:	4770      	bx	lr

0c00beb4 <platform_exit_uninit>:
 * Make dummy function to prevent NULL pointer dereferences
 */
static void platform_exit_uninit( int status )
{
    ((void) status);
}
 c00beb4:	4770      	bx	lr

0c00beb6 <platform_free_uninit>:
 c00beb6:	4770      	bx	lr

0c00beb8 <mbedtls_calloc>:
    return (*mbedtls_calloc_func)( nmemb, size );
 c00beb8:	4b01      	ldr	r3, [pc, #4]	; (c00bec0 <mbedtls_calloc+0x8>)
 c00beba:	681b      	ldr	r3, [r3, #0]
 c00bebc:	4718      	bx	r3
 c00bebe:	bf00      	nop
 c00bec0:	300300d0 	.word	0x300300d0

0c00bec4 <mbedtls_free>:
    (*mbedtls_free_func)( ptr );
 c00bec4:	4b01      	ldr	r3, [pc, #4]	; (c00becc <mbedtls_free+0x8>)
 c00bec6:	681b      	ldr	r3, [r3, #0]
 c00bec8:	4718      	bx	r3
 c00beca:	bf00      	nop
 c00becc:	300300d8 	.word	0x300300d8

0c00bed0 <mbedtls_platform_set_calloc_free>:
    mbedtls_calloc_func = calloc_func;
 c00bed0:	4b02      	ldr	r3, [pc, #8]	; (c00bedc <mbedtls_platform_set_calloc_free+0xc>)
 c00bed2:	6018      	str	r0, [r3, #0]
    mbedtls_free_func = free_func;
 c00bed4:	4b02      	ldr	r3, [pc, #8]	; (c00bee0 <mbedtls_platform_set_calloc_free+0x10>)
}
 c00bed6:	2000      	movs	r0, #0
    mbedtls_free_func = free_func;
 c00bed8:	6019      	str	r1, [r3, #0]
}
 c00beda:	4770      	bx	lr
 c00bedc:	300300d0 	.word	0x300300d0
 c00bee0:	300300d8 	.word	0x300300d8

0c00bee4 <mbedtls_platform_zeroize>:
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
    memset_func( buf, 0, len );
 c00bee4:	4b02      	ldr	r3, [pc, #8]	; (c00bef0 <mbedtls_platform_zeroize+0xc>)
 c00bee6:	460a      	mov	r2, r1
 c00bee8:	681b      	ldr	r3, [r3, #0]
 c00beea:	2100      	movs	r1, #0
 c00beec:	4718      	bx	r3
 c00beee:	bf00      	nop
 c00bef0:	300300dc 	.word	0x300300dc

0c00bef4 <mbedtls_rsa_validate_crt>:
 * Check that RSA CRT parameters are in accordance with core parameters.
 */
int mbedtls_rsa_validate_crt( const mbedtls_mpi *P,  const mbedtls_mpi *Q,
                              const mbedtls_mpi *D,  const mbedtls_mpi *DP,
                              const mbedtls_mpi *DQ, const mbedtls_mpi *QP )
{
 c00bef4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c00bef8:	4699      	mov	r9, r3
 c00befa:	b087      	sub	sp, #28
 c00befc:	4604      	mov	r4, r0
 c00befe:	e9dd 760e 	ldrd	r7, r6, [sp, #56]	; 0x38
    int ret = 0;

    mbedtls_mpi K, L;
    mbedtls_mpi_init( &K );
 c00bf02:	4668      	mov	r0, sp
{
 c00bf04:	460d      	mov	r5, r1
 c00bf06:	4690      	mov	r8, r2
    mbedtls_mpi_init( &K );
 c00bf08:	f7fe fe27 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c00bf0c:	a803      	add	r0, sp, #12
 c00bf0e:	f7fe fe24 	bl	c00ab5a <mbedtls_mpi_init>

    /* Check that DP - D == 0 mod P - 1 */
    if( DP != NULL )
 c00bf12:	f1b9 0f00 	cmp.w	r9, #0
 c00bf16:	d104      	bne.n	c00bf22 <mbedtls_rsa_validate_crt+0x2e>
            goto cleanup;
        }
    }

    /* Check that DQ - D == 0 mod Q - 1 */
    if( DQ != NULL )
 c00bf18:	bb67      	cbnz	r7, c00bf74 <mbedtls_rsa_validate_crt+0x80>
            goto cleanup;
        }
    }

    /* Check that QP * Q - 1 == 0 mod P */
    if( QP != NULL )
 c00bf1a:	2e00      	cmp	r6, #0
 c00bf1c:	d145      	bne.n	c00bfaa <mbedtls_rsa_validate_crt+0xb6>
{
 c00bf1e:	2400      	movs	r4, #0
 c00bf20:	e001      	b.n	c00bf26 <mbedtls_rsa_validate_crt+0x32>
        if( P == NULL )
 c00bf22:	b954      	cbnz	r4, c00bf3a <mbedtls_rsa_validate_crt+0x46>
{
 c00bf24:	4c34      	ldr	r4, [pc, #208]	; (c00bff8 <mbedtls_rsa_validate_crt+0x104>)
        ret != MBEDTLS_ERR_RSA_BAD_INPUT_DATA )
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
    }

    mbedtls_mpi_free( &K );
 c00bf26:	4668      	mov	r0, sp
 c00bf28:	f7fe fe1d 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c00bf2c:	a803      	add	r0, sp, #12
 c00bf2e:	f7fe fe1a 	bl	c00ab66 <mbedtls_mpi_free>

    return( ret );
}
 c00bf32:	4620      	mov	r0, r4
 c00bf34:	b007      	add	sp, #28
 c00bf36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1 ) );
 c00bf3a:	2201      	movs	r2, #1
 c00bf3c:	4621      	mov	r1, r4
 c00bf3e:	4668      	mov	r0, sp
 c00bf40:	f7ff f93d 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00bf44:	2800      	cmp	r0, #0
 c00bf46:	d14d      	bne.n	c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DP, D ) );
 c00bf48:	4642      	mov	r2, r8
 c00bf4a:	4649      	mov	r1, r9
 c00bf4c:	a803      	add	r0, sp, #12
 c00bf4e:	f7ff f913 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00bf52:	2800      	cmp	r0, #0
 c00bf54:	d146      	bne.n	c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 c00bf56:	a903      	add	r1, sp, #12
 c00bf58:	466a      	mov	r2, sp
 c00bf5a:	4608      	mov	r0, r1
 c00bf5c:	f7ff fb71 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00bf60:	2800      	cmp	r0, #0
 c00bf62:	d13f      	bne.n	c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 c00bf64:	4601      	mov	r1, r0
 c00bf66:	a803      	add	r0, sp, #12
 c00bf68:	f7ff f82f 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00bf6c:	2800      	cmp	r0, #0
 c00bf6e:	d0d3      	beq.n	c00bf18 <mbedtls_rsa_validate_crt+0x24>
{
 c00bf70:	4c22      	ldr	r4, [pc, #136]	; (c00bffc <mbedtls_rsa_validate_crt+0x108>)
 c00bf72:	e7d8      	b.n	c00bf26 <mbedtls_rsa_validate_crt+0x32>
        if( Q == NULL )
 c00bf74:	2d00      	cmp	r5, #0
 c00bf76:	d0d5      	beq.n	c00bf24 <mbedtls_rsa_validate_crt+0x30>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1 ) );
 c00bf78:	2201      	movs	r2, #1
 c00bf7a:	4629      	mov	r1, r5
 c00bf7c:	4668      	mov	r0, sp
 c00bf7e:	f7ff f91e 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00bf82:	bb78      	cbnz	r0, c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &L, DQ, D ) );
 c00bf84:	4642      	mov	r2, r8
 c00bf86:	4639      	mov	r1, r7
 c00bf88:	a803      	add	r0, sp, #12
 c00bf8a:	f7ff f8f5 	bl	c00b178 <mbedtls_mpi_sub_mpi>
 c00bf8e:	bb48      	cbnz	r0, c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &L, &L, &K ) );
 c00bf90:	a903      	add	r1, sp, #12
 c00bf92:	466a      	mov	r2, sp
 c00bf94:	4608      	mov	r0, r1
 c00bf96:	f7ff fb54 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00bf9a:	bb18      	cbnz	r0, c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        if( mbedtls_mpi_cmp_int( &L, 0 ) != 0 )
 c00bf9c:	4601      	mov	r1, r0
 c00bf9e:	a803      	add	r0, sp, #12
 c00bfa0:	f7ff f813 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00bfa4:	2800      	cmp	r0, #0
 c00bfa6:	d1e3      	bne.n	c00bf70 <mbedtls_rsa_validate_crt+0x7c>
 c00bfa8:	e7b7      	b.n	c00bf1a <mbedtls_rsa_validate_crt+0x26>
        if( P == NULL || Q == NULL )
 c00bfaa:	2c00      	cmp	r4, #0
 c00bfac:	d0ba      	beq.n	c00bf24 <mbedtls_rsa_validate_crt+0x30>
 c00bfae:	2d00      	cmp	r5, #0
 c00bfb0:	d0b8      	beq.n	c00bf24 <mbedtls_rsa_validate_crt+0x30>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, QP, Q ) );
 c00bfb2:	462a      	mov	r2, r5
 c00bfb4:	4631      	mov	r1, r6
 c00bfb6:	4668      	mov	r0, sp
 c00bfb8:	f7ff f917 	bl	c00b1ea <mbedtls_mpi_mul_mpi>
 c00bfbc:	b990      	cbnz	r0, c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c00bfbe:	2201      	movs	r2, #1
 c00bfc0:	4669      	mov	r1, sp
 c00bfc2:	4668      	mov	r0, sp
 c00bfc4:	f7ff f8fb 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00bfc8:	b960      	cbnz	r0, c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, P ) );
 c00bfca:	4622      	mov	r2, r4
 c00bfcc:	4669      	mov	r1, sp
 c00bfce:	4668      	mov	r0, sp
 c00bfd0:	f7ff fb37 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00bfd4:	b930      	cbnz	r0, c00bfe4 <mbedtls_rsa_validate_crt+0xf0>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c00bfd6:	4601      	mov	r1, r0
 c00bfd8:	4668      	mov	r0, sp
 c00bfda:	f7fe fff6 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00bfde:	2800      	cmp	r0, #0
 c00bfe0:	d1c6      	bne.n	c00bf70 <mbedtls_rsa_validate_crt+0x7c>
 c00bfe2:	e79c      	b.n	c00bf1e <mbedtls_rsa_validate_crt+0x2a>
    if( ret != 0 &&
 c00bfe4:	f510 4f84 	cmn.w	r0, #16896	; 0x4200
 c00bfe8:	d0c2      	beq.n	c00bf70 <mbedtls_rsa_validate_crt+0x7c>
        ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED &&
 c00bfea:	f510 4f81 	cmn.w	r0, #16512	; 0x4080
 c00bfee:	d099      	beq.n	c00bf24 <mbedtls_rsa_validate_crt+0x30>
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c00bff0:	f5a0 4484 	sub.w	r4, r0, #16896	; 0x4200
 c00bff4:	e797      	b.n	c00bf26 <mbedtls_rsa_validate_crt+0x32>
 c00bff6:	bf00      	nop
 c00bff8:	ffffbf80 	.word	0xffffbf80
 c00bffc:	ffffbe00 	.word	0xffffbe00

0c00c000 <mbedtls_rsa_validate_params>:
int mbedtls_rsa_validate_params( const mbedtls_mpi *N, const mbedtls_mpi *P,
                                 const mbedtls_mpi *Q, const mbedtls_mpi *D,
                                 const mbedtls_mpi *E,
                                 int (*f_rng)(void *, unsigned char *, size_t),
                                 void *p_rng )
{
 c00c000:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c00c004:	4688      	mov	r8, r1
 c00c006:	b087      	sub	sp, #28
 c00c008:	4606      	mov	r6, r0
    int ret = 0;
    mbedtls_mpi K, L;

    mbedtls_mpi_init( &K );
 c00c00a:	4668      	mov	r0, sp
{
 c00c00c:	4691      	mov	r9, r2
 c00c00e:	461d      	mov	r5, r3
 c00c010:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    mbedtls_mpi_init( &K );
 c00c012:	f7fe fda2 	bl	c00ab5a <mbedtls_mpi_init>
    mbedtls_mpi_init( &L );
 c00c016:	a803      	add	r0, sp, #12
 c00c018:	f7fe fd9f 	bl	c00ab5a <mbedtls_mpi_init>

    /*
     * Step 2: Check that 1 < N = P * Q
     */

    if( P != NULL && Q != NULL && N != NULL )
 c00c01c:	f1b8 0f00 	cmp.w	r8, #0
 c00c020:	d078      	beq.n	c00c114 <mbedtls_rsa_validate_params+0x114>
 c00c022:	f1b9 0f00 	cmp.w	r9, #0
 c00c026:	f000 80a8 	beq.w	c00c17a <mbedtls_rsa_validate_params+0x17a>
 c00c02a:	2e00      	cmp	r6, #0
 c00c02c:	d15d      	bne.n	c00c0ea <mbedtls_rsa_validate_params+0xea>

    /*
     * Step 4: Check that D, E are inverse modulo P-1 and Q-1
     */

    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c00c02e:	2d00      	cmp	r5, #0
 c00c030:	f000 8092 	beq.w	c00c158 <mbedtls_rsa_validate_params+0x158>
 c00c034:	2f00      	cmp	r7, #0
 c00c036:	f000 808f 	beq.w	c00c158 <mbedtls_rsa_validate_params+0x158>
    {
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c00c03a:	2101      	movs	r1, #1
 c00c03c:	4640      	mov	r0, r8
 c00c03e:	f7fe ffc4 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00c042:	2800      	cmp	r0, #0
 c00c044:	dd4f      	ble.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
            mbedtls_mpi_cmp_int( Q, 1 ) <= 0 )
 c00c046:	2101      	movs	r1, #1
 c00c048:	4648      	mov	r0, r9
 c00c04a:	f7fe ffbe 	bl	c00afca <mbedtls_mpi_cmp_int>
        if( mbedtls_mpi_cmp_int( P, 1 ) <= 0 ||
 c00c04e:	2800      	cmp	r0, #0
 c00c050:	dd49      	ble.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
            goto cleanup;
        }

        /* Compute DE-1 mod P-1 */
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 c00c052:	463a      	mov	r2, r7
 c00c054:	4629      	mov	r1, r5
 c00c056:	4668      	mov	r0, sp
 c00c058:	f7ff f8c7 	bl	c00b1ea <mbedtls_mpi_mul_mpi>
 c00c05c:	4604      	mov	r4, r0
 c00c05e:	2800      	cmp	r0, #0
 c00c060:	d17b      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c00c062:	2201      	movs	r2, #1
 c00c064:	4669      	mov	r1, sp
 c00c066:	4668      	mov	r0, sp
 c00c068:	f7ff f8a9 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00c06c:	4604      	mov	r4, r0
 c00c06e:	2800      	cmp	r0, #0
 c00c070:	d173      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, P, 1 ) );
 c00c072:	2201      	movs	r2, #1
 c00c074:	4641      	mov	r1, r8
 c00c076:	a803      	add	r0, sp, #12
 c00c078:	f7ff f8a1 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00c07c:	4604      	mov	r4, r0
 c00c07e:	2800      	cmp	r0, #0
 c00c080:	d16b      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c00c082:	aa03      	add	r2, sp, #12
 c00c084:	4669      	mov	r1, sp
 c00c086:	4668      	mov	r0, sp
 c00c088:	f7ff fadb 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00c08c:	4604      	mov	r4, r0
 c00c08e:	2800      	cmp	r0, #0
 c00c090:	d163      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c00c092:	4601      	mov	r1, r0
 c00c094:	4668      	mov	r0, sp
 c00c096:	f7fe ff98 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00c09a:	bb20      	cbnz	r0, c00c0e6 <mbedtls_rsa_validate_params+0xe6>
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
            goto cleanup;
        }

        /* Compute DE-1 mod Q-1 */
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, D, E ) );
 c00c09c:	463a      	mov	r2, r7
 c00c09e:	4629      	mov	r1, r5
 c00c0a0:	4668      	mov	r0, sp
 c00c0a2:	f7ff f8a2 	bl	c00b1ea <mbedtls_mpi_mul_mpi>
 c00c0a6:	4604      	mov	r4, r0
 c00c0a8:	2800      	cmp	r0, #0
 c00c0aa:	d156      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, &K, 1 ) );
 c00c0ac:	2201      	movs	r2, #1
 c00c0ae:	4669      	mov	r1, sp
 c00c0b0:	4668      	mov	r0, sp
 c00c0b2:	f7ff f884 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00c0b6:	4604      	mov	r4, r0
 c00c0b8:	2800      	cmp	r0, #0
 c00c0ba:	d14e      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &L, Q, 1 ) );
 c00c0bc:	2201      	movs	r2, #1
 c00c0be:	4649      	mov	r1, r9
 c00c0c0:	a803      	add	r0, sp, #12
 c00c0c2:	f7ff f87c 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00c0c6:	4604      	mov	r4, r0
 c00c0c8:	2800      	cmp	r0, #0
 c00c0ca:	d146      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c00c0cc:	aa03      	add	r2, sp, #12
 c00c0ce:	4669      	mov	r1, sp
 c00c0d0:	4668      	mov	r0, sp
 c00c0d2:	f7ff fab6 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00c0d6:	4604      	mov	r4, r0
 c00c0d8:	2800      	cmp	r0, #0
 c00c0da:	d13e      	bne.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        if( mbedtls_mpi_cmp_int( &K, 0 ) != 0 )
 c00c0dc:	4601      	mov	r1, r0
 c00c0de:	4668      	mov	r0, sp
 c00c0e0:	f7fe ff73 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00c0e4:	b3c0      	cbz	r0, c00c158 <mbedtls_rsa_validate_params+0x158>
        {
            ret = MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c00c0e6:	4c26      	ldr	r4, [pc, #152]	; (c00c180 <mbedtls_rsa_validate_params+0x180>)
            goto cleanup;
 c00c0e8:	e037      	b.n	c00c15a <mbedtls_rsa_validate_params+0x15a>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &K, P, Q ) );
 c00c0ea:	464a      	mov	r2, r9
 c00c0ec:	4641      	mov	r1, r8
 c00c0ee:	4668      	mov	r0, sp
 c00c0f0:	f7ff f87b 	bl	c00b1ea <mbedtls_mpi_mul_mpi>
 c00c0f4:	4604      	mov	r4, r0
 c00c0f6:	bb80      	cbnz	r0, c00c15a <mbedtls_rsa_validate_params+0x15a>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 c00c0f8:	2101      	movs	r1, #1
 c00c0fa:	4630      	mov	r0, r6
 c00c0fc:	f7fe ff65 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00c100:	2800      	cmp	r0, #0
 c00c102:	ddf0      	ble.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
            mbedtls_mpi_cmp_mpi( &K, N ) != 0 )
 c00c104:	4631      	mov	r1, r6
 c00c106:	4668      	mov	r0, sp
 c00c108:	f7fe ff1f 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
        if( mbedtls_mpi_cmp_int( N, 1 )  <= 0 ||
 c00c10c:	2800      	cmp	r0, #0
 c00c10e:	d1ea      	bne.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
    if( N != NULL && D != NULL && E != NULL )
 c00c110:	b915      	cbnz	r5, c00c118 <mbedtls_rsa_validate_params+0x118>
 c00c112:	e01d      	b.n	c00c150 <mbedtls_rsa_validate_params+0x150>
 c00c114:	b306      	cbz	r6, c00c158 <mbedtls_rsa_validate_params+0x158>
 c00c116:	b1fd      	cbz	r5, c00c158 <mbedtls_rsa_validate_params+0x158>
 c00c118:	b1bf      	cbz	r7, c00c14a <mbedtls_rsa_validate_params+0x14a>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c00c11a:	2101      	movs	r1, #1
 c00c11c:	4628      	mov	r0, r5
 c00c11e:	f7fe ff54 	bl	c00afca <mbedtls_mpi_cmp_int>
 c00c122:	2800      	cmp	r0, #0
 c00c124:	dddf      	ble.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c00c126:	2101      	movs	r1, #1
 c00c128:	4638      	mov	r0, r7
 c00c12a:	f7fe ff4e 	bl	c00afca <mbedtls_mpi_cmp_int>
        if ( mbedtls_mpi_cmp_int( D, 1 ) <= 0 ||
 c00c12e:	2800      	cmp	r0, #0
 c00c130:	ddd9      	ble.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c00c132:	4631      	mov	r1, r6
 c00c134:	4628      	mov	r0, r5
 c00c136:	f7fe ff08 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_int( E, 1 ) <= 0 ||
 c00c13a:	2800      	cmp	r0, #0
 c00c13c:	dad3      	bge.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
             mbedtls_mpi_cmp_mpi( E, N ) >= 0 )
 c00c13e:	4631      	mov	r1, r6
 c00c140:	4638      	mov	r0, r7
 c00c142:	f7fe ff02 	bl	c00af4a <mbedtls_mpi_cmp_mpi>
             mbedtls_mpi_cmp_mpi( D, N ) >= 0 ||
 c00c146:	2800      	cmp	r0, #0
 c00c148:	dacd      	bge.n	c00c0e6 <mbedtls_rsa_validate_params+0xe6>
    if( P != NULL && Q != NULL && D != NULL && E != NULL )
 c00c14a:	f1b8 0f00 	cmp.w	r8, #0
 c00c14e:	d003      	beq.n	c00c158 <mbedtls_rsa_validate_params+0x158>
 c00c150:	f1b9 0f00 	cmp.w	r9, #0
 c00c154:	f47f af6b 	bne.w	c00c02e <mbedtls_rsa_validate_params+0x2e>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &K, &K, &L ) );
 c00c158:	2400      	movs	r4, #0
        }
    }

cleanup:

    mbedtls_mpi_free( &K );
 c00c15a:	4668      	mov	r0, sp
 c00c15c:	f7fe fd03 	bl	c00ab66 <mbedtls_mpi_free>
    mbedtls_mpi_free( &L );
 c00c160:	a803      	add	r0, sp, #12
 c00c162:	f7fe fd00 	bl	c00ab66 <mbedtls_mpi_free>

    /* Wrap MPI error codes by RSA check failure error code */
    if( ret != 0 && ret != MBEDTLS_ERR_RSA_KEY_CHECK_FAILED )
 c00c166:	b124      	cbz	r4, c00c172 <mbedtls_rsa_validate_params+0x172>
 c00c168:	f514 4f84 	cmn.w	r4, #16896	; 0x4200
 c00c16c:	d001      	beq.n	c00c172 <mbedtls_rsa_validate_params+0x172>
    {
        ret += MBEDTLS_ERR_RSA_KEY_CHECK_FAILED;
 c00c16e:	f5a4 4484 	sub.w	r4, r4, #16896	; 0x4200
    }

    return( ret );
}
 c00c172:	4620      	mov	r0, r4
 c00c174:	b007      	add	sp, #28
 c00c176:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if( N != NULL && D != NULL && E != NULL )
 c00c17a:	2e00      	cmp	r6, #0
 c00c17c:	d1c8      	bne.n	c00c110 <mbedtls_rsa_validate_params+0x110>
 c00c17e:	e7eb      	b.n	c00c158 <mbedtls_rsa_validate_params+0x158>
 c00c180:	ffffbe00 	.word	0xffffbe00

0c00c184 <mbedtls_rsa_deduce_crt>:

int mbedtls_rsa_deduce_crt( const mbedtls_mpi *P, const mbedtls_mpi *Q,
                            const mbedtls_mpi *D, mbedtls_mpi *DP,
                            mbedtls_mpi *DQ, mbedtls_mpi *QP )
{
 c00c184:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 c00c188:	469a      	mov	sl, r3
 c00c18a:	e9dd 850c 	ldrd	r8, r5, [sp, #48]	; 0x30
 c00c18e:	4607      	mov	r7, r0
    int ret = 0;
    mbedtls_mpi K;
    mbedtls_mpi_init( &K );
 c00c190:	a801      	add	r0, sp, #4
{
 c00c192:	460e      	mov	r6, r1
 c00c194:	4691      	mov	r9, r2
    mbedtls_mpi_init( &K );
 c00c196:	f7fe fce0 	bl	c00ab5a <mbedtls_mpi_init>

    /* DP = D mod P-1 */
    if( DP != NULL )
 c00c19a:	f1ba 0f00 	cmp.w	sl, #0
 c00c19e:	d105      	bne.n	c00c1ac <mbedtls_rsa_deduce_crt+0x28>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
    }

    /* DQ = D mod Q-1 */
    if( DQ != NULL )
 c00c1a0:	f1b8 0f00 	cmp.w	r8, #0
 c00c1a4:	d118      	bne.n	c00c1d8 <mbedtls_rsa_deduce_crt+0x54>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
    }

    /* QP = Q^{-1} mod P */
    if( QP != NULL )
 c00c1a6:	bb45      	cbnz	r5, c00c1fa <mbedtls_rsa_deduce_crt+0x76>
    {
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
    }

cleanup:
 c00c1a8:	462c      	mov	r4, r5
 c00c1aa:	e00e      	b.n	c00c1ca <mbedtls_rsa_deduce_crt+0x46>
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, P, 1  ) );
 c00c1ac:	2201      	movs	r2, #1
 c00c1ae:	4639      	mov	r1, r7
 c00c1b0:	a801      	add	r0, sp, #4
 c00c1b2:	f7ff f804 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00c1b6:	4604      	mov	r4, r0
 c00c1b8:	b938      	cbnz	r0, c00c1ca <mbedtls_rsa_deduce_crt+0x46>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DP, D, &K ) );
 c00c1ba:	aa01      	add	r2, sp, #4
 c00c1bc:	4649      	mov	r1, r9
 c00c1be:	4650      	mov	r0, sl
 c00c1c0:	f7ff fa3f 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00c1c4:	4604      	mov	r4, r0
 c00c1c6:	2800      	cmp	r0, #0
 c00c1c8:	d0ea      	beq.n	c00c1a0 <mbedtls_rsa_deduce_crt+0x1c>
    mbedtls_mpi_free( &K );
 c00c1ca:	a801      	add	r0, sp, #4
 c00c1cc:	f7fe fccb 	bl	c00ab66 <mbedtls_mpi_free>

    return( ret );
}
 c00c1d0:	4620      	mov	r0, r4
 c00c1d2:	b004      	add	sp, #16
 c00c1d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &K, Q, 1  ) );
 c00c1d8:	2201      	movs	r2, #1
 c00c1da:	4631      	mov	r1, r6
 c00c1dc:	a801      	add	r0, sp, #4
 c00c1de:	f7fe ffee 	bl	c00b1be <mbedtls_mpi_sub_int>
 c00c1e2:	4604      	mov	r4, r0
 c00c1e4:	2800      	cmp	r0, #0
 c00c1e6:	d1f0      	bne.n	c00c1ca <mbedtls_rsa_deduce_crt+0x46>
        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( DQ, D, &K ) );
 c00c1e8:	aa01      	add	r2, sp, #4
 c00c1ea:	4649      	mov	r1, r9
 c00c1ec:	4640      	mov	r0, r8
 c00c1ee:	f7ff fa28 	bl	c00b642 <mbedtls_mpi_mod_mpi>
 c00c1f2:	4604      	mov	r4, r0
 c00c1f4:	2800      	cmp	r0, #0
 c00c1f6:	d0d6      	beq.n	c00c1a6 <mbedtls_rsa_deduce_crt+0x22>
 c00c1f8:	e7e7      	b.n	c00c1ca <mbedtls_rsa_deduce_crt+0x46>
        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( QP, Q, P ) );
 c00c1fa:	463a      	mov	r2, r7
 c00c1fc:	4631      	mov	r1, r6
 c00c1fe:	4628      	mov	r0, r5
 c00c200:	f7ff fad5 	bl	c00b7ae <mbedtls_mpi_inv_mod>
 c00c204:	4604      	mov	r4, r0
cleanup:
 c00c206:	e7e0      	b.n	c00c1ca <mbedtls_rsa_deduce_crt+0x46>

0c00c208 <mbedtls_sha256_ret>:
 */
int mbedtls_sha256_ret( const unsigned char *input,
                        size_t ilen,
                        unsigned char output[32],
                        int is224 )
{
 c00c208:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00c20a:	461c      	mov	r4, r3
 c00c20c:	b0dd      	sub	sp, #372	; 0x174
 c00c20e:	4606      	mov	r6, r0

    SHA256_VALIDATE_RET( is224 == 0 || is224 == 1 );
    SHA256_VALIDATE_RET( ilen == 0 || input != NULL );
    SHA256_VALIDATE_RET( (unsigned char *)output != NULL );

    mbedtls_sha256_init( &ctx );
 c00c210:	4668      	mov	r0, sp
{
 c00c212:	460f      	mov	r7, r1
 c00c214:	4615      	mov	r5, r2
    mbedtls_sha256_init( &ctx );
 c00c216:	f7f8 fac5 	bl	c0047a4 <mbedtls_sha256_init>

    if( ( ret = mbedtls_sha256_starts_ret( &ctx, is224 ) ) != 0 )
 c00c21a:	4621      	mov	r1, r4
 c00c21c:	4668      	mov	r0, sp
 c00c21e:	f7f8 fae9 	bl	c0047f4 <mbedtls_sha256_starts_ret>
 c00c222:	4604      	mov	r4, r0
 c00c224:	b958      	cbnz	r0, c00c23e <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_update_ret( &ctx, input, ilen ) ) != 0 )
 c00c226:	463a      	mov	r2, r7
 c00c228:	4631      	mov	r1, r6
 c00c22a:	4668      	mov	r0, sp
 c00c22c:	f7f8 fb07 	bl	c00483e <mbedtls_sha256_update_ret>
 c00c230:	4604      	mov	r4, r0
 c00c232:	b920      	cbnz	r0, c00c23e <mbedtls_sha256_ret+0x36>
        goto exit;

    if( ( ret = mbedtls_sha256_finish_ret( &ctx, output ) ) != 0 )
 c00c234:	4629      	mov	r1, r5
 c00c236:	4668      	mov	r0, sp
 c00c238:	f7f8 fb50 	bl	c0048dc <mbedtls_sha256_finish_ret>
 c00c23c:	4604      	mov	r4, r0
        goto exit;

exit:
    mbedtls_sha256_free( &ctx );
 c00c23e:	4668      	mov	r0, sp
 c00c240:	f7f8 fac8 	bl	c0047d4 <mbedtls_sha256_free>

    return( ret );
}
 c00c244:	4620      	mov	r0, r4
 c00c246:	b05d      	add	sp, #372	; 0x174
 c00c248:	bdf0      	pop	{r4, r5, r6, r7, pc}

0c00c24a <boot_secure_memequal>:
 *              so should not be considered a drop-in replacement.
 *
 * @return      0 if memory regions are equal.
 */
uint32_t boot_secure_memequal(const void *s1, const void *s2, size_t n)
{
 c00c24a:	b570      	push	{r4, r5, r6, lr}
 c00c24c:	4605      	mov	r5, r0
    size_t i;
    uint8_t *s1_p = (uint8_t*) s1;
    uint8_t *s2_p = (uint8_t*) s2;
    uint32_t ret = 0;
 c00c24e:	2000      	movs	r0, #0

    for (i = 0; i < n; i++) {
 c00c250:	4603      	mov	r3, r0
 c00c252:	4293      	cmp	r3, r2
 c00c254:	d100      	bne.n	c00c258 <boot_secure_memequal+0xe>
        ret |= (s1_p[i] ^ s2_p[i]);
    }

    return ret;
}
 c00c256:	bd70      	pop	{r4, r5, r6, pc}
        ret |= (s1_p[i] ^ s2_p[i]);
 c00c258:	5cec      	ldrb	r4, [r5, r3]
 c00c25a:	5cce      	ldrb	r6, [r1, r3]
    for (i = 0; i < n; i++) {
 c00c25c:	3301      	adds	r3, #1
        ret |= (s1_p[i] ^ s2_p[i]);
 c00c25e:	4074      	eors	r4, r6
 c00c260:	4320      	orrs	r0, r4
 c00c262:	e7f6      	b.n	c00c252 <boot_secure_memequal+0x8>

0c00c264 <boot_magic_compatible_check>:
 *                              0 otherwise.
 */
int
boot_magic_compatible_check(uint8_t tbl_val, uint8_t val)
{
    switch (tbl_val) {
 c00c264:	2804      	cmp	r0, #4
 c00c266:	d00a      	beq.n	c00c27e <boot_magic_compatible_check+0x1a>
 c00c268:	2805      	cmp	r0, #5
 c00c26a:	d104      	bne.n	c00c276 <boot_magic_compatible_check+0x12>
    case BOOT_MAGIC_ANY:
        return 1;

    case BOOT_MAGIC_NOTGOOD:
        return val != BOOT_MAGIC_GOOD;
 c00c26c:	f111 30ff 	adds.w	r0, r1, #4294967295
 c00c270:	bf18      	it	ne
 c00c272:	2001      	movne	r0, #1
 c00c274:	4770      	bx	lr

    default:
        return tbl_val == val;
 c00c276:	1a43      	subs	r3, r0, r1
 c00c278:	4258      	negs	r0, r3
 c00c27a:	4158      	adcs	r0, r3
 c00c27c:	4770      	bx	lr
        return 1;
 c00c27e:	2001      	movs	r0, #1
    }
}
 c00c280:	4770      	bx	lr

0c00c282 <boot_magic_off>:
}

uint32_t
boot_magic_off(const struct flash_area *fap)
{
    return fap->fa_size - BOOT_MAGIC_SZ;
 c00c282:	6880      	ldr	r0, [r0, #8]
}
 c00c284:	3810      	subs	r0, #16
 c00c286:	4770      	bx	lr

0c00c288 <boot_read_swap_state>:
#endif

int
boot_read_swap_state(const struct flash_area *fap,
                     struct boot_swap_state *state)
{
 c00c288:	b530      	push	{r4, r5, lr}
 c00c28a:	460c      	mov	r4, r1
    return fap->fa_size - BOOT_MAGIC_SZ;
 c00c28c:	6881      	ldr	r1, [r0, #8]
{
 c00c28e:	b087      	sub	sp, #28
    uint32_t off;
    uint8_t swap_info;
    int rc;

    off = boot_magic_off(fap);
    rc = flash_area_read_is_empty(fap, off, magic, BOOT_MAGIC_SZ);
 c00c290:	2310      	movs	r3, #16
 c00c292:	aa02      	add	r2, sp, #8
 c00c294:	3910      	subs	r1, #16
{
 c00c296:	4605      	mov	r5, r0
    rc = flash_area_read_is_empty(fap, off, magic, BOOT_MAGIC_SZ);
 c00c298:	f001 fdc4 	bl	c00de24 <flash_area_read_is_empty>
    if (rc < 0) {
 c00c29c:	2800      	cmp	r0, #0
 c00c29e:	db0d      	blt.n	c00c2bc <boot_read_swap_state+0x34>
        return BOOT_EFLASH;
    }
    if (rc == 1) {
 c00c2a0:	2801      	cmp	r0, #1
 c00c2a2:	d10d      	bne.n	c00c2c0 <boot_read_swap_state+0x38>
        state->magic = BOOT_MAGIC_UNSET;
 c00c2a4:	2303      	movs	r3, #3
    } else {
        state->magic = boot_magic_decode(magic);
 c00c2a6:	7023      	strb	r3, [r4, #0]
    return boot_copy_done_off(fap) - BOOT_MAX_ALIGN;
 c00c2a8:	68a9      	ldr	r1, [r5, #8]
    }

    off = boot_swap_info_off(fap);
    rc = flash_area_read_is_empty(fap, off, &swap_info, sizeof swap_info);
 c00c2aa:	2301      	movs	r3, #1
 c00c2ac:	f10d 0207 	add.w	r2, sp, #7
 c00c2b0:	3928      	subs	r1, #40	; 0x28
 c00c2b2:	4628      	mov	r0, r5
 c00c2b4:	f001 fdb6 	bl	c00de24 <flash_area_read_is_empty>
    if (rc < 0) {
 c00c2b8:	2800      	cmp	r0, #0
 c00c2ba:	da0b      	bge.n	c00c2d4 <boot_read_swap_state+0x4c>
        return BOOT_EFLASH;
 c00c2bc:	2001      	movs	r0, #1
 c00c2be:	e034      	b.n	c00c32a <boot_read_swap_state+0xa2>
    if (boot_secure_memequal(magic, boot_img_magic, BOOT_MAGIC_SZ) == 0) {
 c00c2c0:	2210      	movs	r2, #16
 c00c2c2:	4921      	ldr	r1, [pc, #132]	; (c00c348 <boot_read_swap_state+0xc0>)
 c00c2c4:	a802      	add	r0, sp, #8
 c00c2c6:	f7ff ffc0 	bl	c00c24a <boot_secure_memequal>
    return BOOT_MAGIC_BAD;
 c00c2ca:	2800      	cmp	r0, #0
 c00c2cc:	bf0c      	ite	eq
 c00c2ce:	2301      	moveq	r3, #1
 c00c2d0:	2302      	movne	r3, #2
 c00c2d2:	e7e8      	b.n	c00c2a6 <boot_read_swap_state+0x1e>
        return BOOT_EFLASH;
    }

    /* Extract the swap type and image number */
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c00c2d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);

    if (rc == 1 || state->swap_type > BOOT_SWAP_TYPE_REVERT) {
 c00c2d8:	2801      	cmp	r0, #1
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c00c2da:	f003 020f 	and.w	r2, r3, #15
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
 c00c2de:	ea4f 1313 	mov.w	r3, r3, lsr #4
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
 c00c2e2:	7062      	strb	r2, [r4, #1]
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
 c00c2e4:	7123      	strb	r3, [r4, #4]
    if (rc == 1 || state->swap_type > BOOT_SWAP_TYPE_REVERT) {
 c00c2e6:	d001      	beq.n	c00c2ec <boot_read_swap_state+0x64>
 c00c2e8:	2a04      	cmp	r2, #4
 c00c2ea:	d903      	bls.n	c00c2f4 <boot_read_swap_state+0x6c>
        state->swap_type = BOOT_SWAP_TYPE_NONE;
 c00c2ec:	2301      	movs	r3, #1
 c00c2ee:	7063      	strb	r3, [r4, #1]
        state->image_num = 0;
 c00c2f0:	2300      	movs	r3, #0
 c00c2f2:	7123      	strb	r3, [r4, #4]
    return boot_image_ok_off(fap) - BOOT_MAX_ALIGN;
 c00c2f4:	68a9      	ldr	r1, [r5, #8]
    }

    off = boot_copy_done_off(fap);
    rc = flash_area_read_is_empty(fap, off, &state->copy_done,
 c00c2f6:	2301      	movs	r3, #1
 c00c2f8:	1ca2      	adds	r2, r4, #2
 c00c2fa:	3920      	subs	r1, #32
 c00c2fc:	4628      	mov	r0, r5
 c00c2fe:	f001 fd91 	bl	c00de24 <flash_area_read_is_empty>
            sizeof state->copy_done);
    if (rc < 0) {
 c00c302:	2800      	cmp	r0, #0
 c00c304:	dbda      	blt.n	c00c2bc <boot_read_swap_state+0x34>
        return BOOT_EFLASH;
    }
    if (rc == 1) {
 c00c306:	2801      	cmp	r0, #1
 c00c308:	d111      	bne.n	c00c32e <boot_read_swap_state+0xa6>
        state->copy_done = BOOT_FLAG_UNSET;
 c00c30a:	2303      	movs	r3, #3
    } else {
        state->copy_done = boot_flag_decode(state->copy_done);
 c00c30c:	70a3      	strb	r3, [r4, #2]
    return boot_magic_off(fap) - BOOT_MAX_ALIGN;
 c00c30e:	68a9      	ldr	r1, [r5, #8]
    }

    off = boot_image_ok_off(fap);
    rc = flash_area_read_is_empty(fap, off, &state->image_ok,
 c00c310:	2301      	movs	r3, #1
 c00c312:	1ce2      	adds	r2, r4, #3
 c00c314:	3918      	subs	r1, #24
 c00c316:	4628      	mov	r0, r5
 c00c318:	f001 fd84 	bl	c00de24 <flash_area_read_is_empty>
                                  sizeof state->image_ok);
    if (rc < 0) {
 c00c31c:	2800      	cmp	r0, #0
 c00c31e:	dbcd      	blt.n	c00c2bc <boot_read_swap_state+0x34>
        return BOOT_EFLASH;
    }
    if (rc == 1) {
 c00c320:	2801      	cmp	r0, #1
 c00c322:	d10a      	bne.n	c00c33a <boot_read_swap_state+0xb2>
        state->image_ok = BOOT_FLAG_UNSET;
 c00c324:	2303      	movs	r3, #3
    } else {
        state->image_ok = boot_flag_decode(state->image_ok);
    }

    return 0;
 c00c326:	2000      	movs	r0, #0
        state->image_ok = boot_flag_decode(state->image_ok);
 c00c328:	70e3      	strb	r3, [r4, #3]
}
 c00c32a:	b007      	add	sp, #28
 c00c32c:	bd30      	pop	{r4, r5, pc}
    if (flag != BOOT_FLAG_SET) {
 c00c32e:	78a3      	ldrb	r3, [r4, #2]
    return BOOT_FLAG_SET;
 c00c330:	2b01      	cmp	r3, #1
 c00c332:	bf14      	ite	ne
 c00c334:	2302      	movne	r3, #2
 c00c336:	2301      	moveq	r3, #1
 c00c338:	e7e8      	b.n	c00c30c <boot_read_swap_state+0x84>
    if (flag != BOOT_FLAG_SET) {
 c00c33a:	78e3      	ldrb	r3, [r4, #3]
    return BOOT_FLAG_SET;
 c00c33c:	2b01      	cmp	r3, #1
 c00c33e:	bf14      	ite	ne
 c00c340:	2302      	movne	r3, #2
 c00c342:	2301      	moveq	r3, #1
 c00c344:	e7ef      	b.n	c00c326 <boot_read_swap_state+0x9e>
 c00c346:	bf00      	nop
 c00c348:	0c01022c 	.word	0x0c01022c

0c00c34c <boot_read_swap_state_by_id>:
/**
 * Reads the image trailer from the scratch area.
 */
int
boot_read_swap_state_by_id(int flash_area_id, struct boot_swap_state *state)
{
 c00c34c:	b513      	push	{r0, r1, r4, lr}
 c00c34e:	460c      	mov	r4, r1
    const struct flash_area *fap;
    int rc;

    rc = flash_area_open(flash_area_id, &fap);
 c00c350:	b2c0      	uxtb	r0, r0
 c00c352:	a901      	add	r1, sp, #4
 c00c354:	f001 fc98 	bl	c00dc88 <flash_area_open>
    if (rc != 0) {
 c00c358:	b950      	cbnz	r0, c00c370 <boot_read_swap_state_by_id+0x24>
        return BOOT_EFLASH;
    }

    rc = boot_read_swap_state(fap, state);
 c00c35a:	4621      	mov	r1, r4
 c00c35c:	9801      	ldr	r0, [sp, #4]
 c00c35e:	f7ff ff93 	bl	c00c288 <boot_read_swap_state>
 c00c362:	4604      	mov	r4, r0
    flash_area_close(fap);
 c00c364:	9801      	ldr	r0, [sp, #4]
 c00c366:	f001 fcad 	bl	c00dcc4 <flash_area_close>
    return rc;
}
 c00c36a:	4620      	mov	r0, r4
 c00c36c:	b002      	add	sp, #8
 c00c36e:	bd10      	pop	{r4, pc}
        return BOOT_EFLASH;
 c00c370:	2401      	movs	r4, #1
 c00c372:	e7fa      	b.n	c00c36a <boot_read_swap_state_by_id+0x1e>

0c00c374 <boot_swap_type_multi>:
}
#endif

int
boot_swap_type_multi(int image_index)
{
 c00c374:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    struct boot_swap_state primary_slot;
    struct boot_swap_state secondary_slot;
    int rc;
    size_t i;

    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c00c378:	4604      	mov	r4, r0
 c00c37a:	b158      	cbz	r0, c00c394 <boot_swap_type_multi+0x20>
 c00c37c:	2801      	cmp	r0, #1
 c00c37e:	bf0c      	ite	eq
 c00c380:	2002      	moveq	r0, #2
 c00c382:	20ff      	movne	r0, #255	; 0xff
 c00c384:	4669      	mov	r1, sp
 c00c386:	f7ff ffe1 	bl	c00c34c <boot_read_swap_state_by_id>
                                    &primary_slot);
    if (rc) {
 c00c38a:	b128      	cbz	r0, c00c398 <boot_swap_type_multi+0x24>
        return BOOT_SWAP_TYPE_PANIC;
 c00c38c:	20ff      	movs	r0, #255	; 0xff
        }
    }

    BOOT_LOG_INF("Swap type: none");
    return BOOT_SWAP_TYPE_NONE;
}
 c00c38e:	b004      	add	sp, #16
 c00c390:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c00c394:	2001      	movs	r0, #1
 c00c396:	e7f5      	b.n	c00c384 <boot_swap_type_multi+0x10>
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY(image_index),
 c00c398:	2c00      	cmp	r4, #0
 c00c39a:	d038      	beq.n	c00c40e <boot_swap_type_multi+0x9a>
 c00c39c:	2c01      	cmp	r4, #1
 c00c39e:	bf0c      	ite	eq
 c00c3a0:	2004      	moveq	r0, #4
 c00c3a2:	20ff      	movne	r0, #255	; 0xff
 c00c3a4:	a902      	add	r1, sp, #8
 c00c3a6:	f7ff ffd1 	bl	c00c34c <boot_read_swap_state_by_id>
    if (rc) {
 c00c3aa:	2800      	cmp	r0, #0
 c00c3ac:	d1ee      	bne.n	c00c38c <boot_swap_type_multi+0x18>
                table->copy_done_primary_slot == primary_slot.copy_done)) {
 c00c3ae:	4602      	mov	r2, r0
        if (boot_magic_compatible_check(table->magic_primary_slot,
 c00c3b0:	f89d 6000 	ldrb.w	r6, [sp]
            boot_magic_compatible_check(table->magic_secondary_slot,
 c00c3b4:	f89d 7008 	ldrb.w	r7, [sp, #8]
                table->image_ok_primary_slot == primary_slot.image_ok) &&
 c00c3b8:	f89d 8003 	ldrb.w	r8, [sp, #3]
                table->image_ok_secondary_slot == secondary_slot.image_ok) &&
 c00c3bc:	f89d 900b 	ldrb.w	r9, [sp, #11]
                table->copy_done_primary_slot == primary_slot.copy_done)) {
 c00c3c0:	f89d a002 	ldrb.w	sl, [sp, #2]
 c00c3c4:	4d1d      	ldr	r5, [pc, #116]	; (c00c43c <boot_swap_type_multi+0xc8>)
        if (boot_magic_compatible_check(table->magic_primary_slot,
 c00c3c6:	4631      	mov	r1, r6
 c00c3c8:	5ca8      	ldrb	r0, [r5, r2]
 c00c3ca:	18ac      	adds	r4, r5, r2
 c00c3cc:	f7ff ff4a 	bl	c00c264 <boot_magic_compatible_check>
 c00c3d0:	b308      	cbz	r0, c00c416 <boot_swap_type_multi+0xa2>
            boot_magic_compatible_check(table->magic_secondary_slot,
 c00c3d2:	4639      	mov	r1, r7
 c00c3d4:	7860      	ldrb	r0, [r4, #1]
 c00c3d6:	f7ff ff45 	bl	c00c264 <boot_magic_compatible_check>
                                        primary_slot.magic) &&
 c00c3da:	b1e0      	cbz	r0, c00c416 <boot_swap_type_multi+0xa2>
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
 c00c3dc:	78a3      	ldrb	r3, [r4, #2]
                                        secondary_slot.magic) &&
 c00c3de:	2b04      	cmp	r3, #4
 c00c3e0:	d001      	beq.n	c00c3e6 <boot_swap_type_multi+0x72>
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
 c00c3e2:	4543      	cmp	r3, r8
 c00c3e4:	d117      	bne.n	c00c416 <boot_swap_type_multi+0xa2>
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
 c00c3e6:	78e3      	ldrb	r3, [r4, #3]
                table->image_ok_primary_slot == primary_slot.image_ok) &&
 c00c3e8:	2b04      	cmp	r3, #4
 c00c3ea:	d001      	beq.n	c00c3f0 <boot_swap_type_multi+0x7c>
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
 c00c3ec:	454b      	cmp	r3, r9
 c00c3ee:	d112      	bne.n	c00c416 <boot_swap_type_multi+0xa2>
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
 c00c3f0:	7923      	ldrb	r3, [r4, #4]
                table->image_ok_secondary_slot == secondary_slot.image_ok) &&
 c00c3f2:	2b04      	cmp	r3, #4
 c00c3f4:	d10d      	bne.n	c00c412 <boot_swap_type_multi+0x9e>
            BOOT_LOG_INF("Swap type: %s",
 c00c3f6:	7963      	ldrb	r3, [r4, #5]
 c00c3f8:	2b02      	cmp	r3, #2
 c00c3fa:	d114      	bne.n	c00c426 <boot_swap_type_multi+0xb2>
 c00c3fc:	4910      	ldr	r1, [pc, #64]	; (c00c440 <boot_swap_type_multi+0xcc>)
 c00c3fe:	4811      	ldr	r0, [pc, #68]	; (c00c444 <boot_swap_type_multi+0xd0>)
 c00c400:	f001 fef4 	bl	c00e1ec <iprintf>
            if (table->swap_type != BOOT_SWAP_TYPE_TEST &&
 c00c404:	7960      	ldrb	r0, [r4, #5]
 c00c406:	1e83      	subs	r3, r0, #2
 c00c408:	2b02      	cmp	r3, #2
 c00c40a:	d9c0      	bls.n	c00c38e <boot_swap_type_multi+0x1a>
 c00c40c:	e7be      	b.n	c00c38c <boot_swap_type_multi+0x18>
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY(image_index),
 c00c40e:	2003      	movs	r0, #3
 c00c410:	e7c8      	b.n	c00c3a4 <boot_swap_type_multi+0x30>
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
 c00c412:	4553      	cmp	r3, sl
 c00c414:	d0ef      	beq.n	c00c3f6 <boot_swap_type_multi+0x82>
 c00c416:	3206      	adds	r2, #6
    for (i = 0; i < BOOT_SWAP_TABLES_COUNT; i++) {
 c00c418:	2a12      	cmp	r2, #18
 c00c41a:	d1d4      	bne.n	c00c3c6 <boot_swap_type_multi+0x52>
    BOOT_LOG_INF("Swap type: none");
 c00c41c:	480a      	ldr	r0, [pc, #40]	; (c00c448 <boot_swap_type_multi+0xd4>)
 c00c41e:	f001 ff59 	bl	c00e2d4 <puts>
    return BOOT_SWAP_TYPE_NONE;
 c00c422:	2001      	movs	r0, #1
 c00c424:	e7b3      	b.n	c00c38e <boot_swap_type_multi+0x1a>
            BOOT_LOG_INF("Swap type: %s",
 c00c426:	2b03      	cmp	r3, #3
 c00c428:	d005      	beq.n	c00c436 <boot_swap_type_multi+0xc2>
 c00c42a:	4908      	ldr	r1, [pc, #32]	; (c00c44c <boot_swap_type_multi+0xd8>)
 c00c42c:	4a08      	ldr	r2, [pc, #32]	; (c00c450 <boot_swap_type_multi+0xdc>)
 c00c42e:	2b04      	cmp	r3, #4
 c00c430:	bf18      	it	ne
 c00c432:	4611      	movne	r1, r2
 c00c434:	e7e3      	b.n	c00c3fe <boot_swap_type_multi+0x8a>
 c00c436:	4907      	ldr	r1, [pc, #28]	; (c00c454 <boot_swap_type_multi+0xe0>)
 c00c438:	e7e1      	b.n	c00c3fe <boot_swap_type_multi+0x8a>
 c00c43a:	bf00      	nop
 c00c43c:	0c01023c 	.word	0x0c01023c
 c00c440:	0c010253 	.word	0x0c010253
 c00c444:	0c010271 	.word	0x0c010271
 c00c448:	0c010287 	.word	0x0c010287
 c00c44c:	0c01026a 	.word	0x0c01026a
 c00c450:	0c010258 	.word	0x0c010258
 c00c454:	0c01024e 	.word	0x0c01024e

0c00c458 <boot_enc_set_key>:
#endif

int
boot_enc_set_key(struct enc_key_data *enc_state, uint8_t slot,
        const struct boot_status *bs)
{
 c00c458:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    int rc;

#if defined(MCUBOOT_USE_MBED_TLS)
    mbedtls_aes_init(&enc_state[slot].aes);
 c00c45c:	f44f 759a 	mov.w	r5, #308	; 0x134
{
 c00c460:	4616      	mov	r6, r2
 c00c462:	4688      	mov	r8, r1
    mbedtls_aes_init(&enc_state[slot].aes);
 c00c464:	434d      	muls	r5, r1
 c00c466:	1944      	adds	r4, r0, r5
 c00c468:	3404      	adds	r4, #4
{
 c00c46a:	4607      	mov	r7, r0
    mbedtls_aes_init(&enc_state[slot].aes);
 c00c46c:	4620      	mov	r0, r4
 c00c46e:	f7f6 fcf5 	bl	c002e5c <mbedtls_aes_init>
    rc = mbedtls_aes_setkey_enc(&enc_state[slot].aes, bs->enckey[slot],
 c00c472:	eb06 1108 	add.w	r1, r6, r8, lsl #4
 c00c476:	2280      	movs	r2, #128	; 0x80
 c00c478:	310c      	adds	r1, #12
 c00c47a:	4620      	mov	r0, r4
 c00c47c:	f7f6 fcfd 	bl	c002e7a <mbedtls_aes_setkey_enc>
            BOOT_ENC_KEY_SIZE_BITS);
    if (rc) {
 c00c480:	b130      	cbz	r0, c00c490 <boot_enc_set_key+0x38>
        mbedtls_aes_free(&enc_state[slot].aes);
 c00c482:	4620      	mov	r0, r4
 c00c484:	f7f6 fcef 	bl	c002e66 <mbedtls_aes_free>
        return -1;
 c00c488:	f04f 30ff 	mov.w	r0, #4294967295
#endif

    enc_state[slot].valid = 1;

    return 0;
}
 c00c48c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    enc_state[slot].valid = 1;
 c00c490:	2301      	movs	r3, #1
 c00c492:	557b      	strb	r3, [r7, r5]
    return 0;
 c00c494:	e7fa      	b.n	c00c48c <boot_enc_set_key+0x34>
	...

0c00c498 <boot_enc_decrypt>:
 * @param buf An encryption TLV read from flash (build time fixed length)
 * @param enckey An AES-128 key sized buffer to store to plain key.
 */
int
boot_enc_decrypt(const uint8_t *buf, uint8_t *enckey)
{
 c00c498:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00c49c:	b0b4      	sub	sp, #208	; 0xd0
#endif
    int rc = -1;

#if defined(MCUBOOT_ENCRYPT_RSA)

    mbedtls_rsa_init(&rsa, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256);
 c00c49e:	2206      	movs	r2, #6
{
 c00c4a0:	4607      	mov	r7, r0
 c00c4a2:	460d      	mov	r5, r1
    mbedtls_rsa_init(&rsa, MBEDTLS_RSA_PKCS_V21, MBEDTLS_MD_SHA256);
 c00c4a4:	a809      	add	r0, sp, #36	; 0x24
 c00c4a6:	2101      	movs	r1, #1
 c00c4a8:	f7f7 fe06 	bl	c0040b8 <mbedtls_rsa_init>

    cp = (uint8_t *)bootutil_enc_key.key;
 c00c4ac:	4b62      	ldr	r3, [pc, #392]	; (c00c638 <boot_enc_decrypt+0x1a0>)
    if (mbedtls_asn1_get_tag(p, end, &len,
 c00c4ae:	ae08      	add	r6, sp, #32
    cp = (uint8_t *)bootutil_enc_key.key;
 c00c4b0:	681c      	ldr	r4, [r3, #0]
    cpend = cp + *bootutil_enc_key.len;
 c00c4b2:	685b      	ldr	r3, [r3, #4]
    cp = (uint8_t *)bootutil_enc_key.key;
 c00c4b4:	9407      	str	r4, [sp, #28]
    cpend = cp + *bootutil_enc_key.len;
 c00c4b6:	681b      	ldr	r3, [r3, #0]
    if (mbedtls_asn1_get_tag(p, end, &len,
 c00c4b8:	4632      	mov	r2, r6
    cpend = cp + *bootutil_enc_key.len;
 c00c4ba:	441c      	add	r4, r3
    if (mbedtls_asn1_get_tag(p, end, &len,
 c00c4bc:	4621      	mov	r1, r4
 c00c4be:	2330      	movs	r3, #48	; 0x30
 c00c4c0:	a807      	add	r0, sp, #28
 c00c4c2:	f7fe f9f4 	bl	c00a8ae <mbedtls_asn1_get_tag>
 c00c4c6:	b140      	cbz	r0, c00c4da <boot_enc_decrypt+0x42>
        return -1;
 c00c4c8:	f04f 37ff 	mov.w	r7, #4294967295

    rc = parse_rsa_enckey(&rsa, &cp, cpend);
    if (rc) {
        mbedtls_rsa_free(&rsa);
 c00c4cc:	a809      	add	r0, sp, #36	; 0x24
 c00c4ce:	f7f8 f92f 	bl	c004730 <mbedtls_rsa_free>
    rc = 0;
#endif
#endif

    return rc;
}
 c00c4d2:	4638      	mov	r0, r7
 c00c4d4:	b034      	add	sp, #208	; 0xd0
 c00c4d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (*p + len != end) {
 c00c4da:	e9dd 3207 	ldrd	r3, r2, [sp, #28]
 c00c4de:	4413      	add	r3, r2
 c00c4e0:	429c      	cmp	r4, r3
 c00c4e2:	f040 80a6 	bne.w	c00c632 <boot_enc_decrypt+0x19a>
        mbedtls_asn1_get_int(p, end, &ctx->ver) != 0 ||
 c00c4e6:	aa09      	add	r2, sp, #36	; 0x24
 c00c4e8:	4621      	mov	r1, r4
 c00c4ea:	a807      	add	r0, sp, #28
 c00c4ec:	f7fe f9f3 	bl	c00a8d6 <mbedtls_asn1_get_int>
    if ( /* version */
 c00c4f0:	2800      	cmp	r0, #0
 c00c4f2:	f040 809b 	bne.w	c00c62c <boot_enc_decrypt+0x194>
        mbedtls_asn1_get_mpi(p, end, &ctx->N) != 0 ||
 c00c4f6:	aa0b      	add	r2, sp, #44	; 0x2c
 c00c4f8:	4621      	mov	r1, r4
 c00c4fa:	a807      	add	r0, sp, #28
 c00c4fc:	f7fe fa0f 	bl	c00a91e <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_int(p, end, &ctx->ver) != 0 ||
 c00c500:	2800      	cmp	r0, #0
 c00c502:	f040 8093 	bne.w	c00c62c <boot_enc_decrypt+0x194>
        mbedtls_asn1_get_mpi(p, end, &ctx->E) != 0 ||
 c00c506:	aa0e      	add	r2, sp, #56	; 0x38
 c00c508:	4621      	mov	r1, r4
 c00c50a:	a807      	add	r0, sp, #28
 c00c50c:	f7fe fa07 	bl	c00a91e <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->N) != 0 ||
 c00c510:	2800      	cmp	r0, #0
 c00c512:	f040 808b 	bne.w	c00c62c <boot_enc_decrypt+0x194>
        mbedtls_asn1_get_mpi(p, end, &ctx->D) != 0 ||
 c00c516:	aa11      	add	r2, sp, #68	; 0x44
 c00c518:	4621      	mov	r1, r4
 c00c51a:	a807      	add	r0, sp, #28
 c00c51c:	f7fe f9ff 	bl	c00a91e <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->E) != 0 ||
 c00c520:	2800      	cmp	r0, #0
 c00c522:	f040 8083 	bne.w	c00c62c <boot_enc_decrypt+0x194>
        mbedtls_asn1_get_mpi(p, end, &ctx->P) != 0 ||
 c00c526:	aa14      	add	r2, sp, #80	; 0x50
 c00c528:	4621      	mov	r1, r4
 c00c52a:	a807      	add	r0, sp, #28
 c00c52c:	f7fe f9f7 	bl	c00a91e <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->D) != 0 ||
 c00c530:	2800      	cmp	r0, #0
 c00c532:	d17b      	bne.n	c00c62c <boot_enc_decrypt+0x194>
        mbedtls_asn1_get_mpi(p, end, &ctx->Q) != 0) {
 c00c534:	aa17      	add	r2, sp, #92	; 0x5c
 c00c536:	4621      	mov	r1, r4
 c00c538:	a807      	add	r0, sp, #28
 c00c53a:	f7fe f9f0 	bl	c00a91e <mbedtls_asn1_get_mpi>
        mbedtls_asn1_get_mpi(p, end, &ctx->P) != 0 ||
 c00c53e:	2800      	cmp	r0, #0
 c00c540:	d174      	bne.n	c00c62c <boot_enc_decrypt+0x194>
    if (*p < end) {
 c00c542:	9b07      	ldr	r3, [sp, #28]
 c00c544:	429c      	cmp	r4, r3
 c00c546:	d920      	bls.n	c00c58a <boot_enc_decrypt+0xf2>
            mbedtls_asn1_get_mpi(p, end, &ctx->DP) != 0 ||
 c00c548:	aa1a      	add	r2, sp, #104	; 0x68
 c00c54a:	4621      	mov	r1, r4
 c00c54c:	a807      	add	r0, sp, #28
 c00c54e:	f7fe f9e6 	bl	c00a91e <mbedtls_asn1_get_mpi>
        if ( /* d mod (p-1) and d mod (q-1) */
 c00c552:	2800      	cmp	r0, #0
 c00c554:	d167      	bne.n	c00c626 <boot_enc_decrypt+0x18e>
            mbedtls_asn1_get_mpi(p, end, &ctx->DQ) != 0 ||
 c00c556:	aa1d      	add	r2, sp, #116	; 0x74
 c00c558:	4621      	mov	r1, r4
 c00c55a:	a807      	add	r0, sp, #28
 c00c55c:	f7fe f9df 	bl	c00a91e <mbedtls_asn1_get_mpi>
            mbedtls_asn1_get_mpi(p, end, &ctx->DP) != 0 ||
 c00c560:	2800      	cmp	r0, #0
 c00c562:	d160      	bne.n	c00c626 <boot_enc_decrypt+0x18e>
            mbedtls_asn1_get_mpi(p, end, &ctx->QP) != 0) {
 c00c564:	aa20      	add	r2, sp, #128	; 0x80
 c00c566:	4621      	mov	r1, r4
 c00c568:	a807      	add	r0, sp, #28
 c00c56a:	f7fe f9d8 	bl	c00a91e <mbedtls_asn1_get_mpi>
            mbedtls_asn1_get_mpi(p, end, &ctx->DQ) != 0 ||
 c00c56e:	2800      	cmp	r0, #0
 c00c570:	d159      	bne.n	c00c626 <boot_enc_decrypt+0x18e>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00c572:	a80b      	add	r0, sp, #44	; 0x2c
 c00c574:	f7fe fbc2 	bl	c00acfc <mbedtls_mpi_size>
 c00c578:	900a      	str	r0, [sp, #40]	; 0x28
    if (mbedtls_rsa_check_privkey(ctx) != 0) {
 c00c57a:	a809      	add	r0, sp, #36	; 0x24
 c00c57c:	f7f7 fdca 	bl	c004114 <mbedtls_rsa_check_privkey>
 c00c580:	4604      	mov	r4, r0
 c00c582:	b188      	cbz	r0, c00c5a8 <boot_enc_decrypt+0x110>
        return -6;
 c00c584:	f06f 0705 	mvn.w	r7, #5
 c00c588:	e7a0      	b.n	c00c4cc <boot_enc_decrypt+0x34>
        if (mbedtls_rsa_deduce_crt(&ctx->P, &ctx->Q, &ctx->D,
 c00c58a:	ab20      	add	r3, sp, #128	; 0x80
 c00c58c:	9301      	str	r3, [sp, #4]
 c00c58e:	ab1d      	add	r3, sp, #116	; 0x74
 c00c590:	9300      	str	r3, [sp, #0]
 c00c592:	aa11      	add	r2, sp, #68	; 0x44
 c00c594:	ab1a      	add	r3, sp, #104	; 0x68
 c00c596:	a917      	add	r1, sp, #92	; 0x5c
 c00c598:	a814      	add	r0, sp, #80	; 0x50
 c00c59a:	f7ff fdf3 	bl	c00c184 <mbedtls_rsa_deduce_crt>
 c00c59e:	2800      	cmp	r0, #0
 c00c5a0:	d0e7      	beq.n	c00c572 <boot_enc_decrypt+0xda>
            return -5;
 c00c5a2:	f06f 0704 	mvn.w	r7, #4
 c00c5a6:	e791      	b.n	c00c4cc <boot_enc_decrypt+0x34>
    rc = mbedtls_rsa_rsaes_oaep_decrypt(&rsa, NULL, NULL, MBEDTLS_RSA_PRIVATE,
 c00c5a8:	2310      	movs	r3, #16
 c00c5aa:	e9cd 6702 	strd	r6, r7, [sp, #8]
 c00c5ae:	4602      	mov	r2, r0
 c00c5b0:	4601      	mov	r1, r0
 c00c5b2:	e9cd 5304 	strd	r5, r3, [sp, #16]
 c00c5b6:	e9cd 0000 	strd	r0, r0, [sp]
 c00c5ba:	2301      	movs	r3, #1
 c00c5bc:	a809      	add	r0, sp, #36	; 0x24
 c00c5be:	f7f7 ffed 	bl	c00459c <mbedtls_rsa_rsaes_oaep_decrypt>
 c00c5c2:	4607      	mov	r7, r0
    mbedtls_rsa_free(&rsa);
 c00c5c4:	a809      	add	r0, sp, #36	; 0x24
 c00c5c6:	f7f8 f8b3 	bl	c004730 <mbedtls_rsa_free>
	olen = 0;
 c00c5ca:	4626      	mov	r6, r4
	{ BOOT_LOG_INF("%x, %x, %x, %x, %x, %x , %x ,%x,",
 c00c5cc:	f8df 806c 	ldr.w	r8, [pc, #108]	; c00c63c <boot_enc_decrypt+0x1a4>
	while(olen!=0)
 c00c5d0:	9c08      	ldr	r4, [sp, #32]
 c00c5d2:	2c00      	cmp	r4, #0
 c00c5d4:	f43f af7d 	beq.w	c00c4d2 <boot_enc_decrypt+0x3a>
	{ BOOT_LOG_INF("%x, %x, %x, %x, %x, %x , %x ,%x,",
 c00c5d8:	f1c4 0017 	rsb	r0, r4, #23
 c00c5dc:	5c28      	ldrb	r0, [r5, r0]
 c00c5de:	f1c4 0312 	rsb	r3, r4, #18
 c00c5e2:	9004      	str	r0, [sp, #16]
 c00c5e4:	f1c4 0016 	rsb	r0, r4, #22
 c00c5e8:	5c28      	ldrb	r0, [r5, r0]
 c00c5ea:	f1c4 0211 	rsb	r2, r4, #17
 c00c5ee:	9003      	str	r0, [sp, #12]
 c00c5f0:	f1c4 0015 	rsb	r0, r4, #21
 c00c5f4:	5c28      	ldrb	r0, [r5, r0]
 c00c5f6:	f1c4 0110 	rsb	r1, r4, #16
 c00c5fa:	9002      	str	r0, [sp, #8]
 c00c5fc:	f1c4 0014 	rsb	r0, r4, #20
 c00c600:	5c28      	ldrb	r0, [r5, r0]
 c00c602:	f1c4 0413 	rsb	r4, r4, #19
 c00c606:	9001      	str	r0, [sp, #4]
 c00c608:	5d28      	ldrb	r0, [r5, r4]
 c00c60a:	5ceb      	ldrb	r3, [r5, r3]
 c00c60c:	9000      	str	r0, [sp, #0]
 c00c60e:	5caa      	ldrb	r2, [r5, r2]
 c00c610:	5c69      	ldrb	r1, [r5, r1]
 c00c612:	4640      	mov	r0, r8
 c00c614:	f001 fdea 	bl	c00e1ec <iprintf>
	if (olen > 8)
 c00c618:	9b08      	ldr	r3, [sp, #32]
 c00c61a:	2b08      	cmp	r3, #8
	olen = olen -8;
 c00c61c:	bf86      	itte	hi
 c00c61e:	3b08      	subhi	r3, #8
 c00c620:	9308      	strhi	r3, [sp, #32]
	olen = 0;
 c00c622:	9608      	strls	r6, [sp, #32]
 c00c624:	e7d4      	b.n	c00c5d0 <boot_enc_decrypt+0x138>
            return -4;
 c00c626:	f06f 0703 	mvn.w	r7, #3
 c00c62a:	e74f      	b.n	c00c4cc <boot_enc_decrypt+0x34>
        return -3;
 c00c62c:	f06f 0702 	mvn.w	r7, #2
 c00c630:	e74c      	b.n	c00c4cc <boot_enc_decrypt+0x34>
        return -2;
 c00c632:	f06f 0701 	mvn.w	r7, #1
 c00c636:	e749      	b.n	c00c4cc <boot_enc_decrypt+0x34>
 c00c638:	0c0020a8 	.word	0x0c0020a8
 c00c63c:	0c01029e 	.word	0x0c01029e

0c00c640 <boot_enc_load>:
 */
int
boot_enc_load(struct enc_key_data *enc_state, int image_index,
        const struct image_header *hdr, const struct flash_area *fap,
        struct boot_status *bs)
{
 c00c640:	b5f0      	push	{r4, r5, r6, r7, lr}
 c00c642:	4607      	mov	r7, r0
 c00c644:	b0cb      	sub	sp, #300	; 0x12c
 c00c646:	4608      	mov	r0, r1
    uint8_t buf[EXPECTED_ENC_LEN];
#endif
    uint8_t slot;
    int rc;

    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c00c648:	7819      	ldrb	r1, [r3, #0]
{
 c00c64a:	4616      	mov	r6, r2
 c00c64c:	461c      	mov	r4, r3
    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c00c64e:	f001 fbc1 	bl	c00ddd4 <flash_area_id_to_multi_image_slot>
    if (rc < 0) {
 c00c652:	2800      	cmp	r0, #0
 c00c654:	db10      	blt.n	c00c678 <boot_enc_load+0x38>
        return rc;
    }
    slot = rc;

    /* Already loaded... */
    if (enc_state[slot].valid) {
 c00c656:	f44f 739a 	mov.w	r3, #308	; 0x134
 c00c65a:	b2c5      	uxtb	r5, r0
 c00c65c:	436b      	muls	r3, r5
 c00c65e:	5cfb      	ldrb	r3, [r7, r3]
 c00c660:	bb43      	cbnz	r3, c00c6b4 <boot_enc_load+0x74>
        return 1;
    }

    rc = bootutil_tlv_iter_begin(&it, hdr, fap, EXPECTED_ENC_TLV, false);
 c00c662:	9300      	str	r3, [sp, #0]
 c00c664:	4622      	mov	r2, r4
 c00c666:	2330      	movs	r3, #48	; 0x30
 c00c668:	4631      	mov	r1, r6
 c00c66a:	a804      	add	r0, sp, #16
 c00c66c:	f001 f914 	bl	c00d898 <bootutil_tlv_iter_begin>
    if (rc) {
 c00c670:	4603      	mov	r3, r0
 c00c672:	b118      	cbz	r0, c00c67c <boot_enc_load+0x3c>
        return -1;
 c00c674:	f04f 30ff 	mov.w	r0, #4294967295
    if (rc) {
        return -1;
    }

    return boot_enc_decrypt(buf, bs->enckey[slot]);
}
 c00c678:	b04b      	add	sp, #300	; 0x12c
 c00c67a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    rc = bootutil_tlv_iter_next(&it, &off, &len, NULL);
 c00c67c:	f10d 020a 	add.w	r2, sp, #10
 c00c680:	a903      	add	r1, sp, #12
 c00c682:	a804      	add	r0, sp, #16
 c00c684:	f001 f954 	bl	c00d930 <bootutil_tlv_iter_next>
    if (rc != 0) {
 c00c688:	2800      	cmp	r0, #0
 c00c68a:	d1f5      	bne.n	c00c678 <boot_enc_load+0x38>
    if (len != EXPECTED_ENC_LEN) {
 c00c68c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 c00c690:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 c00c694:	d1ee      	bne.n	c00c674 <boot_enc_load+0x34>
    rc = flash_area_read(fap, off, buf, EXPECTED_ENC_LEN);
 c00c696:	aa0a      	add	r2, sp, #40	; 0x28
 c00c698:	9903      	ldr	r1, [sp, #12]
 c00c69a:	4620      	mov	r0, r4
 c00c69c:	f001 fb14 	bl	c00dcc8 <flash_area_read>
    if (rc) {
 c00c6a0:	2800      	cmp	r0, #0
 c00c6a2:	d1e7      	bne.n	c00c674 <boot_enc_load+0x34>
    return boot_enc_decrypt(buf, bs->enckey[slot]);
 c00c6a4:	9950      	ldr	r1, [sp, #320]	; 0x140
 c00c6a6:	a80a      	add	r0, sp, #40	; 0x28
 c00c6a8:	eb01 1105 	add.w	r1, r1, r5, lsl #4
 c00c6ac:	310c      	adds	r1, #12
 c00c6ae:	f7ff fef3 	bl	c00c498 <boot_enc_decrypt>
 c00c6b2:	e7e1      	b.n	c00c678 <boot_enc_load+0x38>
        return 1;
 c00c6b4:	2001      	movs	r0, #1
 c00c6b6:	e7df      	b.n	c00c678 <boot_enc_load+0x38>

0c00c6b8 <boot_enc_valid>:

bool
boot_enc_valid(struct enc_key_data *enc_state, int image_index,
        const struct flash_area *fap)
{
 c00c6b8:	b510      	push	{r4, lr}
 c00c6ba:	4604      	mov	r4, r0
 c00c6bc:	4608      	mov	r0, r1
    int rc;

    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c00c6be:	7811      	ldrb	r1, [r2, #0]
 c00c6c0:	f001 fb88 	bl	c00ddd4 <flash_area_id_to_multi_image_slot>
    if (rc < 0) {
 c00c6c4:	2800      	cmp	r0, #0
 c00c6c6:	db07      	blt.n	c00c6d8 <boot_enc_valid+0x20>
        /* can't get proper slot number - skip encryption, */
        /* postpone the error for a upper layer */
        return false;
    }

    return enc_state[rc].valid;
 c00c6c8:	f44f 739a 	mov.w	r3, #308	; 0x134
 c00c6cc:	4358      	muls	r0, r3
 c00c6ce:	5c20      	ldrb	r0, [r4, r0]
 c00c6d0:	3000      	adds	r0, #0
 c00c6d2:	bf18      	it	ne
 c00c6d4:	2001      	movne	r0, #1
}
 c00c6d6:	bd10      	pop	{r4, pc}
        return false;
 c00c6d8:	2000      	movs	r0, #0
 c00c6da:	e7fc      	b.n	c00c6d6 <boot_enc_valid+0x1e>

0c00c6dc <boot_encrypt>:

void
boot_encrypt(struct enc_key_data *enc_state, int image_index,
        const struct flash_area *fap, uint32_t off, uint32_t sz,
        uint32_t blk_off, uint8_t *buf)
{
 c00c6dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c00c6e0:	b089      	sub	sp, #36	; 0x24
 c00c6e2:	4606      	mov	r6, r0
 c00c6e4:	e9dd 4911 	ldrd	r4, r9, [sp, #68]	; 0x44
 c00c6e8:	4608      	mov	r0, r1
    uint8_t u8;
    uint8_t nonce[16];
    uint8_t blk[16];
    int rc;

    memset(nonce, 0, 12);
 c00c6ea:	466f      	mov	r7, sp
 c00c6ec:	2100      	movs	r1, #0
 c00c6ee:	9100      	str	r1, [sp, #0]
 c00c6f0:	e9c7 1101 	strd	r1, r1, [r7, #4]
    off >>= 4;
    nonce[12] = (uint8_t)(off >> 24);
 c00c6f4:	0f19      	lsrs	r1, r3, #28
 c00c6f6:	f88d 100c 	strb.w	r1, [sp, #12]
    nonce[13] = (uint8_t)(off >> 16);
 c00c6fa:	0d19      	lsrs	r1, r3, #20
 c00c6fc:	f88d 100d 	strb.w	r1, [sp, #13]
    nonce[14] = (uint8_t)(off >> 8);
 c00c700:	0b19      	lsrs	r1, r3, #12
 c00c702:	f88d 100e 	strb.w	r1, [sp, #14]
    off >>= 4;
 c00c706:	091b      	lsrs	r3, r3, #4
    nonce[15] = (uint8_t)off;

    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c00c708:	7811      	ldrb	r1, [r2, #0]
    nonce[15] = (uint8_t)off;
 c00c70a:	f88d 300f 	strb.w	r3, [sp, #15]
    rc = flash_area_id_to_multi_image_slot(image_index, fap->fa_id);
 c00c70e:	f001 fb61 	bl	c00ddd4 <flash_area_id_to_multi_image_slot>
    if (rc < 0) {
 c00c712:	2800      	cmp	r0, #0
 c00c714:	db0a      	blt.n	c00c72c <boot_encrypt+0x50>
        assert(0);
        return;
    }

    enc = &enc_state[rc];
 c00c716:	f44f 739a 	mov.w	r3, #308	; 0x134
    assert(enc->valid == 1);
    for (i = 0; i < sz; i++) {
 c00c71a:	464d      	mov	r5, r9
    enc = &enc_state[rc];
 c00c71c:	fb03 6600 	mla	r6, r3, r0, r6
 c00c720:	9b10      	ldr	r3, [sp, #64]	; 0x40
        if (i == 0 || blk_off == 0) {
#if defined(MCUBOOT_USE_MBED_TLS)
            mbedtls_aes_crypt_ecb(&enc->aes, MBEDTLS_AES_ENCRYPT, nonce, blk);
 c00c722:	3604      	adds	r6, #4
 c00c724:	eb09 0803 	add.w	r8, r9, r3
    for (i = 0; i < sz; i++) {
 c00c728:	4545      	cmp	r5, r8
 c00c72a:	d102      	bne.n	c00c732 <boot_encrypt+0x56>

        u8 = *buf;
        *buf++ = u8 ^ blk[blk_off];
        blk_off = (blk_off + 1) & 0x0f;
    }
}
 c00c72c:	b009      	add	sp, #36	; 0x24
 c00c72e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (i == 0 || blk_off == 0) {
 c00c732:	454d      	cmp	r5, r9
 c00c734:	d000      	beq.n	c00c738 <boot_encrypt+0x5c>
 c00c736:	b974      	cbnz	r4, c00c756 <boot_encrypt+0x7a>
            mbedtls_aes_crypt_ecb(&enc->aes, MBEDTLS_AES_ENCRYPT, nonce, blk);
 c00c738:	463a      	mov	r2, r7
 c00c73a:	ab04      	add	r3, sp, #16
 c00c73c:	2101      	movs	r1, #1
 c00c73e:	4630      	mov	r0, r6
 c00c740:	f7f6 fbbd 	bl	c002ebe <mbedtls_aes_crypt_ecb>
 c00c744:	aa04      	add	r2, sp, #16
                if (++nonce[j - 1] != 0) {
 c00c746:	f812 3d01 	ldrb.w	r3, [r2, #-1]!
 c00c74a:	3301      	adds	r3, #1
 c00c74c:	b2db      	uxtb	r3, r3
 c00c74e:	7013      	strb	r3, [r2, #0]
 c00c750:	b90b      	cbnz	r3, c00c756 <boot_encrypt+0x7a>
            for (j = 16; j > 0; --j) {
 c00c752:	4297      	cmp	r7, r2
 c00c754:	d1f7      	bne.n	c00c746 <boot_encrypt+0x6a>
        *buf++ = u8 ^ blk[blk_off];
 c00c756:	aa08      	add	r2, sp, #32
 c00c758:	4422      	add	r2, r4
        u8 = *buf;
 c00c75a:	782b      	ldrb	r3, [r5, #0]
        *buf++ = u8 ^ blk[blk_off];
 c00c75c:	f812 2c10 	ldrb.w	r2, [r2, #-16]
        blk_off = (blk_off + 1) & 0x0f;
 c00c760:	3401      	adds	r4, #1
        *buf++ = u8 ^ blk[blk_off];
 c00c762:	4053      	eors	r3, r2
 c00c764:	f805 3b01 	strb.w	r3, [r5], #1
        blk_off = (blk_off + 1) & 0x0f;
 c00c768:	f004 040f 	and.w	r4, r4, #15
 c00c76c:	e7dc      	b.n	c00c728 <boot_encrypt+0x4c>

0c00c76e <boot_enc_zeroize>:
 * Clears encrypted state after use.
 */
void
boot_enc_zeroize(struct enc_key_data *enc_state)
{
    memset(enc_state, 0, sizeof(struct enc_key_data) * BOOT_NUM_SLOTS);
 c00c76e:	f44f 721a 	mov.w	r2, #616	; 0x268
 c00c772:	2100      	movs	r1, #0
 c00c774:	f001 bc89 	b.w	c00e08a <memset>

0c00c778 <bootutil_verify_sig>:
}

int
bootutil_verify_sig(uint8_t *hash, uint32_t hlen, uint8_t *sig, size_t slen,
  uint8_t key_id)
{
 c00c778:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00c77c:	4617      	mov	r7, r2
    mbedtls_rsa_context ctx;
    int rc;
    uint8_t *cp;
    uint8_t *end;

    mbedtls_rsa_init(&ctx, 0, 0);
 c00c77e:	2200      	movs	r2, #0
{
 c00c780:	f2ad 4db4 	subw	sp, sp, #1204	; 0x4b4
 c00c784:	4680      	mov	r8, r0
 c00c786:	4689      	mov	r9, r1
    mbedtls_rsa_init(&ctx, 0, 0);
 c00c788:	a80d      	add	r0, sp, #52	; 0x34
 c00c78a:	4611      	mov	r1, r2
{
 c00c78c:	f89d 54d8 	ldrb.w	r5, [sp, #1240]	; 0x4d8
 c00c790:	461e      	mov	r6, r3
    mbedtls_rsa_init(&ctx, 0, 0);
 c00c792:	f7f7 fc91 	bl	c0040b8 <mbedtls_rsa_init>

    cp = (uint8_t *)bootutil_keys[key_id].key;
 c00c796:	4b7e      	ldr	r3, [pc, #504]	; (c00c990 <bootutil_verify_sig+0x218>)
    if ((rc = mbedtls_asn1_get_tag(p, end, &len,
 c00c798:	a803      	add	r0, sp, #12
    cp = (uint8_t *)bootutil_keys[key_id].key;
 c00c79a:	f853 4035 	ldr.w	r4, [r3, r5, lsl #3]
    end = cp + *bootutil_keys[key_id].len;
 c00c79e:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
 c00c7a2:	685b      	ldr	r3, [r3, #4]
    cp = (uint8_t *)bootutil_keys[key_id].key;
 c00c7a4:	9403      	str	r4, [sp, #12]
    end = cp + *bootutil_keys[key_id].len;
 c00c7a6:	681b      	ldr	r3, [r3, #0]
    if ((rc = mbedtls_asn1_get_tag(p, end, &len,
 c00c7a8:	adcc      	add	r5, sp, #816	; 0x330
    end = cp + *bootutil_keys[key_id].len;
 c00c7aa:	441c      	add	r4, r3
    if ((rc = mbedtls_asn1_get_tag(p, end, &len,
 c00c7ac:	462a      	mov	r2, r5
 c00c7ae:	2330      	movs	r3, #48	; 0x30
 c00c7b0:	4621      	mov	r1, r4
 c00c7b2:	f7fe f87c 	bl	c00a8ae <mbedtls_asn1_get_tag>
 c00c7b6:	b110      	cbz	r0, c00c7be <bootutil_verify_sig+0x46>
        return -1;
 c00c7b8:	f04f 34ff 	mov.w	r4, #4294967295
 c00c7bc:	e0d4      	b.n	c00c968 <bootutil_verify_sig+0x1f0>
    if (*p + len != end) {
 c00c7be:	9b03      	ldr	r3, [sp, #12]
 c00c7c0:	682a      	ldr	r2, [r5, #0]
 c00c7c2:	4413      	add	r3, r2
 c00c7c4:	429c      	cmp	r4, r3
 c00c7c6:	f040 80e0 	bne.w	c00c98a <bootutil_verify_sig+0x212>
    if ((rc = mbedtls_asn1_get_mpi(p, end, &ctx->N)) != 0 ||
 c00c7ca:	aa0f      	add	r2, sp, #60	; 0x3c
 c00c7cc:	4621      	mov	r1, r4
 c00c7ce:	a803      	add	r0, sp, #12
 c00c7d0:	f7fe f8a5 	bl	c00a91e <mbedtls_asn1_get_mpi>
 c00c7d4:	2800      	cmp	r0, #0
 c00c7d6:	f040 80d5 	bne.w	c00c984 <bootutil_verify_sig+0x20c>
 c00c7da:	f10d 0b48 	add.w	fp, sp, #72	; 0x48
 c00c7de:	465a      	mov	r2, fp
 c00c7e0:	4621      	mov	r1, r4
 c00c7e2:	a803      	add	r0, sp, #12
 c00c7e4:	f7fe f89b 	bl	c00a91e <mbedtls_asn1_get_mpi>
 c00c7e8:	4682      	mov	sl, r0
 c00c7ea:	2800      	cmp	r0, #0
 c00c7ec:	f040 80ca 	bne.w	c00c984 <bootutil_verify_sig+0x20c>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00c7f0:	a80f      	add	r0, sp, #60	; 0x3c
 c00c7f2:	f7fe fa83 	bl	c00acfc <mbedtls_mpi_size>
    if (*p != end) {
 c00c7f6:	9b03      	ldr	r3, [sp, #12]
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00c7f8:	900e      	str	r0, [sp, #56]	; 0x38
    if (*p != end) {
 c00c7fa:	429c      	cmp	r4, r3
 c00c7fc:	f040 80bf 	bne.w	c00c97e <bootutil_verify_sig+0x206>
    rc = mbedtls_rsa_import(ctx, &ctx->N, NULL, NULL, NULL, &ctx->E);
 c00c800:	e9cd ab00 	strd	sl, fp, [sp]
 c00c804:	4653      	mov	r3, sl
 c00c806:	4652      	mov	r2, sl
 c00c808:	a90f      	add	r1, sp, #60	; 0x3c
 c00c80a:	a80d      	add	r0, sp, #52	; 0x34
 c00c80c:	f7f7 fc10 	bl	c004030 <mbedtls_rsa_import>
    if (rc != 0) {
 c00c810:	2800      	cmp	r0, #0
 c00c812:	f040 80b1 	bne.w	c00c978 <bootutil_verify_sig+0x200>
    rc = mbedtls_rsa_check_pubkey(ctx);
 c00c816:	a80d      	add	r0, sp, #52	; 0x34
 c00c818:	f7f7 fc58 	bl	c0040cc <mbedtls_rsa_check_pubkey>
    if (rc != 0) {
 c00c81c:	4604      	mov	r4, r0
 c00c81e:	2800      	cmp	r0, #0
 c00c820:	f040 80a0 	bne.w	c00c964 <bootutil_verify_sig+0x1ec>
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00c824:	a80f      	add	r0, sp, #60	; 0x3c
 c00c826:	f7fe fa69 	bl	c00acfc <mbedtls_mpi_size>

    rc = bootutil_parse_rsakey(&ctx, &cp, end);
    if (rc || slen != ctx.len) {
 c00c82a:	4286      	cmp	r6, r0
    ctx->len = mbedtls_mpi_size(&ctx->N);
 c00c82c:	900e      	str	r0, [sp, #56]	; 0x38
    if (rc || slen != ctx.len) {
 c00c82e:	f040 809b 	bne.w	c00c968 <bootutil_verify_sig+0x1f0>
    if (ctx->len != PSS_EMLEN || PSS_EMLEN > MBEDTLS_MPI_MAX_SIZE) {
 c00c832:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 c00c836:	d1bf      	bne.n	c00c7b8 <bootutil_verify_sig+0x40>
    if (hlen != PSS_HLEN) {
 c00c838:	f1b9 0f20 	cmp.w	r9, #32
 c00c83c:	d1bc      	bne.n	c00c7b8 <bootutil_verify_sig+0x40>
    if (mbedtls_rsa_public(ctx, sig, em)) {
 c00c83e:	462a      	mov	r2, r5
 c00c840:	4639      	mov	r1, r7
 c00c842:	a80d      	add	r0, sp, #52	; 0x34
 c00c844:	f7f7 fc9c 	bl	c004180 <mbedtls_rsa_public>
 c00c848:	4604      	mov	r4, r0
 c00c84a:	2800      	cmp	r0, #0
 c00c84c:	d1b4      	bne.n	c00c7b8 <bootutil_verify_sig+0x40>
    if (em[PSS_EMLEN - 1] != 0xbc) {
 c00c84e:	f895 30ff 	ldrb.w	r3, [r5, #255]	; 0xff
 c00c852:	2bbc      	cmp	r3, #188	; 0xbc
 c00c854:	d1b0      	bne.n	c00c7b8 <bootutil_verify_sig+0x40>
    uint8_t counter[4] = { 0, 0, 0, 0 };
 c00c856:	f10d 09e0 	add.w	r9, sp, #224	; 0xe0
    int count = PSS_MASK_LEN;
 c00c85a:	27df      	movs	r7, #223	; 0xdf
 c00c85c:	464e      	mov	r6, r9
    uint8_t counter[4] = { 0, 0, 0, 0 };
 c00c85e:	9004      	str	r0, [sp, #16]
    mbedtls_sha256_init(ctx);
 c00c860:	a870      	add	r0, sp, #448	; 0x1c0
 c00c862:	f7f7 ff9f 	bl	c0047a4 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c00c866:	2100      	movs	r1, #0
 c00c868:	a870      	add	r0, sp, #448	; 0x1c0
 c00c86a:	f7f7 ffc3 	bl	c0047f4 <mbedtls_sha256_starts_ret>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c00c86e:	2220      	movs	r2, #32
 c00c870:	f20d 410f 	addw	r1, sp, #1039	; 0x40f
 c00c874:	a870      	add	r0, sp, #448	; 0x1c0
 c00c876:	f7f7 ffe2 	bl	c00483e <mbedtls_sha256_update_ret>
 c00c87a:	2204      	movs	r2, #4
 c00c87c:	a904      	add	r1, sp, #16
 c00c87e:	a870      	add	r0, sp, #448	; 0x1c0
 c00c880:	f7f7 ffdd 	bl	c00483e <mbedtls_sha256_update_ret>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c00c884:	a905      	add	r1, sp, #20
 c00c886:	a870      	add	r0, sp, #448	; 0x1c0
 c00c888:	f7f8 f828 	bl	c0048dc <mbedtls_sha256_finish_ret>
        if (bytes > count)
 c00c88c:	2f1f      	cmp	r7, #31
 c00c88e:	bfd4      	ite	le
 c00c890:	46ba      	movle	sl, r7
 c00c892:	f04f 0a20 	movgt.w	sl, #32
        counter[3]++;
 c00c896:	f89d 3013 	ldrb.w	r3, [sp, #19]
        memcpy(mask, htmp, bytes);
 c00c89a:	4648      	mov	r0, r9
        counter[3]++;
 c00c89c:	3301      	adds	r3, #1
        memcpy(mask, htmp, bytes);
 c00c89e:	4652      	mov	r2, sl
 c00c8a0:	a905      	add	r1, sp, #20
        count -= bytes;
 c00c8a2:	eba7 070a 	sub.w	r7, r7, sl
        counter[3]++;
 c00c8a6:	f88d 3013 	strb.w	r3, [sp, #19]
        memcpy(mask, htmp, bytes);
 c00c8aa:	f001 fbca 	bl	c00e042 <memcpy>
    while (count > 0) {
 c00c8ae:	2f00      	cmp	r7, #0
        mask += bytes;
 c00c8b0:	44d1      	add	r9, sl
    while (count > 0) {
 c00c8b2:	dcd5      	bgt.n	c00c860 <bootutil_verify_sig+0xe8>
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c00c8b4:	2300      	movs	r3, #0
        db_mask[i] ^= em[i];
 c00c8b6:	5cf2      	ldrb	r2, [r6, r3]
 c00c8b8:	5ce9      	ldrb	r1, [r5, r3]
 c00c8ba:	404a      	eors	r2, r1
 c00c8bc:	54f2      	strb	r2, [r6, r3]
    for (i = 0; i < PSS_MASK_LEN; i++) {
 c00c8be:	3301      	adds	r3, #1
 c00c8c0:	2bdf      	cmp	r3, #223	; 0xdf
 c00c8c2:	d1f8      	bne.n	c00c8b6 <bootutil_verify_sig+0x13e>
    db_mask[0] &= 0x7F;
 c00c8c4:	7833      	ldrb	r3, [r6, #0]
 c00c8c6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 c00c8ca:	7033      	strb	r3, [r6, #0]
    for (i = 0; i < PSS_MASK_ZERO_COUNT; i++) {
 c00c8cc:	2300      	movs	r3, #0
        if (db_mask[i] != 0) {
 c00c8ce:	5cf7      	ldrb	r7, [r6, r3]
 c00c8d0:	2f00      	cmp	r7, #0
 c00c8d2:	f47f af71 	bne.w	c00c7b8 <bootutil_verify_sig+0x40>
    for (i = 0; i < PSS_MASK_ZERO_COUNT; i++) {
 c00c8d6:	3301      	adds	r3, #1
 c00c8d8:	2bbe      	cmp	r3, #190	; 0xbe
 c00c8da:	d1f8      	bne.n	c00c8ce <bootutil_verify_sig+0x156>
    if (db_mask[PSS_MASK_ONE_POS] != 1) {
 c00c8dc:	f896 30be 	ldrb.w	r3, [r6, #190]	; 0xbe
 c00c8e0:	2b01      	cmp	r3, #1
 c00c8e2:	f47f af69 	bne.w	c00c7b8 <bootutil_verify_sig+0x40>
    mbedtls_sha256_init(ctx);
 c00c8e6:	a870      	add	r0, sp, #448	; 0x1c0
 c00c8e8:	f7f7 ff5c 	bl	c0047a4 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c00c8ec:	4639      	mov	r1, r7
 c00c8ee:	a870      	add	r0, sp, #448	; 0x1c0
 c00c8f0:	f7f7 ff80 	bl	c0047f4 <mbedtls_sha256_starts_ret>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c00c8f4:	2208      	movs	r2, #8
 c00c8f6:	4927      	ldr	r1, [pc, #156]	; (c00c994 <bootutil_verify_sig+0x21c>)
 c00c8f8:	a870      	add	r0, sp, #448	; 0x1c0
 c00c8fa:	f7f7 ffa0 	bl	c00483e <mbedtls_sha256_update_ret>
 c00c8fe:	2220      	movs	r2, #32
 c00c900:	4641      	mov	r1, r8
 c00c902:	a870      	add	r0, sp, #448	; 0x1c0
 c00c904:	f7f7 ff9b 	bl	c00483e <mbedtls_sha256_update_ret>
 c00c908:	2220      	movs	r2, #32
 c00c90a:	f20d 119f 	addw	r1, sp, #415	; 0x19f
 c00c90e:	a870      	add	r0, sp, #448	; 0x1c0
 c00c910:	f7f7 ff95 	bl	c00483e <mbedtls_sha256_update_ret>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c00c914:	a905      	add	r1, sp, #20
 c00c916:	a870      	add	r0, sp, #448	; 0x1c0
 c00c918:	f7f7 ffe0 	bl	c0048dc <mbedtls_sha256_finish_ret>
    if (boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN) != 0) {
 c00c91c:	2220      	movs	r2, #32
 c00c91e:	f20d 410f 	addw	r1, sp, #1039	; 0x40f
 c00c922:	a805      	add	r0, sp, #20
 c00c924:	f7ff fc91 	bl	c00c24a <boot_secure_memequal>
 c00c928:	2800      	cmp	r0, #0
 c00c92a:	f47f af45 	bne.w	c00c7b8 <bootutil_verify_sig+0x40>
    if (ImageValidEnable == 1)
 c00c92e:	4b1a      	ldr	r3, [pc, #104]	; (c00c998 <bootutil_verify_sig+0x220>)
 c00c930:	781b      	ldrb	r3, [r3, #0]
 c00c932:	2b01      	cmp	r3, #1
 c00c934:	d118      	bne.n	c00c968 <bootutil_verify_sig+0x1f0>
        if (ImageValidIndex >= MCUBOOT_IMAGE_NUMBER)
 c00c936:	4e19      	ldr	r6, [pc, #100]	; (c00c99c <bootutil_verify_sig+0x224>)
 c00c938:	7833      	ldrb	r3, [r6, #0]
 c00c93a:	2b01      	cmp	r3, #1
 c00c93c:	f63f af3c 	bhi.w	c00c7b8 <bootutil_verify_sig+0x40>
        em[PSS_HASH_OFFSET] ^= IMAGE_VALID;
 c00c940:	f895 30df 	ldrb.w	r3, [r5, #223]	; 0xdf
        ImageValidStatus[ImageValidIndex++] = boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN);
 c00c944:	2220      	movs	r2, #32
        em[PSS_HASH_OFFSET] ^= IMAGE_VALID;
 c00c946:	f083 0355 	eor.w	r3, r3, #85	; 0x55
        ImageValidStatus[ImageValidIndex++] = boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN);
 c00c94a:	f20d 410f 	addw	r1, sp, #1039	; 0x40f
 c00c94e:	a805      	add	r0, sp, #20
        em[PSS_HASH_OFFSET] ^= IMAGE_VALID;
 c00c950:	f885 30df 	strb.w	r3, [r5, #223]	; 0xdf
        ImageValidStatus[ImageValidIndex++] = boot_secure_memequal(h2, &em[PSS_HASH_OFFSET], PSS_HLEN);
 c00c954:	f7ff fc79 	bl	c00c24a <boot_secure_memequal>
 c00c958:	7833      	ldrb	r3, [r6, #0]
 c00c95a:	1c5a      	adds	r2, r3, #1
 c00c95c:	7032      	strb	r2, [r6, #0]
 c00c95e:	4a10      	ldr	r2, [pc, #64]	; (c00c9a0 <bootutil_verify_sig+0x228>)
 c00c960:	54d0      	strb	r0, [r2, r3]
 c00c962:	e001      	b.n	c00c968 <bootutil_verify_sig+0x1f0>
        return -6;
 c00c964:	f06f 0405 	mvn.w	r4, #5
        mbedtls_rsa_free(&ctx);
        return rc;
    }
    rc = bootutil_cmp_rsasig(&ctx, hash, hlen, sig);
    mbedtls_rsa_free(&ctx);
 c00c968:	a80d      	add	r0, sp, #52	; 0x34
 c00c96a:	f7f7 fee1 	bl	c004730 <mbedtls_rsa_free>

    return rc;
}
 c00c96e:	4620      	mov	r0, r4
 c00c970:	f20d 4db4 	addw	sp, sp, #1204	; 0x4b4
 c00c974:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return -5;
 c00c978:	f06f 0404 	mvn.w	r4, #4
 c00c97c:	e7f4      	b.n	c00c968 <bootutil_verify_sig+0x1f0>
        return -4;
 c00c97e:	f06f 0403 	mvn.w	r4, #3
 c00c982:	e7f1      	b.n	c00c968 <bootutil_verify_sig+0x1f0>
        return -3;
 c00c984:	f06f 0402 	mvn.w	r4, #2
 c00c988:	e7ee      	b.n	c00c968 <bootutil_verify_sig+0x1f0>
        return -2;
 c00c98a:	f06f 0401 	mvn.w	r4, #1
 c00c98e:	e7eb      	b.n	c00c968 <bootutil_verify_sig+0x1f0>
 c00c990:	0c002560 	.word	0x0c002560
 c00c994:	0c0102c7 	.word	0x0c0102c7
 c00c998:	30030174 	.word	0x30030174
 c00c99c:	30030175 	.word	0x30030175
 c00c9a0:	30030004 	.word	0x30030004

0c00c9a4 <bootutil_get_img_security_cnt>:
 */
int32_t
bootutil_get_img_security_cnt(struct image_header *hdr,
                              const struct flash_area *fap,
                              uint32_t *img_security_cnt)
{
 c00c9a4:	b530      	push	{r4, r5, lr}
 c00c9a6:	460c      	mov	r4, r1
 c00c9a8:	b08b      	sub	sp, #44	; 0x2c
 c00c9aa:	4615      	mov	r5, r2
    struct image_tlv_iter it;
    uint32_t off;
    uint16_t len;
    int32_t rc;

    if ((hdr == NULL) ||
 c00c9ac:	4601      	mov	r1, r0
 c00c9ae:	b320      	cbz	r0, c00c9fa <bootutil_get_img_security_cnt+0x56>
 c00c9b0:	b31c      	cbz	r4, c00c9fa <bootutil_get_img_security_cnt+0x56>
        (fap == NULL) ||
 c00c9b2:	b312      	cbz	r2, c00c9fa <bootutil_get_img_security_cnt+0x56>
        /* Invalid parameter. */
        return BOOT_EBADARGS;
    }

    /* The security counter TLV is in the protected part of the TLV area. */
    if (hdr->ih_protect_tlv_size == 0) {
 c00c9b4:	8943      	ldrh	r3, [r0, #10]
 c00c9b6:	b913      	cbnz	r3, c00c9be <bootutil_get_img_security_cnt+0x1a>
        return BOOT_EBADIMAGE;
 c00c9b8:	2003      	movs	r0, #3
    if (rc != 0) {
        return BOOT_EFLASH;
    }

    return 0;
}
 c00c9ba:	b00b      	add	sp, #44	; 0x2c
 c00c9bc:	bd30      	pop	{r4, r5, pc}
    rc = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_SEC_CNT, true);
 c00c9be:	2301      	movs	r3, #1
 c00c9c0:	4622      	mov	r2, r4
 c00c9c2:	9300      	str	r3, [sp, #0]
 c00c9c4:	a804      	add	r0, sp, #16
 c00c9c6:	2350      	movs	r3, #80	; 0x50
 c00c9c8:	f000 ff66 	bl	c00d898 <bootutil_tlv_iter_begin>
    if (rc) {
 c00c9cc:	2800      	cmp	r0, #0
 c00c9ce:	d1f4      	bne.n	c00c9ba <bootutil_get_img_security_cnt+0x16>
    rc = bootutil_tlv_iter_next(&it, &off, &len, NULL);
 c00c9d0:	4603      	mov	r3, r0
 c00c9d2:	f10d 020a 	add.w	r2, sp, #10
 c00c9d6:	a903      	add	r1, sp, #12
 c00c9d8:	a804      	add	r0, sp, #16
 c00c9da:	f000 ffa9 	bl	c00d930 <bootutil_tlv_iter_next>
    if (rc != 0) {
 c00c9de:	b970      	cbnz	r0, c00c9fe <bootutil_get_img_security_cnt+0x5a>
    if (len != sizeof(*img_security_cnt)) {
 c00c9e0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 c00c9e4:	2b04      	cmp	r3, #4
 c00c9e6:	d1e7      	bne.n	c00c9b8 <bootutil_get_img_security_cnt+0x14>
    rc = flash_area_read(fap, off, img_security_cnt, len);
 c00c9e8:	462a      	mov	r2, r5
 c00c9ea:	9903      	ldr	r1, [sp, #12]
 c00c9ec:	4620      	mov	r0, r4
 c00c9ee:	f001 f96b 	bl	c00dcc8 <flash_area_read>
    if (rc != 0) {
 c00c9f2:	3000      	adds	r0, #0
 c00c9f4:	bf18      	it	ne
 c00c9f6:	2001      	movne	r0, #1
 c00c9f8:	e7df      	b.n	c00c9ba <bootutil_get_img_security_cnt+0x16>
        return BOOT_EBADARGS;
 c00c9fa:	2007      	movs	r0, #7
 c00c9fc:	e7dd      	b.n	c00c9ba <bootutil_get_img_security_cnt+0x16>
        return -1;
 c00c9fe:	f04f 30ff 	mov.w	r0, #4294967295
 c00ca02:	e7da      	b.n	c00c9ba <bootutil_get_img_security_cnt+0x16>

0c00ca04 <bootutil_img_validate>:
int
bootutil_img_validate(struct enc_key_data *enc_state, int image_index,
                      struct image_header *hdr, const struct flash_area *fap,
                      uint8_t *tmp_buf, uint32_t tmp_buf_sz, uint8_t *seed,
                      int seed_len, uint8_t *out_hash)
{
 c00ca04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00ca08:	461d      	mov	r5, r3
    uint8_t buf[SIG_BUF_SIZE];
    uint8_t hash[32];
    int rc;
#ifdef MCUBOOT_HW_ROLLBACK_PROT
    uint32_t security_cnt = UINT32_MAX;
    uint32_t img_security_cnt = 0;
 c00ca0a:	f04f 37ff 	mov.w	r7, #4294967295
 c00ca0e:	2300      	movs	r3, #0
{
 c00ca10:	f5ad 7d3f 	sub.w	sp, sp, #764	; 0x2fc
    uint32_t img_security_cnt = 0;
 c00ca14:	e9cd 730a 	strd	r7, r3, [sp, #40]	; 0x28
{
 c00ca18:	9007      	str	r0, [sp, #28]
 c00ca1a:	4692      	mov	sl, r2
 c00ca1c:	9cca      	ldr	r4, [sp, #808]	; 0x328
 c00ca1e:	9ecb      	ldr	r6, [sp, #812]	; 0x32c
    if (MUST_DECRYPT(fap, image_index, hdr) &&
 c00ca20:	782b      	ldrb	r3, [r5, #0]
 c00ca22:	460f      	mov	r7, r1
 c00ca24:	b1c1      	cbz	r1, c00ca58 <bootutil_img_validate+0x54>
 c00ca26:	2901      	cmp	r1, #1
 c00ca28:	bf14      	ite	ne
 c00ca2a:	22ff      	movne	r2, #255	; 0xff
 c00ca2c:	2204      	moveq	r2, #4
 c00ca2e:	9205      	str	r2, [sp, #20]
 c00ca30:	9a05      	ldr	r2, [sp, #20]
 c00ca32:	4293      	cmp	r3, r2
 c00ca34:	d112      	bne.n	c00ca5c <bootutil_img_validate+0x58>
 c00ca36:	f8da 3010 	ldr.w	r3, [sl, #16]
 c00ca3a:	0758      	lsls	r0, r3, #29
 c00ca3c:	d50e      	bpl.n	c00ca5c <bootutil_img_validate+0x58>
            !boot_enc_valid(enc_state, image_index, fap)) {
 c00ca3e:	462a      	mov	r2, r5
 c00ca40:	4639      	mov	r1, r7
 c00ca42:	9807      	ldr	r0, [sp, #28]
 c00ca44:	f7ff fe38 	bl	c00c6b8 <boot_enc_valid>
    if (MUST_DECRYPT(fap, image_index, hdr) &&
 c00ca48:	b940      	cbnz	r0, c00ca5c <bootutil_img_validate+0x58>
            }
            if (rc)
            {

                BOOT_LOG_INF("unexpected TLV %x ", type);
                return rc;
 c00ca4a:	f04f 34ff 	mov.w	r4, #4294967295
            off += sizeof(data);
        }
    }
#endif /* !defined(MCUBOOT_PRIMARY_ONLY) */
    return 0;
}
 c00ca4e:	4620      	mov	r0, r4
 c00ca50:	f50d 7d3f 	add.w	sp, sp, #764	; 0x2fc
 c00ca54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (MUST_DECRYPT(fap, image_index, hdr) &&
 c00ca58:	2203      	movs	r2, #3
 c00ca5a:	e7e8      	b.n	c00ca2e <bootutil_img_validate+0x2a>
    mbedtls_sha256_init(ctx);
 c00ca5c:	a862      	add	r0, sp, #392	; 0x188
 c00ca5e:	f7f7 fea1 	bl	c0047a4 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c00ca62:	2100      	movs	r1, #0
 c00ca64:	a862      	add	r0, sp, #392	; 0x188
 c00ca66:	f7f7 fec5 	bl	c0047f4 <mbedtls_sha256_starts_ret>
    if (seed && (seed_len > 0)) {
 c00ca6a:	b134      	cbz	r4, c00ca7a <bootutil_img_validate+0x76>
 c00ca6c:	2e00      	cmp	r6, #0
 c00ca6e:	dd04      	ble.n	c00ca7a <bootutil_img_validate+0x76>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c00ca70:	4632      	mov	r2, r6
 c00ca72:	4621      	mov	r1, r4
 c00ca74:	a862      	add	r0, sp, #392	; 0x188
 c00ca76:	f7f7 fee2 	bl	c00483e <mbedtls_sha256_update_ret>
    for (off = 0; off < size; off += blk_sz) {
 c00ca7a:	2600      	movs	r6, #0
    size += hdr->ih_img_size;
 c00ca7c:	f8da 300c 	ldr.w	r3, [sl, #12]
    size = hdr_size = hdr->ih_hdr_size;
 c00ca80:	f8ba b008 	ldrh.w	fp, [sl, #8]
    size += hdr->ih_img_size;
 c00ca84:	eb0b 0903 	add.w	r9, fp, r3
    size += hdr->ih_protect_tlv_size;
 c00ca88:	f8ba 300a 	ldrh.w	r3, [sl, #10]
 c00ca8c:	444b      	add	r3, r9
 c00ca8e:	9306      	str	r3, [sp, #24]
    for (off = 0; off < size; off += blk_sz) {
 c00ca90:	9b06      	ldr	r3, [sp, #24]
 c00ca92:	42b3      	cmp	r3, r6
 c00ca94:	d84e      	bhi.n	c00cb34 <bootutil_img_validate+0x130>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c00ca96:	f50d 78c4 	add.w	r8, sp, #392	; 0x188
 c00ca9a:	a912      	add	r1, sp, #72	; 0x48
 c00ca9c:	4640      	mov	r0, r8
 c00ca9e:	f7f7 ff1d 	bl	c0048dc <mbedtls_sha256_finish_ret>
    if (out_hash) {
 c00caa2:	9bcc      	ldr	r3, [sp, #816]	; 0x330
 c00caa4:	b153      	cbz	r3, c00cabc <bootutil_img_validate+0xb8>
        memcpy(out_hash, hash, 32);
 c00caa6:	aa12      	add	r2, sp, #72	; 0x48
 c00caa8:	ae1a      	add	r6, sp, #104	; 0x68
 c00caaa:	4614      	mov	r4, r2
 c00caac:	cc03      	ldmia	r4!, {r0, r1}
 c00caae:	42b4      	cmp	r4, r6
 c00cab0:	6018      	str	r0, [r3, #0]
 c00cab2:	6059      	str	r1, [r3, #4]
 c00cab4:	4622      	mov	r2, r4
 c00cab6:	f103 0308 	add.w	r3, r3, #8
 c00caba:	d1f6      	bne.n	c00caaa <bootutil_img_validate+0xa6>
    rc = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_ANY, false);
 c00cabc:	2300      	movs	r3, #0
 c00cabe:	462a      	mov	r2, r5
 c00cac0:	9300      	str	r3, [sp, #0]
 c00cac2:	4651      	mov	r1, sl
 c00cac4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 c00cac8:	a80c      	add	r0, sp, #48	; 0x30
 c00caca:	f000 fee5 	bl	c00d898 <bootutil_tlv_iter_begin>
    if (rc) {
 c00cace:	4604      	mov	r4, r0
 c00cad0:	2800      	cmp	r0, #0
 c00cad2:	d1bc      	bne.n	c00ca4e <bootutil_img_validate+0x4a>
    int sha256_valid = 0;
 c00cad4:	4683      	mov	fp, r0
    int key_id = -1;
 c00cad6:	f04f 36ff 	mov.w	r6, #4294967295
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c00cada:	4baf      	ldr	r3, [pc, #700]	; (c00cd98 <bootutil_img_validate+0x394>)
    int valid_signature = 0;
 c00cadc:	9006      	str	r0, [sp, #24]
    int32_t security_counter_valid = 0;
 c00cade:	9005      	str	r0, [sp, #20]
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c00cae0:	eb03 0ac7 	add.w	sl, r3, r7, lsl #3
        rc = bootutil_tlv_iter_next(&it, &off, &len, &type);
 c00cae4:	f10d 0322 	add.w	r3, sp, #34	; 0x22
 c00cae8:	aa08      	add	r2, sp, #32
 c00caea:	a909      	add	r1, sp, #36	; 0x24
 c00caec:	a80c      	add	r0, sp, #48	; 0x30
 c00caee:	f000 ff1f 	bl	c00d930 <bootutil_tlv_iter_next>
        if (rc < 0) {
 c00caf2:	2800      	cmp	r0, #0
 c00caf4:	dba9      	blt.n	c00ca4a <bootutil_img_validate+0x46>
        } else if (rc > 0) {
 c00caf6:	f040 80f4 	bne.w	c00cce2 <bootutil_img_validate+0x2de>
        if (type == IMAGE_TLV_SHA256) {
 c00cafa:	f8bd 9022 	ldrh.w	r9, [sp, #34]	; 0x22
 c00cafe:	f1b9 0f10 	cmp.w	r9, #16
 c00cb02:	d158      	bne.n	c00cbb6 <bootutil_img_validate+0x1b2>
            if (len != sizeof(hash)) {
 c00cb04:	f8bd 9020 	ldrh.w	r9, [sp, #32]
 c00cb08:	f1b9 0f20 	cmp.w	r9, #32
 c00cb0c:	d19d      	bne.n	c00ca4a <bootutil_img_validate+0x46>
            rc = flash_area_read(fap, off, buf, sizeof hash);
 c00cb0e:	464b      	mov	r3, r9
 c00cb10:	aa22      	add	r2, sp, #136	; 0x88
 c00cb12:	9909      	ldr	r1, [sp, #36]	; 0x24
 c00cb14:	4628      	mov	r0, r5
 c00cb16:	f001 f8d7 	bl	c00dcc8 <flash_area_read>
            if (rc) {
 c00cb1a:	2800      	cmp	r0, #0
 c00cb1c:	f040 8139 	bne.w	c00cd92 <bootutil_img_validate+0x38e>
            if (boot_secure_memequal(hash, buf, sizeof(hash))) {
 c00cb20:	464a      	mov	r2, r9
 c00cb22:	a922      	add	r1, sp, #136	; 0x88
 c00cb24:	a812      	add	r0, sp, #72	; 0x48
 c00cb26:	f7ff fb90 	bl	c00c24a <boot_secure_memequal>
 c00cb2a:	2800      	cmp	r0, #0
 c00cb2c:	d18d      	bne.n	c00ca4a <bootutil_img_validate+0x46>
            sha256_valid = 1;
 c00cb2e:	f04f 0b01 	mov.w	fp, #1
 c00cb32:	e7d7      	b.n	c00cae4 <bootutil_img_validate+0xe0>
        blk_sz = size - off;
 c00cb34:	9b06      	ldr	r3, [sp, #24]
 c00cb36:	eba3 0806 	sub.w	r8, r3, r6
 c00cb3a:	9bc9      	ldr	r3, [sp, #804]	; 0x324
 c00cb3c:	4598      	cmp	r8, r3
 c00cb3e:	bf28      	it	cs
 c00cb40:	4698      	movcs	r8, r3
        if ((off < hdr_size) && ((off + blk_sz) > hdr_size)) {
 c00cb42:	45b3      	cmp	fp, r6
 c00cb44:	d905      	bls.n	c00cb52 <bootutil_img_validate+0x14e>
 c00cb46:	eb08 0306 	add.w	r3, r8, r6
 c00cb4a:	459b      	cmp	fp, r3
            blk_sz = hdr_size - off;
 c00cb4c:	bf38      	it	cc
 c00cb4e:	ebab 0806 	subcc.w	r8, fp, r6
        if ((off < tlv_off) && ((off + blk_sz) > tlv_off)) {
 c00cb52:	45b1      	cmp	r9, r6
 c00cb54:	d905      	bls.n	c00cb62 <bootutil_img_validate+0x15e>
 c00cb56:	eb06 0308 	add.w	r3, r6, r8
 c00cb5a:	4599      	cmp	r9, r3
            blk_sz = tlv_off - off;
 c00cb5c:	bf38      	it	cc
 c00cb5e:	eba9 0806 	subcc.w	r8, r9, r6
        rc = flash_area_read(fap, off, tmp_buf, blk_sz);
 c00cb62:	4643      	mov	r3, r8
 c00cb64:	9ac8      	ldr	r2, [sp, #800]	; 0x320
 c00cb66:	4631      	mov	r1, r6
 c00cb68:	4628      	mov	r0, r5
 c00cb6a:	f001 f8ad 	bl	c00dcc8 <flash_area_read>
        if (rc) {
 c00cb6e:	4604      	mov	r4, r0
 c00cb70:	2800      	cmp	r0, #0
 c00cb72:	f47f af6c 	bne.w	c00ca4e <bootutil_img_validate+0x4a>
    if (MUST_DECRYPT(fap, image_index, hdr)) {
 c00cb76:	782b      	ldrb	r3, [r5, #0]
 c00cb78:	9a05      	ldr	r2, [sp, #20]
 c00cb7a:	429a      	cmp	r2, r3
 c00cb7c:	d114      	bne.n	c00cba8 <bootutil_img_validate+0x1a4>
 c00cb7e:	f8da 3010 	ldr.w	r3, [sl, #16]
 c00cb82:	0759      	lsls	r1, r3, #29
 c00cb84:	d510      	bpl.n	c00cba8 <bootutil_img_validate+0x1a4>
            if (off >= hdr_size && off < tlv_off) {
 c00cb86:	45b3      	cmp	fp, r6
 c00cb88:	d80e      	bhi.n	c00cba8 <bootutil_img_validate+0x1a4>
 c00cb8a:	45b1      	cmp	r9, r6
 c00cb8c:	d90c      	bls.n	c00cba8 <bootutil_img_validate+0x1a4>
                boot_encrypt(enc_state, image_index, fap, off - hdr_size,
 c00cb8e:	9ac8      	ldr	r2, [sp, #800]	; 0x320
                blk_off = (off - hdr_size) & 0xf;
 c00cb90:	eba6 030b 	sub.w	r3, r6, fp
                boot_encrypt(enc_state, image_index, fap, off - hdr_size,
 c00cb94:	9202      	str	r2, [sp, #8]
                blk_off = (off - hdr_size) & 0xf;
 c00cb96:	f003 020f 	and.w	r2, r3, #15
                boot_encrypt(enc_state, image_index, fap, off - hdr_size,
 c00cb9a:	e9cd 8200 	strd	r8, r2, [sp]
 c00cb9e:	4639      	mov	r1, r7
 c00cba0:	462a      	mov	r2, r5
 c00cba2:	9807      	ldr	r0, [sp, #28]
 c00cba4:	f7ff fd9a 	bl	c00c6dc <boot_encrypt>
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c00cba8:	4642      	mov	r2, r8
 c00cbaa:	99c8      	ldr	r1, [sp, #800]	; 0x320
 c00cbac:	a862      	add	r0, sp, #392	; 0x188
 c00cbae:	f7f7 fe46 	bl	c00483e <mbedtls_sha256_update_ret>
    for (off = 0; off < size; off += blk_sz) {
 c00cbb2:	4446      	add	r6, r8
 c00cbb4:	e76c      	b.n	c00ca90 <bootutil_img_validate+0x8c>
        } else if (type == IMAGE_TLV_KEYHASH) {
 c00cbb6:	f1b9 0f01 	cmp.w	r9, #1
 c00cbba:	d130      	bne.n	c00cc1e <bootutil_img_validate+0x21a>
            if (len > 32) {
 c00cbbc:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 c00cbc0:	2b20      	cmp	r3, #32
 c00cbc2:	f63f af42 	bhi.w	c00ca4a <bootutil_img_validate+0x46>
            rc = flash_area_read(fap, off, buf, len);
 c00cbc6:	aa22      	add	r2, sp, #136	; 0x88
 c00cbc8:	9909      	ldr	r1, [sp, #36]	; 0x24
 c00cbca:	4628      	mov	r0, r5
 c00cbcc:	f001 f87c 	bl	c00dcc8 <flash_area_read>
            if (rc) {
 c00cbd0:	4681      	mov	r9, r0
 c00cbd2:	2800      	cmp	r0, #0
 c00cbd4:	f040 80db 	bne.w	c00cd8e <bootutil_img_validate+0x38a>
            key_id = bootutil_find_key(image_index, buf, len);
 c00cbd8:	f89d 6020 	ldrb.w	r6, [sp, #32]
    if (keyhash_len > 32) {
 c00cbdc:	2e20      	cmp	r6, #32
 c00cbde:	d819      	bhi.n	c00cc14 <bootutil_img_validate+0x210>
    mbedtls_sha256_init(ctx);
 c00cbe0:	4640      	mov	r0, r8
 c00cbe2:	f7f7 fddf 	bl	c0047a4 <mbedtls_sha256_init>
    (void)mbedtls_sha256_starts_ret(ctx, 0);
 c00cbe6:	4649      	mov	r1, r9
 c00cbe8:	4640      	mov	r0, r8
 c00cbea:	f7f7 fe03 	bl	c0047f4 <mbedtls_sha256_starts_ret>
    bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
 c00cbee:	f8da 3004 	ldr.w	r3, [sl, #4]
    (void)mbedtls_sha256_update_ret(ctx, data, data_len);
 c00cbf2:	4640      	mov	r0, r8
 c00cbf4:	681a      	ldr	r2, [r3, #0]
 c00cbf6:	4b68      	ldr	r3, [pc, #416]	; (c00cd98 <bootutil_img_validate+0x394>)
 c00cbf8:	f853 1037 	ldr.w	r1, [r3, r7, lsl #3]
 c00cbfc:	f7f7 fe1f 	bl	c00483e <mbedtls_sha256_update_ret>
    (void)mbedtls_sha256_finish_ret(ctx, output);
 c00cc00:	a91a      	add	r1, sp, #104	; 0x68
 c00cc02:	4640      	mov	r0, r8
 c00cc04:	f7f7 fe6a 	bl	c0048dc <mbedtls_sha256_finish_ret>
    if (!boot_secure_memequal(hash, keyhash, keyhash_len)) {
 c00cc08:	4632      	mov	r2, r6
 c00cc0a:	a922      	add	r1, sp, #136	; 0x88
 c00cc0c:	a81a      	add	r0, sp, #104	; 0x68
 c00cc0e:	f7ff fb1c 	bl	c00c24a <boot_secure_memequal>
 c00cc12:	b110      	cbz	r0, c00cc1a <bootutil_img_validate+0x216>
            key_id = -1;
 c00cc14:	f04f 36ff 	mov.w	r6, #4294967295
 c00cc18:	e764      	b.n	c00cae4 <bootutil_img_validate+0xe0>
    if (!boot_secure_memequal(hash, keyhash, keyhash_len)) {
 c00cc1a:	463e      	mov	r6, r7
 c00cc1c:	e762      	b.n	c00cae4 <bootutil_img_validate+0xe0>
        } else if (type == EXPECTED_SIG_TLV) {
 c00cc1e:	f1b9 0f20 	cmp.w	r9, #32
 c00cc22:	d12a      	bne.n	c00cc7a <bootutil_img_validate+0x276>
            if (key_id < 0 || key_id >= bootutil_key_cnt) {
 c00cc24:	2e00      	cmp	r6, #0
 c00cc26:	dbf5      	blt.n	c00cc14 <bootutil_img_validate+0x210>
 c00cc28:	4b5c      	ldr	r3, [pc, #368]	; (c00cd9c <bootutil_img_validate+0x398>)
 c00cc2a:	681b      	ldr	r3, [r3, #0]
 c00cc2c:	42b3      	cmp	r3, r6
 c00cc2e:	ddf1      	ble.n	c00cc14 <bootutil_img_validate+0x210>
            if (!EXPECTED_SIG_LEN(len) || len > sizeof(buf)) {
 c00cc30:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 c00cc34:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 c00cc38:	f47f af07 	bne.w	c00ca4a <bootutil_img_validate+0x46>
            rc = flash_area_read(fap, off, buf, len);
 c00cc3c:	aa22      	add	r2, sp, #136	; 0x88
 c00cc3e:	9909      	ldr	r1, [sp, #36]	; 0x24
 c00cc40:	4628      	mov	r0, r5
 c00cc42:	f001 f841 	bl	c00dcc8 <flash_area_read>
            if (rc) {
 c00cc46:	2800      	cmp	r0, #0
 c00cc48:	f47f aeff 	bne.w	c00ca4a <bootutil_img_validate+0x46>
			BOOT_LOG_INF("verify sig key id %d", key_id);
 c00cc4c:	4631      	mov	r1, r6
 c00cc4e:	4854      	ldr	r0, [pc, #336]	; (c00cda0 <bootutil_img_validate+0x39c>)
            rc = bootutil_verify_sig(hash, sizeof(hash), buf, len, key_id);
 c00cc50:	b2f6      	uxtb	r6, r6
			BOOT_LOG_INF("verify sig key id %d", key_id);
 c00cc52:	f001 facb 	bl	c00e1ec <iprintf>
            rc = bootutil_verify_sig(hash, sizeof(hash), buf, len, key_id);
 c00cc56:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 c00cc5a:	9600      	str	r6, [sp, #0]
 c00cc5c:	aa22      	add	r2, sp, #136	; 0x88
 c00cc5e:	4649      	mov	r1, r9
 c00cc60:	a812      	add	r0, sp, #72	; 0x48
 c00cc62:	f7ff fd89 	bl	c00c778 <bootutil_verify_sig>
            if (rc == 0) {
 c00cc66:	2800      	cmp	r0, #0
 c00cc68:	d1d4      	bne.n	c00cc14 <bootutil_img_validate+0x210>
				BOOT_LOG_INF("signature OK");
 c00cc6a:	484e      	ldr	r0, [pc, #312]	; (c00cda4 <bootutil_img_validate+0x3a0>)
 c00cc6c:	f001 fb32 	bl	c00e2d4 <puts>
                valid_signature = 1;
 c00cc70:	2301      	movs	r3, #1
            key_id = -1;
 c00cc72:	f04f 36ff 	mov.w	r6, #4294967295
                valid_signature = 1;
 c00cc76:	9306      	str	r3, [sp, #24]
 c00cc78:	e734      	b.n	c00cae4 <bootutil_img_validate+0xe0>
        } else if (type == IMAGE_TLV_SEC_CNT) {
 c00cc7a:	f1b9 0f50 	cmp.w	r9, #80	; 0x50
 c00cc7e:	d123      	bne.n	c00ccc8 <bootutil_img_validate+0x2c4>
            if (len != sizeof(img_security_cnt)) {
 c00cc80:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 c00cc84:	2b04      	cmp	r3, #4
 c00cc86:	f47f aee0 	bne.w	c00ca4a <bootutil_img_validate+0x46>
            rc = flash_area_read(fap, off, &img_security_cnt, len);
 c00cc8a:	aa0b      	add	r2, sp, #44	; 0x2c
 c00cc8c:	9909      	ldr	r1, [sp, #36]	; 0x24
 c00cc8e:	4628      	mov	r0, r5
 c00cc90:	f001 f81a 	bl	c00dcc8 <flash_area_read>
            if (rc) {
 c00cc94:	2800      	cmp	r0, #0
 c00cc96:	d17c      	bne.n	c00cd92 <bootutil_img_validate+0x38e>
            rc = boot_nv_security_counter_get(image_index, &security_cnt);
 c00cc98:	a90a      	add	r1, sp, #40	; 0x28
 c00cc9a:	4638      	mov	r0, r7
 c00cc9c:	f001 f938 	bl	c00df10 <boot_nv_security_counter_get>
            if (rc) {
 c00cca0:	2800      	cmp	r0, #0
 c00cca2:	d176      	bne.n	c00cd92 <bootutil_img_validate+0x38e>
            BOOT_LOG_INF("verify counter  %d %x %x", image_index,img_security_cnt, security_cnt );
 c00cca4:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
 c00cca8:	4639      	mov	r1, r7
 c00ccaa:	483f      	ldr	r0, [pc, #252]	; (c00cda8 <bootutil_img_validate+0x3a4>)
 c00ccac:	f001 fa9e 	bl	c00e1ec <iprintf>
            if (img_security_cnt < security_cnt) {
 c00ccb0:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
 c00ccb4:	429a      	cmp	r2, r3
 c00ccb6:	f4ff aec8 	bcc.w	c00ca4a <bootutil_img_validate+0x46>
            BOOT_LOG_INF("counter  %d : ok", image_index );
 c00ccba:	4639      	mov	r1, r7
 c00ccbc:	483b      	ldr	r0, [pc, #236]	; (c00cdac <bootutil_img_validate+0x3a8>)
 c00ccbe:	f001 fa95 	bl	c00e1ec <iprintf>
            security_counter_valid = 1;
 c00ccc2:	2301      	movs	r3, #1
 c00ccc4:	9305      	str	r3, [sp, #20]
 c00ccc6:	e70d      	b.n	c00cae4 <bootutil_img_validate+0xe0>
            if (type == IMAGE_TLV_ENC_RSA2048)
 c00ccc8:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
 c00cccc:	f43f af0a 	beq.w	c00cae4 <bootutil_img_validate+0xe0>
            if (type == IMAGE_TLV_DEPENDENCY)
 c00ccd0:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
 c00ccd4:	f43f af06 	beq.w	c00cae4 <bootutil_img_validate+0xe0>
                BOOT_LOG_INF("unexpected TLV %x ", type);
 c00ccd8:	4649      	mov	r1, r9
 c00ccda:	4835      	ldr	r0, [pc, #212]	; (c00cdb0 <bootutil_img_validate+0x3ac>)
 c00ccdc:	f001 fa86 	bl	c00e1ec <iprintf>
 c00cce0:	e6b3      	b.n	c00ca4a <bootutil_img_validate+0x46>
    if (!sha256_valid) {
 c00cce2:	f1bb 0f00 	cmp.w	fp, #0
 c00cce6:	f43f aeb0 	beq.w	c00ca4a <bootutil_img_validate+0x46>
    } else if (!valid_signature) {
 c00ccea:	9b06      	ldr	r3, [sp, #24]
 c00ccec:	2b00      	cmp	r3, #0
 c00ccee:	f43f aeac 	beq.w	c00ca4a <bootutil_img_validate+0x46>
    } else if (!security_counter_valid) {
 c00ccf2:	9b05      	ldr	r3, [sp, #20]
 c00ccf4:	2b00      	cmp	r3, #0
 c00ccf6:	f43f aea8 	beq.w	c00ca4a <bootutil_img_validate+0x46>
    if (fap->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index))
 c00ccfa:	782a      	ldrb	r2, [r5, #0]
 c00ccfc:	b327      	cbz	r7, c00cd48 <bootutil_img_validate+0x344>
 c00ccfe:	2f01      	cmp	r7, #1
 c00cd00:	bf14      	ite	ne
 c00cd02:	23ff      	movne	r3, #255	; 0xff
 c00cd04:	2304      	moveq	r3, #4
 c00cd06:	429a      	cmp	r2, r3
 c00cd08:	f47f aea1 	bne.w	c00ca4e <bootutil_img_validate+0x4a>
        off = it.tlv_end;
 c00cd0c:	9b11      	ldr	r3, [sp, #68]	; 0x44
        if (off % 8)
 c00cd0e:	075a      	lsls	r2, r3, #29
        off = it.tlv_end;
 c00cd10:	9309      	str	r3, [sp, #36]	; 0x24
        if (off % 8)
 c00cd12:	d11b      	bne.n	c00cd4c <bootutil_img_validate+0x348>
        uint32_t end = boot_magic_off(fap);
 c00cd14:	4628      	mov	r0, r5
 c00cd16:	f7ff fab4 	bl	c00c282 <boot_magic_off>
 c00cd1a:	4607      	mov	r7, r0
        while (off < end)
 c00cd1c:	9909      	ldr	r1, [sp, #36]	; 0x24
 c00cd1e:	42b9      	cmp	r1, r7
 c00cd20:	f4bf ae95 	bcs.w	c00ca4e <bootutil_img_validate+0x4a>
            rc = flash_area_read(fap, off, &data, sizeof(data));
 c00cd24:	2308      	movs	r3, #8
 c00cd26:	4642      	mov	r2, r8
 c00cd28:	4628      	mov	r0, r5
 c00cd2a:	f000 ffcd 	bl	c00dcc8 <flash_area_read>
                BOOT_LOG_INF("read failed %x ", off);
 c00cd2e:	9909      	ldr	r1, [sp, #36]	; 0x24
            if (rc)
 c00cd30:	4606      	mov	r6, r0
 c00cd32:	b9d0      	cbnz	r0, c00cd6a <bootutil_img_validate+0x366>
            if (data != 0xffffffffffffffff)
 c00cd34:	e9d8 2300 	ldrd	r2, r3, [r8]
 c00cd38:	3301      	adds	r3, #1
 c00cd3a:	bf08      	it	eq
 c00cd3c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
 c00cd40:	d11c      	bne.n	c00cd7c <bootutil_img_validate+0x378>
            off += sizeof(data);
 c00cd42:	3108      	adds	r1, #8
 c00cd44:	9109      	str	r1, [sp, #36]	; 0x24
 c00cd46:	e7e9      	b.n	c00cd1c <bootutil_img_validate+0x318>
    if (fap->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index))
 c00cd48:	2303      	movs	r3, #3
 c00cd4a:	e7dc      	b.n	c00cd06 <bootutil_img_validate+0x302>
            uint32_t end0 = (((off / 8) + 1) * 8);
 c00cd4c:	f023 0307 	bic.w	r3, r3, #7
 c00cd50:	f103 0708 	add.w	r7, r3, #8
            while (off < end0)
 c00cd54:	9909      	ldr	r1, [sp, #36]	; 0x24
 c00cd56:	42b9      	cmp	r1, r7
 c00cd58:	d2dc      	bcs.n	c00cd14 <bootutil_img_validate+0x310>
                rc = flash_area_read(fap, off, &data, sizeof(data));
 c00cd5a:	2301      	movs	r3, #1
 c00cd5c:	4642      	mov	r2, r8
 c00cd5e:	4628      	mov	r0, r5
 c00cd60:	f000 ffb2 	bl	c00dcc8 <flash_area_read>
                    BOOT_LOG_INF("read failed %x ", off);
 c00cd64:	9909      	ldr	r1, [sp, #36]	; 0x24
                if (rc)
 c00cd66:	4606      	mov	r6, r0
 c00cd68:	b120      	cbz	r0, c00cd74 <bootutil_img_validate+0x370>
                BOOT_LOG_INF("read failed %x ", off);
 c00cd6a:	4812      	ldr	r0, [pc, #72]	; (c00cdb4 <bootutil_img_validate+0x3b0>)
 c00cd6c:	f001 fa3e 	bl	c00e1ec <iprintf>
 c00cd70:	4634      	mov	r4, r6
 c00cd72:	e66c      	b.n	c00ca4e <bootutil_img_validate+0x4a>
                if (data != 0xff)
 c00cd74:	f898 3000 	ldrb.w	r3, [r8]
 c00cd78:	2bff      	cmp	r3, #255	; 0xff
 c00cd7a:	d005      	beq.n	c00cd88 <bootutil_img_validate+0x384>
                BOOT_LOG_INF("data wrong at %x", off);
 c00cd7c:	480e      	ldr	r0, [pc, #56]	; (c00cdb8 <bootutil_img_validate+0x3b4>)
 c00cd7e:	f001 fa35 	bl	c00e1ec <iprintf>
                return -1;
 c00cd82:	f04f 36ff 	mov.w	r6, #4294967295
 c00cd86:	e7f3      	b.n	c00cd70 <bootutil_img_validate+0x36c>
                off += sizeof(data);
 c00cd88:	3101      	adds	r1, #1
 c00cd8a:	9109      	str	r1, [sp, #36]	; 0x24
 c00cd8c:	e7e2      	b.n	c00cd54 <bootutil_img_validate+0x350>
            rc = flash_area_read(fap, off, buf, len);
 c00cd8e:	4604      	mov	r4, r0
 c00cd90:	e65d      	b.n	c00ca4e <bootutil_img_validate+0x4a>
            rc = boot_nv_security_counter_get(image_index, &security_cnt);
 c00cd92:	4604      	mov	r4, r0
 c00cd94:	e65b      	b.n	c00ca4e <bootutil_img_validate+0x4a>
 c00cd96:	bf00      	nop
 c00cd98:	0c002560 	.word	0x0c002560
 c00cd9c:	0c00255c 	.word	0x0c00255c
 c00cda0:	0c0102cf 	.word	0x0c0102cf
 c00cda4:	0c0102ec 	.word	0x0c0102ec
 c00cda8:	0c010300 	.word	0x0c010300
 c00cdac:	0c010321 	.word	0x0c010321
 c00cdb0:	0c01033a 	.word	0x0c01033a
 c00cdb4:	0c010355 	.word	0x0c010355
 c00cdb8:	0c01036d 	.word	0x0c01036d

0c00cdbc <boot_initialize_area>:
    return rc;
}
#else  /* defined(MCUBOOT_USE_FLASH_AREA_GET_SECTORS) */
static int
boot_initialize_area(struct boot_loader_state *state, int flash_area)
{
 c00cdbc:	b513      	push	{r0, r1, r4, lr}
    uint32_t num_sectors;
    struct flash_sector *out_sectors;
    size_t *out_num_sectors;
    int rc;

    num_sectors = BOOT_MAX_IMG_SECTORS;
 c00cdbe:	f44f 7312 	mov.w	r3, #584	; 0x248
{
 c00cdc2:	4604      	mov	r4, r0
    num_sectors = BOOT_MAX_IMG_SECTORS;
 c00cdc4:	9301      	str	r3, [sp, #4]

    if (flash_area == FLASH_AREA_IMAGE_PRIMARY(BOOT_CURR_IMG(state))) {
 c00cdc6:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
{
 c00cdca:	4608      	mov	r0, r1
    if (flash_area == FLASH_AREA_IMAGE_PRIMARY(BOOT_CURR_IMG(state))) {
 c00cdcc:	b31b      	cbz	r3, c00ce16 <boot_initialize_area+0x5a>
 c00cdce:	2b01      	cmp	r3, #1
 c00cdd0:	d11d      	bne.n	c00ce0e <boot_initialize_area+0x52>
 c00cdd2:	2902      	cmp	r1, #2
 c00cdd4:	d10f      	bne.n	c00cdf6 <boot_initialize_area+0x3a>
        out_sectors = BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors;
 c00cdd6:	2158      	movs	r1, #88	; 0x58
 c00cdd8:	fb01 4203 	mla	r2, r1, r3, r4
        out_num_sectors = &BOOT_IMG(state, BOOT_PRIMARY_SLOT).num_sectors;
 c00cddc:	fb01 4303 	mla	r3, r1, r3, r4
        out_sectors = BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors;
 c00cde0:	6a52      	ldr	r2, [r2, #36]	; 0x24
        out_num_sectors = &BOOT_IMG(state, BOOT_PRIMARY_SLOT).num_sectors;
 c00cde2:	f103 0428 	add.w	r4, r3, #40	; 0x28
#endif
    } else {
        return BOOT_EFLASH;
    }

    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
 c00cde6:	a901      	add	r1, sp, #4
 c00cde8:	f001 f842 	bl	c00de70 <flash_area_get_sectors>
    if (rc != 0) {
 c00cdec:	b908      	cbnz	r0, c00cdf2 <boot_initialize_area+0x36>
        return rc;
    }
    *out_num_sectors = num_sectors;
 c00cdee:	9b01      	ldr	r3, [sp, #4]
 c00cdf0:	6023      	str	r3, [r4, #0]
    return 0;
}
 c00cdf2:	b002      	add	sp, #8
 c00cdf4:	bd10      	pop	{r4, pc}
    } else if (flash_area == FLASH_AREA_IMAGE_SECONDARY(BOOT_CURR_IMG(state))) {
 c00cdf6:	2204      	movs	r2, #4
 c00cdf8:	4282      	cmp	r2, r0
 c00cdfa:	d10a      	bne.n	c00ce12 <boot_initialize_area+0x56>
        out_sectors = BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors;
 c00cdfc:	2158      	movs	r1, #88	; 0x58
 c00cdfe:	fb01 4203 	mla	r2, r1, r3, r4
        out_num_sectors = &BOOT_IMG(state, BOOT_SECONDARY_SLOT).num_sectors;
 c00ce02:	fb01 4303 	mla	r3, r1, r3, r4
        out_sectors = BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors;
 c00ce06:	6d12      	ldr	r2, [r2, #80]	; 0x50
        out_num_sectors = &BOOT_IMG(state, BOOT_SECONDARY_SLOT).num_sectors;
 c00ce08:	f103 0454 	add.w	r4, r3, #84	; 0x54
 c00ce0c:	e7eb      	b.n	c00cde6 <boot_initialize_area+0x2a>
    if (flash_area == FLASH_AREA_IMAGE_PRIMARY(BOOT_CURR_IMG(state))) {
 c00ce0e:	29ff      	cmp	r1, #255	; 0xff
 c00ce10:	d0e1      	beq.n	c00cdd6 <boot_initialize_area+0x1a>
        return BOOT_EFLASH;
 c00ce12:	2001      	movs	r0, #1
 c00ce14:	e7ed      	b.n	c00cdf2 <boot_initialize_area+0x36>
    if (flash_area == FLASH_AREA_IMAGE_PRIMARY(BOOT_CURR_IMG(state))) {
 c00ce16:	2901      	cmp	r1, #1
 c00ce18:	d0dd      	beq.n	c00cdd6 <boot_initialize_area+0x1a>
    } else if (flash_area == FLASH_AREA_IMAGE_SECONDARY(BOOT_CURR_IMG(state))) {
 c00ce1a:	2203      	movs	r2, #3
 c00ce1c:	e7ec      	b.n	c00cdf8 <boot_initialize_area+0x3c>

0c00ce1e <boot_read_image_headers>:
{
 c00ce1e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00ce22:	4616      	mov	r6, r2
#define BOOT_IMG_HDR(state) (&BOOT_IMG(state,0).hdr)

static inline struct image_header*
boot_img_hdr(struct boot_loader_state *state, size_t slot)
{
    return &BOOT_IMG(state, slot).hdr;
 c00ce24:	2758      	movs	r7, #88	; 0x58
 c00ce26:	f890 2588 	ldrb.w	r2, [r0, #1416]	; 0x588
 c00ce2a:	4688      	mov	r8, r1
        rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
 c00ce2c:	4633      	mov	r3, r6
 c00ce2e:	fb02 0207 	mla	r2, r2, r7, r0
 c00ce32:	2100      	movs	r1, #0
{
 c00ce34:	4604      	mov	r4, r0
        rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
 c00ce36:	f000 fcc1 	bl	c00d7bc <boot_read_image_header>
        if (rc != 0) {
 c00ce3a:	4605      	mov	r5, r0
 c00ce3c:	b970      	cbnz	r0, c00ce5c <boot_read_image_headers+0x3e>
 c00ce3e:	f894 2588 	ldrb.w	r2, [r4, #1416]	; 0x588
        rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
 c00ce42:	4633      	mov	r3, r6
 c00ce44:	fb07 4202 	mla	r2, r7, r2, r4
 c00ce48:	2101      	movs	r1, #1
 c00ce4a:	322c      	adds	r2, #44	; 0x2c
 c00ce4c:	4620      	mov	r0, r4
 c00ce4e:	f000 fcb5 	bl	c00d7bc <boot_read_image_header>
        if (rc != 0) {
 c00ce52:	b118      	cbz	r0, c00ce5c <boot_read_image_headers+0x3e>
            if (i > 0 && !require_all) {
 c00ce54:	f1b8 0f00 	cmp.w	r8, #0
 c00ce58:	bf18      	it	ne
 c00ce5a:	4605      	movne	r5, r0
}
 c00ce5c:	4628      	mov	r0, r5
 c00ce5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0c00ce62 <boot_read_sectors>:
 * and copy during an image swap.  The information collected during this
 * function is used to populate the state.
 */
static int
boot_read_sectors(struct boot_loader_state *state)
{
 c00ce62:	b538      	push	{r3, r4, r5, lr}
    uint8_t image_index;
    int rc;

    image_index = BOOT_CURR_IMG(state);
 c00ce64:	f890 5588 	ldrb.w	r5, [r0, #1416]	; 0x588
{
 c00ce68:	4604      	mov	r4, r0

    rc = boot_initialize_area(state, FLASH_AREA_IMAGE_PRIMARY(image_index));
 c00ce6a:	b155      	cbz	r5, c00ce82 <boot_read_sectors+0x20>
 c00ce6c:	2d01      	cmp	r5, #1
 c00ce6e:	bf0c      	ite	eq
 c00ce70:	2102      	moveq	r1, #2
 c00ce72:	21ff      	movne	r1, #255	; 0xff
 c00ce74:	4620      	mov	r0, r4
 c00ce76:	f7ff ffa1 	bl	c00cdbc <boot_initialize_area>
    if (rc != 0) {
 c00ce7a:	b120      	cbz	r0, c00ce86 <boot_read_sectors+0x24>
        return BOOT_EFLASH;
 c00ce7c:	2501      	movs	r5, #1
#endif

    BOOT_WRITE_SZ(state) = boot_write_sz(state);

    return 0;
}
 c00ce7e:	4628      	mov	r0, r5
 c00ce80:	bd38      	pop	{r3, r4, r5, pc}
    rc = boot_initialize_area(state, FLASH_AREA_IMAGE_PRIMARY(image_index));
 c00ce82:	2101      	movs	r1, #1
 c00ce84:	e7f6      	b.n	c00ce74 <boot_read_sectors+0x12>
    rc = boot_initialize_area(state, FLASH_AREA_IMAGE_SECONDARY(image_index));
 c00ce86:	b1a5      	cbz	r5, c00ceb2 <boot_read_sectors+0x50>
 c00ce88:	2d01      	cmp	r5, #1
 c00ce8a:	bf0c      	ite	eq
 c00ce8c:	2104      	moveq	r1, #4
 c00ce8e:	21ff      	movne	r1, #255	; 0xff
 c00ce90:	4620      	mov	r0, r4
 c00ce92:	f7ff ff93 	bl	c00cdbc <boot_initialize_area>
    if (rc != 0) {
 c00ce96:	4605      	mov	r5, r0
 c00ce98:	2800      	cmp	r0, #0
 c00ce9a:	d1ef      	bne.n	c00ce7c <boot_read_sectors+0x1a>
    elem_sz = flash_area_align(BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT));
 c00ce9c:	2258      	movs	r2, #88	; 0x58
 c00ce9e:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00cea2:	fb02 4303 	mla	r3, r2, r3, r4
 c00cea6:	6a18      	ldr	r0, [r3, #32]
 c00cea8:	f000 ff56 	bl	c00dd58 <flash_area_align>
    BOOT_WRITE_SZ(state) = boot_write_sz(state);
 c00ceac:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
 c00ceb0:	e7e5      	b.n	c00ce7e <boot_read_sectors+0x1c>
    rc = boot_initialize_area(state, FLASH_AREA_IMAGE_SECONDARY(image_index));
 c00ceb2:	2103      	movs	r1, #3
 c00ceb4:	e7ec      	b.n	c00ce90 <boot_read_sectors+0x2e>

0c00ceb6 <boot_update_security_counter.constprop.2>:
 *                      that is currently stored in the given slot.
 *
 * @return              0 on success; nonzero on failure.
 */
static int
boot_update_security_counter(uint8_t image_index, int slot,
 c00ceb6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c00ceb8:	460e      	mov	r6, r1
                             struct image_header *hdr)
{
    const struct flash_area *fap = NULL;
 c00ceba:	2100      	movs	r1, #0
 c00cebc:	ac02      	add	r4, sp, #8
 c00cebe:	f844 1d08 	str.w	r1, [r4, #-8]!
boot_update_security_counter(uint8_t image_index, int slot,
 c00cec2:	4605      	mov	r5, r0
    uint32_t img_security_cnt;
    int rc;

    rc = flash_area_open(flash_area_id_from_multi_image_slot(image_index, slot),
 c00cec4:	f000 ff6c 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
 c00cec8:	4621      	mov	r1, r4
 c00ceca:	b2c0      	uxtb	r0, r0
 c00cecc:	f000 fedc 	bl	c00dc88 <flash_area_open>
                         &fap);
    if (rc != 0) {
 c00ced0:	b988      	cbnz	r0, c00cef6 <boot_update_security_counter.constprop.2+0x40>
        rc = BOOT_EFLASH;
        goto done;
    }

    rc = bootutil_get_img_security_cnt(hdr, fap, &img_security_cnt);
 c00ced2:	aa01      	add	r2, sp, #4
 c00ced4:	9900      	ldr	r1, [sp, #0]
 c00ced6:	4630      	mov	r0, r6
 c00ced8:	f7ff fd64 	bl	c00c9a4 <bootutil_get_img_security_cnt>
    if (rc != 0) {
 c00cedc:	4604      	mov	r4, r0
 c00cede:	b920      	cbnz	r0, c00ceea <boot_update_security_counter.constprop.2+0x34>
        goto done;
    }

    rc = boot_nv_security_counter_update(image_index, img_security_cnt);
 c00cee0:	9901      	ldr	r1, [sp, #4]
 c00cee2:	4628      	mov	r0, r5
 c00cee4:	f001 f828 	bl	c00df38 <boot_nv_security_counter_update>
 c00cee8:	4604      	mov	r4, r0
    if (rc != 0) {
        goto done;
    }

done:
    flash_area_close(fap);
 c00ceea:	9800      	ldr	r0, [sp, #0]
 c00ceec:	f000 feea 	bl	c00dcc4 <flash_area_close>
    return rc;
}
 c00cef0:	4620      	mov	r0, r4
 c00cef2:	b002      	add	sp, #8
 c00cef4:	bd70      	pop	{r4, r5, r6, pc}
        rc = BOOT_EFLASH;
 c00cef6:	2401      	movs	r4, #1
 c00cef8:	e7f7      	b.n	c00ceea <boot_update_security_counter.constprop.2+0x34>
	...

0c00cefc <boot_validate_slot>:
{
 c00cefc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00cf00:	4604      	mov	r4, r0
 c00cf02:	b089      	sub	sp, #36	; 0x24
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00cf04:	f890 0588 	ldrb.w	r0, [r0, #1416]	; 0x588
{
 c00cf08:	460e      	mov	r6, r1
 c00cf0a:	4617      	mov	r7, r2
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00cf0c:	f000 ff48 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
 c00cf10:	a906      	add	r1, sp, #24
 c00cf12:	b2c0      	uxtb	r0, r0
 c00cf14:	f000 feb8 	bl	c00dc88 <flash_area_open>
    if (rc != 0) {
 c00cf18:	2800      	cmp	r0, #0
 c00cf1a:	f040 809e 	bne.w	c00d05a <boot_validate_slot+0x15e>
 c00cf1e:	f894 a588 	ldrb.w	sl, [r4, #1416]	; 0x588
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00cf22:	4631      	mov	r1, r6
 c00cf24:	4650      	mov	r0, sl
 c00cf26:	f000 ff3b 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
 c00cf2a:	f04f 082c 	mov.w	r8, #44	; 0x2c
    rc = flash_area_open(area_id, &fap);
 c00cf2e:	a907      	add	r1, sp, #28
 c00cf30:	b2c0      	uxtb	r0, r0
 c00cf32:	fb08 f806 	mul.w	r8, r8, r6
 c00cf36:	f000 fea7 	bl	c00dc88 <flash_area_open>
    if (rc != 0) {
 c00cf3a:	b1a0      	cbz	r0, c00cf66 <boot_validate_slot+0x6a>
        (hdr->ih_flags & IMAGE_F_NON_BOOTABLE)) {
 c00cf3c:	2358      	movs	r3, #88	; 0x58
 c00cf3e:	fb03 f20a 	mul.w	r2, r3, sl
 c00cf42:	232c      	movs	r3, #44	; 0x2c
 c00cf44:	fb03 2306 	mla	r3, r3, r6, r2
 c00cf48:	18e1      	adds	r1, r4, r3
 c00cf4a:	690a      	ldr	r2, [r1, #16]
    if (boot_check_header_erased(state, slot) == 0 ||
 c00cf4c:	06d0      	lsls	r0, r2, #27
 c00cf4e:	d41b      	bmi.n	c00cf88 <boot_validate_slot+0x8c>
    if (hdr->ih_magic != IMAGE_MAGIC) {
 c00cf50:	58e0      	ldr	r0, [r4, r3]
 c00cf52:	4b43      	ldr	r3, [pc, #268]	; (c00d060 <boot_validate_slot+0x164>)
 c00cf54:	4298      	cmp	r0, r3
 c00cf56:	d01e      	beq.n	c00cf96 <boot_validate_slot+0x9a>
        if (slot != BOOT_PRIMARY_SLOT) {
 c00cf58:	2e00      	cmp	r6, #0
 c00cf5a:	d177      	bne.n	c00d04c <boot_validate_slot+0x150>
        BOOT_LOG_ERR("Image in the %s slot is not valid!",
 c00cf5c:	4941      	ldr	r1, [pc, #260]	; (c00d064 <boot_validate_slot+0x168>)
 c00cf5e:	4842      	ldr	r0, [pc, #264]	; (c00d068 <boot_validate_slot+0x16c>)
 c00cf60:	f001 f944 	bl	c00e1ec <iprintf>
 c00cf64:	e010      	b.n	c00cf88 <boot_validate_slot+0x8c>
    erased_val = flash_area_erased_val(fap);
 c00cf66:	9807      	ldr	r0, [sp, #28]
 c00cf68:	f000 ff50 	bl	c00de0c <flash_area_erased_val>
 c00cf6c:	4605      	mov	r5, r0
    flash_area_close(fap);
 c00cf6e:	9807      	ldr	r0, [sp, #28]
 c00cf70:	f000 fea8 	bl	c00dcc4 <flash_area_close>
    if (!boot_data_is_set_to(erased_val, &hdr->ih_magic, sizeof(hdr->ih_magic))) {
 c00cf74:	2358      	movs	r3, #88	; 0x58
 c00cf76:	f894 2588 	ldrb.w	r2, [r4, #1416]	; 0x588
 c00cf7a:	fb13 8302 	smlabb	r3, r3, r2, r8
 c00cf7e:	4423      	add	r3, r4
 c00cf80:	1e5a      	subs	r2, r3, #1
 c00cf82:	3303      	adds	r3, #3
    for (i = 0; i < len; i++) {
 c00cf84:	429a      	cmp	r2, r3
 c00cf86:	d101      	bne.n	c00cf8c <boot_validate_slot+0x90>
        rc = 1;
 c00cf88:	2401      	movs	r4, #1
 c00cf8a:	e03a      	b.n	c00d002 <boot_validate_slot+0x106>
        if (val != p[i]) {
 c00cf8c:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 c00cf90:	42a9      	cmp	r1, r5
 c00cf92:	d0f7      	beq.n	c00cf84 <boot_validate_slot+0x88>
 c00cf94:	e7d2      	b.n	c00cf3c <boot_validate_slot+0x40>
    if (!boot_u32_safe_add(&size, hdr->ih_img_size, hdr->ih_hdr_size)) {
 c00cf96:	68cb      	ldr	r3, [r1, #12]
 c00cf98:	8909      	ldrh	r1, [r1, #8]
    if (a > UINT32_MAX - b) {
 c00cf9a:	43c8      	mvns	r0, r1
 c00cf9c:	4283      	cmp	r3, r0
 c00cf9e:	d8db      	bhi.n	c00cf58 <boot_validate_slot+0x5c>
 c00cfa0:	f8dd b018 	ldr.w	fp, [sp, #24]
        *dest = a + b;
 c00cfa4:	440b      	add	r3, r1
    if (size >= fap->fa_size) {
 c00cfa6:	f8db 1008 	ldr.w	r1, [fp, #8]
 c00cfaa:	428b      	cmp	r3, r1
 c00cfac:	d2d4      	bcs.n	c00cf58 <boot_validate_slot+0x5c>
    image_index = BOOT_CURR_IMG(state);
 c00cfae:	f894 9588 	ldrb.w	r9, [r4, #1416]	; 0x588
    if (MUST_DECRYPT(fap, image_index, hdr)) { 
 c00cfb2:	f89b 1000 	ldrb.w	r1, [fp]
 c00cfb6:	f1b9 0f00 	cmp.w	r9, #0
 c00cfba:	d029      	beq.n	c00d010 <boot_validate_slot+0x114>
 c00cfbc:	f1b9 0f01 	cmp.w	r9, #1
 c00cfc0:	bf14      	ite	ne
 c00cfc2:	23ff      	movne	r3, #255	; 0xff
 c00cfc4:	2304      	moveq	r3, #4
    return &BOOT_IMG(state, slot).hdr;
 c00cfc6:	2558      	movs	r5, #88	; 0x58
 c00cfc8:	fb15 850a 	smlabb	r5, r5, sl, r8
 c00cfcc:	4299      	cmp	r1, r3
 c00cfce:	4425      	add	r5, r4
 c00cfd0:	d020      	beq.n	c00d014 <boot_validate_slot+0x118>
    if (bootutil_img_validate(BOOT_CURR_ENC(state), image_index, hdr, fap, tmpbuf,
 c00cfd2:	f44f 731a 	mov.w	r3, #616	; 0x268
 c00cfd6:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00cfda:	462a      	mov	r2, r5
 c00cfdc:	fb03 4000 	mla	r0, r3, r0, r4
 c00cfe0:	2300      	movs	r3, #0
 c00cfe2:	e9cd 3303 	strd	r3, r3, [sp, #12]
 c00cfe6:	9302      	str	r3, [sp, #8]
 c00cfe8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c00cfec:	9301      	str	r3, [sp, #4]
 c00cfee:	4b1f      	ldr	r3, [pc, #124]	; (c00d06c <boot_validate_slot+0x170>)
 c00cff0:	4649      	mov	r1, r9
 c00cff2:	9300      	str	r3, [sp, #0]
 c00cff4:	30b8      	adds	r0, #184	; 0xb8
 c00cff6:	465b      	mov	r3, fp
 c00cff8:	f7ff fd04 	bl	c00ca04 <bootutil_img_validate>
 c00cffc:	4604      	mov	r4, r0
 c00cffe:	2800      	cmp	r0, #0
 c00d000:	d1aa      	bne.n	c00cf58 <boot_validate_slot+0x5c>
    flash_area_close(fap);
 c00d002:	9806      	ldr	r0, [sp, #24]
 c00d004:	f000 fe5e 	bl	c00dcc4 <flash_area_close>
}
 c00d008:	4620      	mov	r0, r4
 c00d00a:	b009      	add	sp, #36	; 0x24
 c00d00c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (MUST_DECRYPT(fap, image_index, hdr)) { 
 c00d010:	2303      	movs	r3, #3
 c00d012:	e7d8      	b.n	c00cfc6 <boot_validate_slot+0xca>
 c00d014:	0753      	lsls	r3, r2, #29
 c00d016:	d5dc      	bpl.n	c00cfd2 <boot_validate_slot+0xd6>
        rc = boot_enc_load(BOOT_CURR_ENC(state), image_index, hdr, fap, bs);
 c00d018:	f44f 781a 	mov.w	r8, #616	; 0x268
 c00d01c:	fb08 4009 	mla	r0, r8, r9, r4
 c00d020:	9700      	str	r7, [sp, #0]
 c00d022:	465b      	mov	r3, fp
 c00d024:	462a      	mov	r2, r5
 c00d026:	4649      	mov	r1, r9
 c00d028:	30b8      	adds	r0, #184	; 0xb8
 c00d02a:	f7ff fb09 	bl	c00c640 <boot_enc_load>
        if (rc < 0) {
 c00d02e:	2800      	cmp	r0, #0
 c00d030:	db92      	blt.n	c00cf58 <boot_validate_slot+0x5c>
        if (rc == 0 && boot_enc_set_key(BOOT_CURR_ENC(state), 1, bs)) {
 c00d032:	d1ce      	bne.n	c00cfd2 <boot_validate_slot+0xd6>
 c00d034:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d038:	463a      	mov	r2, r7
 c00d03a:	fb08 4000 	mla	r0, r8, r0, r4
 c00d03e:	2101      	movs	r1, #1
 c00d040:	30b8      	adds	r0, #184	; 0xb8
 c00d042:	f7ff fa09 	bl	c00c458 <boot_enc_set_key>
 c00d046:	2800      	cmp	r0, #0
 c00d048:	d0c3      	beq.n	c00cfd2 <boot_validate_slot+0xd6>
 c00d04a:	e785      	b.n	c00cf58 <boot_validate_slot+0x5c>
            flash_area_erase(fap, 0, fap->fa_size);
 c00d04c:	9806      	ldr	r0, [sp, #24]
 c00d04e:	2100      	movs	r1, #0
 c00d050:	6882      	ldr	r2, [r0, #8]
 c00d052:	f000 fe5d 	bl	c00dd10 <flash_area_erase>
        BOOT_LOG_ERR("Image in the %s slot is not valid!",
 c00d056:	4906      	ldr	r1, [pc, #24]	; (c00d070 <boot_validate_slot+0x174>)
 c00d058:	e781      	b.n	c00cf5e <boot_validate_slot+0x62>
        return -1;
 c00d05a:	f04f 34ff 	mov.w	r4, #4294967295
 c00d05e:	e7d3      	b.n	c00d008 <boot_validate_slot+0x10c>
 c00d060:	96f3b83d 	.word	0x96f3b83d
 c00d064:	0c010386 	.word	0x0c010386
 c00d068:	0c010398 	.word	0x0c010398
 c00d06c:	300361e4 	.word	0x300361e4
 c00d070:	0c01038e 	.word	0x0c01038e

0c00d074 <boot_status_reset>:
{
 c00d074:	b510      	push	{r4, lr}
    memset(&bs->enckey, 0xff, BOOT_NUM_SLOTS * BOOT_ENC_KEY_SIZE);
 c00d076:	2220      	movs	r2, #32
{
 c00d078:	4604      	mov	r4, r0
    memset(&bs->enckey, 0xff, BOOT_NUM_SLOTS * BOOT_ENC_KEY_SIZE);
 c00d07a:	21ff      	movs	r1, #255	; 0xff
 c00d07c:	300c      	adds	r0, #12
 c00d07e:	f001 f804 	bl	c00e08a <memset>
    bs->idx = BOOT_STATUS_IDX_0;
 c00d082:	2201      	movs	r2, #1
    bs->source = 0;
 c00d084:	2300      	movs	r3, #0
    bs->idx = BOOT_STATUS_IDX_0;
 c00d086:	6022      	str	r2, [r4, #0]
 c00d088:	f102 2201 	add.w	r2, r2, #16777472	; 0x1000100
    bs->source = 0;
 c00d08c:	62e3      	str	r3, [r4, #44]	; 0x2c
    bs->swap_type = BOOT_SWAP_TYPE_NONE;
 c00d08e:	e9c4 2301 	strd	r2, r3, [r4, #4]
}
 c00d092:	bd10      	pop	{r4, pc}

0c00d094 <boot_status_is_reset>:
            bs->idx == BOOT_STATUS_IDX_0 &&
 c00d094:	7943      	ldrb	r3, [r0, #5]
 c00d096:	2b01      	cmp	r3, #1
 c00d098:	d107      	bne.n	c00d0aa <boot_status_is_reset+0x16>
    return (bs->op == BOOT_STATUS_OP_MOVE &&
 c00d09a:	6803      	ldr	r3, [r0, #0]
 c00d09c:	2b01      	cmp	r3, #1
 c00d09e:	d104      	bne.n	c00d0aa <boot_status_is_reset+0x16>
            bs->idx == BOOT_STATUS_IDX_0 &&
 c00d0a0:	7900      	ldrb	r0, [r0, #4]
 c00d0a2:	1e43      	subs	r3, r0, #1
 c00d0a4:	4258      	negs	r0, r3
 c00d0a6:	4158      	adcs	r0, r3
 c00d0a8:	4770      	bx	lr
 c00d0aa:	2000      	movs	r0, #0
}
 c00d0ac:	4770      	bx	lr
	...

0c00d0b0 <boot_copy_region>:
int
boot_copy_region(struct boot_loader_state *state,
                 const struct flash_area *fap_src,
                 const struct flash_area *fap_dst,
                 uint32_t off_src, uint32_t off_dst, uint32_t sz)
{
 c00d0b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00d0b4:	4606      	mov	r6, r0
 c00d0b6:	4691      	mov	r9, r2
 c00d0b8:	469a      	mov	sl, r3
#endif
#if !defined(MCUBOOT_ENC_IMAGES)
    (void)state;
#endif

    bytes_copied = 0;
 c00d0ba:	2500      	movs	r5, #0
{
 c00d0bc:	b087      	sub	sp, #28
        if (sz - bytes_copied > sizeof buf) {
            chunk_sz = sizeof buf;
        } else {
            chunk_sz = sz - bytes_copied;
        }
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c00d0be:	f8df 80e8 	ldr.w	r8, [pc, #232]	; c00d1a8 <boot_copy_region+0xf8>
{
 c00d0c2:	9105      	str	r1, [sp, #20]
    while (bytes_copied < sz) {
 c00d0c4:	9b11      	ldr	r3, [sp, #68]	; 0x44
 c00d0c6:	429d      	cmp	r5, r3
 c00d0c8:	d301      	bcc.n	c00d0ce <boot_copy_region+0x1e>
        bytes_copied += chunk_sz;

        MCUBOOT_WATCHDOG_FEED();
    }

    return 0;
 c00d0ca:	2000      	movs	r0, #0
 c00d0cc:	e00f      	b.n	c00d0ee <boot_copy_region+0x3e>
        if (sz - bytes_copied > sizeof buf) {
 c00d0ce:	9b11      	ldr	r3, [sp, #68]	; 0x44
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c00d0d0:	4642      	mov	r2, r8
        if (sz - bytes_copied > sizeof buf) {
 c00d0d2:	1b5c      	subs	r4, r3, r5
 c00d0d4:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
 c00d0d8:	bf28      	it	cs
 c00d0da:	f44f 5480 	movcs.w	r4, #4096	; 0x1000
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
 c00d0de:	eb05 010a 	add.w	r1, r5, sl
 c00d0e2:	4623      	mov	r3, r4
 c00d0e4:	9805      	ldr	r0, [sp, #20]
 c00d0e6:	f000 fdef 	bl	c00dcc8 <flash_area_read>
        if (rc != 0) {
 c00d0ea:	b118      	cbz	r0, c00d0f4 <boot_copy_region+0x44>
            return BOOT_EFLASH;
 c00d0ec:	2001      	movs	r0, #1
}
 c00d0ee:	b007      	add	sp, #28
 c00d0f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((fap_src->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index) ||
 c00d0f4:	9b05      	ldr	r3, [sp, #20]
        image_index = BOOT_CURR_IMG(state);
 c00d0f6:	f896 1588 	ldrb.w	r1, [r6, #1416]	; 0x588
        if ((fap_src->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index) ||
 c00d0fa:	781a      	ldrb	r2, [r3, #0]
 c00d0fc:	2900      	cmp	r1, #0
 c00d0fe:	d043      	beq.n	c00d188 <boot_copy_region+0xd8>
 c00d100:	2901      	cmp	r1, #1
 c00d102:	bf14      	ite	ne
 c00d104:	23ff      	movne	r3, #255	; 0xff
 c00d106:	2304      	moveq	r3, #4
 c00d108:	429a      	cmp	r2, r3
 c00d10a:	f899 0000 	ldrb.w	r0, [r9]
 c00d10e:	d03d      	beq.n	c00d18c <boot_copy_region+0xdc>
 c00d110:	4283      	cmp	r3, r0
 c00d112:	d13d      	bne.n	c00d190 <boot_copy_region+0xe0>
 c00d114:	2258      	movs	r2, #88	; 0x58
 c00d116:	fb11 f202 	smulbb	r2, r1, r2
            if (fap_dst->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index)) {
 c00d11a:	4283      	cmp	r3, r0
 c00d11c:	bf1a      	itte	ne
 c00d11e:	322c      	addne	r2, #44	; 0x2c
 c00d120:	1992      	addne	r2, r2, r6
 c00d122:	1992      	addeq	r2, r2, r6
            if (IS_ENCRYPTED(hdr)) {
 c00d124:	6913      	ldr	r3, [r2, #16]
            off = off_src;
 c00d126:	bf14      	ite	ne
 c00d128:	4650      	movne	r0, sl
                off = off_dst;
 c00d12a:	9810      	ldreq	r0, [sp, #64]	; 0x40
            if (IS_ENCRYPTED(hdr)) {
 c00d12c:	075b      	lsls	r3, r3, #29
 c00d12e:	d52f      	bpl.n	c00d190 <boot_copy_region+0xe0>
                if (off + bytes_copied < hdr->ih_hdr_size) {
 c00d130:	8913      	ldrh	r3, [r2, #8]
 c00d132:	4428      	add	r0, r5
 c00d134:	469b      	mov	fp, r3
                tlv_off = BOOT_TLV_OFF(hdr);
 c00d136:	68d2      	ldr	r2, [r2, #12]
                if (off + bytes_copied < hdr->ih_hdr_size) {
 c00d138:	4298      	cmp	r0, r3
 c00d13a:	eba0 0e03 	sub.w	lr, r0, r3
                    blk_off = ((off + bytes_copied) - hdr->ih_hdr_size) & 0xf;
 c00d13e:	bf28      	it	cs
 c00d140:	f00e 030f 	andcs.w	r3, lr, #15
                tlv_off = BOOT_TLV_OFF(hdr);
 c00d144:	445a      	add	r2, fp
                if (off + bytes_copied + chunk_sz > tlv_off) {
 c00d146:	eb00 0b04 	add.w	fp, r0, r4
                    blk_off = ((off + bytes_copied) - hdr->ih_hdr_size) & 0xf;
 c00d14a:	bf2d      	iteet	cs
 c00d14c:	461f      	movcs	r7, r3
                    blk_sz = chunk_sz - hdr->ih_hdr_size;
 c00d14e:	eba4 0c03 	subcc.w	ip, r4, r3
                    blk_off = 0;
 c00d152:	2700      	movcc	r7, #0
                blk_sz = chunk_sz;
 c00d154:	46a4      	movcs	ip, r4
                idx = 0;
 c00d156:	bf28      	it	cs
 c00d158:	2300      	movcs	r3, #0
                if (off + bytes_copied + chunk_sz > tlv_off) {
 c00d15a:	4593      	cmp	fp, r2
 c00d15c:	d905      	bls.n	c00d16a <boot_copy_region+0xba>
                    if (off + bytes_copied >= tlv_off) {
 c00d15e:	4290      	cmp	r0, r2
                        blk_sz = 0;
 c00d160:	bf2c      	ite	cs
 c00d162:	f04f 0c00 	movcs.w	ip, #0
                        blk_sz = tlv_off - (off + bytes_copied);
 c00d166:	eba2 0c00 	subcc.w	ip, r2, r0
                boot_encrypt(BOOT_CURR_ENC(state), image_index, fap_src,
 c00d16a:	f44f 701a 	mov.w	r0, #616	; 0x268
 c00d16e:	fb00 6001 	mla	r0, r0, r1, r6
 c00d172:	eb03 0208 	add.w	r2, r3, r8
 c00d176:	9202      	str	r2, [sp, #8]
 c00d178:	e9cd c700 	strd	ip, r7, [sp]
 c00d17c:	4473      	add	r3, lr
 c00d17e:	9a05      	ldr	r2, [sp, #20]
 c00d180:	30b8      	adds	r0, #184	; 0xb8
 c00d182:	f7ff faab 	bl	c00c6dc <boot_encrypt>
 c00d186:	e003      	b.n	c00d190 <boot_copy_region+0xe0>
        if ((fap_src->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index) ||
 c00d188:	2303      	movs	r3, #3
 c00d18a:	e7bd      	b.n	c00d108 <boot_copy_region+0x58>
            !(fap_src->fa_id == FLASH_AREA_IMAGE_SECONDARY(image_index) &&
 c00d18c:	4283      	cmp	r3, r0
 c00d18e:	d1c1      	bne.n	c00d114 <boot_copy_region+0x64>
        rc = flash_area_write(fap_dst, off_dst + bytes_copied, buf, chunk_sz);
 c00d190:	9910      	ldr	r1, [sp, #64]	; 0x40
 c00d192:	4623      	mov	r3, r4
 c00d194:	4642      	mov	r2, r8
 c00d196:	1869      	adds	r1, r5, r1
 c00d198:	4648      	mov	r0, r9
 c00d19a:	f000 fda7 	bl	c00dcec <flash_area_write>
        if (rc != 0) {
 c00d19e:	2800      	cmp	r0, #0
 c00d1a0:	d1a4      	bne.n	c00d0ec <boot_copy_region+0x3c>
        bytes_copied += chunk_sz;
 c00d1a2:	4425      	add	r5, r4
 c00d1a4:	e78e      	b.n	c00d0c4 <boot_copy_region+0x14>
 c00d1a6:	bf00      	nop
 c00d1a8:	300308e4 	.word	0x300308e4

0c00d1ac <context_boot_go>:
#endif
}

int
context_boot_go(struct boot_loader_state *state, struct boot_rsp *rsp)
{
 c00d1ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00d1b0:	4604      	mov	r4, r0

    /* Iterate over all the images. By the end of the loop the swap type has
     * to be determined for each image and all aborted swaps have to be
     * completed.
     */
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d1b2:	2700      	movs	r7, #0
    int rc = -1;
 c00d1b4:	f04f 35ff 	mov.w	r5, #4294967295
{
 c00d1b8:	b09d      	sub	sp, #116	; 0x74
 c00d1ba:	4689      	mov	r9, r1
    memset(state, 0, sizeof(struct boot_loader_state));
 c00d1bc:	f240 528c 	movw	r2, #1420	; 0x58c
 c00d1c0:	2100      	movs	r1, #0

        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
            primary_slot_sectors[image_index];
#if !defined(MCUBOOT_PRIMARY_ONLY)
        BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors =
            secondary_slot_sectors[image_index];
 c00d1c2:	f8df a348 	ldr.w	sl, [pc, #840]	; c00d50c <context_boot_go+0x360>
        BOOT_LOG_WRN("Failed reading image headers; Image=%u",
 c00d1c6:	f8df b348 	ldr.w	fp, [pc, #840]	; c00d510 <context_boot_go+0x364>
    memset(state, 0, sizeof(struct boot_loader_state));
 c00d1ca:	f000 ff5e 	bl	c00e08a <memset>
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d1ce:	f884 7588 	strb.w	r7, [r4, #1416]	; 0x588
 c00d1d2:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d1d6:	2801      	cmp	r0, #1
 c00d1d8:	d92e      	bls.n	c00d238 <context_boot_go+0x8c>
#endif
        }
    }

#if (BOOT_IMAGE_NUMBER > 1)
    if (has_upgrade) {
 c00d1da:	2f00      	cmp	r7, #0
 c00d1dc:	f000 8152 	beq.w	c00d484 <context_boot_go+0x2d8>
    BOOT_CURR_IMG(state) = 0;
 c00d1e0:	2300      	movs	r3, #0
    int rc = -1;
 c00d1e2:	f04f 35ff 	mov.w	r5, #4294967295
 c00d1e6:	262c      	movs	r6, #44	; 0x2c
 c00d1e8:	2758      	movs	r7, #88	; 0x58
    BOOT_CURR_IMG(state) = 0;
 c00d1ea:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
    while (BOOT_CURR_IMG(state) < BOOT_IMAGE_NUMBER) {
 c00d1ee:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d1f2:	2801      	cmp	r0, #1
 c00d1f4:	f200 8146 	bhi.w	c00d484 <context_boot_go+0x2d8>
        if (BOOT_SWAP_TYPE(state) != BOOT_SWAP_TYPE_NONE &&
 c00d1f8:	1823      	adds	r3, r4, r0
 c00d1fa:	f893 50b0 	ldrb.w	r5, [r3, #176]	; 0xb0
 c00d1fe:	f005 05fb 	and.w	r5, r5, #251	; 0xfb
 c00d202:	f115 35ff 	adds.w	r5, r5, #4294967295
 c00d206:	bf18      	it	ne
 c00d208:	2501      	movne	r5, #1
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00d20a:	4629      	mov	r1, r5
 c00d20c:	f000 fdc8 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
 c00d210:	a905      	add	r1, sp, #20
 c00d212:	b2c0      	uxtb	r0, r0
 c00d214:	f000 fd38 	bl	c00dc88 <flash_area_open>
    if (rc != 0) {
 c00d218:	2800      	cmp	r0, #0
 c00d21a:	f000 80cd 	beq.w	c00d3b8 <context_boot_go+0x20c>
        rc = BOOT_EFLASH;
 c00d21e:	2501      	movs	r5, #1
    flash_area_close(fap);
 c00d220:	9805      	ldr	r0, [sp, #20]
 c00d222:	f000 fd4f 	bl	c00dcc4 <flash_area_close>
        if (rc == 0) {
 c00d226:	2d00      	cmp	r5, #0
 c00d228:	f040 8125 	bne.w	c00d476 <context_boot_go+0x2ca>
            BOOT_CURR_IMG(state)++;
 c00d22c:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d230:	3301      	adds	r3, #1
 c00d232:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
 c00d236:	e7da      	b.n	c00d1ee <context_boot_go+0x42>
        boot_enc_zeroize(BOOT_CURR_ENC(state));
 c00d238:	f44f 731a 	mov.w	r3, #616	; 0x268
 c00d23c:	fb03 4000 	mla	r0, r3, r0, r4
 c00d240:	30b8      	adds	r0, #184	; 0xb8
 c00d242:	f7ff fa94 	bl	c00c76e <boot_enc_zeroize>
 c00d246:	f44f 5392 	mov.w	r3, #4672	; 0x1240
        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
 c00d24a:	2658      	movs	r6, #88	; 0x58
        image_index = BOOT_CURR_IMG(state);
 c00d24c:	f894 5588 	ldrb.w	r5, [r4, #1416]	; 0x588
            primary_slot_sectors[image_index];
 c00d250:	49ab      	ldr	r1, [pc, #684]	; (c00d500 <context_boot_go+0x354>)
 c00d252:	436b      	muls	r3, r5
        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
 c00d254:	fb06 4205 	mla	r2, r6, r5, r4
            primary_slot_sectors[image_index];
 c00d258:	1859      	adds	r1, r3, r1
            secondary_slot_sectors[image_index];
 c00d25a:	4453      	add	r3, sl
        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
 c00d25c:	6251      	str	r1, [r2, #36]	; 0x24
        BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors =
 c00d25e:	6513      	str	r3, [r2, #80]	; 0x50
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
 c00d260:	2100      	movs	r1, #0
 c00d262:	4628      	mov	r0, r5
 c00d264:	f000 fd9c 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(state, slot));
 c00d268:	f894 1588 	ldrb.w	r1, [r4, #1416]	; 0x588
 c00d26c:	b2c0      	uxtb	r0, r0
 c00d26e:	fb06 4101 	mla	r1, r6, r1, r4
 c00d272:	3120      	adds	r1, #32
 c00d274:	f000 fd08 	bl	c00dc88 <flash_area_open>
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
 c00d278:	2101      	movs	r1, #1
 c00d27a:	4628      	mov	r0, r5
 c00d27c:	f000 fd90 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(state, slot));
 c00d280:	f894 1588 	ldrb.w	r1, [r4, #1416]	; 0x588
 c00d284:	b2c0      	uxtb	r0, r0
 c00d286:	fb06 4101 	mla	r1, r6, r1, r4
 c00d28a:	314c      	adds	r1, #76	; 0x4c
 c00d28c:	f000 fcfc 	bl	c00dc88 <flash_area_open>
 c00d290:	4605      	mov	r5, r0
    rc = boot_read_sectors(state);
 c00d292:	4620      	mov	r0, r4
 c00d294:	f7ff fde5 	bl	c00ce62 <boot_read_sectors>
    if (rc != 0) {
 c00d298:	4602      	mov	r2, r0
 c00d29a:	b158      	cbz	r0, c00d2b4 <context_boot_go+0x108>
        BOOT_LOG_WRN("Failed reading sectors; BOOT_MAX_IMG_SECTORS=%d"
 c00d29c:	f44f 7112 	mov.w	r1, #584	; 0x248
 c00d2a0:	4898      	ldr	r0, [pc, #608]	; (c00d504 <context_boot_go+0x358>)
        BOOT_LOG_WRN("Failed reading image headers; Image=%u",
 c00d2a2:	f000 ffa3 	bl	c00e1ec <iprintf>
        BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
 c00d2a6:	2201      	movs	r2, #1
 c00d2a8:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d2ac:	4423      	add	r3, r4
 c00d2ae:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
 c00d2b2:	e059      	b.n	c00d368 <context_boot_go+0x1bc>
    rc = boot_read_image_headers(state, false, NULL);
 c00d2b4:	4601      	mov	r1, r0
 c00d2b6:	4620      	mov	r0, r4
 c00d2b8:	f7ff fdb1 	bl	c00ce1e <boot_read_image_headers>
    if (rc != 0) {
 c00d2bc:	b118      	cbz	r0, c00d2c6 <context_boot_go+0x11a>
        BOOT_LOG_WRN("Failed reading image headers; Image=%u",
 c00d2be:	f894 1588 	ldrb.w	r1, [r4, #1416]	; 0x588
 c00d2c2:	4658      	mov	r0, fp
 c00d2c4:	e7ed      	b.n	c00d2a2 <context_boot_go+0xf6>
    if (boot_slots_compatible(state)) {
 c00d2c6:	4620      	mov	r0, r4
 c00d2c8:	f000 fa94 	bl	c00d7f4 <boot_slots_compatible>
 c00d2cc:	2800      	cmp	r0, #0
 c00d2ce:	d0ea      	beq.n	c00d2a6 <context_boot_go+0xfa>
        boot_status_reset(bs);
 c00d2d0:	a810      	add	r0, sp, #64	; 0x40
 c00d2d2:	f7ff fecf 	bl	c00d074 <boot_status_reset>
        if (!boot_status_is_reset(bs)) {
 c00d2d6:	a810      	add	r0, sp, #64	; 0x40
 c00d2d8:	f7ff fedc 	bl	c00d094 <boot_status_is_reset>
 c00d2dc:	4606      	mov	r6, r0
 c00d2de:	b9b0      	cbnz	r0, c00d30e <context_boot_go+0x162>
    if (BOOT_CURR_IMG(state) == 0) {
 c00d2e0:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d2e4:	b98b      	cbnz	r3, c00d30a <context_boot_go+0x15e>
            rc = boot_read_image_headers(state, false, bs);
 c00d2e6:	aa10      	add	r2, sp, #64	; 0x40
 c00d2e8:	2100      	movs	r1, #0
 c00d2ea:	4620      	mov	r0, r4
 c00d2ec:	f7ff fd97 	bl	c00ce1e <boot_read_image_headers>
 c00d2f0:	e7d9      	b.n	c00d2a6 <context_boot_go+0xfa>
 c00d2f2:	19a2      	adds	r2, r4, r6
        if (state->swap_type[i] == BOOT_SWAP_TYPE_REVERT) {
 c00d2f4:	f892 00b0 	ldrb.w	r0, [r2, #176]	; 0xb0
 c00d2f8:	3601      	adds	r6, #1
 c00d2fa:	2804      	cmp	r0, #4
            state->swap_type[i] = BOOT_SWAP_TYPE_NONE;
 c00d2fc:	bf08      	it	eq
 c00d2fe:	f882 10b0 	strbeq.w	r1, [r2, #176]	; 0xb0
    for (uint8_t i = 0; i < BOOT_CURR_IMG(state); i++) {
 c00d302:	b2f2      	uxtb	r2, r6
 c00d304:	4293      	cmp	r3, r2
 c00d306:	d8f4      	bhi.n	c00d2f2 <context_boot_go+0x146>
 c00d308:	e7ed      	b.n	c00d2e6 <context_boot_go+0x13a>
            state->swap_type[i] = BOOT_SWAP_TYPE_NONE;
 c00d30a:	2101      	movs	r1, #1
 c00d30c:	e7f9      	b.n	c00d302 <context_boot_go+0x156>
            if (bs->swap_type == BOOT_SWAP_TYPE_NONE) {
 c00d30e:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
 c00d312:	2901      	cmp	r1, #1
 c00d314:	d137      	bne.n	c00d386 <context_boot_go+0x1da>
    swap_type = boot_swap_type_multi(BOOT_CURR_IMG(state));
 c00d316:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d31a:	9103      	str	r1, [sp, #12]
 c00d31c:	f7ff f82a 	bl	c00c374 <boot_swap_type_multi>
    if (BOOT_IS_UPGRADE(swap_type)) {
 c00d320:	1e82      	subs	r2, r0, #2
 c00d322:	2a02      	cmp	r2, #2
    swap_type = boot_swap_type_multi(BOOT_CURR_IMG(state));
 c00d324:	4680      	mov	r8, r0
    if (BOOT_IS_UPGRADE(swap_type)) {
 c00d326:	9903      	ldr	r1, [sp, #12]
 c00d328:	d809      	bhi.n	c00d33e <context_boot_go+0x192>
        rc = boot_validate_slot(state, BOOT_SECONDARY_SLOT, bs);
 c00d32a:	aa10      	add	r2, sp, #64	; 0x40
 c00d32c:	4620      	mov	r0, r4
 c00d32e:	f7ff fde5 	bl	c00cefc <boot_validate_slot>
        if (rc == 1) {
 c00d332:	2801      	cmp	r0, #1
 c00d334:	d025      	beq.n	c00d382 <context_boot_go+0x1d6>
            swap_type = BOOT_SWAP_TYPE_FAIL;
 c00d336:	2800      	cmp	r0, #0
 c00d338:	bf18      	it	ne
 c00d33a:	f04f 0805 	movne.w	r8, #5
                BOOT_SWAP_TYPE(state) = boot_validated_swap_type(state, bs);
 c00d33e:	f894 2588 	ldrb.w	r2, [r4, #1416]	; 0x588
 c00d342:	4422      	add	r2, r4
 c00d344:	f882 80b0 	strb.w	r8, [r2, #176]	; 0xb0
    if (BOOT_CURR_IMG(state) == 0) {
 c00d348:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d34c:	b163      	cbz	r3, c00d368 <context_boot_go+0x1bc>
 c00d34e:	18e2      	adds	r2, r4, r3
 c00d350:	f892 20b0 	ldrb.w	r2, [r2, #176]	; 0xb0
        if ((BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_NONE) ||
 c00d354:	2a01      	cmp	r2, #1
 c00d356:	d010      	beq.n	c00d37a <context_boot_go+0x1ce>
 c00d358:	2a04      	cmp	r2, #4
 c00d35a:	f000 8217 	beq.w	c00d78c <context_boot_go+0x5e0>
 c00d35e:	2200      	movs	r2, #0
            state->swap_type[i] = BOOT_SWAP_TYPE_NONE;
 c00d360:	2001      	movs	r0, #1
    for (uint8_t i = 0; i < BOOT_CURR_IMG(state); i++) {
 c00d362:	b2d1      	uxtb	r1, r2
 c00d364:	428b      	cmp	r3, r1
 c00d366:	d81e      	bhi.n	c00d3a6 <context_boot_go+0x1fa>
        if (BOOT_IS_UPGRADE(BOOT_SWAP_TYPE(state))) {
 c00d368:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d36c:	18e2      	adds	r2, r4, r3
 c00d36e:	f892 20b0 	ldrb.w	r2, [r2, #176]	; 0xb0
 c00d372:	3a02      	subs	r2, #2
            has_upgrade = true;
 c00d374:	2a02      	cmp	r2, #2
 c00d376:	bf98      	it	ls
 c00d378:	2701      	movls	r7, #1
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d37a:	3301      	adds	r3, #1
 c00d37c:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
 c00d380:	e727      	b.n	c00d1d2 <context_boot_go+0x26>
            swap_type = BOOT_SWAP_TYPE_NONE;
 c00d382:	4680      	mov	r8, r0
 c00d384:	e7db      	b.n	c00d33e <context_boot_go+0x192>
            } else if (boot_validate_slot(state, BOOT_SECONDARY_SLOT, bs) != 0) {
 c00d386:	aa10      	add	r2, sp, #64	; 0x40
 c00d388:	2101      	movs	r1, #1
 c00d38a:	4620      	mov	r0, r4
 c00d38c:	f7ff fdb6 	bl	c00cefc <boot_validate_slot>
 c00d390:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
                BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_FAIL;
 c00d394:	4423      	add	r3, r4
            } else if (boot_validate_slot(state, BOOT_SECONDARY_SLOT, bs) != 0) {
 c00d396:	b118      	cbz	r0, c00d3a0 <context_boot_go+0x1f4>
                BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_FAIL;
 c00d398:	2205      	movs	r2, #5
                BOOT_SWAP_TYPE(state) = bs->swap_type;
 c00d39a:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
 c00d39e:	e7d3      	b.n	c00d348 <context_boot_go+0x19c>
 c00d3a0:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
 c00d3a4:	e7f9      	b.n	c00d39a <context_boot_go+0x1ee>
 c00d3a6:	18a1      	adds	r1, r4, r2
        if (state->swap_type[i] == BOOT_SWAP_TYPE_REVERT) {
 c00d3a8:	f891 60b0 	ldrb.w	r6, [r1, #176]	; 0xb0
 c00d3ac:	3201      	adds	r2, #1
 c00d3ae:	2e04      	cmp	r6, #4
            state->swap_type[i] = BOOT_SWAP_TYPE_NONE;
 c00d3b0:	bf08      	it	eq
 c00d3b2:	f881 00b0 	strbeq.w	r0, [r1, #176]	; 0xb0
 c00d3b6:	e7d4      	b.n	c00d362 <context_boot_go+0x1b6>
    rc = bootutil_tlv_iter_begin(&it, boot_img_hdr(state, slot), fap,
 c00d3b8:	2301      	movs	r3, #1
 c00d3ba:	4375      	muls	r5, r6
 c00d3bc:	f894 1588 	ldrb.w	r1, [r4, #1416]	; 0x588
 c00d3c0:	9300      	str	r3, [sp, #0]
 c00d3c2:	fb17 5101 	smlabb	r1, r7, r1, r5
 c00d3c6:	2340      	movs	r3, #64	; 0x40
 c00d3c8:	9a05      	ldr	r2, [sp, #20]
 c00d3ca:	4421      	add	r1, r4
 c00d3cc:	a80a      	add	r0, sp, #40	; 0x28
 c00d3ce:	f000 fa63 	bl	c00d898 <bootutil_tlv_iter_begin>
    if (rc != 0) {
 c00d3d2:	4605      	mov	r5, r0
 c00d3d4:	2800      	cmp	r0, #0
 c00d3d6:	f47f af23 	bne.w	c00d220 <context_boot_go+0x74>
        rc = bootutil_tlv_iter_next(&it, &off, &len, NULL);
 c00d3da:	2300      	movs	r3, #0
 c00d3dc:	f10d 0212 	add.w	r2, sp, #18
 c00d3e0:	a906      	add	r1, sp, #24
 c00d3e2:	a80a      	add	r0, sp, #40	; 0x28
 c00d3e4:	f000 faa4 	bl	c00d930 <bootutil_tlv_iter_next>
        if (rc < 0) {
 c00d3e8:	2800      	cmp	r0, #0
 c00d3ea:	f2c0 81cc 	blt.w	c00d786 <context_boot_go+0x5da>
 c00d3ee:	9805      	ldr	r0, [sp, #20]
        } else if (rc > 0) {
 c00d3f0:	f47f af16 	bne.w	c00d220 <context_boot_go+0x74>
        if (len != sizeof(dep)) {
 c00d3f4:	f8bd 3012 	ldrh.w	r3, [sp, #18]
 c00d3f8:	2b0c      	cmp	r3, #12
 c00d3fa:	d138      	bne.n	c00d46e <context_boot_go+0x2c2>
        rc = flash_area_read(fap, off, &dep, len);
 c00d3fc:	aa07      	add	r2, sp, #28
 c00d3fe:	9906      	ldr	r1, [sp, #24]
 c00d400:	f000 fc62 	bl	c00dcc8 <flash_area_read>
        if (rc != 0) {
 c00d404:	2800      	cmp	r0, #0
 c00d406:	f47f af0a 	bne.w	c00d21e <context_boot_go+0x72>
        if (dep.image_id >= BOOT_IMAGE_NUMBER) {
 c00d40a:	f89d 201c 	ldrb.w	r2, [sp, #28]
 c00d40e:	2a01      	cmp	r2, #1
 c00d410:	d82f      	bhi.n	c00d472 <context_boot_go+0x2c6>
    swap_type = state->swap_type[dep->image_id];
 c00d412:	18a3      	adds	r3, r4, r2
                                          : BOOT_PRIMARY_SLOT;
 c00d414:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
    if (ver->iv_major > req->iv_major) {
 c00d418:	437a      	muls	r2, r7
                                          : BOOT_PRIMARY_SLOT;
 c00d41a:	3b02      	subs	r3, #2
 c00d41c:	2b02      	cmp	r3, #2
 c00d41e:	bf8c      	ite	hi
 c00d420:	2300      	movhi	r3, #0
 c00d422:	2301      	movls	r3, #1
    if (ver->iv_major > req->iv_major) {
 c00d424:	fb06 2303 	mla	r3, r6, r3, r2
 c00d428:	4423      	add	r3, r4
 c00d42a:	7d19      	ldrb	r1, [r3, #20]
 c00d42c:	f89d 2020 	ldrb.w	r2, [sp, #32]
 c00d430:	4291      	cmp	r1, r2
 c00d432:	d8d2      	bhi.n	c00d3da <context_boot_go+0x22e>
    if (ver->iv_major < req->iv_major) {
 c00d434:	d30a      	bcc.n	c00d44c <context_boot_go+0x2a0>
    if (ver->iv_minor > req->iv_minor) {
 c00d436:	7d59      	ldrb	r1, [r3, #21]
 c00d438:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
 c00d43c:	4291      	cmp	r1, r2
 c00d43e:	d8cc      	bhi.n	c00d3da <context_boot_go+0x22e>
    if (ver->iv_minor < req->iv_minor) {
 c00d440:	d304      	bcc.n	c00d44c <context_boot_go+0x2a0>
    if (ver->iv_revision < req->iv_revision) {
 c00d442:	8ada      	ldrh	r2, [r3, #22]
 c00d444:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 c00d448:	429a      	cmp	r2, r3
 c00d44a:	d2c6      	bcs.n	c00d3da <context_boot_go+0x22e>
        switch (BOOT_SWAP_TYPE(state)) {
 c00d44c:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d450:	4423      	add	r3, r4
 c00d452:	f893 20b0 	ldrb.w	r2, [r3, #176]	; 0xb0
 c00d456:	2a01      	cmp	r2, #1
 c00d458:	d007      	beq.n	c00d46a <context_boot_go+0x2be>
 c00d45a:	d304      	bcc.n	c00d466 <context_boot_go+0x2ba>
 c00d45c:	2a03      	cmp	r2, #3
 c00d45e:	d802      	bhi.n	c00d466 <context_boot_go+0x2ba>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
 c00d460:	2201      	movs	r2, #1
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_REVERT;
 c00d462:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
        switch (BOOT_SWAP_TYPE(state)) {
 c00d466:	2508      	movs	r5, #8
 c00d468:	e6da      	b.n	c00d220 <context_boot_go+0x74>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_REVERT;
 c00d46a:	2204      	movs	r2, #4
 c00d46c:	e7f9      	b.n	c00d462 <context_boot_go+0x2b6>
            rc = BOOT_EBADIMAGE;
 c00d46e:	2503      	movs	r5, #3
 c00d470:	e6d6      	b.n	c00d220 <context_boot_go+0x74>
            rc = BOOT_EBADARGS;
 c00d472:	2507      	movs	r5, #7
 c00d474:	e6d4      	b.n	c00d220 <context_boot_go+0x74>
        } else if (rc == BOOT_EBADVERSION) {
 c00d476:	2d08      	cmp	r5, #8
 c00d478:	d104      	bne.n	c00d484 <context_boot_go+0x2d8>
                BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
 c00d47a:	f240 1301 	movw	r3, #257	; 0x101
             * It was impossible to upgrade because the expected dependency version
             * was not available. Here we already changed the swap_type so that
             * instead of asserting the bootloader, we continue and no upgrade is
             * performed.
             */
            rc = 0;
 c00d47e:	2500      	movs	r5, #0
                BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
 c00d480:	f8a4 30b0 	strh.w	r3, [r4, #176]	; 0xb0

    /* Iterate over all the images. At this point there are no aborted swaps
     * and the swap types are determined for each image. By the end of the loop
     * all required update operations will have been finished.
     */
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d484:	2300      	movs	r3, #0
 c00d486:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
 c00d48a:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d48e:	2801      	cmp	r0, #1
 c00d490:	d91a      	bls.n	c00d4c8 <context_boot_go+0x31c>

    /* Iterate over all the images. At this point all required update operations
     * have finished. By the end of the loop each image in the primary slot will
     * have been re-validated.
     */
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d492:	2300      	movs	r3, #0
        }

#ifdef MCUBOOT_VALIDATE_PRIMARY_SLOT
#if defined(MCUBOOT_DOUBLE_SIGN_VERIF)
        /* Enable image validation double check */
        ImageValidEnable = 1;
 c00d494:	4f1c      	ldr	r7, [pc, #112]	; (c00d508 <context_boot_go+0x35c>)
#ifdef MCUBOOT_MEASURED_BOOT
        rc = boot_save_boot_status(BOOT_CURR_IMG(state),
                                   boot_img_hdr(state, BOOT_PRIMARY_SLOT),
                                   BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT));
        if (rc != 0) {
            BOOT_LOG_ERR("Failed to add Image %u data to shared memory area",
 c00d496:	f8df 807c 	ldr.w	r8, [pc, #124]	; c00d514 <context_boot_go+0x368>
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d49a:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
            rc = boot_read_image_headers(state, false, &bs);
 c00d49e:	ae10      	add	r6, sp, #64	; 0x40
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d4a0:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d4a4:	2b01      	cmp	r3, #1
 c00d4a6:	f240 80f0 	bls.w	c00d68a <context_boot_go+0x4de>
    /*
     * Since the boot_status struct stores plaintext encryption keys, reset
     * them here to avoid the possibility of jumping into an image that could
     * easily recover them.
     */
    memset(&bs, 0, sizeof(struct boot_status));
 c00d4aa:	2230      	movs	r2, #48	; 0x30
 c00d4ac:	2100      	movs	r1, #0
 c00d4ae:	a810      	add	r0, sp, #64	; 0x40
 c00d4b0:	f000 fdeb 	bl	c00e08a <memset>

    rsp->br_flash_dev_id = BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT)->fa_device_id;
 c00d4b4:	6a23      	ldr	r3, [r4, #32]
 c00d4b6:	785a      	ldrb	r2, [r3, #1]
 c00d4b8:	f889 2004 	strb.w	r2, [r9, #4]
    rsp->br_image_off = boot_img_slot_off(state, BOOT_PRIMARY_SLOT);
 c00d4bc:	685b      	ldr	r3, [r3, #4]
    rsp->br_hdr = boot_img_hdr(state, BOOT_PRIMARY_SLOT);
 c00d4be:	f8c9 4000 	str.w	r4, [r9]
    rsp->br_image_off = boot_img_slot_off(state, BOOT_PRIMARY_SLOT);
 c00d4c2:	f8c9 3008 	str.w	r3, [r9, #8]
 c00d4c6:	e0f7      	b.n	c00d6b8 <context_boot_go+0x50c>
        boot_enc_zeroize(BOOT_CURR_ENC(state));
 c00d4c8:	f44f 731a 	mov.w	r3, #616	; 0x268
 c00d4cc:	fb03 4000 	mla	r0, r3, r0, r4
        boot_status_reset(&bs);
 c00d4d0:	f10d 0a40 	add.w	sl, sp, #64	; 0x40
        boot_enc_zeroize(BOOT_CURR_ENC(state));
 c00d4d4:	30b8      	adds	r0, #184	; 0xb8
 c00d4d6:	f7ff f94a 	bl	c00c76e <boot_enc_zeroize>
        boot_status_reset(&bs);
 c00d4da:	4650      	mov	r0, sl
 c00d4dc:	f7ff fdca 	bl	c00d074 <boot_status_reset>
        bs.swap_type = BOOT_SWAP_TYPE(state);
 c00d4e0:	f894 2588 	ldrb.w	r2, [r4, #1416]	; 0x588
 c00d4e4:	18a1      	adds	r1, r4, r2
 c00d4e6:	f891 30b0 	ldrb.w	r3, [r1, #176]	; 0xb0
 c00d4ea:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
        switch (BOOT_SWAP_TYPE(state)) {
 c00d4ee:	3b01      	subs	r3, #1
 c00d4f0:	2b04      	cmp	r3, #4
 c00d4f2:	f200 80c4 	bhi.w	c00d67e <context_boot_go+0x4d2>
 c00d4f6:	e8df f003 	tbb	[pc, r3]
 c00d4fa:	0f88      	.short	0x0f88
 c00d4fc:	0f0f      	.short	0x0f0f
 c00d4fe:	88          	.byte	0x88
 c00d4ff:	00          	.byte	0x00
 c00d500:	300318e4 	.word	0x300318e4
 c00d504:	0c0103c3 	.word	0x0c0103c3
 c00d508:	30030174 	.word	0x30030174
 c00d50c:	30033d64 	.word	0x30033d64
 c00d510:	0c010408 	.word	0x0c010408
 c00d514:	0c010555 	.word	0x0c010555
    if (IS_OTFDEC_ENCRYPTED(boot_img_hdr(state, BOOT_SECONDARY_SLOT))) {
 c00d518:	2358      	movs	r3, #88	; 0x58
 c00d51a:	fb03 4202 	mla	r2, r3, r2, r4
 c00d51e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 c00d520:	0719      	lsls	r1, r3, #28
 c00d522:	d442      	bmi.n	c00d5aa <context_boot_go+0x3fe>
    BOOT_LOG_INF("Image upgrade secondary slot -> primary slot");
 c00d524:	489c      	ldr	r0, [pc, #624]	; (c00d798 <context_boot_go+0x5ec>)
 c00d526:	f000 fed5 	bl	c00e2d4 <puts>
    BOOT_LOG_INF("Erasing the primary slot");
 c00d52a:	489c      	ldr	r0, [pc, #624]	; (c00d79c <context_boot_go+0x5f0>)
 c00d52c:	f000 fed2 	bl	c00e2d4 <puts>
    image_index = BOOT_CURR_IMG(state);
 c00d530:	f894 7588 	ldrb.w	r7, [r4, #1416]	; 0x588
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c00d534:	2f00      	cmp	r7, #0
 c00d536:	d13e      	bne.n	c00d5b6 <context_boot_go+0x40a>
 c00d538:	2001      	movs	r0, #1
 c00d53a:	a907      	add	r1, sp, #28
 c00d53c:	f000 fba4 	bl	c00dc88 <flash_area_open>
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY(image_index),
 c00d540:	2f00      	cmp	r7, #0
 c00d542:	d03d      	beq.n	c00d5c0 <context_boot_go+0x414>
 c00d544:	2f01      	cmp	r7, #1
 c00d546:	bf14      	ite	ne
 c00d548:	20ff      	movne	r0, #255	; 0xff
 c00d54a:	2004      	moveq	r0, #4
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c00d54c:	2600      	movs	r6, #0
}

static inline size_t
boot_img_num_sectors(const struct boot_loader_state *state, size_t slot)
{
    return BOOT_IMG(state, slot).num_sectors;
 c00d54e:	2558      	movs	r5, #88	; 0x58
 c00d550:	46b0      	mov	r8, r6
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY(image_index),
 c00d552:	a90a      	add	r1, sp, #40	; 0x28
 c00d554:	f000 fb98 	bl	c00dc88 <flash_area_open>
 c00d558:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d55c:	fb05 4303 	mla	r3, r5, r3, r4
 c00d560:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c00d562:	4543      	cmp	r3, r8
 c00d564:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d568:	d12c      	bne.n	c00d5c4 <context_boot_go+0x418>
    if (IS_ENCRYPTED(boot_img_hdr(state, BOOT_SECONDARY_SLOT))) {
 c00d56a:	fb05 4300 	mla	r3, r5, r0, r4
 c00d56e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 c00d570:	075a      	lsls	r2, r3, #29
 c00d572:	d439      	bmi.n	c00d5e8 <context_boot_go+0x43c>
    BOOT_LOG_INF("Copying the secondary slot to the primary slot: 0x%x bytes",
 c00d574:	4631      	mov	r1, r6
 c00d576:	488a      	ldr	r0, [pc, #552]	; (c00d7a0 <context_boot_go+0x5f4>)
 c00d578:	f000 fe38 	bl	c00e1ec <iprintf>
    rc = boot_copy_region(state, fap_secondary_slot, fap_primary_slot, 0, 0, size);
 c00d57c:	2300      	movs	r3, #0
 c00d57e:	9601      	str	r6, [sp, #4]
    return &BOOT_IMG(state, slot).hdr;
 c00d580:	2658      	movs	r6, #88	; 0x58
 c00d582:	9300      	str	r3, [sp, #0]
 c00d584:	9a07      	ldr	r2, [sp, #28]
 c00d586:	990a      	ldr	r1, [sp, #40]	; 0x28
 c00d588:	4620      	mov	r0, r4
 c00d58a:	f7ff fd91 	bl	c00d0b0 <boot_copy_region>
    rc = boot_update_security_counter(BOOT_CURR_IMG(state), BOOT_PRIMARY_SLOT,
 c00d58e:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d592:	fb06 4100 	mla	r1, r6, r0, r4
 c00d596:	312c      	adds	r1, #44	; 0x2c
 c00d598:	f7ff fc8d 	bl	c00ceb6 <boot_update_security_counter.constprop.2>
    if (rc != 0) {
 c00d59c:	4605      	mov	r5, r0
 c00d59e:	2800      	cmp	r0, #0
 c00d5a0:	d04b      	beq.n	c00d63a <context_boot_go+0x48e>
        BOOT_LOG_ERR("Security counter update failed after image upgrade.");
 c00d5a2:	4880      	ldr	r0, [pc, #512]	; (c00d7a4 <context_boot_go+0x5f8>)
 c00d5a4:	f000 fe96 	bl	c00e2d4 <puts>
 c00d5a8:	e02f      	b.n	c00d60a <context_boot_go+0x45e>
        if (otfdec_invalidate_key() != 0) {
 c00d5aa:	f7f5 feb3 	bl	c003314 <otfdec_invalidate_key>
 c00d5ae:	2800      	cmp	r0, #0
 c00d5b0:	d0b8      	beq.n	c00d524 <context_boot_go+0x378>
            return BOOT_EFLASH;
 c00d5b2:	2501      	movs	r5, #1
 c00d5b4:	e029      	b.n	c00d60a <context_boot_go+0x45e>
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index),
 c00d5b6:	2f01      	cmp	r7, #1
 c00d5b8:	bf14      	ite	ne
 c00d5ba:	20ff      	movne	r0, #255	; 0xff
 c00d5bc:	2002      	moveq	r0, #2
 c00d5be:	e7bc      	b.n	c00d53a <context_boot_go+0x38e>
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY(image_index),
 c00d5c0:	2003      	movs	r0, #3
 c00d5c2:	e7c3      	b.n	c00d54c <context_boot_go+0x3a0>

static inline size_t
boot_img_sector_size(const struct boot_loader_state *state,
                     size_t slot, size_t sector)
{
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c00d5c4:	fb05 4000 	mla	r0, r5, r0, r4
 c00d5c8:	6a42      	ldr	r2, [r0, #36]	; 0x24
    return flash_area_erase(fap, off, sz);
 c00d5ca:	4631      	mov	r1, r6
 c00d5cc:	eb02 02c8 	add.w	r2, r2, r8, lsl #3
 c00d5d0:	f8d2 b004 	ldr.w	fp, [r2, #4]
 c00d5d4:	9807      	ldr	r0, [sp, #28]
 c00d5d6:	465a      	mov	r2, fp
 c00d5d8:	9303      	str	r3, [sp, #12]
        size += this_size;
 c00d5da:	445e      	add	r6, fp
    return flash_area_erase(fap, off, sz);
 c00d5dc:	f000 fb98 	bl	c00dd10 <flash_area_erase>
    for (sect = 0, size = 0; sect < sect_count; sect++) {
 c00d5e0:	f108 0801 	add.w	r8, r8, #1
 c00d5e4:	9b03      	ldr	r3, [sp, #12]
 c00d5e6:	e7bc      	b.n	c00d562 <context_boot_go+0x3b6>
        rc = boot_enc_load(BOOT_CURR_ENC(state), image_index,
 c00d5e8:	f44f 781a 	mov.w	r8, #616	; 0x268
    return &BOOT_IMG(state, slot).hdr;
 c00d5ec:	fb05 4200 	mla	r2, r5, r0, r4
 c00d5f0:	fb08 4000 	mla	r0, r8, r0, r4
 c00d5f4:	f8cd a000 	str.w	sl, [sp]
 c00d5f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 c00d5fa:	322c      	adds	r2, #44	; 0x2c
 c00d5fc:	4639      	mov	r1, r7
 c00d5fe:	30b8      	adds	r0, #184	; 0xb8
 c00d600:	f7ff f81e 	bl	c00c640 <boot_enc_load>
        if (rc < 0) {
 c00d604:	2800      	cmp	r0, #0
 c00d606:	da0b      	bge.n	c00d620 <context_boot_go+0x474>
            return BOOT_EBADIMAGE;
 c00d608:	2503      	movs	r5, #3
        if (BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_PANIC) {
 c00d60a:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d60e:	18e2      	adds	r2, r4, r3
 c00d610:	f892 20b0 	ldrb.w	r2, [r2, #176]	; 0xb0
 c00d614:	2aff      	cmp	r2, #255	; 0xff
 c00d616:	d136      	bne.n	c00d686 <context_boot_go+0x4da>
            BOOT_LOG_ERR("panic!");
 c00d618:	4863      	ldr	r0, [pc, #396]	; (c00d7a8 <context_boot_go+0x5fc>)
 c00d61a:	f000 fe5b 	bl	c00e2d4 <puts>
 c00d61e:	e7fe      	b.n	c00d61e <context_boot_go+0x472>
        if (rc == 0 && boot_enc_set_key(BOOT_CURR_ENC(state), 1, bs)) {
 c00d620:	d1a8      	bne.n	c00d574 <context_boot_go+0x3c8>
 c00d622:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d626:	4652      	mov	r2, sl
 c00d628:	fb08 4000 	mla	r0, r8, r0, r4
 c00d62c:	2101      	movs	r1, #1
 c00d62e:	30b8      	adds	r0, #184	; 0xb8
 c00d630:	f7fe ff12 	bl	c00c458 <boot_enc_set_key>
 c00d634:	2800      	cmp	r0, #0
 c00d636:	d09d      	beq.n	c00d574 <context_boot_go+0x3c8>
 c00d638:	e7e6      	b.n	c00d608 <context_boot_go+0x45c>

static inline uint32_t
boot_img_sector_off(const struct boot_loader_state *state, size_t slot,
                    size_t sector)
{
    return BOOT_IMG(state, slot).sectors[sector].fs_off -
 c00d63a:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
    return flash_area_erase(fap, off, sz);
 c00d63e:	4601      	mov	r1, r0
 c00d640:	fb06 4303 	mla	r3, r6, r3, r4
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c00d644:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 c00d646:	980a      	ldr	r0, [sp, #40]	; 0x28
 c00d648:	685a      	ldr	r2, [r3, #4]
 c00d64a:	f000 fb61 	bl	c00dd10 <flash_area_erase>
    return BOOT_IMG(state, slot).num_sectors;
 c00d64e:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
    return BOOT_IMG(state, slot).sectors[sector].fs_off -
 c00d652:	fb06 4303 	mla	r3, r6, r3, r4
    last_sector = boot_img_num_sectors(state, BOOT_SECONDARY_SLOT) - 1;
 c00d656:	e9d3 2314 	ldrd	r2, r3, [r3, #80]	; 0x50
 c00d65a:	3b01      	subs	r3, #1
 c00d65c:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
 c00d660:	eb02 00c3 	add.w	r0, r2, r3, lsl #3
 c00d664:	6813      	ldr	r3, [r2, #0]
    return flash_area_erase(fap, off, sz);
 c00d666:	6842      	ldr	r2, [r0, #4]
 c00d668:	1ac9      	subs	r1, r1, r3
 c00d66a:	980a      	ldr	r0, [sp, #40]	; 0x28
 c00d66c:	f000 fb50 	bl	c00dd10 <flash_area_erase>
    flash_area_close(fap_primary_slot);
 c00d670:	9807      	ldr	r0, [sp, #28]
 c00d672:	f000 fb27 	bl	c00dcc4 <flash_area_close>
    flash_area_close(fap_secondary_slot);
 c00d676:	980a      	ldr	r0, [sp, #40]	; 0x28
 c00d678:	f000 fb24 	bl	c00dcc4 <flash_area_close>
 c00d67c:	e7c5      	b.n	c00d60a <context_boot_go+0x45e>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_PANIC;
 c00d67e:	23ff      	movs	r3, #255	; 0xff
 c00d680:	f881 30b0 	strb.w	r3, [r1, #176]	; 0xb0
 c00d684:	e7c1      	b.n	c00d60a <context_boot_go+0x45e>
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d686:	3301      	adds	r3, #1
 c00d688:	e6fd      	b.n	c00d486 <context_boot_go+0x2da>
        if (BOOT_SWAP_TYPE(state) != BOOT_SWAP_TYPE_NONE) {
 c00d68a:	4423      	add	r3, r4
 c00d68c:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 c00d690:	2b01      	cmp	r3, #1
 c00d692:	d109      	bne.n	c00d6a8 <context_boot_go+0x4fc>
        rc = boot_validate_slot(state, BOOT_PRIMARY_SLOT, NULL);
 c00d694:	2200      	movs	r2, #0
        ImageValidEnable = 1;
 c00d696:	2501      	movs	r5, #1
        rc = boot_validate_slot(state, BOOT_PRIMARY_SLOT, NULL);
 c00d698:	4611      	mov	r1, r2
 c00d69a:	4620      	mov	r0, r4
        ImageValidEnable = 1;
 c00d69c:	703d      	strb	r5, [r7, #0]
        rc = boot_validate_slot(state, BOOT_PRIMARY_SLOT, NULL);
 c00d69e:	f7ff fc2d 	bl	c00cefc <boot_validate_slot>
        if (rc != 0) {
 c00d6a2:	b318      	cbz	r0, c00d6ec <context_boot_go+0x540>
            rc = BOOT_EBADIMAGE;
 c00d6a4:	2503      	movs	r5, #3
 c00d6a6:	e007      	b.n	c00d6b8 <context_boot_go+0x50c>
            rc = boot_read_image_headers(state, false, &bs);
 c00d6a8:	4632      	mov	r2, r6
 c00d6aa:	2100      	movs	r1, #0
 c00d6ac:	4620      	mov	r0, r4
 c00d6ae:	f7ff fbb6 	bl	c00ce1e <boot_read_image_headers>
            if (rc != 0) {
 c00d6b2:	4605      	mov	r5, r0
 c00d6b4:	2800      	cmp	r0, #0
 c00d6b6:	d0ed      	beq.n	c00d694 <context_boot_go+0x4e8>

out:
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d6b8:	2300      	movs	r3, #0
#if MCUBOOT_SWAP_USING_SCRATCH
        flash_area_close(BOOT_SCRATCH_AREA(state));
#endif
        for (slot = 0; slot < BOOT_NUM_SLOTS; slot++) {
            flash_area_close(BOOT_IMG_AREA(state, BOOT_NUM_SLOTS - 1 - slot));
 c00d6ba:	2658      	movs	r6, #88	; 0x58
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d6bc:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
 c00d6c0:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d6c4:	2b01      	cmp	r3, #1
 c00d6c6:	d863      	bhi.n	c00d790 <context_boot_go+0x5e4>
            flash_area_close(BOOT_IMG_AREA(state, BOOT_NUM_SLOTS - 1 - slot));
 c00d6c8:	fb06 4303 	mla	r3, r6, r3, r4
 c00d6cc:	6cd8      	ldr	r0, [r3, #76]	; 0x4c
 c00d6ce:	f000 faf9 	bl	c00dcc4 <flash_area_close>
 c00d6d2:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d6d6:	fb06 4303 	mla	r3, r6, r3, r4
 c00d6da:	6a18      	ldr	r0, [r3, #32]
 c00d6dc:	f000 faf2 	bl	c00dcc4 <flash_area_close>
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d6e0:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d6e4:	3301      	adds	r3, #1
 c00d6e6:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
 c00d6ea:	e7e9      	b.n	c00d6c0 <context_boot_go+0x514>
        if ((IS_OTFDEC_ENCRYPTED(boot_img_hdr(state, BOOT_PRIMARY_SLOT)))
 c00d6ec:	f04f 0a58 	mov.w	sl, #88	; 0x58
    return &BOOT_IMG(state, slot).hdr;
 c00d6f0:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
        ImageValidEnable = 0;
 c00d6f4:	7038      	strb	r0, [r7, #0]
        if ((IS_OTFDEC_ENCRYPTED(boot_img_hdr(state, BOOT_PRIMARY_SLOT)))
 c00d6f6:	fb0a 4303 	mla	r3, sl, r3, r4
 c00d6fa:	691b      	ldr	r3, [r3, #16]
 c00d6fc:	071b      	lsls	r3, r3, #28
 c00d6fe:	d411      	bmi.n	c00d724 <context_boot_go+0x578>
        if (BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_NONE) {
 c00d700:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d704:	1823      	adds	r3, r4, r0
 c00d706:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 c00d70a:	2b01      	cmp	r3, #1
 c00d70c:	d125      	bne.n	c00d75a <context_boot_go+0x5ae>
            rc = boot_update_security_counter(
 c00d70e:	2158      	movs	r1, #88	; 0x58
 c00d710:	fb00 4101 	mla	r1, r0, r1, r4
 c00d714:	f7ff fbcf 	bl	c00ceb6 <boot_update_security_counter.constprop.2>
            if (rc != 0) {
 c00d718:	4605      	mov	r5, r0
 c00d71a:	b1f0      	cbz	r0, c00d75a <context_boot_go+0x5ae>
                BOOT_LOG_ERR("Security counter update failed after image "
 c00d71c:	4823      	ldr	r0, [pc, #140]	; (c00d7ac <context_boot_go+0x600>)
 c00d71e:	f000 fdd9 	bl	c00e2d4 <puts>
                goto out;
 c00d722:	e7c9      	b.n	c00d6b8 <context_boot_go+0x50c>
            && (otfdec_is_key_valid() == 0)) {
 c00d724:	f7f5 fddc 	bl	c0032e0 <otfdec_is_key_valid>
 c00d728:	2800      	cmp	r0, #0
 c00d72a:	d1e9      	bne.n	c00d700 <context_boot_go+0x554>
            rc = boot_enc_load(BOOT_CURR_ENC(state), image_index,
 c00d72c:	f44f 701a 	mov.w	r0, #616	; 0x268
            image_index = BOOT_CURR_IMG(state);
 c00d730:	f894 1588 	ldrb.w	r1, [r4, #1416]	; 0x588
            rc = boot_enc_load(BOOT_CURR_ENC(state), image_index,
 c00d734:	9600      	str	r6, [sp, #0]
 c00d736:	fb0a 4301 	mla	r3, sl, r1, r4
 c00d73a:	fb00 4001 	mla	r0, r0, r1, r4
 c00d73e:	6a1b      	ldr	r3, [r3, #32]
 c00d740:	fb01 420a 	mla	r2, r1, sl, r4
 c00d744:	30b8      	adds	r0, #184	; 0xb8
 c00d746:	f7fe ff7b 	bl	c00c640 <boot_enc_load>
            if (rc != 0) {
 c00d74a:	2800      	cmp	r0, #0
 c00d74c:	d1aa      	bne.n	c00d6a4 <context_boot_go+0x4f8>
            if (otfdec_write_key(bs.enckey[0]) != 0) {
 c00d74e:	a813      	add	r0, sp, #76	; 0x4c
 c00d750:	f7f5 fda6 	bl	c0032a0 <otfdec_write_key>
 c00d754:	2800      	cmp	r0, #0
 c00d756:	d0d3      	beq.n	c00d700 <context_boot_go+0x554>
 c00d758:	e7ae      	b.n	c00d6b8 <context_boot_go+0x50c>
        rc = boot_save_boot_status(BOOT_CURR_IMG(state),
 c00d75a:	2158      	movs	r1, #88	; 0x58
 c00d75c:	f894 0588 	ldrb.w	r0, [r4, #1416]	; 0x588
 c00d760:	fb01 4300 	mla	r3, r1, r0, r4
 c00d764:	6a1a      	ldr	r2, [r3, #32]
 c00d766:	4619      	mov	r1, r3
 c00d768:	f000 f9fa 	bl	c00db60 <boot_save_boot_status>
        if (rc != 0) {
 c00d76c:	4605      	mov	r5, r0
 c00d76e:	b120      	cbz	r0, c00d77a <context_boot_go+0x5ce>
            BOOT_LOG_ERR("Failed to add Image %u data to shared memory area",
 c00d770:	f894 1588 	ldrb.w	r1, [r4, #1416]	; 0x588
 c00d774:	4640      	mov	r0, r8
 c00d776:	f000 fd39 	bl	c00e1ec <iprintf>
    IMAGES_ITER(BOOT_CURR_IMG(state)) {
 c00d77a:	f894 3588 	ldrb.w	r3, [r4, #1416]	; 0x588
 c00d77e:	3301      	adds	r3, #1
 c00d780:	f884 3588 	strb.w	r3, [r4, #1416]	; 0x588
 c00d784:	e68c      	b.n	c00d4a0 <context_boot_go+0x2f4>
            return -1;
 c00d786:	f04f 35ff 	mov.w	r5, #4294967295
 c00d78a:	e67b      	b.n	c00d484 <context_boot_go+0x2d8>
            has_upgrade = true;
 c00d78c:	4637      	mov	r7, r6
 c00d78e:	e5f4      	b.n	c00d37a <context_boot_go+0x1ce>
        }
    }
    return rc;
}
 c00d790:	4628      	mov	r0, r5
 c00d792:	b01d      	add	sp, #116	; 0x74
 c00d794:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c00d798:	0c010437 	.word	0x0c010437
 c00d79c:	0c01046b 	.word	0x0c01046b
 c00d7a0:	0c01048b 	.word	0x0c01048b
 c00d7a4:	0c0104ce 	.word	0x0c0104ce
 c00d7a8:	0c010509 	.word	0x0c010509
 c00d7ac:	0c010517 	.word	0x0c010517

0c00d7b0 <boot_go>:
 * @return                      0 on success; nonzero on failure.
 */
int
boot_go(struct boot_rsp *rsp)
{
    return context_boot_go(&boot_data, rsp);
 c00d7b0:	4601      	mov	r1, r0
 c00d7b2:	4801      	ldr	r0, [pc, #4]	; (c00d7b8 <boot_go+0x8>)
 c00d7b4:	f7ff bcfa 	b.w	c00d1ac <context_boot_go>
 c00d7b8:	30030358 	.word	0x30030358

0c00d7bc <boot_read_image_header>:
#endif

int
boot_read_image_header(struct boot_loader_state *state, int slot,
                       struct image_header *out_hdr, struct boot_status *bs)
{
 c00d7bc:	b513      	push	{r0, r1, r4, lr}

#if (BOOT_IMAGE_NUMBER == 1)
    (void)state;
#endif

    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00d7be:	f890 0588 	ldrb.w	r0, [r0, #1416]	; 0x588
{
 c00d7c2:	4614      	mov	r4, r2
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
 c00d7c4:	f000 faec 	bl	c00dda0 <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
 c00d7c8:	a901      	add	r1, sp, #4
 c00d7ca:	b2c0      	uxtb	r0, r0
 c00d7cc:	f000 fa5c 	bl	c00dc88 <flash_area_open>
    if (rc != 0) {
 c00d7d0:	4601      	mov	r1, r0
 c00d7d2:	b968      	cbnz	r0, c00d7f0 <boot_read_image_header+0x34>
        rc = BOOT_EFLASH;
        goto done;
    }

    rc = flash_area_read(fap, 0, out_hdr, sizeof *out_hdr);
 c00d7d4:	4622      	mov	r2, r4
 c00d7d6:	2320      	movs	r3, #32
 c00d7d8:	9801      	ldr	r0, [sp, #4]
 c00d7da:	f000 fa75 	bl	c00dcc8 <flash_area_read>
    if (rc != 0) {
 c00d7de:	1c04      	adds	r4, r0, #0
 c00d7e0:	bf18      	it	ne
 c00d7e2:	2401      	movne	r4, #1
    }

    rc = 0;

done:
    flash_area_close(fap);
 c00d7e4:	9801      	ldr	r0, [sp, #4]
 c00d7e6:	f000 fa6d 	bl	c00dcc4 <flash_area_close>
    return rc;
}
 c00d7ea:	4620      	mov	r0, r4
 c00d7ec:	b002      	add	sp, #8
 c00d7ee:	bd10      	pop	{r4, pc}
        rc = BOOT_EFLASH;
 c00d7f0:	2401      	movs	r4, #1
 c00d7f2:	e7f7      	b.n	c00d7e4 <boot_read_image_header+0x28>

0c00d7f4 <boot_slots_compatible>:
    return BOOT_IMG(state, slot).num_sectors;
 c00d7f4:	2258      	movs	r2, #88	; 0x58
 * area, and have sizes that are a multiple of each other (powers of two
 * presumably!).
 */
int
boot_slots_compatible(struct boot_loader_state *state)
{
 c00d7f6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00d7f8:	f890 3588 	ldrb.w	r3, [r0, #1416]	; 0x588
 c00d7fc:	fb02 0003 	mla	r0, r2, r3, r0
 c00d800:	f8d0 c028 	ldr.w	ip, [r0, #40]	; 0x28
    size_t i, j;
    int8_t smaller;

    num_sectors_primary = boot_img_num_sectors(state, BOOT_PRIMARY_SLOT);
    num_sectors_secondary = boot_img_num_sectors(state, BOOT_SECONDARY_SLOT);
    if ((num_sectors_primary > BOOT_MAX_IMG_SECTORS) ||
 c00d804:	f5bc 7f12 	cmp.w	ip, #584	; 0x248
 c00d808:	d803      	bhi.n	c00d812 <boot_slots_compatible+0x1e>
 c00d80a:	6d46      	ldr	r6, [r0, #84]	; 0x54
 c00d80c:	f5b6 7f12 	cmp.w	r6, #584	; 0x248
 c00d810:	d933      	bls.n	c00d87a <boot_slots_compatible+0x86>
        (num_sectors_secondary > BOOT_MAX_IMG_SECTORS)) {
        BOOT_LOG_WRN("Cannot upgrade: more sectors than allowed");
 c00d812:	481e      	ldr	r0, [pc, #120]	; (c00d88c <boot_slots_compatible+0x98>)
    }

    if ((i != num_sectors_primary) ||
        (j != num_sectors_secondary) ||
        (primary_slot_sz != secondary_slot_sz)) {
        BOOT_LOG_WRN("Cannot upgrade: slots are not compatible");
 c00d814:	f000 fd5e 	bl	c00e2d4 <puts>
        return 0;
 c00d818:	2000      	movs	r0, #0
    }

    return 1;
}
 c00d81a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (sz0 == sz1) {
 c00d81c:	42ac      	cmp	r4, r5
 c00d81e:	d115      	bne.n	c00d84c <boot_slots_compatible+0x58>
    return BOOT_IMG(state, slot).sectors[sector].fs_size;
 c00d820:	6a47      	ldr	r7, [r0, #36]	; 0x24
 c00d822:	eb07 07c2 	add.w	r7, r7, r2, lsl #3
            sz0 += boot_img_sector_size(state, BOOT_PRIMARY_SLOT, i);
 c00d826:	687f      	ldr	r7, [r7, #4]
            i++;
 c00d828:	3201      	adds	r2, #1
            sz0 += boot_img_sector_size(state, BOOT_PRIMARY_SLOT, i);
 c00d82a:	443c      	add	r4, r7
 c00d82c:	6d07      	ldr	r7, [r0, #80]	; 0x50
 c00d82e:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
            sz1 += boot_img_sector_size(state, BOOT_SECONDARY_SLOT, j);
 c00d832:	687f      	ldr	r7, [r7, #4]
            j++;
 c00d834:	3301      	adds	r3, #1
            sz1 += boot_img_sector_size(state, BOOT_SECONDARY_SLOT, j);
 c00d836:	443d      	add	r5, r7
    while (i < num_sectors_primary || j < num_sectors_secondary) {
 c00d838:	4562      	cmp	r2, ip
 c00d83a:	d3ef      	bcc.n	c00d81c <boot_slots_compatible+0x28>
 c00d83c:	42b3      	cmp	r3, r6
 c00d83e:	d3ed      	bcc.n	c00d81c <boot_slots_compatible+0x28>
    if ((i != num_sectors_primary) ||
 c00d840:	4562      	cmp	r2, ip
 c00d842:	d101      	bne.n	c00d848 <boot_slots_compatible+0x54>
 c00d844:	42b3      	cmp	r3, r6
 c00d846:	d01e      	beq.n	c00d886 <boot_slots_compatible+0x92>
        BOOT_LOG_WRN("Cannot upgrade: slots are not compatible");
 c00d848:	4811      	ldr	r0, [pc, #68]	; (c00d890 <boot_slots_compatible+0x9c>)
 c00d84a:	e7e3      	b.n	c00d814 <boot_slots_compatible+0x20>
        } else if (sz0 < sz1) {
 c00d84c:	d20b      	bcs.n	c00d866 <boot_slots_compatible+0x72>
 c00d84e:	6a47      	ldr	r7, [r0, #36]	; 0x24
            if (smaller == 2) {
 c00d850:	2902      	cmp	r1, #2
 c00d852:	eb07 07c2 	add.w	r7, r7, r2, lsl #3
            sz0 += boot_img_sector_size(state, BOOT_PRIMARY_SLOT, i);
 c00d856:	687f      	ldr	r7, [r7, #4]
 c00d858:	443c      	add	r4, r7
            if (smaller == 2) {
 c00d85a:	d101      	bne.n	c00d860 <boot_slots_compatible+0x6c>
                BOOT_LOG_WRN("Cannot upgrade: slots have non-compatible sectors");
 c00d85c:	480d      	ldr	r0, [pc, #52]	; (c00d894 <boot_slots_compatible+0xa0>)
 c00d85e:	e7d9      	b.n	c00d814 <boot_slots_compatible+0x20>
            i++;
 c00d860:	3201      	adds	r2, #1
            smaller = 1;
 c00d862:	2101      	movs	r1, #1
 c00d864:	e7e8      	b.n	c00d838 <boot_slots_compatible+0x44>
 c00d866:	6d07      	ldr	r7, [r0, #80]	; 0x50
            if (smaller == 1) {
 c00d868:	2901      	cmp	r1, #1
 c00d86a:	eb07 07c3 	add.w	r7, r7, r3, lsl #3
            sz1 += boot_img_sector_size(state, BOOT_SECONDARY_SLOT, j);
 c00d86e:	687f      	ldr	r7, [r7, #4]
 c00d870:	443d      	add	r5, r7
            if (smaller == 1) {
 c00d872:	d0f3      	beq.n	c00d85c <boot_slots_compatible+0x68>
            j++;
 c00d874:	3301      	adds	r3, #1
            smaller = 2;
 c00d876:	2102      	movs	r1, #2
 c00d878:	e7de      	b.n	c00d838 <boot_slots_compatible+0x44>
    smaller = 0;
 c00d87a:	2100      	movs	r1, #0
    j = sz1 = secondary_slot_sz = 0;
 c00d87c:	460b      	mov	r3, r1
    i = sz0 = primary_slot_sz = 0;
 c00d87e:	460a      	mov	r2, r1
    j = sz1 = secondary_slot_sz = 0;
 c00d880:	460d      	mov	r5, r1
    i = sz0 = primary_slot_sz = 0;
 c00d882:	460c      	mov	r4, r1
 c00d884:	e7d8      	b.n	c00d838 <boot_slots_compatible+0x44>
    return 1;
 c00d886:	2001      	movs	r0, #1
 c00d888:	e7c7      	b.n	c00d81a <boot_slots_compatible+0x26>
 c00d88a:	bf00      	nop
 c00d88c:	0c01058f 	.word	0x0c01058f
 c00d890:	0c0105f9 	.word	0x0c0105f9
 c00d894:	0c0105c0 	.word	0x0c0105c0

0c00d898 <bootutil_tlv_iter_begin>:
 *          -1 on errors
 */
int
bootutil_tlv_iter_begin(struct image_tlv_iter *it, const struct image_header *hdr,
                        const struct flash_area *fap, uint16_t type, bool prot)
{
 c00d898:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 c00d89c:	460e      	mov	r6, r1
 c00d89e:	4617      	mov	r7, r2
 c00d8a0:	4699      	mov	r9, r3
    uint32_t off_;
    struct image_tlv_info info;

    if (it == NULL || hdr == NULL || fap == NULL) {
 c00d8a2:	4604      	mov	r4, r0
 c00d8a4:	b928      	cbnz	r0, c00d8b2 <bootutil_tlv_iter_begin+0x1a>
        return -1;
 c00d8a6:	f04f 38ff 	mov.w	r8, #4294967295
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
    // position on first TLV
    it->tlv_off = off_ + sizeof(info);
    return 0;
}
 c00d8aa:	4640      	mov	r0, r8
 c00d8ac:	b003      	add	sp, #12
 c00d8ae:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (it == NULL || hdr == NULL || fap == NULL) {
 c00d8b2:	2900      	cmp	r1, #0
 c00d8b4:	d0f7      	beq.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>
 c00d8b6:	2a00      	cmp	r2, #0
 c00d8b8:	d0f5      	beq.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>
    off_ = BOOT_TLV_OFF(hdr);
 c00d8ba:	68cb      	ldr	r3, [r1, #12]
 c00d8bc:	890d      	ldrh	r5, [r1, #8]
    if (flash_area_read(fap, off_, &info, sizeof(info))) {
 c00d8be:	4638      	mov	r0, r7
    off_ = BOOT_TLV_OFF(hdr);
 c00d8c0:	441d      	add	r5, r3
    if (flash_area_read(fap, off_, &info, sizeof(info))) {
 c00d8c2:	2304      	movs	r3, #4
 c00d8c4:	4629      	mov	r1, r5
 c00d8c6:	eb0d 0203 	add.w	r2, sp, r3
 c00d8ca:	f000 f9fd 	bl	c00dcc8 <flash_area_read>
 c00d8ce:	4680      	mov	r8, r0
 c00d8d0:	2800      	cmp	r0, #0
 c00d8d2:	d1e8      	bne.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>
    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
 c00d8d4:	f646 1208 	movw	r2, #26888	; 0x6908
 c00d8d8:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 c00d8dc:	8973      	ldrh	r3, [r6, #10]
 c00d8de:	4291      	cmp	r1, r2
 c00d8e0:	d123      	bne.n	c00d92a <bootutil_tlv_iter_begin+0x92>
        if (hdr->ih_protect_tlv_size != info.it_tlv_tot) {
 c00d8e2:	f8bd 1006 	ldrh.w	r1, [sp, #6]
 c00d8e6:	4299      	cmp	r1, r3
 c00d8e8:	d1dd      	bne.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>
        if (flash_area_read(fap, off_ + info.it_tlv_tot, &info, sizeof(info))) {
 c00d8ea:	2304      	movs	r3, #4
 c00d8ec:	4429      	add	r1, r5
 c00d8ee:	eb0d 0203 	add.w	r2, sp, r3
 c00d8f2:	4638      	mov	r0, r7
 c00d8f4:	f000 f9e8 	bl	c00dcc8 <flash_area_read>
 c00d8f8:	2800      	cmp	r0, #0
 c00d8fa:	d1d4      	bne.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
 c00d8fc:	f646 1307 	movw	r3, #26887	; 0x6907
 c00d900:	f8bd 2004 	ldrh.w	r2, [sp, #4]
 c00d904:	429a      	cmp	r2, r3
 c00d906:	d1ce      	bne.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>
    it->prot = prot;
 c00d908:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
 c00d90c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    it->prot = prot;
 c00d910:	72a3      	strb	r3, [r4, #10]
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
 c00d912:	8973      	ldrh	r3, [r6, #10]
    it->fap = fap;
 c00d914:	e9c4 6700 	strd	r6, r7, [r4]
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
 c00d918:	442b      	add	r3, r5
 c00d91a:	60e3      	str	r3, [r4, #12]
    it->tlv_off = off_ + sizeof(info);
 c00d91c:	3504      	adds	r5, #4
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
 c00d91e:	4413      	add	r3, r2
    it->type = type;
 c00d920:	f8a4 9008 	strh.w	r9, [r4, #8]
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
 c00d924:	6163      	str	r3, [r4, #20]
    it->tlv_off = off_ + sizeof(info);
 c00d926:	6125      	str	r5, [r4, #16]
    return 0;
 c00d928:	e7bf      	b.n	c00d8aa <bootutil_tlv_iter_begin+0x12>
    } else if (hdr->ih_protect_tlv_size != 0) {
 c00d92a:	2b00      	cmp	r3, #0
 c00d92c:	d0e6      	beq.n	c00d8fc <bootutil_tlv_iter_begin+0x64>
 c00d92e:	e7ba      	b.n	c00d8a6 <bootutil_tlv_iter_begin+0xe>

0c00d930 <bootutil_tlv_iter_next>:
 *          -1 on errors
 */
int
bootutil_tlv_iter_next(struct image_tlv_iter *it, uint32_t *off, uint16_t *len,
                       uint16_t *type)
{
 c00d930:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c00d934:	460e      	mov	r6, r1
 c00d936:	4617      	mov	r7, r2
 c00d938:	461d      	mov	r5, r3
    struct image_tlv tlv;
    int rc;

    if (it == NULL || it->hdr == NULL || it->fap == NULL) {
 c00d93a:	4604      	mov	r4, r0
 c00d93c:	b920      	cbnz	r0, c00d948 <bootutil_tlv_iter_next+0x18>
        return -1;
 c00d93e:	f04f 30ff 	mov.w	r0, #4294967295

        it->tlv_off += sizeof(tlv) + tlv.it_len;
    }

    return 1;
}
 c00d942:	b002      	add	sp, #8
 c00d944:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (it == NULL || it->hdr == NULL || it->fap == NULL) {
 c00d948:	6803      	ldr	r3, [r0, #0]
 c00d94a:	2b00      	cmp	r3, #0
 c00d94c:	d0f7      	beq.n	c00d93e <bootutil_tlv_iter_next+0xe>
 c00d94e:	6843      	ldr	r3, [r0, #4]
 c00d950:	2b00      	cmp	r3, #0
 c00d952:	d0f4      	beq.n	c00d93e <bootutil_tlv_iter_next+0xe>
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
 c00d954:	f64f 78ff 	movw	r8, #65535	; 0xffff
    while (it->tlv_off < it->tlv_end) {
 c00d958:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 c00d95c:	429a      	cmp	r2, r3
 c00d95e:	d216      	bcs.n	c00d98e <bootutil_tlv_iter_next+0x5e>
        if (it->hdr->ih_protect_tlv_size > 0 && it->tlv_off == it->prot_end) {
 c00d960:	6823      	ldr	r3, [r4, #0]
 c00d962:	895b      	ldrh	r3, [r3, #10]
 c00d964:	b123      	cbz	r3, c00d970 <bootutil_tlv_iter_next+0x40>
 c00d966:	68e3      	ldr	r3, [r4, #12]
 c00d968:	4293      	cmp	r3, r2
            it->tlv_off += sizeof(struct image_tlv_info);
 c00d96a:	bf04      	itt	eq
 c00d96c:	3304      	addeq	r3, #4
 c00d96e:	6123      	streq	r3, [r4, #16]
        rc = flash_area_read(it->fap, it->tlv_off, &tlv, sizeof tlv);
 c00d970:	2304      	movs	r3, #4
 c00d972:	6921      	ldr	r1, [r4, #16]
 c00d974:	eb0d 0203 	add.w	r2, sp, r3
 c00d978:	6860      	ldr	r0, [r4, #4]
 c00d97a:	f000 f9a5 	bl	c00dcc8 <flash_area_read>
        if (rc) {
 c00d97e:	2800      	cmp	r0, #0
 c00d980:	d1dd      	bne.n	c00d93e <bootutil_tlv_iter_next+0xe>
        if (it->prot && it->tlv_off >= it->prot_end) {
 c00d982:	7aa2      	ldrb	r2, [r4, #10]
 c00d984:	6923      	ldr	r3, [r4, #16]
 c00d986:	b122      	cbz	r2, c00d992 <bootutil_tlv_iter_next+0x62>
 c00d988:	68e2      	ldr	r2, [r4, #12]
 c00d98a:	429a      	cmp	r2, r3
 c00d98c:	d801      	bhi.n	c00d992 <bootutil_tlv_iter_next+0x62>
            return 1;
 c00d98e:	2001      	movs	r0, #1
 c00d990:	e7d7      	b.n	c00d942 <bootutil_tlv_iter_next+0x12>
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
 c00d992:	f8b4 c008 	ldrh.w	ip, [r4, #8]
 c00d996:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 c00d99a:	45c4      	cmp	ip, r8
 c00d99c:	f102 0104 	add.w	r1, r2, #4
 c00d9a0:	d003      	beq.n	c00d9aa <bootutil_tlv_iter_next+0x7a>
 c00d9a2:	f8bd e004 	ldrh.w	lr, [sp, #4]
 c00d9a6:	45e6      	cmp	lr, ip
 c00d9a8:	d10b      	bne.n	c00d9c2 <bootutil_tlv_iter_next+0x92>
            if (type != NULL) {
 c00d9aa:	b11d      	cbz	r5, c00d9b4 <bootutil_tlv_iter_next+0x84>
                *type = tlv.it_type;
 c00d9ac:	f8bd c004 	ldrh.w	ip, [sp, #4]
 c00d9b0:	f8a5 c000 	strh.w	ip, [r5]
            *off = it->tlv_off + sizeof(tlv);
 c00d9b4:	3304      	adds	r3, #4
 c00d9b6:	6033      	str	r3, [r6, #0]
            *len = tlv.it_len;
 c00d9b8:	803a      	strh	r2, [r7, #0]
            it->tlv_off += sizeof(tlv) + tlv.it_len;
 c00d9ba:	6922      	ldr	r2, [r4, #16]
 c00d9bc:	440a      	add	r2, r1
 c00d9be:	6122      	str	r2, [r4, #16]
            return 0;
 c00d9c0:	e7bf      	b.n	c00d942 <bootutil_tlv_iter_next+0x12>
        it->tlv_off += sizeof(tlv) + tlv.it_len;
 c00d9c2:	440b      	add	r3, r1
 c00d9c4:	6123      	str	r3, [r4, #16]
 c00d9c6:	e7c7      	b.n	c00d958 <bootutil_tlv_iter_next+0x28>

0c00d9c8 <main>:

    jumper(vt);
}

int main(void)
{
 c00d9c8:	b530      	push	{r4, r5, lr}
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 c00d9ca:	4b29      	ldr	r3, [pc, #164]	; (c00da70 <main+0xa8>)
 c00d9cc:	b085      	sub	sp, #20
 c00d9ce:	f383 880a 	msr	MSPLIM, r3
#if defined(__ARM_ARCH_8M_MAIN__) || defined(__ARM_ARCH_8M_BASE__)
    __set_MSPLIM(msp_stack_bottom);
#endif

    /* Perform platform specific initialization */
    if (boot_platform_init() != 0) {
 c00d9d2:	f7f5 fe15 	bl	c003600 <boot_platform_init>
 c00d9d6:	b100      	cbz	r0, c00d9da <main+0x12>
 c00d9d8:	e7fe      	b.n	c00d9d8 <main+0x10>
        while (1)
            ;
    }

#if MCUBOOT_LOG_LEVEL > MCUBOOT_LOG_LEVEL_OFF
    stdio_init();
 c00d9da:	f000 fad7 	bl	c00df8c <stdio_init>
#endif

    BOOT_LOG_INF("Starting bootloader");
 c00d9de:	4825      	ldr	r0, [pc, #148]	; (c00da74 <main+0xac>)
 c00d9e0:	f000 fc78 	bl	c00e2d4 <puts>

    /* Initialise the mbedtls static memory allocator so that mbedtls allocates
     * memory from the provided static buffer instead of from the heap.
     */
    mbedtls_memory_buffer_alloc_init(mbedtls_mem_buf, BL2_MBEDTLS_MEM_BUF_LEN);
 c00d9e4:	f44f 41e4 	mov.w	r1, #29184	; 0x7200
 c00d9e8:	4823      	ldr	r0, [pc, #140]	; (c00da78 <main+0xb0>)
 c00d9ea:	f7fe fa2f 	bl	c00be4c <mbedtls_memory_buffer_alloc_init>

    rc = boot_nv_security_counter_init();
 c00d9ee:	f000 fa87 	bl	c00df00 <boot_nv_security_counter_init>
    if (rc != 0) {
 c00d9f2:	b120      	cbz	r0, c00d9fe <main+0x36>
        BOOT_LOG_ERR("Error while initializing the security counter");
 c00d9f4:	4821      	ldr	r0, [pc, #132]	; (c00da7c <main+0xb4>)
 c00d9f6:	f000 fc6d 	bl	c00e2d4 <puts>
        Error_Handler();
 c00d9fa:	f003 ff91 	bl	c011920 <Error_Handler>
    }


    rc = boot_go(&rsp);
 c00d9fe:	a801      	add	r0, sp, #4
 c00da00:	f7ff fed6 	bl	c00d7b0 <boot_go>
    if (rc != 0) {
 c00da04:	b120      	cbz	r0, c00da10 <main+0x48>
        BOOT_LOG_ERR("Unable to find bootable image");
 c00da06:	481e      	ldr	r0, [pc, #120]	; (c00da80 <main+0xb8>)
 c00da08:	f000 fc64 	bl	c00e2d4 <puts>
#ifdef MCUBOOT_EXT_LOADER
       boot_platform_noimage();
 c00da0c:	f7f5 fd76 	bl	c0034fc <boot_platform_noimage>
	   Error_Handler();
#endif
    }


    BOOT_LOG_INF("Bootloader chainload address offset: 0x%x",
 c00da10:	9903      	ldr	r1, [sp, #12]
 c00da12:	481c      	ldr	r0, [pc, #112]	; (c00da84 <main+0xbc>)
 c00da14:	f000 fbea 	bl	c00e1ec <iprintf>
                 rsp.br_image_off);
    BOOT_LOG_INF("Jumping to the first image slot");
 c00da18:	481b      	ldr	r0, [pc, #108]	; (c00da88 <main+0xc0>)
 c00da1a:	f000 fc5b 	bl	c00e2d4 <puts>
    rc = flash_device_base(rsp->br_flash_dev_id, &flash_base);
 c00da1e:	4669      	mov	r1, sp
 c00da20:	f89d 0008 	ldrb.w	r0, [sp, #8]
 c00da24:	f000 f9a4 	bl	c00dd70 <flash_device_base>
    if (rsp->br_hdr->ih_flags & IMAGE_F_RAM_LOAD) {
 c00da28:	9a01      	ldr	r2, [sp, #4]
 c00da2a:	4c18      	ldr	r4, [pc, #96]	; (c00da8c <main+0xc4>)
 c00da2c:	6913      	ldr	r3, [r2, #16]
 c00da2e:	8911      	ldrh	r1, [r2, #8]
 c00da30:	f013 0f20 	tst.w	r3, #32
        vt = (struct arm_vector_table *)(flash_base +
 c00da34:	bf05      	ittet	eq
 c00da36:	9b03      	ldreq	r3, [sp, #12]
 c00da38:	9a00      	ldreq	r2, [sp, #0]
        vt = (struct arm_vector_table *)(rsp->br_hdr->ih_load_addr +
 c00da3a:	6853      	ldrne	r3, [r2, #4]
        vt = (struct arm_vector_table *)(flash_base +
 c00da3c:	189b      	addeq	r3, r3, r2
                                         rsp->br_image_off +
 c00da3e:	440b      	add	r3, r1
        vt = (struct arm_vector_table *)(flash_base +
 c00da40:	6023      	str	r3, [r4, #0]
    rc = FLASH_DEV_NAME.Uninitialize();
 c00da42:	4b13      	ldr	r3, [pc, #76]	; (c00da90 <main+0xc8>)
 c00da44:	68db      	ldr	r3, [r3, #12]
 c00da46:	4798      	blx	r3
    if(rc != ARM_DRIVER_OK) {
 c00da48:	b110      	cbz	r0, c00da50 <main+0x88>
        BOOT_LOG_ERR("Error while uninitializing Flash Interface");
 c00da4a:	4812      	ldr	r0, [pc, #72]	; (c00da94 <main+0xcc>)
 c00da4c:	f000 fc42 	bl	c00e2d4 <puts>
    stdio_uninit();
 c00da50:	f000 faaa 	bl	c00dfa8 <stdio_uninit>
 c00da54:	2500      	movs	r5, #0
 c00da56:	f385 880a 	msr	MSPLIM, r5
    jumper(vt);
 c00da5a:	6820      	ldr	r0, [r4, #0]
 c00da5c:	f003 ff98 	bl	c011990 <jumper>
    do_boot(&rsp);

    BOOT_LOG_ERR("Never should get here");
 c00da60:	480d      	ldr	r0, [pc, #52]	; (c00da98 <main+0xd0>)
 c00da62:	f000 fc37 	bl	c00e2d4 <puts>
    Error_Handler();
 c00da66:	f003 ff5b 	bl	c011920 <Error_Handler>
    return 0;
}
 c00da6a:	4628      	mov	r0, r5
 c00da6c:	b005      	add	sp, #20
 c00da6e:	bd30      	pop	{r4, r5, pc}
 c00da70:	3003e424 	.word	0x3003e424
 c00da74:	0c010629 	.word	0x0c010629
 c00da78:	300371e4 	.word	0x300371e4
 c00da7c:	0c010644 	.word	0x0c010644
 c00da80:	0c010679 	.word	0x0c010679
 c00da84:	0c01069e 	.word	0x0c01069e
 c00da88:	0c0106d0 	.word	0x0c0106d0
 c00da8c:	3003e3e4 	.word	0x3003e3e4
 c00da90:	0c00fad0 	.word	0x0c00fad0
 c00da94:	0c0106f7 	.word	0x0c0106f7
 c00da98:	0c010729 	.word	0x0c010729

0c00da9c <boot_add_data_to_shared_area>:
enum shared_memory_err_t
boot_add_data_to_shared_area(uint8_t        major_type,
                             uint16_t       minor_type,
                             size_t         size,
                             const uint8_t *data)
{
 c00da9c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 c00daa0:	461e      	mov	r6, r3
    struct shared_data_tlv_entry tlv_entry = {0};
 c00daa2:	2300      	movs	r3, #0
    boot_data = (struct tfm_boot_data *)BOOT_TFM_SHARED_DATA_BASE;

    /* Check whether first time to call this function. If does then initialise
     * shared data area.
     */
    if (shared_memory_init_done == SHARED_MEMORY_UNINITIALZED) {
 c00daa4:	f8df 80b4 	ldr.w	r8, [pc, #180]	; c00db5c <boot_add_data_to_shared_area+0xc0>
{
 c00daa8:	460c      	mov	r4, r1
    if (shared_memory_init_done == SHARED_MEMORY_UNINITIALZED) {
 c00daaa:	f8d8 1000 	ldr.w	r1, [r8]
{
 c00daae:	4607      	mov	r7, r0
 c00dab0:	4615      	mov	r5, r2
    struct shared_data_tlv_entry tlv_entry = {0};
 c00dab2:	9301      	str	r3, [sp, #4]
    if (shared_memory_init_done == SHARED_MEMORY_UNINITIALZED) {
 c00dab4:	b951      	cbnz	r1, c00dacc <boot_add_data_to_shared_area+0x30>
        memset((void *)BOOT_TFM_SHARED_DATA_BASE, 0, BOOT_TFM_SHARED_DATA_SIZE);
 c00dab6:	4b27      	ldr	r3, [pc, #156]	; (c00db54 <boot_add_data_to_shared_area+0xb8>)
 c00dab8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 c00dabc:	4618      	mov	r0, r3
 c00dabe:	f000 fae4 	bl	c00e08a <memset>
        boot_data->header.tlv_magic   = SHARED_DATA_TLV_INFO_MAGIC;
        boot_data->header.tlv_tot_len = SHARED_DATA_HEADER_SIZE;
        shared_memory_init_done = SHARED_MEMORY_INITIALZED;
 c00dac2:	2301      	movs	r3, #1
        boot_data->header.tlv_magic   = SHARED_DATA_TLV_INFO_MAGIC;
 c00dac4:	4a24      	ldr	r2, [pc, #144]	; (c00db58 <boot_add_data_to_shared_area+0xbc>)
 c00dac6:	6002      	str	r2, [r0, #0]
        shared_memory_init_done = SHARED_MEMORY_INITIALZED;
 c00dac8:	f8c8 3000 	str.w	r3, [r8]
    }

    /* Check whether TLV entry is already added.
     * Get the boundaries of TLV section
     */
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c00dacc:	4b21      	ldr	r3, [pc, #132]	; (c00db54 <boot_add_data_to_shared_area+0xb8>)
     * returns with error: SHARED_MEMORY_OVERWRITE
     */
    for (; offset < tlv_end; offset += tlv_entry.tlv_len) {
        /* Create local copy to avoid unaligned access */
        memcpy(&tlv_entry, (const void *)offset, SHARED_DATA_ENTRY_HEADER_SIZE);
        if (GET_MAJOR(tlv_entry.tlv_type) == major_type &&
 c00dace:	fa1f fc87 	uxth.w	ip, r7
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c00dad2:	885a      	ldrh	r2, [r3, #2]
    offset  = BOOT_TFM_SHARED_DATA_BASE + SHARED_DATA_HEADER_SIZE;
 c00dad4:	3304      	adds	r3, #4
    tlv_end = BOOT_TFM_SHARED_DATA_BASE + boot_data->header.tlv_tot_len;
 c00dad6:	f102 5240 	add.w	r2, r2, #805306368	; 0x30000000
 c00dada:	f502 327f 	add.w	r2, r2, #261120	; 0x3fc00
    for (; offset < tlv_end; offset += tlv_entry.tlv_len) {
 c00dade:	4293      	cmp	r3, r2
 c00dae0:	d325      	bcc.n	c00db2e <boot_add_data_to_shared_area+0x92>
            return SHARED_MEMORY_OVERWRITE;
        }
    }

    /* Add TLV entry */
    tlv_entry.tlv_type = SET_TLV_TYPE(major_type, minor_type);
 c00dae2:	f3c4 000b 	ubfx	r0, r4, #0, #12
    tlv_entry.tlv_len  = SHARED_DATA_ENTRY_SIZE(size);
 c00dae6:	1d2c      	adds	r4, r5, #4
    tlv_entry.tlv_type = SET_TLV_TYPE(major_type, minor_type);
 c00dae8:	ea40 3007 	orr.w	r0, r0, r7, lsl #12
    tlv_entry.tlv_len  = SHARED_DATA_ENTRY_SIZE(size);
 c00daec:	b2a4      	uxth	r4, r4

    if (!boot_u16_safe_add(&boot_data_size, boot_data->header.tlv_tot_len,
 c00daee:	4f19      	ldr	r7, [pc, #100]	; (c00db54 <boot_add_data_to_shared_area+0xb8>)
    tlv_entry.tlv_type = SET_TLV_TYPE(major_type, minor_type);
 c00daf0:	f8ad 0004 	strh.w	r0, [sp, #4]
    tlv_entry.tlv_len  = SHARED_DATA_ENTRY_SIZE(size);
 c00daf4:	f8ad 4006 	strh.w	r4, [sp, #6]
    if (!boot_u16_safe_add(&boot_data_size, boot_data->header.tlv_tot_len,
 c00daf8:	8878      	ldrh	r0, [r7, #2]
 * the result in *dest if it can be done without overflow.  Otherwise,
 * returns false.
 */
static inline bool boot_u16_safe_add(uint16_t *dest, uint16_t a, uint16_t b)
{
    uint32_t tmp = a + b;
 c00dafa:	1903      	adds	r3, r0, r4
    if (tmp > UINT16_MAX) {
 c00dafc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 c00db00:	da23      	bge.n	c00db4a <boot_add_data_to_shared_area+0xae>
                           tlv_entry.tlv_len)) {
        return SHARED_MEMORY_GEN_ERROR;
    }

    /* Verify overflow of shared area */
    if (boot_data_size > BOOT_TFM_SHARED_DATA_SIZE) {
 c00db02:	b29b      	uxth	r3, r3
 c00db04:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 c00db08:	d821      	bhi.n	c00db4e <boot_add_data_to_shared_area+0xb2>
        return SHARED_MEMORY_OVERFLOW;
    }

    next_tlv = (uint8_t *)boot_data + boot_data->header.tlv_tot_len;
    memcpy(next_tlv, &tlv_entry, SHARED_DATA_ENTRY_HEADER_SIZE);
 c00db0a:	9b01      	ldr	r3, [sp, #4]
 c00db0c:	f100 5040 	add.w	r0, r0, #805306368	; 0x30000000
 c00db10:	f500 307f 	add.w	r0, r0, #261120	; 0x3fc00
 c00db14:	f840 3b04 	str.w	r3, [r0], #4

    next_tlv += SHARED_DATA_ENTRY_HEADER_SIZE;
    memcpy(next_tlv, data, size);
 c00db18:	462a      	mov	r2, r5
 c00db1a:	4631      	mov	r1, r6
 c00db1c:	f000 fa91 	bl	c00e042 <memcpy>

    boot_data->header.tlv_tot_len += tlv_entry.tlv_len;

    return SHARED_MEMORY_OK;
 c00db20:	2000      	movs	r0, #0
    boot_data->header.tlv_tot_len += tlv_entry.tlv_len;
 c00db22:	887b      	ldrh	r3, [r7, #2]
 c00db24:	441c      	add	r4, r3
 c00db26:	807c      	strh	r4, [r7, #2]
}
 c00db28:	b002      	add	sp, #8
 c00db2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        memcpy(&tlv_entry, (const void *)offset, SHARED_DATA_ENTRY_HEADER_SIZE);
 c00db2e:	6818      	ldr	r0, [r3, #0]
 c00db30:	b281      	uxth	r1, r0
        if (GET_MAJOR(tlv_entry.tlv_type) == major_type &&
 c00db32:	ebbc 3f11 	cmp.w	ip, r1, lsr #12
 c00db36:	d103      	bne.n	c00db40 <boot_add_data_to_shared_area+0xa4>
 c00db38:	f3c1 010b 	ubfx	r1, r1, #0, #12
 c00db3c:	42a1      	cmp	r1, r4
 c00db3e:	d002      	beq.n	c00db46 <boot_add_data_to_shared_area+0xaa>
    for (; offset < tlv_end; offset += tlv_entry.tlv_len) {
 c00db40:	eb03 4310 	add.w	r3, r3, r0, lsr #16
 c00db44:	e7cb      	b.n	c00dade <boot_add_data_to_shared_area+0x42>
            return SHARED_MEMORY_OVERWRITE;
 c00db46:	2002      	movs	r0, #2
 c00db48:	e7ee      	b.n	c00db28 <boot_add_data_to_shared_area+0x8c>
        return SHARED_MEMORY_GEN_ERROR;
 c00db4a:	2003      	movs	r0, #3
 c00db4c:	e7ec      	b.n	c00db28 <boot_add_data_to_shared_area+0x8c>
        return SHARED_MEMORY_OVERFLOW;
 c00db4e:	2001      	movs	r0, #1
 c00db50:	e7ea      	b.n	c00db28 <boot_add_data_to_shared_area+0x8c>
 c00db52:	bf00      	nop
 c00db54:	3003fc00 	.word	0x3003fc00
 c00db58:	00042016 	.word	0x00042016
 c00db5c:	3003e3e8 	.word	0x3003e3e8

0c00db60 <boot_save_boot_status>:
/* See in boot_record.h */
enum boot_status_err_t
boot_save_boot_status(uint8_t sw_module,
                      const struct image_header *hdr,
                      const struct flash_area *fap)
{
 c00db60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     * be removed in the future.
     */

    enum boot_status_err_t res;
#if (MCUBOOT_IMAGE_NUMBER==2)
    sw_module+=SW_SPE;
 c00db64:	3004      	adds	r0, #4
 c00db66:	b2c0      	uxtb	r0, r0
    switch (sw_module) {
 c00db68:	2805      	cmp	r0, #5
{
 c00db6a:	b094      	sub	sp, #80	; 0x50
 c00db6c:	460e      	mov	r6, r1
 c00db6e:	4690      	mov	r8, r2
    switch (sw_module) {
 c00db70:	d005      	beq.n	c00db7e <boot_save_boot_status+0x1e>
 c00db72:	2806      	cmp	r0, #6
 c00db74:	d067      	beq.n	c00dc46 <boot_save_boot_status+0xe6>
 c00db76:	2804      	cmp	r0, #4
 c00db78:	d161      	bne.n	c00dc3e <boot_save_boot_status+0xde>
        sw_type = sw_comp_s;
 c00db7a:	4f3e      	ldr	r7, [pc, #248]	; (c00dc74 <boot_save_boot_status+0x114>)
 c00db7c:	e000      	b.n	c00db80 <boot_save_boot_status+0x20>
        sw_type = sw_comp_ns;
 c00db7e:	4f3e      	ldr	r7, [pc, #248]	; (c00dc78 <boot_save_boot_status+0x118>)
    ias_minor = SET_IAS_MINOR(sw_module, SW_TYPE);
 c00db80:	0184      	lsls	r4, r0, #6
    res = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00db82:	4638      	mov	r0, r7
 c00db84:	f000 fbf2 	bl	c00e36c <strlen>
    ias_minor = SET_IAS_MINOR(sw_module, SW_TYPE);
 c00db88:	b225      	sxth	r5, r4
    res = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00db8a:	4602      	mov	r2, r0
 c00db8c:	463b      	mov	r3, r7
 c00db8e:	f045 0103 	orr.w	r1, r5, #3
 c00db92:	2001      	movs	r0, #1
 c00db94:	f7ff ff82 	bl	c00da9c <boot_add_data_to_shared_area>
    if (res) {
 c00db98:	2800      	cmp	r0, #0
 c00db9a:	d150      	bne.n	c00dc3e <boot_save_boot_status+0xde>
    cnt = snprintf(sw_version, sizeof(sw_version), "%u.%u.%u",
 c00db9c:	8af2      	ldrh	r2, [r6, #22]
 c00db9e:	7d33      	ldrb	r3, [r6, #20]
 c00dba0:	9201      	str	r2, [sp, #4]
 c00dba2:	7d72      	ldrb	r2, [r6, #21]
 c00dba4:	210e      	movs	r1, #14
 c00dba6:	9200      	str	r2, [sp, #0]
 c00dba8:	a80c      	add	r0, sp, #48	; 0x30
 c00dbaa:	4a34      	ldr	r2, [pc, #208]	; (c00dc7c <boot_save_boot_status+0x11c>)
 c00dbac:	f000 fbaa 	bl	c00e304 <sniprintf>
    res = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00dbb0:	ab0c      	add	r3, sp, #48	; 0x30
 c00dbb2:	4602      	mov	r2, r0
 c00dbb4:	4621      	mov	r1, r4
 c00dbb6:	2001      	movs	r0, #1
 c00dbb8:	f7ff ff70 	bl	c00da9c <boot_add_data_to_shared_area>
    if (res) {
 c00dbbc:	4602      	mov	r2, r0
 c00dbbe:	2800      	cmp	r0, #0
 c00dbc0:	d13d      	bne.n	c00dc3e <boot_save_boot_status+0xde>
    char measure_type[] = "SHA256";
 c00dbc2:	4b2f      	ldr	r3, [pc, #188]	; (c00dc80 <boot_save_boot_status+0x120>)
    res = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_ANY, false);
 c00dbc4:	9200      	str	r2, [sp, #0]
    char measure_type[] = "SHA256";
 c00dbc6:	6818      	ldr	r0, [r3, #0]
 c00dbc8:	8899      	ldrh	r1, [r3, #4]
 c00dbca:	799b      	ldrb	r3, [r3, #6]
 c00dbcc:	9004      	str	r0, [sp, #16]
 c00dbce:	f8ad 1014 	strh.w	r1, [sp, #20]
 c00dbd2:	f88d 3016 	strb.w	r3, [sp, #22]
    res = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_ANY, false);
 c00dbd6:	4642      	mov	r2, r8
 c00dbd8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 c00dbdc:	4631      	mov	r1, r6
 c00dbde:	a806      	add	r0, sp, #24
 c00dbe0:	f7ff fe5a 	bl	c00d898 <bootutil_tlv_iter_begin>
    if (res) {
 c00dbe4:	bb58      	cbnz	r0, c00dc3e <boot_save_boot_status+0xde>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00dbe6:	f045 0701 	orr.w	r7, r5, #1
        res = bootutil_tlv_iter_next(&it, &offset, &len, &type);
 c00dbea:	f10d 030a 	add.w	r3, sp, #10
 c00dbee:	aa02      	add	r2, sp, #8
 c00dbf0:	a903      	add	r1, sp, #12
 c00dbf2:	a806      	add	r0, sp, #24
 c00dbf4:	f7ff fe9c 	bl	c00d930 <bootutil_tlv_iter_next>
        if (res < 0) {
 c00dbf8:	2800      	cmp	r0, #0
 c00dbfa:	db20      	blt.n	c00dc3e <boot_save_boot_status+0xde>
        } else if (res > 0) {
 c00dbfc:	d137      	bne.n	c00dc6e <boot_save_boot_status+0x10e>
        if (type == IMAGE_TLV_SHA256) {
 c00dbfe:	f8bd 400a 	ldrh.w	r4, [sp, #10]
 c00dc02:	2c10      	cmp	r4, #16
 c00dc04:	d121      	bne.n	c00dc4a <boot_save_boot_status+0xea>
            if (len != sizeof(buf)) { /* SHA256 - 32 bytes */
 c00dc06:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 c00dc0a:	2b20      	cmp	r3, #32
 c00dc0c:	d117      	bne.n	c00dc3e <boot_save_boot_status+0xde>
            res = LOAD_IMAGE_DATA(hdr, fap, offset, buf, len);
 c00dc0e:	aa0c      	add	r2, sp, #48	; 0x30
 c00dc10:	9903      	ldr	r1, [sp, #12]
 c00dc12:	4640      	mov	r0, r8
 c00dc14:	f000 f858 	bl	c00dcc8 <flash_area_read>
            if (res) {
 c00dc18:	b988      	cbnz	r0, c00dc3e <boot_save_boot_status+0xde>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00dc1a:	ab0c      	add	r3, sp, #48	; 0x30
 c00dc1c:	f8bd 2008 	ldrh.w	r2, [sp, #8]
 c00dc20:	f045 0108 	orr.w	r1, r5, #8
 c00dc24:	2001      	movs	r0, #1
 c00dc26:	f7ff ff39 	bl	c00da9c <boot_add_data_to_shared_area>
            if (res2) {
 c00dc2a:	b940      	cbnz	r0, c00dc3e <boot_save_boot_status+0xde>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00dc2c:	2206      	movs	r2, #6
 c00dc2e:	ab04      	add	r3, sp, #16
 c00dc30:	f045 0109 	orr.w	r1, r5, #9
 c00dc34:	2001      	movs	r0, #1
 c00dc36:	f7ff ff31 	bl	c00da9c <boot_add_data_to_shared_area>
            if (res2) {
 c00dc3a:	2800      	cmp	r0, #0
 c00dc3c:	d0d5      	beq.n	c00dbea <boot_save_boot_status+0x8a>
        return BOOT_STATUS_ERROR;
 c00dc3e:	2001      	movs	r0, #1
    }

    return BOOT_STATUS_OK;

#endif /* MCUBOOT_INDIVIDUAL_CLAIMS */
}
 c00dc40:	b014      	add	sp, #80	; 0x50
 c00dc42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        sw_type = sw_comp_ns_s;
 c00dc46:	4f0f      	ldr	r7, [pc, #60]	; (c00dc84 <boot_save_boot_status+0x124>)
 c00dc48:	e79a      	b.n	c00db80 <boot_save_boot_status+0x20>
        } else if (type == IMAGE_TLV_KEYHASH) {
 c00dc4a:	2c01      	cmp	r4, #1
 c00dc4c:	d1cd      	bne.n	c00dbea <boot_save_boot_status+0x8a>
            if (len != sizeof(buf)) { /* SHA256 - 32 bytes */
 c00dc4e:	f8bd 6008 	ldrh.w	r6, [sp, #8]
 c00dc52:	2e20      	cmp	r6, #32
 c00dc54:	d1f3      	bne.n	c00dc3e <boot_save_boot_status+0xde>
            res = LOAD_IMAGE_DATA(hdr, fap, offset, buf, len);
 c00dc56:	4633      	mov	r3, r6
 c00dc58:	aa0c      	add	r2, sp, #48	; 0x30
 c00dc5a:	9903      	ldr	r1, [sp, #12]
 c00dc5c:	4640      	mov	r0, r8
 c00dc5e:	f000 f833 	bl	c00dcc8 <flash_area_read>
            if (res) {
 c00dc62:	2800      	cmp	r0, #0
 c00dc64:	d1eb      	bne.n	c00dc3e <boot_save_boot_status+0xde>
            res2 = boot_add_data_to_shared_area(TLV_MAJOR_IAS,
 c00dc66:	ab0c      	add	r3, sp, #48	; 0x30
 c00dc68:	4632      	mov	r2, r6
 c00dc6a:	4639      	mov	r1, r7
 c00dc6c:	e7e2      	b.n	c00dc34 <boot_save_boot_status+0xd4>
    return BOOT_STATUS_OK;
 c00dc6e:	2000      	movs	r0, #0
 c00dc70:	e7e6      	b.n	c00dc40 <boot_save_boot_status+0xe0>
 c00dc72:	bf00      	nop
 c00dc74:	0c01075d 	.word	0x0c01075d
 c00dc78:	0c01074f 	.word	0x0c01074f
 c00dc7c:	0c010746 	.word	0x0c010746
 c00dc80:	0c01021c 	.word	0x0c01021c
 c00dc84:	0c010754 	.word	0x0c010754

0c00dc88 <flash_area_open>:
    int i;

    BOOT_LOG_DBG("area %d", id);

    for (i = 0; i < flash_map_entry_num; i++) {
        if (id == flash_map[i].fa_id) {
 c00dc88:	2801      	cmp	r0, #1
 c00dc8a:	d00f      	beq.n	c00dcac <flash_area_open+0x24>
 c00dc8c:	2803      	cmp	r0, #3
 c00dc8e:	d00f      	beq.n	c00dcb0 <flash_area_open+0x28>
 c00dc90:	2802      	cmp	r0, #2
 c00dc92:	d004      	beq.n	c00dc9e <flash_area_open+0x16>
 c00dc94:	2804      	cmp	r0, #4
 c00dc96:	d00d      	beq.n	c00dcb4 <flash_area_open+0x2c>
 c00dc98:	2805      	cmp	r0, #5
 c00dc9a:	d10d      	bne.n	c00dcb8 <flash_area_open+0x30>
    for (i = 0; i < flash_map_entry_num; i++) {
 c00dc9c:	2004      	movs	r0, #4
    }
    if (i == flash_map_entry_num) {
        return -1;
    }

    *area = &flash_map[i];
 c00dc9e:	220c      	movs	r2, #12
 c00dca0:	4b07      	ldr	r3, [pc, #28]	; (c00dcc0 <flash_area_open+0x38>)
 c00dca2:	fb02 3000 	mla	r0, r2, r0, r3
 c00dca6:	6008      	str	r0, [r1, #0]
    return 0;
 c00dca8:	2000      	movs	r0, #0
 c00dcaa:	4770      	bx	lr
    for (i = 0; i < flash_map_entry_num; i++) {
 c00dcac:	2000      	movs	r0, #0
 c00dcae:	e7f6      	b.n	c00dc9e <flash_area_open+0x16>
 c00dcb0:	2001      	movs	r0, #1
 c00dcb2:	e7f4      	b.n	c00dc9e <flash_area_open+0x16>
 c00dcb4:	2003      	movs	r0, #3
 c00dcb6:	e7f2      	b.n	c00dc9e <flash_area_open+0x16>
        return -1;
 c00dcb8:	f04f 30ff 	mov.w	r0, #4294967295
}
 c00dcbc:	4770      	bx	lr
 c00dcbe:	bf00      	nop
 c00dcc0:	0c010764 	.word	0x0c010764

0c00dcc4 <flash_area_close>:

void flash_area_close(const struct flash_area *area)
{
    /* Nothing to do. */
}
 c00dcc4:	4770      	bx	lr
	...

0c00dcc8 <flash_area_read>:

int flash_area_read(const struct flash_area *area, uint32_t off, void *dst,
                    uint32_t len)
{
 c00dcc8:	b430      	push	{r4, r5}
 c00dcca:	4604      	mov	r4, r0
 c00dccc:	4615      	mov	r5, r2
    BOOT_LOG_DBG("read area=%d, off=%#x, len=%#x", area->fa_id, off, len);
    return driver_list[area->fa_device_id]->ReadData(area->fa_off + off, dst, len);;
 c00dcce:	6842      	ldr	r2, [r0, #4]
 c00dcd0:	1888      	adds	r0, r1, r2
 c00dcd2:	7861      	ldrb	r1, [r4, #1]
 c00dcd4:	4a04      	ldr	r2, [pc, #16]	; (c00dce8 <flash_area_read+0x20>)
 c00dcd6:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 c00dcda:	4629      	mov	r1, r5
 c00dcdc:	6954      	ldr	r4, [r2, #20]
 c00dcde:	461a      	mov	r2, r3
 c00dce0:	4623      	mov	r3, r4
}
 c00dce2:	bc30      	pop	{r4, r5}
    return driver_list[area->fa_device_id]->ReadData(area->fa_off + off, dst, len);;
 c00dce4:	4718      	bx	r3
 c00dce6:	bf00      	nop
 c00dce8:	300300e0 	.word	0x300300e0

0c00dcec <flash_area_write>:

int flash_area_write(const struct flash_area *area, uint32_t off,
                     const void *src, uint32_t len)
{
 c00dcec:	b430      	push	{r4, r5}
 c00dcee:	4604      	mov	r4, r0
 c00dcf0:	4615      	mov	r5, r2
    BOOT_LOG_DBG("write area=%d, off=%#x, len=%#x", area->fa_id, off, len);
    return driver_list[area->fa_device_id]->ProgramData(area->fa_off + off, src, len);
 c00dcf2:	6842      	ldr	r2, [r0, #4]
 c00dcf4:	1888      	adds	r0, r1, r2
 c00dcf6:	7861      	ldrb	r1, [r4, #1]
 c00dcf8:	4a04      	ldr	r2, [pc, #16]	; (c00dd0c <flash_area_write+0x20>)
 c00dcfa:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
 c00dcfe:	4629      	mov	r1, r5
 c00dd00:	6994      	ldr	r4, [r2, #24]
 c00dd02:	461a      	mov	r2, r3
 c00dd04:	4623      	mov	r3, r4
}
 c00dd06:	bc30      	pop	{r4, r5}
    return driver_list[area->fa_device_id]->ProgramData(area->fa_off + off, src, len);
 c00dd08:	4718      	bx	r3
 c00dd0a:	bf00      	nop
 c00dd0c:	300300e0 	.word	0x300300e0

0c00dd10 <flash_area_erase>:

int flash_area_erase(const struct flash_area *area, uint32_t off, uint32_t len)
{
 c00dd10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ARM_FLASH_INFO *flash_info;
    uint32_t deleted_len = 0;
    int32_t rc = 0;

    BOOT_LOG_DBG("erase area=%d, off=%#x, len=%#x", area->fa_id, off, len);
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00dd14:	4d0f      	ldr	r5, [pc, #60]	; (c00dd54 <flash_area_erase+0x44>)
 c00dd16:	7843      	ldrb	r3, [r0, #1]
{
 c00dd18:	4606      	mov	r6, r0
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00dd1a:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
{
 c00dd1e:	4688      	mov	r8, r1
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00dd20:	6a9b      	ldr	r3, [r3, #40]	; 0x28
{
 c00dd22:	4617      	mov	r7, r2
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00dd24:	4798      	blx	r3

    if (flash_info->sector_info == NULL) {
 c00dd26:	6804      	ldr	r4, [r0, #0]
    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00dd28:	4681      	mov	r9, r0
    if (flash_info->sector_info == NULL) {
 c00dd2a:	b17c      	cbz	r4, c00dd4c <flash_area_erase+0x3c>
    int32_t rc = 0;
 c00dd2c:	2000      	movs	r0, #0
         * Currently not supported.
         */
    }

    return rc;
}
 c00dd2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
            rc = driver_list[area->fa_device_id]->EraseSector(area->fa_off + off);
 c00dd32:	7873      	ldrb	r3, [r6, #1]
 c00dd34:	6870      	ldr	r0, [r6, #4]
 c00dd36:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 c00dd3a:	4440      	add	r0, r8
 c00dd3c:	69db      	ldr	r3, [r3, #28]
 c00dd3e:	4798      	blx	r3
            if (rc != 0) {
 c00dd40:	2800      	cmp	r0, #0
 c00dd42:	d1f4      	bne.n	c00dd2e <flash_area_erase+0x1e>
            deleted_len += flash_info->sector_size;
 c00dd44:	f8d9 3008 	ldr.w	r3, [r9, #8]
 c00dd48:	441c      	add	r4, r3
            off         += flash_info->sector_size;
 c00dd4a:	4498      	add	r8, r3
        while (deleted_len < len) {
 c00dd4c:	42bc      	cmp	r4, r7
 c00dd4e:	d3f0      	bcc.n	c00dd32 <flash_area_erase+0x22>
 c00dd50:	e7ec      	b.n	c00dd2c <flash_area_erase+0x1c>
 c00dd52:	bf00      	nop
 c00dd54:	300300e0 	.word	0x300300e0

0c00dd58 <flash_area_align>:

uint32_t flash_area_align(const struct flash_area *area)
{
 c00dd58:	b508      	push	{r3, lr}
    ARM_FLASH_INFO *flash_info;

    flash_info = driver_list[area->fa_device_id]->GetInfo();
 c00dd5a:	4b04      	ldr	r3, [pc, #16]	; (c00dd6c <flash_area_align+0x14>)
 c00dd5c:	7842      	ldrb	r2, [r0, #1]
 c00dd5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c00dd62:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c00dd64:	4798      	blx	r3
    return flash_info->program_unit;
}
 c00dd66:	6900      	ldr	r0, [r0, #16]
 c00dd68:	bd08      	pop	{r3, pc}
 c00dd6a:	bf00      	nop
 c00dd6c:	300300e0 	.word	0x300300e0

0c00dd70 <flash_device_base>:
/* Flash device name must be specified by target */
extern ARM_DRIVER_FLASH* driver_list[2];


int flash_device_base(uint8_t fd_id, uintptr_t *ret)
{
 c00dd70:	b508      	push	{r3, lr}
    if ((fd_id +FLASH_DEVICE_ID) == FLASH_DEVICE_ID) {
 c00dd72:	b918      	cbnz	r0, c00dd7c <flash_device_base+0xc>
        *ret = FLASH_BASE_ADDRESS;
 c00dd74:	f04f 6340 	mov.w	r3, #201326592	; 0xc000000
 c00dd78:	600b      	str	r3, [r1, #0]
                     (fd_id + FLASH_DEVICE_ID), FLASH_DEVICE_ID);
        return -1;
    }
#endif /* TFM_EXTERNAL_FLASH_ENABLE */
    return 0;
}
 c00dd7a:	bd08      	pop	{r3, pc}
    else if ((fd_id +FLASH_DEVICE_ID)== OSPI_FLASH_DEVICE_ID) {
 c00dd7c:	2801      	cmp	r0, #1
 c00dd7e:	d104      	bne.n	c00dd8a <flash_device_base+0x1a>
        *ret = OSPI_FLASH_BASE_ADDRESS;
 c00dd80:	f04f 4310 	mov.w	r3, #2415919104	; 0x90000000
    return 0;
 c00dd84:	2000      	movs	r0, #0
        *ret = OSPI_FLASH_BASE_ADDRESS;
 c00dd86:	600b      	str	r3, [r1, #0]
 c00dd88:	e7f7      	b.n	c00dd7a <flash_device_base+0xa>
        BOOT_LOG_ERR("invalid flash ID %d; expected %d or %d",
 c00dd8a:	2264      	movs	r2, #100	; 0x64
 c00dd8c:	2365      	movs	r3, #101	; 0x65
 c00dd8e:	1881      	adds	r1, r0, r2
 c00dd90:	4802      	ldr	r0, [pc, #8]	; (c00dd9c <flash_device_base+0x2c>)
 c00dd92:	f000 fa2b 	bl	c00e1ec <iprintf>
        return -1;
 c00dd96:	f04f 30ff 	mov.w	r0, #4294967295
 c00dd9a:	e7ee      	b.n	c00dd7a <flash_device_base+0xa>
 c00dd9c:	0c0107bd 	.word	0x0c0107bd

0c00dda0 <flash_area_id_from_multi_image_slot>:
 * MCUBoot uses continuous numbering for the primary slot, the secondary slot,
 * and the scratch while TF-M might number it differently.
 */
int flash_area_id_from_multi_image_slot(int image_index, int slot)
{
    switch (slot) {
 c00dda0:	2901      	cmp	r1, #1
 c00dda2:	d00b      	beq.n	c00ddbc <flash_area_id_from_multi_image_slot+0x1c>
 c00dda4:	2902      	cmp	r1, #2
 c00dda6:	d00f      	beq.n	c00ddc8 <flash_area_id_from_multi_image_slot+0x28>
 c00dda8:	b111      	cbz	r1, c00ddb0 <flash_area_id_from_multi_image_slot+0x10>
    case 1: return FLASH_AREA_IMAGE_SECONDARY(image_index); 
    case 2: return FLASH_AREA_IMAGE_SCRATCH;
#endif
    }

    return -1; /* flash_area_open will fail on that */
 c00ddaa:	f04f 30ff 	mov.w	r0, #4294967295
 c00ddae:	4770      	bx	lr
    case 0: return FLASH_AREA_IMAGE_PRIMARY(image_index);
 c00ddb0:	b160      	cbz	r0, c00ddcc <flash_area_id_from_multi_image_slot+0x2c>
 c00ddb2:	2801      	cmp	r0, #1
 c00ddb4:	bf14      	ite	ne
 c00ddb6:	20ff      	movne	r0, #255	; 0xff
 c00ddb8:	2002      	moveq	r0, #2
 c00ddba:	4770      	bx	lr
    case 1: return FLASH_AREA_IMAGE_SECONDARY(image_index); 
 c00ddbc:	b140      	cbz	r0, c00ddd0 <flash_area_id_from_multi_image_slot+0x30>
 c00ddbe:	2801      	cmp	r0, #1
 c00ddc0:	bf14      	ite	ne
 c00ddc2:	20ff      	movne	r0, #255	; 0xff
 c00ddc4:	2004      	moveq	r0, #4
 c00ddc6:	4770      	bx	lr
    case 2: return FLASH_AREA_IMAGE_SCRATCH;
 c00ddc8:	2005      	movs	r0, #5
 c00ddca:	4770      	bx	lr
    case 0: return FLASH_AREA_IMAGE_PRIMARY(image_index);
 c00ddcc:	2001      	movs	r0, #1
 c00ddce:	4770      	bx	lr
    case 1: return FLASH_AREA_IMAGE_SECONDARY(image_index); 
 c00ddd0:	2003      	movs	r0, #3
}
 c00ddd2:	4770      	bx	lr

0c00ddd4 <flash_area_id_to_multi_image_slot>:
{
    return flash_area_id_from_multi_image_slot(0, slot);
}

int flash_area_id_to_multi_image_slot(int image_index, int area_id)
{
 c00ddd4:	b508      	push	{r3, lr}
    if (area_id == FLASH_AREA_IMAGE_PRIMARY(image_index)) {
 c00ddd6:	b190      	cbz	r0, c00ddfe <flash_area_id_to_multi_image_slot+0x2a>
 c00ddd8:	2801      	cmp	r0, #1
 c00ddda:	d10c      	bne.n	c00ddf6 <flash_area_id_to_multi_image_slot+0x22>
 c00dddc:	2902      	cmp	r1, #2
 c00ddde:	d00c      	beq.n	c00ddfa <flash_area_id_to_multi_image_slot+0x26>
        return 0;
    }
#if !defined(MCUBOOT_PRIMARY_ONLY)
    if (area_id == FLASH_AREA_IMAGE_SECONDARY(image_index)) {
 c00dde0:	2304      	movs	r3, #4
 c00dde2:	4299      	cmp	r1, r3
 c00dde4:	d005      	beq.n	c00ddf2 <flash_area_id_to_multi_image_slot+0x1e>
        return 1;
    }
#endif
    BOOT_LOG_ERR("invalid flash area ID");
 c00dde6:	4808      	ldr	r0, [pc, #32]	; (c00de08 <flash_area_id_to_multi_image_slot+0x34>)
 c00dde8:	f000 fa74 	bl	c00e2d4 <puts>
    return -1;
 c00ddec:	f04f 30ff 	mov.w	r0, #4294967295
}
 c00ddf0:	bd08      	pop	{r3, pc}
        return 1;
 c00ddf2:	2001      	movs	r0, #1
 c00ddf4:	e7fc      	b.n	c00ddf0 <flash_area_id_to_multi_image_slot+0x1c>
    if (area_id == FLASH_AREA_IMAGE_PRIMARY(image_index)) {
 c00ddf6:	29ff      	cmp	r1, #255	; 0xff
 c00ddf8:	d1f5      	bne.n	c00dde6 <flash_area_id_to_multi_image_slot+0x12>
        return 0;
 c00ddfa:	2000      	movs	r0, #0
 c00ddfc:	e7f8      	b.n	c00ddf0 <flash_area_id_to_multi_image_slot+0x1c>
    if (area_id == FLASH_AREA_IMAGE_PRIMARY(image_index)) {
 c00ddfe:	2901      	cmp	r1, #1
 c00de00:	d0f6      	beq.n	c00ddf0 <flash_area_id_to_multi_image_slot+0x1c>
    if (area_id == FLASH_AREA_IMAGE_SECONDARY(image_index)) {
 c00de02:	2303      	movs	r3, #3
 c00de04:	e7ed      	b.n	c00dde2 <flash_area_id_to_multi_image_slot+0xe>
 c00de06:	bf00      	nop
 c00de08:	0c0107a0 	.word	0x0c0107a0

0c00de0c <flash_area_erased_val>:
{
    return flash_area_id_to_multi_image_slot(0, area_id);
}

uint8_t flash_area_erased_val(const struct flash_area *fap)
{
 c00de0c:	b508      	push	{r3, lr}
    (void)fap;

    return driver_list[fap->fa_device_id]->GetInfo()->erased_value;;
 c00de0e:	4b04      	ldr	r3, [pc, #16]	; (c00de20 <flash_area_erased_val+0x14>)
 c00de10:	7842      	ldrb	r2, [r0, #1]
 c00de12:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c00de16:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 c00de18:	4798      	blx	r3
}
 c00de1a:	7d00      	ldrb	r0, [r0, #20]
 c00de1c:	bd08      	pop	{r3, pc}
 c00de1e:	bf00      	nop
 c00de20:	300300e0 	.word	0x300300e0

0c00de24 <flash_area_read_is_empty>:

int flash_area_read_is_empty(const struct flash_area *fa, uint32_t off,
        void *dst, uint32_t len)
{
 c00de24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00de28:	4607      	mov	r7, r0
 c00de2a:	4614      	mov	r4, r2
 c00de2c:	461e      	mov	r6, r3
    int rc;

    BOOT_LOG_DBG("read_is_empty area=%d, off=%#x, len=%#x",
                 fa->fa_id, off, len);

    rc = driver_list[fa->fa_device_id]->ReadData(fa->fa_off + off, dst, len);
 c00de2e:	787a      	ldrb	r2, [r7, #1]
 c00de30:	4b0e      	ldr	r3, [pc, #56]	; (c00de6c <flash_area_read_is_empty+0x48>)
 c00de32:	6840      	ldr	r0, [r0, #4]
 c00de34:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 c00de38:	4408      	add	r0, r1
 c00de3a:	695b      	ldr	r3, [r3, #20]
 c00de3c:	4632      	mov	r2, r6
 c00de3e:	4621      	mov	r1, r4
 c00de40:	4798      	blx	r3
    if (rc) {
 c00de42:	4605      	mov	r5, r0
 c00de44:	b970      	cbnz	r0, c00de64 <flash_area_read_is_empty+0x40>
 c00de46:	4426      	add	r6, r4
        return -1;
    }

    u8dst = (uint8_t*)dst;

    for (i = 0; i < len; i++) {
 c00de48:	42b4      	cmp	r4, r6
 c00de4a:	d101      	bne.n	c00de50 <flash_area_read_is_empty+0x2c>
        if (u8dst[i] != flash_area_erased_val(fa)) {
            return 0;
        }
    }

    return 1;
 c00de4c:	2501      	movs	r5, #1
 c00de4e:	e006      	b.n	c00de5e <flash_area_read_is_empty+0x3a>
        if (u8dst[i] != flash_area_erased_val(fa)) {
 c00de50:	4638      	mov	r0, r7
 c00de52:	f814 8b01 	ldrb.w	r8, [r4], #1
 c00de56:	f7ff ffd9 	bl	c00de0c <flash_area_erased_val>
 c00de5a:	4580      	cmp	r8, r0
 c00de5c:	d0f4      	beq.n	c00de48 <flash_area_read_is_empty+0x24>
}
 c00de5e:	4628      	mov	r0, r5
 c00de60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return -1;
 c00de64:	f04f 35ff 	mov.w	r5, #4294967295
 c00de68:	e7f9      	b.n	c00de5e <flash_area_read_is_empty+0x3a>
 c00de6a:	bf00      	nop
 c00de6c:	300300e0 	.word	0x300300e0

0c00de70 <flash_area_get_sectors>:
 * `ret` with all of the sectors in the area.  `*cnt` will be set to
 * the storage at `ret` and should be set to the final number of
 * sectors in this area.
 */
int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
 c00de70:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    const struct flash_area *fa;
    uint32_t max_cnt = *cnt;
 c00de74:	680f      	ldr	r7, [r1, #0]
{
 c00de76:	4606      	mov	r6, r0
 c00de78:	460d      	mov	r5, r1
    uint32_t rem_len;
    int rc = -1;

    if (flash_area_open(idx, &fa)) {
 c00de7a:	b2c0      	uxtb	r0, r0
 c00de7c:	a901      	add	r1, sp, #4
{
 c00de7e:	4690      	mov	r8, r2
    if (flash_area_open(idx, &fa)) {
 c00de80:	f7ff ff02 	bl	c00dc88 <flash_area_open>
 c00de84:	4604      	mov	r4, r0
 c00de86:	2800      	cmp	r0, #0
 c00de88:	d132      	bne.n	c00def0 <flash_area_get_sectors+0x80>
    }

    BOOT_LOG_DBG("area %d: offset=0x%x, length=0x%x", idx, fa->fa_off,
                 fa->fa_size);

    if (*cnt < 1) {
 c00de8a:	682b      	ldr	r3, [r5, #0]
 c00de8c:	b1cb      	cbz	r3, c00dec2 <flash_area_get_sectors+0x52>
    BOOT_LOG_DBG("area %d: offset=0x%x, length=0x%x", idx, fa->fa_off,
 c00de8e:	9a01      	ldr	r2, [sp, #4]
        goto fa_close_out;
    }

    rem_len = fa->fa_size;
 c00de90:	6891      	ldr	r1, [r2, #8]
    *cnt = 0;
 c00de92:	6028      	str	r0, [r5, #0]
                         idx, fa->fa_size, FLASH_AREA_IMAGE_SECTOR_SIZE);
            goto fa_close_out;
        }

        ret[*cnt].fs_off = FLASH_AREA_IMAGE_SECTOR_SIZE * (*cnt);
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c00de94:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 c00de98:	682b      	ldr	r3, [r5, #0]
    while (rem_len > 0 && *cnt < max_cnt) {
 c00de9a:	b109      	cbz	r1, c00dea0 <flash_area_get_sectors+0x30>
 c00de9c:	429f      	cmp	r7, r3
 c00de9e:	d806      	bhi.n	c00deae <flash_area_get_sectors+0x3e>
        *cnt = *cnt + 1;
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
    }

    if (*cnt > max_cnt) {
 c00dea0:	429f      	cmp	r7, r3
 c00dea2:	d210      	bcs.n	c00dec6 <flash_area_get_sectors+0x56>
        BOOT_LOG_ERR("flash area %d sector count overflow", idx);
 c00dea4:	4631      	mov	r1, r6
 c00dea6:	4814      	ldr	r0, [pc, #80]	; (c00def8 <flash_area_get_sectors+0x88>)
 c00dea8:	f000 f9a0 	bl	c00e1ec <iprintf>
 c00deac:	e009      	b.n	c00dec2 <flash_area_get_sectors+0x52>
        if (rem_len < FLASH_AREA_IMAGE_SECTOR_SIZE) {
 c00deae:	f5b1 5f80 	cmp.w	r1, #4096	; 0x1000
 c00deb2:	d20f      	bcs.n	c00ded4 <flash_area_get_sectors+0x64>
            BOOT_LOG_ERR("area %d size 0x%x not divisible by sector size 0x%x",
 c00deb4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 c00deb8:	6892      	ldr	r2, [r2, #8]
 c00deba:	4631      	mov	r1, r6
 c00debc:	480f      	ldr	r0, [pc, #60]	; (c00defc <flash_area_get_sectors+0x8c>)
 c00debe:	f000 f995 	bl	c00e1ec <iprintf>
    int rc = -1;
 c00dec2:	f04f 34ff 	mov.w	r4, #4294967295
    }

    rc = 0;

fa_close_out:
    flash_area_close(fa);
 c00dec6:	9801      	ldr	r0, [sp, #4]
 c00dec8:	f7ff fefc 	bl	c00dcc4 <flash_area_close>
out:
    return rc;
}
 c00decc:	4620      	mov	r0, r4
 c00dece:	b002      	add	sp, #8
 c00ded0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        ret[*cnt].fs_off = FLASH_AREA_IMAGE_SECTOR_SIZE * (*cnt);
 c00ded4:	ea4f 3c03 	mov.w	ip, r3, lsl #12
 c00ded8:	f848 c033 	str.w	ip, [r8, r3, lsl #3]
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c00dedc:	682b      	ldr	r3, [r5, #0]
        rem_len -= FLASH_AREA_IMAGE_SECTOR_SIZE;
 c00dede:	f5a1 5180 	sub.w	r1, r1, #4096	; 0x1000
        ret[*cnt].fs_size = FLASH_AREA_IMAGE_SECTOR_SIZE;
 c00dee2:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 c00dee6:	6058      	str	r0, [r3, #4]
        *cnt = *cnt + 1;
 c00dee8:	682b      	ldr	r3, [r5, #0]
 c00deea:	3301      	adds	r3, #1
 c00deec:	602b      	str	r3, [r5, #0]
 c00deee:	e7d3      	b.n	c00de98 <flash_area_get_sectors+0x28>
    int rc = -1;
 c00def0:	f04f 34ff 	mov.w	r4, #4294967295
    return rc;
 c00def4:	e7ea      	b.n	c00decc <flash_area_get_sectors+0x5c>
 c00def6:	bf00      	nop
 c00def8:	0c010828 	.word	0x0c010828
 c00defc:	0c0107ec 	.word	0x0c0107ec

0c00df00 <boot_nv_security_counter_init>:

    return (enum tfm_nv_counter_t)nv_counter;
}

int32_t boot_nv_security_counter_init(void)
{
 c00df00:	b508      	push	{r3, lr}
    enum tfm_plat_err_t err;

    err = tfm_plat_init_nv_counter();
 c00df02:	f7f5 f86d 	bl	c002fe0 <tfm_plat_init_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c00df06:	3000      	adds	r0, #0
 c00df08:	bf18      	it	ne
 c00df0a:	2001      	movne	r0, #1
        return -1;
    }

    return 0;
}
 c00df0c:	4240      	negs	r0, r0
 c00df0e:	bd08      	pop	{r3, pc}

0c00df10 <boot_nv_security_counter_get>:

int32_t boot_nv_security_counter_get(uint32_t image_id, uint32_t *security_cnt)
{
 c00df10:	b508      	push	{r3, lr}
    enum tfm_nv_counter_t nv_counter;
    enum tfm_plat_err_t err;

    /* Check if it's a null-pointer. */
    if (!security_cnt) {
 c00df12:	460a      	mov	r2, r1
 c00df14:	b169      	cbz	r1, c00df32 <boot_nv_security_counter_get+0x22>
    if ((UINT32_MAX - TFM_BOOT_NV_COUNTER_0) < image_id) {
 c00df16:	1d03      	adds	r3, r0, #4
 c00df18:	d80b      	bhi.n	c00df32 <boot_nv_security_counter_get+0x22>
    nv_counter = TFM_BOOT_NV_COUNTER_0 + image_id;
 c00df1a:	3003      	adds	r0, #3
    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
 c00df1c:	2804      	cmp	r0, #4
 c00df1e:	d808      	bhi.n	c00df32 <boot_nv_security_counter_get+0x22>
    nv_counter = get_nv_counter_from_image_id(image_id);
    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
        return -1;
    }

    err = tfm_plat_read_nv_counter(nv_counter,
 c00df20:	2104      	movs	r1, #4
 c00df22:	b2c0      	uxtb	r0, r0
 c00df24:	f7f5 f81a 	bl	c002f5c <tfm_plat_read_nv_counter>
                                   sizeof(*security_cnt),
                                   (uint8_t *)security_cnt);
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c00df28:	3000      	adds	r0, #0
 c00df2a:	bf18      	it	ne
 c00df2c:	2001      	movne	r0, #1
 c00df2e:	4240      	negs	r0, r0
        return -1;
    }

    return 0;
}
 c00df30:	bd08      	pop	{r3, pc}
        return -1;
 c00df32:	f04f 30ff 	mov.w	r0, #4294967295
 c00df36:	e7fb      	b.n	c00df30 <boot_nv_security_counter_get+0x20>

0c00df38 <boot_nv_security_counter_update>:

int32_t boot_nv_security_counter_update(uint32_t image_id,
                                        uint32_t img_security_cnt)
{
 c00df38:	b508      	push	{r3, lr}
    if ((UINT32_MAX - TFM_BOOT_NV_COUNTER_0) < image_id) {
 c00df3a:	1d03      	adds	r3, r0, #4
 c00df3c:	d80a      	bhi.n	c00df54 <boot_nv_security_counter_update+0x1c>
    nv_counter = TFM_BOOT_NV_COUNTER_0 + image_id;
 c00df3e:	3003      	adds	r0, #3
    if (nv_counter >= TFM_BOOT_NV_COUNTER_MAX) {
 c00df40:	2804      	cmp	r0, #4
 c00df42:	d807      	bhi.n	c00df54 <boot_nv_security_counter_update+0x1c>
    nv_counter = get_nv_counter_from_image_id(image_id);
    if (nv_counter == TFM_BOOT_NV_COUNTER_MAX) {
        return -1;
    }

    err = tfm_plat_set_nv_counter(nv_counter, img_security_cnt);
 c00df44:	b2c0      	uxtb	r0, r0
 c00df46:	f7f5 f963 	bl	c003210 <tfm_plat_set_nv_counter>
    if (err != TFM_PLAT_ERR_SUCCESS) {
 c00df4a:	3000      	adds	r0, #0
 c00df4c:	bf18      	it	ne
 c00df4e:	2001      	movne	r0, #1
 c00df50:	4240      	negs	r0, r0
        return -1;
    }

    return 0;
}
 c00df52:	bd08      	pop	{r3, pc}
        return -1;
 c00df54:	f04f 30ff 	mov.w	r0, #4294967295
 c00df58:	e7fb      	b.n	c00df52 <boot_nv_security_counter_update+0x1a>
	...

0c00df5c <_write>:
    return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 c00df5c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 c00df5e:	460e      	mov	r6, r1
 c00df60:	4615      	mov	r5, r2
    int i;

    for (i = 0; i < len; i++) {
 c00df62:	460c      	mov	r4, r1
    ret = TFM_DRIVER_STDIO.Send(&c, 1);
 c00df64:	4f08      	ldr	r7, [pc, #32]	; (c00df88 <_write+0x2c>)
    for (i = 0; i < len; i++) {
 c00df66:	1ba3      	subs	r3, r4, r6
 c00df68:	429d      	cmp	r5, r3
 c00df6a:	dc02      	bgt.n	c00df72 <_write+0x16>
        uart_putc(str[i]);
    }

    /* Return the number of characters written */
    return len;
}
 c00df6c:	4628      	mov	r0, r5
 c00df6e:	b003      	add	sp, #12
 c00df70:	bdf0      	pop	{r4, r5, r6, r7, pc}
        uart_putc(str[i]);
 c00df72:	f814 3b01 	ldrb.w	r3, [r4], #1
    ret = TFM_DRIVER_STDIO.Send(&c, 1);
 c00df76:	2101      	movs	r1, #1
 c00df78:	f88d 3007 	strb.w	r3, [sp, #7]
 c00df7c:	f10d 0007 	add.w	r0, sp, #7
 c00df80:	697b      	ldr	r3, [r7, #20]
 c00df82:	4798      	blx	r3
 c00df84:	e7ef      	b.n	c00df66 <_write+0xa>
 c00df86:	bf00      	nop
 c00df88:	0c00fa7c 	.word	0x0c00fa7c

0c00df8c <stdio_init>:
    return ch;
}
#endif

void stdio_init(void)
{
 c00df8c:	b510      	push	{r4, lr}
#ifdef NDEBUG
    __attribute__((unused))
#endif
    int32_t ret = ARM_DRIVER_OK;
    ret = TFM_DRIVER_STDIO.Initialize(NULL);
 c00df8e:	4c05      	ldr	r4, [pc, #20]	; (c00dfa4 <stdio_init+0x18>)
 c00df90:	2000      	movs	r0, #0
 c00df92:	68a3      	ldr	r3, [r4, #8]
 c00df94:	4798      	blx	r3
    ASSERT_HIGH(ret);

    ret = TFM_DRIVER_STDIO.Control(ARM_USART_MODE_ASYNCHRONOUS, 115200);
 c00df96:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 c00df98:	f44f 31e1 	mov.w	r1, #115200	; 0x1c200
    ASSERT_HIGH(ret);
}
 c00df9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ret = TFM_DRIVER_STDIO.Control(ARM_USART_MODE_ASYNCHRONOUS, 115200);
 c00dfa0:	2001      	movs	r0, #1
 c00dfa2:	4718      	bx	r3
 c00dfa4:	0c00fa7c 	.word	0x0c00fa7c

0c00dfa8 <stdio_uninit>:
{
#ifdef NDEBUG
    __attribute__((unused))
#endif
    int32_t ret = ARM_DRIVER_OK;
    ret = TFM_DRIVER_STDIO.Uninitialize();
 c00dfa8:	4b01      	ldr	r3, [pc, #4]	; (c00dfb0 <stdio_uninit+0x8>)
 c00dfaa:	68db      	ldr	r3, [r3, #12]
 c00dfac:	4718      	bx	r3
 c00dfae:	bf00      	nop
 c00dfb0:	0c00fa7c 	.word	0x0c00fa7c

0c00dfb4 <exit>:
 c00dfb4:	b508      	push	{r3, lr}
 c00dfb6:	4b07      	ldr	r3, [pc, #28]	; (c00dfd4 <exit+0x20>)
 c00dfb8:	4604      	mov	r4, r0
 c00dfba:	b113      	cbz	r3, c00dfc2 <exit+0xe>
 c00dfbc:	2100      	movs	r1, #0
 c00dfbe:	e000      	b.n	c00dfc2 <exit+0xe>
 c00dfc0:	bf00      	nop
 c00dfc2:	4b05      	ldr	r3, [pc, #20]	; (c00dfd8 <exit+0x24>)
 c00dfc4:	6818      	ldr	r0, [r3, #0]
 c00dfc6:	6a83      	ldr	r3, [r0, #40]	; 0x28
 c00dfc8:	b103      	cbz	r3, c00dfcc <exit+0x18>
 c00dfca:	4798      	blx	r3
 c00dfcc:	4620      	mov	r0, r4
 c00dfce:	f001 fb65 	bl	c00f69c <_exit>
 c00dfd2:	bf00      	nop
 c00dfd4:	00000000 	.word	0x00000000
 c00dfd8:	0c010854 	.word	0x0c010854

0c00dfdc <__libc_init_array>:
 c00dfdc:	b570      	push	{r4, r5, r6, lr}
 c00dfde:	4e0d      	ldr	r6, [pc, #52]	; (c00e014 <__libc_init_array+0x38>)
 c00dfe0:	2500      	movs	r5, #0
 c00dfe2:	4c0d      	ldr	r4, [pc, #52]	; (c00e018 <__libc_init_array+0x3c>)
 c00dfe4:	1ba4      	subs	r4, r4, r6
 c00dfe6:	10a4      	asrs	r4, r4, #2
 c00dfe8:	42a5      	cmp	r5, r4
 c00dfea:	d109      	bne.n	c00e000 <__libc_init_array+0x24>
 c00dfec:	4e0b      	ldr	r6, [pc, #44]	; (c00e01c <__libc_init_array+0x40>)
 c00dfee:	2500      	movs	r5, #0
 c00dff0:	4c0b      	ldr	r4, [pc, #44]	; (c00e020 <__libc_init_array+0x44>)
 c00dff2:	f001 fb55 	bl	c00f6a0 <_init>
 c00dff6:	1ba4      	subs	r4, r4, r6
 c00dff8:	10a4      	asrs	r4, r4, #2
 c00dffa:	42a5      	cmp	r5, r4
 c00dffc:	d105      	bne.n	c00e00a <__libc_init_array+0x2e>
 c00dffe:	bd70      	pop	{r4, r5, r6, pc}
 c00e000:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 c00e004:	3501      	adds	r5, #1
 c00e006:	4798      	blx	r3
 c00e008:	e7ee      	b.n	c00dfe8 <__libc_init_array+0xc>
 c00e00a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 c00e00e:	3501      	adds	r5, #1
 c00e010:	4798      	blx	r3
 c00e012:	e7f2      	b.n	c00dffa <__libc_init_array+0x1e>
 c00e014:	3003014c 	.word	0x3003014c
 c00e018:	3003014c 	.word	0x3003014c
 c00e01c:	3003014c 	.word	0x3003014c
 c00e020:	30030150 	.word	0x30030150

0c00e024 <memcmp>:
 c00e024:	b530      	push	{r4, r5, lr}
 c00e026:	2400      	movs	r4, #0
 c00e028:	42a2      	cmp	r2, r4
 c00e02a:	d101      	bne.n	c00e030 <memcmp+0xc>
 c00e02c:	2000      	movs	r0, #0
 c00e02e:	e007      	b.n	c00e040 <memcmp+0x1c>
 c00e030:	5d03      	ldrb	r3, [r0, r4]
 c00e032:	3401      	adds	r4, #1
 c00e034:	190d      	adds	r5, r1, r4
 c00e036:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 c00e03a:	42ab      	cmp	r3, r5
 c00e03c:	d0f4      	beq.n	c00e028 <memcmp+0x4>
 c00e03e:	1b58      	subs	r0, r3, r5
 c00e040:	bd30      	pop	{r4, r5, pc}

0c00e042 <memcpy>:
 c00e042:	1e43      	subs	r3, r0, #1
 c00e044:	440a      	add	r2, r1
 c00e046:	b510      	push	{r4, lr}
 c00e048:	4291      	cmp	r1, r2
 c00e04a:	d100      	bne.n	c00e04e <memcpy+0xc>
 c00e04c:	bd10      	pop	{r4, pc}
 c00e04e:	f811 4b01 	ldrb.w	r4, [r1], #1
 c00e052:	f803 4f01 	strb.w	r4, [r3, #1]!
 c00e056:	e7f7      	b.n	c00e048 <memcpy+0x6>

0c00e058 <memmove>:
 c00e058:	4288      	cmp	r0, r1
 c00e05a:	eb01 0302 	add.w	r3, r1, r2
 c00e05e:	b510      	push	{r4, lr}
 c00e060:	d807      	bhi.n	c00e072 <memmove+0x1a>
 c00e062:	1e42      	subs	r2, r0, #1
 c00e064:	4299      	cmp	r1, r3
 c00e066:	d00a      	beq.n	c00e07e <memmove+0x26>
 c00e068:	f811 4b01 	ldrb.w	r4, [r1], #1
 c00e06c:	f802 4f01 	strb.w	r4, [r2, #1]!
 c00e070:	e7f8      	b.n	c00e064 <memmove+0xc>
 c00e072:	4283      	cmp	r3, r0
 c00e074:	d9f5      	bls.n	c00e062 <memmove+0xa>
 c00e076:	1881      	adds	r1, r0, r2
 c00e078:	1ad2      	subs	r2, r2, r3
 c00e07a:	42d3      	cmn	r3, r2
 c00e07c:	d100      	bne.n	c00e080 <memmove+0x28>
 c00e07e:	bd10      	pop	{r4, pc}
 c00e080:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 c00e084:	f801 4d01 	strb.w	r4, [r1, #-1]!
 c00e088:	e7f7      	b.n	c00e07a <memmove+0x22>

0c00e08a <memset>:
 c00e08a:	4402      	add	r2, r0
 c00e08c:	4603      	mov	r3, r0
 c00e08e:	4293      	cmp	r3, r2
 c00e090:	d100      	bne.n	c00e094 <memset+0xa>
 c00e092:	4770      	bx	lr
 c00e094:	f803 1b01 	strb.w	r1, [r3], #1
 c00e098:	e7f9      	b.n	c00e08e <memset+0x4>
	...

0c00e09c <_free_r>:
 c00e09c:	b538      	push	{r3, r4, r5, lr}
 c00e09e:	4605      	mov	r5, r0
 c00e0a0:	2900      	cmp	r1, #0
 c00e0a2:	d045      	beq.n	c00e130 <_free_r+0x94>
 c00e0a4:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c00e0a8:	1f0c      	subs	r4, r1, #4
 c00e0aa:	2b00      	cmp	r3, #0
 c00e0ac:	bfb8      	it	lt
 c00e0ae:	18e4      	addlt	r4, r4, r3
 c00e0b0:	f000 fc00 	bl	c00e8b4 <__malloc_lock>
 c00e0b4:	4a1f      	ldr	r2, [pc, #124]	; (c00e134 <_free_r+0x98>)
 c00e0b6:	6813      	ldr	r3, [r2, #0]
 c00e0b8:	4610      	mov	r0, r2
 c00e0ba:	b933      	cbnz	r3, c00e0ca <_free_r+0x2e>
 c00e0bc:	6063      	str	r3, [r4, #4]
 c00e0be:	6014      	str	r4, [r2, #0]
 c00e0c0:	4628      	mov	r0, r5
 c00e0c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c00e0c6:	f000 bbf6 	b.w	c00e8b6 <__malloc_unlock>
 c00e0ca:	42a3      	cmp	r3, r4
 c00e0cc:	d90c      	bls.n	c00e0e8 <_free_r+0x4c>
 c00e0ce:	6821      	ldr	r1, [r4, #0]
 c00e0d0:	1862      	adds	r2, r4, r1
 c00e0d2:	4293      	cmp	r3, r2
 c00e0d4:	bf02      	ittt	eq
 c00e0d6:	681a      	ldreq	r2, [r3, #0]
 c00e0d8:	685b      	ldreq	r3, [r3, #4]
 c00e0da:	1852      	addeq	r2, r2, r1
 c00e0dc:	6063      	str	r3, [r4, #4]
 c00e0de:	bf08      	it	eq
 c00e0e0:	6022      	streq	r2, [r4, #0]
 c00e0e2:	6004      	str	r4, [r0, #0]
 c00e0e4:	e7ec      	b.n	c00e0c0 <_free_r+0x24>
 c00e0e6:	4613      	mov	r3, r2
 c00e0e8:	685a      	ldr	r2, [r3, #4]
 c00e0ea:	b10a      	cbz	r2, c00e0f0 <_free_r+0x54>
 c00e0ec:	42a2      	cmp	r2, r4
 c00e0ee:	d9fa      	bls.n	c00e0e6 <_free_r+0x4a>
 c00e0f0:	6819      	ldr	r1, [r3, #0]
 c00e0f2:	1858      	adds	r0, r3, r1
 c00e0f4:	42a0      	cmp	r0, r4
 c00e0f6:	d10b      	bne.n	c00e110 <_free_r+0x74>
 c00e0f8:	6820      	ldr	r0, [r4, #0]
 c00e0fa:	4401      	add	r1, r0
 c00e0fc:	1858      	adds	r0, r3, r1
 c00e0fe:	6019      	str	r1, [r3, #0]
 c00e100:	4282      	cmp	r2, r0
 c00e102:	d1dd      	bne.n	c00e0c0 <_free_r+0x24>
 c00e104:	6810      	ldr	r0, [r2, #0]
 c00e106:	6852      	ldr	r2, [r2, #4]
 c00e108:	4401      	add	r1, r0
 c00e10a:	605a      	str	r2, [r3, #4]
 c00e10c:	6019      	str	r1, [r3, #0]
 c00e10e:	e7d7      	b.n	c00e0c0 <_free_r+0x24>
 c00e110:	d902      	bls.n	c00e118 <_free_r+0x7c>
 c00e112:	230c      	movs	r3, #12
 c00e114:	602b      	str	r3, [r5, #0]
 c00e116:	e7d3      	b.n	c00e0c0 <_free_r+0x24>
 c00e118:	6820      	ldr	r0, [r4, #0]
 c00e11a:	1821      	adds	r1, r4, r0
 c00e11c:	428a      	cmp	r2, r1
 c00e11e:	bf02      	ittt	eq
 c00e120:	6811      	ldreq	r1, [r2, #0]
 c00e122:	6852      	ldreq	r2, [r2, #4]
 c00e124:	1809      	addeq	r1, r1, r0
 c00e126:	6062      	str	r2, [r4, #4]
 c00e128:	bf08      	it	eq
 c00e12a:	6021      	streq	r1, [r4, #0]
 c00e12c:	605c      	str	r4, [r3, #4]
 c00e12e:	e7c7      	b.n	c00e0c0 <_free_r+0x24>
 c00e130:	bd38      	pop	{r3, r4, r5, pc}
 c00e132:	bf00      	nop
 c00e134:	3003e3ec 	.word	0x3003e3ec

0c00e138 <_malloc_r>:
 c00e138:	b570      	push	{r4, r5, r6, lr}
 c00e13a:	1ccd      	adds	r5, r1, #3
 c00e13c:	4606      	mov	r6, r0
 c00e13e:	f025 0503 	bic.w	r5, r5, #3
 c00e142:	3508      	adds	r5, #8
 c00e144:	2d0c      	cmp	r5, #12
 c00e146:	bf38      	it	cc
 c00e148:	250c      	movcc	r5, #12
 c00e14a:	2d00      	cmp	r5, #0
 c00e14c:	db01      	blt.n	c00e152 <_malloc_r+0x1a>
 c00e14e:	42a9      	cmp	r1, r5
 c00e150:	d903      	bls.n	c00e15a <_malloc_r+0x22>
 c00e152:	230c      	movs	r3, #12
 c00e154:	6033      	str	r3, [r6, #0]
 c00e156:	2000      	movs	r0, #0
 c00e158:	bd70      	pop	{r4, r5, r6, pc}
 c00e15a:	f000 fbab 	bl	c00e8b4 <__malloc_lock>
 c00e15e:	4a21      	ldr	r2, [pc, #132]	; (c00e1e4 <_malloc_r+0xac>)
 c00e160:	6814      	ldr	r4, [r2, #0]
 c00e162:	4621      	mov	r1, r4
 c00e164:	b991      	cbnz	r1, c00e18c <_malloc_r+0x54>
 c00e166:	4c20      	ldr	r4, [pc, #128]	; (c00e1e8 <_malloc_r+0xb0>)
 c00e168:	6823      	ldr	r3, [r4, #0]
 c00e16a:	b91b      	cbnz	r3, c00e174 <_malloc_r+0x3c>
 c00e16c:	4630      	mov	r0, r6
 c00e16e:	f000 f8b9 	bl	c00e2e4 <_sbrk_r>
 c00e172:	6020      	str	r0, [r4, #0]
 c00e174:	4629      	mov	r1, r5
 c00e176:	4630      	mov	r0, r6
 c00e178:	f000 f8b4 	bl	c00e2e4 <_sbrk_r>
 c00e17c:	1c43      	adds	r3, r0, #1
 c00e17e:	d124      	bne.n	c00e1ca <_malloc_r+0x92>
 c00e180:	230c      	movs	r3, #12
 c00e182:	4630      	mov	r0, r6
 c00e184:	6033      	str	r3, [r6, #0]
 c00e186:	f000 fb96 	bl	c00e8b6 <__malloc_unlock>
 c00e18a:	e7e4      	b.n	c00e156 <_malloc_r+0x1e>
 c00e18c:	680b      	ldr	r3, [r1, #0]
 c00e18e:	1b5b      	subs	r3, r3, r5
 c00e190:	d418      	bmi.n	c00e1c4 <_malloc_r+0x8c>
 c00e192:	2b0b      	cmp	r3, #11
 c00e194:	d90f      	bls.n	c00e1b6 <_malloc_r+0x7e>
 c00e196:	18cc      	adds	r4, r1, r3
 c00e198:	600b      	str	r3, [r1, #0]
 c00e19a:	50cd      	str	r5, [r1, r3]
 c00e19c:	4630      	mov	r0, r6
 c00e19e:	f000 fb8a 	bl	c00e8b6 <__malloc_unlock>
 c00e1a2:	f104 000b 	add.w	r0, r4, #11
 c00e1a6:	1d23      	adds	r3, r4, #4
 c00e1a8:	f020 0007 	bic.w	r0, r0, #7
 c00e1ac:	1ac3      	subs	r3, r0, r3
 c00e1ae:	d0d3      	beq.n	c00e158 <_malloc_r+0x20>
 c00e1b0:	425a      	negs	r2, r3
 c00e1b2:	50e2      	str	r2, [r4, r3]
 c00e1b4:	e7d0      	b.n	c00e158 <_malloc_r+0x20>
 c00e1b6:	428c      	cmp	r4, r1
 c00e1b8:	684b      	ldr	r3, [r1, #4]
 c00e1ba:	bf1a      	itte	ne
 c00e1bc:	6063      	strne	r3, [r4, #4]
 c00e1be:	460c      	movne	r4, r1
 c00e1c0:	6013      	streq	r3, [r2, #0]
 c00e1c2:	e7eb      	b.n	c00e19c <_malloc_r+0x64>
 c00e1c4:	460c      	mov	r4, r1
 c00e1c6:	6849      	ldr	r1, [r1, #4]
 c00e1c8:	e7cc      	b.n	c00e164 <_malloc_r+0x2c>
 c00e1ca:	1cc4      	adds	r4, r0, #3
 c00e1cc:	f024 0403 	bic.w	r4, r4, #3
 c00e1d0:	42a0      	cmp	r0, r4
 c00e1d2:	d005      	beq.n	c00e1e0 <_malloc_r+0xa8>
 c00e1d4:	1a21      	subs	r1, r4, r0
 c00e1d6:	4630      	mov	r0, r6
 c00e1d8:	f000 f884 	bl	c00e2e4 <_sbrk_r>
 c00e1dc:	3001      	adds	r0, #1
 c00e1de:	d0cf      	beq.n	c00e180 <_malloc_r+0x48>
 c00e1e0:	6025      	str	r5, [r4, #0]
 c00e1e2:	e7db      	b.n	c00e19c <_malloc_r+0x64>
 c00e1e4:	3003e3ec 	.word	0x3003e3ec
 c00e1e8:	3003e3f0 	.word	0x3003e3f0

0c00e1ec <iprintf>:
 c00e1ec:	b40f      	push	{r0, r1, r2, r3}
 c00e1ee:	4b0a      	ldr	r3, [pc, #40]	; (c00e218 <iprintf+0x2c>)
 c00e1f0:	b513      	push	{r0, r1, r4, lr}
 c00e1f2:	681c      	ldr	r4, [r3, #0]
 c00e1f4:	b124      	cbz	r4, c00e200 <iprintf+0x14>
 c00e1f6:	69a3      	ldr	r3, [r4, #24]
 c00e1f8:	b913      	cbnz	r3, c00e200 <iprintf+0x14>
 c00e1fa:	4620      	mov	r0, r4
 c00e1fc:	f000 fa6c 	bl	c00e6d8 <__sinit>
 c00e200:	ab05      	add	r3, sp, #20
 c00e202:	9a04      	ldr	r2, [sp, #16]
 c00e204:	68a1      	ldr	r1, [r4, #8]
 c00e206:	4620      	mov	r0, r4
 c00e208:	9301      	str	r3, [sp, #4]
 c00e20a:	f000 fcd1 	bl	c00ebb0 <_vfiprintf_r>
 c00e20e:	b002      	add	sp, #8
 c00e210:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 c00e214:	b004      	add	sp, #16
 c00e216:	4770      	bx	lr
 c00e218:	300300e8 	.word	0x300300e8

0c00e21c <_puts_r>:
 c00e21c:	b570      	push	{r4, r5, r6, lr}
 c00e21e:	460e      	mov	r6, r1
 c00e220:	4605      	mov	r5, r0
 c00e222:	b118      	cbz	r0, c00e22c <_puts_r+0x10>
 c00e224:	6983      	ldr	r3, [r0, #24]
 c00e226:	b90b      	cbnz	r3, c00e22c <_puts_r+0x10>
 c00e228:	f000 fa56 	bl	c00e6d8 <__sinit>
 c00e22c:	69ab      	ldr	r3, [r5, #24]
 c00e22e:	68ac      	ldr	r4, [r5, #8]
 c00e230:	b913      	cbnz	r3, c00e238 <_puts_r+0x1c>
 c00e232:	4628      	mov	r0, r5
 c00e234:	f000 fa50 	bl	c00e6d8 <__sinit>
 c00e238:	4b23      	ldr	r3, [pc, #140]	; (c00e2c8 <_puts_r+0xac>)
 c00e23a:	429c      	cmp	r4, r3
 c00e23c:	d117      	bne.n	c00e26e <_puts_r+0x52>
 c00e23e:	686c      	ldr	r4, [r5, #4]
 c00e240:	89a3      	ldrh	r3, [r4, #12]
 c00e242:	071b      	lsls	r3, r3, #28
 c00e244:	d51d      	bpl.n	c00e282 <_puts_r+0x66>
 c00e246:	6923      	ldr	r3, [r4, #16]
 c00e248:	b1db      	cbz	r3, c00e282 <_puts_r+0x66>
 c00e24a:	3e01      	subs	r6, #1
 c00e24c:	68a3      	ldr	r3, [r4, #8]
 c00e24e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 c00e252:	3b01      	subs	r3, #1
 c00e254:	60a3      	str	r3, [r4, #8]
 c00e256:	b9e9      	cbnz	r1, c00e294 <_puts_r+0x78>
 c00e258:	2b00      	cmp	r3, #0
 c00e25a:	da2e      	bge.n	c00e2ba <_puts_r+0x9e>
 c00e25c:	4622      	mov	r2, r4
 c00e25e:	210a      	movs	r1, #10
 c00e260:	4628      	mov	r0, r5
 c00e262:	f000 f88b 	bl	c00e37c <__swbuf_r>
 c00e266:	3001      	adds	r0, #1
 c00e268:	d011      	beq.n	c00e28e <_puts_r+0x72>
 c00e26a:	200a      	movs	r0, #10
 c00e26c:	e011      	b.n	c00e292 <_puts_r+0x76>
 c00e26e:	4b17      	ldr	r3, [pc, #92]	; (c00e2cc <_puts_r+0xb0>)
 c00e270:	429c      	cmp	r4, r3
 c00e272:	d101      	bne.n	c00e278 <_puts_r+0x5c>
 c00e274:	68ac      	ldr	r4, [r5, #8]
 c00e276:	e7e3      	b.n	c00e240 <_puts_r+0x24>
 c00e278:	4b15      	ldr	r3, [pc, #84]	; (c00e2d0 <_puts_r+0xb4>)
 c00e27a:	429c      	cmp	r4, r3
 c00e27c:	bf08      	it	eq
 c00e27e:	68ec      	ldreq	r4, [r5, #12]
 c00e280:	e7de      	b.n	c00e240 <_puts_r+0x24>
 c00e282:	4621      	mov	r1, r4
 c00e284:	4628      	mov	r0, r5
 c00e286:	f000 f8cb 	bl	c00e420 <__swsetup_r>
 c00e28a:	2800      	cmp	r0, #0
 c00e28c:	d0dd      	beq.n	c00e24a <_puts_r+0x2e>
 c00e28e:	f04f 30ff 	mov.w	r0, #4294967295
 c00e292:	bd70      	pop	{r4, r5, r6, pc}
 c00e294:	2b00      	cmp	r3, #0
 c00e296:	da04      	bge.n	c00e2a2 <_puts_r+0x86>
 c00e298:	69a2      	ldr	r2, [r4, #24]
 c00e29a:	429a      	cmp	r2, r3
 c00e29c:	dc06      	bgt.n	c00e2ac <_puts_r+0x90>
 c00e29e:	290a      	cmp	r1, #10
 c00e2a0:	d004      	beq.n	c00e2ac <_puts_r+0x90>
 c00e2a2:	6823      	ldr	r3, [r4, #0]
 c00e2a4:	1c5a      	adds	r2, r3, #1
 c00e2a6:	6022      	str	r2, [r4, #0]
 c00e2a8:	7019      	strb	r1, [r3, #0]
 c00e2aa:	e7cf      	b.n	c00e24c <_puts_r+0x30>
 c00e2ac:	4622      	mov	r2, r4
 c00e2ae:	4628      	mov	r0, r5
 c00e2b0:	f000 f864 	bl	c00e37c <__swbuf_r>
 c00e2b4:	3001      	adds	r0, #1
 c00e2b6:	d1c9      	bne.n	c00e24c <_puts_r+0x30>
 c00e2b8:	e7e9      	b.n	c00e28e <_puts_r+0x72>
 c00e2ba:	6823      	ldr	r3, [r4, #0]
 c00e2bc:	200a      	movs	r0, #10
 c00e2be:	1c5a      	adds	r2, r3, #1
 c00e2c0:	6022      	str	r2, [r4, #0]
 c00e2c2:	7018      	strb	r0, [r3, #0]
 c00e2c4:	e7e5      	b.n	c00e292 <_puts_r+0x76>
 c00e2c6:	bf00      	nop
 c00e2c8:	0c010878 	.word	0x0c010878
 c00e2cc:	0c010898 	.word	0x0c010898
 c00e2d0:	0c010858 	.word	0x0c010858

0c00e2d4 <puts>:
 c00e2d4:	4b02      	ldr	r3, [pc, #8]	; (c00e2e0 <puts+0xc>)
 c00e2d6:	4601      	mov	r1, r0
 c00e2d8:	6818      	ldr	r0, [r3, #0]
 c00e2da:	f7ff bf9f 	b.w	c00e21c <_puts_r>
 c00e2de:	bf00      	nop
 c00e2e0:	300300e8 	.word	0x300300e8

0c00e2e4 <_sbrk_r>:
 c00e2e4:	b538      	push	{r3, r4, r5, lr}
 c00e2e6:	2300      	movs	r3, #0
 c00e2e8:	4c05      	ldr	r4, [pc, #20]	; (c00e300 <_sbrk_r+0x1c>)
 c00e2ea:	4605      	mov	r5, r0
 c00e2ec:	4608      	mov	r0, r1
 c00e2ee:	6023      	str	r3, [r4, #0]
 c00e2f0:	f001 f9c6 	bl	c00f680 <_sbrk>
 c00e2f4:	1c43      	adds	r3, r0, #1
 c00e2f6:	d102      	bne.n	c00e2fe <_sbrk_r+0x1a>
 c00e2f8:	6823      	ldr	r3, [r4, #0]
 c00e2fa:	b103      	cbz	r3, c00e2fe <_sbrk_r+0x1a>
 c00e2fc:	602b      	str	r3, [r5, #0]
 c00e2fe:	bd38      	pop	{r3, r4, r5, pc}
 c00e300:	3003e420 	.word	0x3003e420

0c00e304 <sniprintf>:
 c00e304:	b40c      	push	{r2, r3}
 c00e306:	4b18      	ldr	r3, [pc, #96]	; (c00e368 <sniprintf+0x64>)
 c00e308:	b530      	push	{r4, r5, lr}
 c00e30a:	1e0c      	subs	r4, r1, #0
 c00e30c:	b09d      	sub	sp, #116	; 0x74
 c00e30e:	681d      	ldr	r5, [r3, #0]
 c00e310:	da08      	bge.n	c00e324 <sniprintf+0x20>
 c00e312:	238b      	movs	r3, #139	; 0x8b
 c00e314:	f04f 30ff 	mov.w	r0, #4294967295
 c00e318:	602b      	str	r3, [r5, #0]
 c00e31a:	b01d      	add	sp, #116	; 0x74
 c00e31c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 c00e320:	b002      	add	sp, #8
 c00e322:	4770      	bx	lr
 c00e324:	f44f 7302 	mov.w	r3, #520	; 0x208
 c00e328:	9002      	str	r0, [sp, #8]
 c00e32a:	9006      	str	r0, [sp, #24]
 c00e32c:	a902      	add	r1, sp, #8
 c00e32e:	f8ad 3014 	strh.w	r3, [sp, #20]
 c00e332:	bf14      	ite	ne
 c00e334:	f104 33ff 	addne.w	r3, r4, #4294967295
 c00e338:	4623      	moveq	r3, r4
 c00e33a:	9a20      	ldr	r2, [sp, #128]	; 0x80
 c00e33c:	4628      	mov	r0, r5
 c00e33e:	9304      	str	r3, [sp, #16]
 c00e340:	9307      	str	r3, [sp, #28]
 c00e342:	f64f 73ff 	movw	r3, #65535	; 0xffff
 c00e346:	f8ad 3016 	strh.w	r3, [sp, #22]
 c00e34a:	ab21      	add	r3, sp, #132	; 0x84
 c00e34c:	9301      	str	r3, [sp, #4]
 c00e34e:	f000 fb0d 	bl	c00e96c <_svfiprintf_r>
 c00e352:	1c43      	adds	r3, r0, #1
 c00e354:	bfbc      	itt	lt
 c00e356:	238b      	movlt	r3, #139	; 0x8b
 c00e358:	602b      	strlt	r3, [r5, #0]
 c00e35a:	2c00      	cmp	r4, #0
 c00e35c:	d0dd      	beq.n	c00e31a <sniprintf+0x16>
 c00e35e:	9b02      	ldr	r3, [sp, #8]
 c00e360:	2200      	movs	r2, #0
 c00e362:	701a      	strb	r2, [r3, #0]
 c00e364:	e7d9      	b.n	c00e31a <sniprintf+0x16>
 c00e366:	bf00      	nop
 c00e368:	300300e8 	.word	0x300300e8

0c00e36c <strlen>:
 c00e36c:	4603      	mov	r3, r0
 c00e36e:	f813 2b01 	ldrb.w	r2, [r3], #1
 c00e372:	2a00      	cmp	r2, #0
 c00e374:	d1fb      	bne.n	c00e36e <strlen+0x2>
 c00e376:	1a18      	subs	r0, r3, r0
 c00e378:	3801      	subs	r0, #1
 c00e37a:	4770      	bx	lr

0c00e37c <__swbuf_r>:
 c00e37c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00e37e:	460e      	mov	r6, r1
 c00e380:	4614      	mov	r4, r2
 c00e382:	4605      	mov	r5, r0
 c00e384:	b118      	cbz	r0, c00e38e <__swbuf_r+0x12>
 c00e386:	6983      	ldr	r3, [r0, #24]
 c00e388:	b90b      	cbnz	r3, c00e38e <__swbuf_r+0x12>
 c00e38a:	f000 f9a5 	bl	c00e6d8 <__sinit>
 c00e38e:	4b21      	ldr	r3, [pc, #132]	; (c00e414 <__swbuf_r+0x98>)
 c00e390:	429c      	cmp	r4, r3
 c00e392:	d12a      	bne.n	c00e3ea <__swbuf_r+0x6e>
 c00e394:	686c      	ldr	r4, [r5, #4]
 c00e396:	69a3      	ldr	r3, [r4, #24]
 c00e398:	60a3      	str	r3, [r4, #8]
 c00e39a:	89a3      	ldrh	r3, [r4, #12]
 c00e39c:	071a      	lsls	r2, r3, #28
 c00e39e:	d52e      	bpl.n	c00e3fe <__swbuf_r+0x82>
 c00e3a0:	6923      	ldr	r3, [r4, #16]
 c00e3a2:	b363      	cbz	r3, c00e3fe <__swbuf_r+0x82>
 c00e3a4:	6923      	ldr	r3, [r4, #16]
 c00e3a6:	b2f6      	uxtb	r6, r6
 c00e3a8:	6820      	ldr	r0, [r4, #0]
 c00e3aa:	4637      	mov	r7, r6
 c00e3ac:	1ac0      	subs	r0, r0, r3
 c00e3ae:	6963      	ldr	r3, [r4, #20]
 c00e3b0:	4283      	cmp	r3, r0
 c00e3b2:	dc04      	bgt.n	c00e3be <__swbuf_r+0x42>
 c00e3b4:	4621      	mov	r1, r4
 c00e3b6:	4628      	mov	r0, r5
 c00e3b8:	f000 f924 	bl	c00e604 <_fflush_r>
 c00e3bc:	bb28      	cbnz	r0, c00e40a <__swbuf_r+0x8e>
 c00e3be:	68a3      	ldr	r3, [r4, #8]
 c00e3c0:	3001      	adds	r0, #1
 c00e3c2:	3b01      	subs	r3, #1
 c00e3c4:	60a3      	str	r3, [r4, #8]
 c00e3c6:	6823      	ldr	r3, [r4, #0]
 c00e3c8:	1c5a      	adds	r2, r3, #1
 c00e3ca:	6022      	str	r2, [r4, #0]
 c00e3cc:	701e      	strb	r6, [r3, #0]
 c00e3ce:	6963      	ldr	r3, [r4, #20]
 c00e3d0:	4283      	cmp	r3, r0
 c00e3d2:	d004      	beq.n	c00e3de <__swbuf_r+0x62>
 c00e3d4:	89a3      	ldrh	r3, [r4, #12]
 c00e3d6:	07db      	lsls	r3, r3, #31
 c00e3d8:	d519      	bpl.n	c00e40e <__swbuf_r+0x92>
 c00e3da:	2e0a      	cmp	r6, #10
 c00e3dc:	d117      	bne.n	c00e40e <__swbuf_r+0x92>
 c00e3de:	4621      	mov	r1, r4
 c00e3e0:	4628      	mov	r0, r5
 c00e3e2:	f000 f90f 	bl	c00e604 <_fflush_r>
 c00e3e6:	b190      	cbz	r0, c00e40e <__swbuf_r+0x92>
 c00e3e8:	e00f      	b.n	c00e40a <__swbuf_r+0x8e>
 c00e3ea:	4b0b      	ldr	r3, [pc, #44]	; (c00e418 <__swbuf_r+0x9c>)
 c00e3ec:	429c      	cmp	r4, r3
 c00e3ee:	d101      	bne.n	c00e3f4 <__swbuf_r+0x78>
 c00e3f0:	68ac      	ldr	r4, [r5, #8]
 c00e3f2:	e7d0      	b.n	c00e396 <__swbuf_r+0x1a>
 c00e3f4:	4b09      	ldr	r3, [pc, #36]	; (c00e41c <__swbuf_r+0xa0>)
 c00e3f6:	429c      	cmp	r4, r3
 c00e3f8:	bf08      	it	eq
 c00e3fa:	68ec      	ldreq	r4, [r5, #12]
 c00e3fc:	e7cb      	b.n	c00e396 <__swbuf_r+0x1a>
 c00e3fe:	4621      	mov	r1, r4
 c00e400:	4628      	mov	r0, r5
 c00e402:	f000 f80d 	bl	c00e420 <__swsetup_r>
 c00e406:	2800      	cmp	r0, #0
 c00e408:	d0cc      	beq.n	c00e3a4 <__swbuf_r+0x28>
 c00e40a:	f04f 37ff 	mov.w	r7, #4294967295
 c00e40e:	4638      	mov	r0, r7
 c00e410:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c00e412:	bf00      	nop
 c00e414:	0c010878 	.word	0x0c010878
 c00e418:	0c010898 	.word	0x0c010898
 c00e41c:	0c010858 	.word	0x0c010858

0c00e420 <__swsetup_r>:
 c00e420:	4b32      	ldr	r3, [pc, #200]	; (c00e4ec <__swsetup_r+0xcc>)
 c00e422:	b570      	push	{r4, r5, r6, lr}
 c00e424:	681d      	ldr	r5, [r3, #0]
 c00e426:	4606      	mov	r6, r0
 c00e428:	460c      	mov	r4, r1
 c00e42a:	b125      	cbz	r5, c00e436 <__swsetup_r+0x16>
 c00e42c:	69ab      	ldr	r3, [r5, #24]
 c00e42e:	b913      	cbnz	r3, c00e436 <__swsetup_r+0x16>
 c00e430:	4628      	mov	r0, r5
 c00e432:	f000 f951 	bl	c00e6d8 <__sinit>
 c00e436:	4b2e      	ldr	r3, [pc, #184]	; (c00e4f0 <__swsetup_r+0xd0>)
 c00e438:	429c      	cmp	r4, r3
 c00e43a:	d10f      	bne.n	c00e45c <__swsetup_r+0x3c>
 c00e43c:	686c      	ldr	r4, [r5, #4]
 c00e43e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c00e442:	b29a      	uxth	r2, r3
 c00e444:	0715      	lsls	r5, r2, #28
 c00e446:	d42c      	bmi.n	c00e4a2 <__swsetup_r+0x82>
 c00e448:	06d0      	lsls	r0, r2, #27
 c00e44a:	d411      	bmi.n	c00e470 <__swsetup_r+0x50>
 c00e44c:	2209      	movs	r2, #9
 c00e44e:	6032      	str	r2, [r6, #0]
 c00e450:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c00e454:	f04f 30ff 	mov.w	r0, #4294967295
 c00e458:	81a3      	strh	r3, [r4, #12]
 c00e45a:	e03e      	b.n	c00e4da <__swsetup_r+0xba>
 c00e45c:	4b25      	ldr	r3, [pc, #148]	; (c00e4f4 <__swsetup_r+0xd4>)
 c00e45e:	429c      	cmp	r4, r3
 c00e460:	d101      	bne.n	c00e466 <__swsetup_r+0x46>
 c00e462:	68ac      	ldr	r4, [r5, #8]
 c00e464:	e7eb      	b.n	c00e43e <__swsetup_r+0x1e>
 c00e466:	4b24      	ldr	r3, [pc, #144]	; (c00e4f8 <__swsetup_r+0xd8>)
 c00e468:	429c      	cmp	r4, r3
 c00e46a:	bf08      	it	eq
 c00e46c:	68ec      	ldreq	r4, [r5, #12]
 c00e46e:	e7e6      	b.n	c00e43e <__swsetup_r+0x1e>
 c00e470:	0751      	lsls	r1, r2, #29
 c00e472:	d512      	bpl.n	c00e49a <__swsetup_r+0x7a>
 c00e474:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c00e476:	b141      	cbz	r1, c00e48a <__swsetup_r+0x6a>
 c00e478:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c00e47c:	4299      	cmp	r1, r3
 c00e47e:	d002      	beq.n	c00e486 <__swsetup_r+0x66>
 c00e480:	4630      	mov	r0, r6
 c00e482:	f7ff fe0b 	bl	c00e09c <_free_r>
 c00e486:	2300      	movs	r3, #0
 c00e488:	6363      	str	r3, [r4, #52]	; 0x34
 c00e48a:	89a3      	ldrh	r3, [r4, #12]
 c00e48c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 c00e490:	81a3      	strh	r3, [r4, #12]
 c00e492:	2300      	movs	r3, #0
 c00e494:	6063      	str	r3, [r4, #4]
 c00e496:	6923      	ldr	r3, [r4, #16]
 c00e498:	6023      	str	r3, [r4, #0]
 c00e49a:	89a3      	ldrh	r3, [r4, #12]
 c00e49c:	f043 0308 	orr.w	r3, r3, #8
 c00e4a0:	81a3      	strh	r3, [r4, #12]
 c00e4a2:	6923      	ldr	r3, [r4, #16]
 c00e4a4:	b94b      	cbnz	r3, c00e4ba <__swsetup_r+0x9a>
 c00e4a6:	89a3      	ldrh	r3, [r4, #12]
 c00e4a8:	f403 7320 	and.w	r3, r3, #640	; 0x280
 c00e4ac:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 c00e4b0:	d003      	beq.n	c00e4ba <__swsetup_r+0x9a>
 c00e4b2:	4621      	mov	r1, r4
 c00e4b4:	4630      	mov	r0, r6
 c00e4b6:	f000 f9bd 	bl	c00e834 <__smakebuf_r>
 c00e4ba:	89a2      	ldrh	r2, [r4, #12]
 c00e4bc:	f012 0301 	ands.w	r3, r2, #1
 c00e4c0:	d00c      	beq.n	c00e4dc <__swsetup_r+0xbc>
 c00e4c2:	2300      	movs	r3, #0
 c00e4c4:	60a3      	str	r3, [r4, #8]
 c00e4c6:	6963      	ldr	r3, [r4, #20]
 c00e4c8:	425b      	negs	r3, r3
 c00e4ca:	61a3      	str	r3, [r4, #24]
 c00e4cc:	6923      	ldr	r3, [r4, #16]
 c00e4ce:	b953      	cbnz	r3, c00e4e6 <__swsetup_r+0xc6>
 c00e4d0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c00e4d4:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 c00e4d8:	d1ba      	bne.n	c00e450 <__swsetup_r+0x30>
 c00e4da:	bd70      	pop	{r4, r5, r6, pc}
 c00e4dc:	0792      	lsls	r2, r2, #30
 c00e4de:	bf58      	it	pl
 c00e4e0:	6963      	ldrpl	r3, [r4, #20]
 c00e4e2:	60a3      	str	r3, [r4, #8]
 c00e4e4:	e7f2      	b.n	c00e4cc <__swsetup_r+0xac>
 c00e4e6:	2000      	movs	r0, #0
 c00e4e8:	e7f7      	b.n	c00e4da <__swsetup_r+0xba>
 c00e4ea:	bf00      	nop
 c00e4ec:	300300e8 	.word	0x300300e8
 c00e4f0:	0c010878 	.word	0x0c010878
 c00e4f4:	0c010898 	.word	0x0c010898
 c00e4f8:	0c010858 	.word	0x0c010858

0c00e4fc <__sflush_r>:
 c00e4fc:	898a      	ldrh	r2, [r1, #12]
 c00e4fe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00e502:	4605      	mov	r5, r0
 c00e504:	0710      	lsls	r0, r2, #28
 c00e506:	460c      	mov	r4, r1
 c00e508:	d458      	bmi.n	c00e5bc <__sflush_r+0xc0>
 c00e50a:	684b      	ldr	r3, [r1, #4]
 c00e50c:	2b00      	cmp	r3, #0
 c00e50e:	dc05      	bgt.n	c00e51c <__sflush_r+0x20>
 c00e510:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 c00e512:	2b00      	cmp	r3, #0
 c00e514:	dc02      	bgt.n	c00e51c <__sflush_r+0x20>
 c00e516:	2000      	movs	r0, #0
 c00e518:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 c00e51c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 c00e51e:	2e00      	cmp	r6, #0
 c00e520:	d0f9      	beq.n	c00e516 <__sflush_r+0x1a>
 c00e522:	2300      	movs	r3, #0
 c00e524:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 c00e528:	682f      	ldr	r7, [r5, #0]
 c00e52a:	6a21      	ldr	r1, [r4, #32]
 c00e52c:	602b      	str	r3, [r5, #0]
 c00e52e:	d032      	beq.n	c00e596 <__sflush_r+0x9a>
 c00e530:	6d60      	ldr	r0, [r4, #84]	; 0x54
 c00e532:	89a3      	ldrh	r3, [r4, #12]
 c00e534:	075a      	lsls	r2, r3, #29
 c00e536:	d505      	bpl.n	c00e544 <__sflush_r+0x48>
 c00e538:	6863      	ldr	r3, [r4, #4]
 c00e53a:	1ac0      	subs	r0, r0, r3
 c00e53c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 c00e53e:	b10b      	cbz	r3, c00e544 <__sflush_r+0x48>
 c00e540:	6c23      	ldr	r3, [r4, #64]	; 0x40
 c00e542:	1ac0      	subs	r0, r0, r3
 c00e544:	2300      	movs	r3, #0
 c00e546:	4602      	mov	r2, r0
 c00e548:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 c00e54a:	4628      	mov	r0, r5
 c00e54c:	6a21      	ldr	r1, [r4, #32]
 c00e54e:	47b0      	blx	r6
 c00e550:	1c43      	adds	r3, r0, #1
 c00e552:	89a3      	ldrh	r3, [r4, #12]
 c00e554:	d106      	bne.n	c00e564 <__sflush_r+0x68>
 c00e556:	6829      	ldr	r1, [r5, #0]
 c00e558:	291d      	cmp	r1, #29
 c00e55a:	d847      	bhi.n	c00e5ec <__sflush_r+0xf0>
 c00e55c:	4a28      	ldr	r2, [pc, #160]	; (c00e600 <__sflush_r+0x104>)
 c00e55e:	40ca      	lsrs	r2, r1
 c00e560:	07d6      	lsls	r6, r2, #31
 c00e562:	d543      	bpl.n	c00e5ec <__sflush_r+0xf0>
 c00e564:	2200      	movs	r2, #0
 c00e566:	04d9      	lsls	r1, r3, #19
 c00e568:	6062      	str	r2, [r4, #4]
 c00e56a:	6922      	ldr	r2, [r4, #16]
 c00e56c:	6022      	str	r2, [r4, #0]
 c00e56e:	d504      	bpl.n	c00e57a <__sflush_r+0x7e>
 c00e570:	1c42      	adds	r2, r0, #1
 c00e572:	d101      	bne.n	c00e578 <__sflush_r+0x7c>
 c00e574:	682b      	ldr	r3, [r5, #0]
 c00e576:	b903      	cbnz	r3, c00e57a <__sflush_r+0x7e>
 c00e578:	6560      	str	r0, [r4, #84]	; 0x54
 c00e57a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 c00e57c:	602f      	str	r7, [r5, #0]
 c00e57e:	2900      	cmp	r1, #0
 c00e580:	d0c9      	beq.n	c00e516 <__sflush_r+0x1a>
 c00e582:	f104 0344 	add.w	r3, r4, #68	; 0x44
 c00e586:	4299      	cmp	r1, r3
 c00e588:	d002      	beq.n	c00e590 <__sflush_r+0x94>
 c00e58a:	4628      	mov	r0, r5
 c00e58c:	f7ff fd86 	bl	c00e09c <_free_r>
 c00e590:	2000      	movs	r0, #0
 c00e592:	6360      	str	r0, [r4, #52]	; 0x34
 c00e594:	e7c0      	b.n	c00e518 <__sflush_r+0x1c>
 c00e596:	2301      	movs	r3, #1
 c00e598:	4628      	mov	r0, r5
 c00e59a:	47b0      	blx	r6
 c00e59c:	1c41      	adds	r1, r0, #1
 c00e59e:	d1c8      	bne.n	c00e532 <__sflush_r+0x36>
 c00e5a0:	682b      	ldr	r3, [r5, #0]
 c00e5a2:	2b00      	cmp	r3, #0
 c00e5a4:	d0c5      	beq.n	c00e532 <__sflush_r+0x36>
 c00e5a6:	2b1d      	cmp	r3, #29
 c00e5a8:	d001      	beq.n	c00e5ae <__sflush_r+0xb2>
 c00e5aa:	2b16      	cmp	r3, #22
 c00e5ac:	d101      	bne.n	c00e5b2 <__sflush_r+0xb6>
 c00e5ae:	602f      	str	r7, [r5, #0]
 c00e5b0:	e7b1      	b.n	c00e516 <__sflush_r+0x1a>
 c00e5b2:	89a3      	ldrh	r3, [r4, #12]
 c00e5b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c00e5b8:	81a3      	strh	r3, [r4, #12]
 c00e5ba:	e7ad      	b.n	c00e518 <__sflush_r+0x1c>
 c00e5bc:	690f      	ldr	r7, [r1, #16]
 c00e5be:	2f00      	cmp	r7, #0
 c00e5c0:	d0a9      	beq.n	c00e516 <__sflush_r+0x1a>
 c00e5c2:	0793      	lsls	r3, r2, #30
 c00e5c4:	680e      	ldr	r6, [r1, #0]
 c00e5c6:	600f      	str	r7, [r1, #0]
 c00e5c8:	bf0c      	ite	eq
 c00e5ca:	694b      	ldreq	r3, [r1, #20]
 c00e5cc:	2300      	movne	r3, #0
 c00e5ce:	eba6 0807 	sub.w	r8, r6, r7
 c00e5d2:	608b      	str	r3, [r1, #8]
 c00e5d4:	f1b8 0f00 	cmp.w	r8, #0
 c00e5d8:	dd9d      	ble.n	c00e516 <__sflush_r+0x1a>
 c00e5da:	4643      	mov	r3, r8
 c00e5dc:	463a      	mov	r2, r7
 c00e5de:	6a21      	ldr	r1, [r4, #32]
 c00e5e0:	4628      	mov	r0, r5
 c00e5e2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 c00e5e4:	47b0      	blx	r6
 c00e5e6:	2800      	cmp	r0, #0
 c00e5e8:	dc06      	bgt.n	c00e5f8 <__sflush_r+0xfc>
 c00e5ea:	89a3      	ldrh	r3, [r4, #12]
 c00e5ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c00e5f0:	f04f 30ff 	mov.w	r0, #4294967295
 c00e5f4:	81a3      	strh	r3, [r4, #12]
 c00e5f6:	e78f      	b.n	c00e518 <__sflush_r+0x1c>
 c00e5f8:	4407      	add	r7, r0
 c00e5fa:	eba8 0800 	sub.w	r8, r8, r0
 c00e5fe:	e7e9      	b.n	c00e5d4 <__sflush_r+0xd8>
 c00e600:	20400001 	.word	0x20400001

0c00e604 <_fflush_r>:
 c00e604:	b538      	push	{r3, r4, r5, lr}
 c00e606:	690b      	ldr	r3, [r1, #16]
 c00e608:	4605      	mov	r5, r0
 c00e60a:	460c      	mov	r4, r1
 c00e60c:	b1db      	cbz	r3, c00e646 <_fflush_r+0x42>
 c00e60e:	b118      	cbz	r0, c00e618 <_fflush_r+0x14>
 c00e610:	6983      	ldr	r3, [r0, #24]
 c00e612:	b90b      	cbnz	r3, c00e618 <_fflush_r+0x14>
 c00e614:	f000 f860 	bl	c00e6d8 <__sinit>
 c00e618:	4b0c      	ldr	r3, [pc, #48]	; (c00e64c <_fflush_r+0x48>)
 c00e61a:	429c      	cmp	r4, r3
 c00e61c:	d109      	bne.n	c00e632 <_fflush_r+0x2e>
 c00e61e:	686c      	ldr	r4, [r5, #4]
 c00e620:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c00e624:	b17b      	cbz	r3, c00e646 <_fflush_r+0x42>
 c00e626:	4621      	mov	r1, r4
 c00e628:	4628      	mov	r0, r5
 c00e62a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 c00e62e:	f7ff bf65 	b.w	c00e4fc <__sflush_r>
 c00e632:	4b07      	ldr	r3, [pc, #28]	; (c00e650 <_fflush_r+0x4c>)
 c00e634:	429c      	cmp	r4, r3
 c00e636:	d101      	bne.n	c00e63c <_fflush_r+0x38>
 c00e638:	68ac      	ldr	r4, [r5, #8]
 c00e63a:	e7f1      	b.n	c00e620 <_fflush_r+0x1c>
 c00e63c:	4b05      	ldr	r3, [pc, #20]	; (c00e654 <_fflush_r+0x50>)
 c00e63e:	429c      	cmp	r4, r3
 c00e640:	bf08      	it	eq
 c00e642:	68ec      	ldreq	r4, [r5, #12]
 c00e644:	e7ec      	b.n	c00e620 <_fflush_r+0x1c>
 c00e646:	2000      	movs	r0, #0
 c00e648:	bd38      	pop	{r3, r4, r5, pc}
 c00e64a:	bf00      	nop
 c00e64c:	0c010878 	.word	0x0c010878
 c00e650:	0c010898 	.word	0x0c010898
 c00e654:	0c010858 	.word	0x0c010858

0c00e658 <std>:
 c00e658:	2300      	movs	r3, #0
 c00e65a:	b510      	push	{r4, lr}
 c00e65c:	4604      	mov	r4, r0
 c00e65e:	6083      	str	r3, [r0, #8]
 c00e660:	8181      	strh	r1, [r0, #12]
 c00e662:	4619      	mov	r1, r3
 c00e664:	6643      	str	r3, [r0, #100]	; 0x64
 c00e666:	81c2      	strh	r2, [r0, #14]
 c00e668:	2208      	movs	r2, #8
 c00e66a:	6183      	str	r3, [r0, #24]
 c00e66c:	e9c0 3300 	strd	r3, r3, [r0]
 c00e670:	e9c0 3304 	strd	r3, r3, [r0, #16]
 c00e674:	305c      	adds	r0, #92	; 0x5c
 c00e676:	f7ff fd08 	bl	c00e08a <memset>
 c00e67a:	4b05      	ldr	r3, [pc, #20]	; (c00e690 <std+0x38>)
 c00e67c:	6224      	str	r4, [r4, #32]
 c00e67e:	6263      	str	r3, [r4, #36]	; 0x24
 c00e680:	4b04      	ldr	r3, [pc, #16]	; (c00e694 <std+0x3c>)
 c00e682:	62a3      	str	r3, [r4, #40]	; 0x28
 c00e684:	4b04      	ldr	r3, [pc, #16]	; (c00e698 <std+0x40>)
 c00e686:	62e3      	str	r3, [r4, #44]	; 0x2c
 c00e688:	4b04      	ldr	r3, [pc, #16]	; (c00e69c <std+0x44>)
 c00e68a:	6323      	str	r3, [r4, #48]	; 0x30
 c00e68c:	bd10      	pop	{r4, pc}
 c00e68e:	bf00      	nop
 c00e690:	0c00f0f1 	.word	0x0c00f0f1
 c00e694:	0c00f113 	.word	0x0c00f113
 c00e698:	0c00f14b 	.word	0x0c00f14b
 c00e69c:	0c00f16f 	.word	0x0c00f16f

0c00e6a0 <_cleanup_r>:
 c00e6a0:	4901      	ldr	r1, [pc, #4]	; (c00e6a8 <_cleanup_r+0x8>)
 c00e6a2:	f000 b885 	b.w	c00e7b0 <_fwalk_reent>
 c00e6a6:	bf00      	nop
 c00e6a8:	0c00e605 	.word	0x0c00e605

0c00e6ac <__sfmoreglue>:
 c00e6ac:	b570      	push	{r4, r5, r6, lr}
 c00e6ae:	1e4a      	subs	r2, r1, #1
 c00e6b0:	2568      	movs	r5, #104	; 0x68
 c00e6b2:	460e      	mov	r6, r1
 c00e6b4:	4355      	muls	r5, r2
 c00e6b6:	f105 0174 	add.w	r1, r5, #116	; 0x74
 c00e6ba:	f7ff fd3d 	bl	c00e138 <_malloc_r>
 c00e6be:	4604      	mov	r4, r0
 c00e6c0:	b140      	cbz	r0, c00e6d4 <__sfmoreglue+0x28>
 c00e6c2:	2100      	movs	r1, #0
 c00e6c4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 c00e6c8:	e9c0 1600 	strd	r1, r6, [r0]
 c00e6cc:	300c      	adds	r0, #12
 c00e6ce:	60a0      	str	r0, [r4, #8]
 c00e6d0:	f7ff fcdb 	bl	c00e08a <memset>
 c00e6d4:	4620      	mov	r0, r4
 c00e6d6:	bd70      	pop	{r4, r5, r6, pc}

0c00e6d8 <__sinit>:
 c00e6d8:	6983      	ldr	r3, [r0, #24]
 c00e6da:	b510      	push	{r4, lr}
 c00e6dc:	4604      	mov	r4, r0
 c00e6de:	bb33      	cbnz	r3, c00e72e <__sinit+0x56>
 c00e6e0:	6503      	str	r3, [r0, #80]	; 0x50
 c00e6e2:	4a13      	ldr	r2, [pc, #76]	; (c00e730 <__sinit+0x58>)
 c00e6e4:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 c00e6e8:	4b12      	ldr	r3, [pc, #72]	; (c00e734 <__sinit+0x5c>)
 c00e6ea:	6282      	str	r2, [r0, #40]	; 0x28
 c00e6ec:	681b      	ldr	r3, [r3, #0]
 c00e6ee:	4298      	cmp	r0, r3
 c00e6f0:	bf04      	itt	eq
 c00e6f2:	2301      	moveq	r3, #1
 c00e6f4:	6183      	streq	r3, [r0, #24]
 c00e6f6:	f000 f81f 	bl	c00e738 <__sfp>
 c00e6fa:	6060      	str	r0, [r4, #4]
 c00e6fc:	4620      	mov	r0, r4
 c00e6fe:	f000 f81b 	bl	c00e738 <__sfp>
 c00e702:	60a0      	str	r0, [r4, #8]
 c00e704:	4620      	mov	r0, r4
 c00e706:	f000 f817 	bl	c00e738 <__sfp>
 c00e70a:	2200      	movs	r2, #0
 c00e70c:	60e0      	str	r0, [r4, #12]
 c00e70e:	2104      	movs	r1, #4
 c00e710:	6860      	ldr	r0, [r4, #4]
 c00e712:	f7ff ffa1 	bl	c00e658 <std>
 c00e716:	2201      	movs	r2, #1
 c00e718:	2109      	movs	r1, #9
 c00e71a:	68a0      	ldr	r0, [r4, #8]
 c00e71c:	f7ff ff9c 	bl	c00e658 <std>
 c00e720:	2202      	movs	r2, #2
 c00e722:	2112      	movs	r1, #18
 c00e724:	68e0      	ldr	r0, [r4, #12]
 c00e726:	f7ff ff97 	bl	c00e658 <std>
 c00e72a:	2301      	movs	r3, #1
 c00e72c:	61a3      	str	r3, [r4, #24]
 c00e72e:	bd10      	pop	{r4, pc}
 c00e730:	0c00e6a1 	.word	0x0c00e6a1
 c00e734:	0c010854 	.word	0x0c010854

0c00e738 <__sfp>:
 c00e738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00e73a:	4b1b      	ldr	r3, [pc, #108]	; (c00e7a8 <__sfp+0x70>)
 c00e73c:	4607      	mov	r7, r0
 c00e73e:	681e      	ldr	r6, [r3, #0]
 c00e740:	69b3      	ldr	r3, [r6, #24]
 c00e742:	b913      	cbnz	r3, c00e74a <__sfp+0x12>
 c00e744:	4630      	mov	r0, r6
 c00e746:	f7ff ffc7 	bl	c00e6d8 <__sinit>
 c00e74a:	3648      	adds	r6, #72	; 0x48
 c00e74c:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 c00e750:	3b01      	subs	r3, #1
 c00e752:	d503      	bpl.n	c00e75c <__sfp+0x24>
 c00e754:	6833      	ldr	r3, [r6, #0]
 c00e756:	b133      	cbz	r3, c00e766 <__sfp+0x2e>
 c00e758:	6836      	ldr	r6, [r6, #0]
 c00e75a:	e7f7      	b.n	c00e74c <__sfp+0x14>
 c00e75c:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 c00e760:	b16d      	cbz	r5, c00e77e <__sfp+0x46>
 c00e762:	3468      	adds	r4, #104	; 0x68
 c00e764:	e7f4      	b.n	c00e750 <__sfp+0x18>
 c00e766:	2104      	movs	r1, #4
 c00e768:	4638      	mov	r0, r7
 c00e76a:	f7ff ff9f 	bl	c00e6ac <__sfmoreglue>
 c00e76e:	6030      	str	r0, [r6, #0]
 c00e770:	2800      	cmp	r0, #0
 c00e772:	d1f1      	bne.n	c00e758 <__sfp+0x20>
 c00e774:	230c      	movs	r3, #12
 c00e776:	4604      	mov	r4, r0
 c00e778:	603b      	str	r3, [r7, #0]
 c00e77a:	4620      	mov	r0, r4
 c00e77c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c00e77e:	4b0b      	ldr	r3, [pc, #44]	; (c00e7ac <__sfp+0x74>)
 c00e780:	2208      	movs	r2, #8
 c00e782:	6665      	str	r5, [r4, #100]	; 0x64
 c00e784:	4629      	mov	r1, r5
 c00e786:	60a5      	str	r5, [r4, #8]
 c00e788:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 c00e78c:	e9c4 5500 	strd	r5, r5, [r4]
 c00e790:	e9c4 3503 	strd	r3, r5, [r4, #12]
 c00e794:	e9c4 5505 	strd	r5, r5, [r4, #20]
 c00e798:	f7ff fc77 	bl	c00e08a <memset>
 c00e79c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 c00e7a0:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 c00e7a4:	e7e9      	b.n	c00e77a <__sfp+0x42>
 c00e7a6:	bf00      	nop
 c00e7a8:	0c010854 	.word	0x0c010854
 c00e7ac:	ffff0001 	.word	0xffff0001

0c00e7b0 <_fwalk_reent>:
 c00e7b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 c00e7b4:	4680      	mov	r8, r0
 c00e7b6:	4689      	mov	r9, r1
 c00e7b8:	f100 0448 	add.w	r4, r0, #72	; 0x48
 c00e7bc:	2600      	movs	r6, #0
 c00e7be:	b914      	cbnz	r4, c00e7c6 <_fwalk_reent+0x16>
 c00e7c0:	4630      	mov	r0, r6
 c00e7c2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 c00e7c6:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 c00e7ca:	3f01      	subs	r7, #1
 c00e7cc:	d501      	bpl.n	c00e7d2 <_fwalk_reent+0x22>
 c00e7ce:	6824      	ldr	r4, [r4, #0]
 c00e7d0:	e7f5      	b.n	c00e7be <_fwalk_reent+0xe>
 c00e7d2:	89ab      	ldrh	r3, [r5, #12]
 c00e7d4:	2b01      	cmp	r3, #1
 c00e7d6:	d907      	bls.n	c00e7e8 <_fwalk_reent+0x38>
 c00e7d8:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 c00e7dc:	3301      	adds	r3, #1
 c00e7de:	d003      	beq.n	c00e7e8 <_fwalk_reent+0x38>
 c00e7e0:	4629      	mov	r1, r5
 c00e7e2:	4640      	mov	r0, r8
 c00e7e4:	47c8      	blx	r9
 c00e7e6:	4306      	orrs	r6, r0
 c00e7e8:	3568      	adds	r5, #104	; 0x68
 c00e7ea:	e7ee      	b.n	c00e7ca <_fwalk_reent+0x1a>

0c00e7ec <__swhatbuf_r>:
 c00e7ec:	b570      	push	{r4, r5, r6, lr}
 c00e7ee:	460e      	mov	r6, r1
 c00e7f0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00e7f4:	b096      	sub	sp, #88	; 0x58
 c00e7f6:	4614      	mov	r4, r2
 c00e7f8:	2900      	cmp	r1, #0
 c00e7fa:	461d      	mov	r5, r3
 c00e7fc:	da07      	bge.n	c00e80e <__swhatbuf_r+0x22>
 c00e7fe:	2300      	movs	r3, #0
 c00e800:	602b      	str	r3, [r5, #0]
 c00e802:	89b3      	ldrh	r3, [r6, #12]
 c00e804:	061a      	lsls	r2, r3, #24
 c00e806:	d410      	bmi.n	c00e82a <__swhatbuf_r+0x3e>
 c00e808:	f44f 6380 	mov.w	r3, #1024	; 0x400
 c00e80c:	e00e      	b.n	c00e82c <__swhatbuf_r+0x40>
 c00e80e:	466a      	mov	r2, sp
 c00e810:	f000 fcd4 	bl	c00f1bc <_fstat_r>
 c00e814:	2800      	cmp	r0, #0
 c00e816:	dbf2      	blt.n	c00e7fe <__swhatbuf_r+0x12>
 c00e818:	9a01      	ldr	r2, [sp, #4]
 c00e81a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 c00e81e:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 c00e822:	425a      	negs	r2, r3
 c00e824:	415a      	adcs	r2, r3
 c00e826:	602a      	str	r2, [r5, #0]
 c00e828:	e7ee      	b.n	c00e808 <__swhatbuf_r+0x1c>
 c00e82a:	2340      	movs	r3, #64	; 0x40
 c00e82c:	2000      	movs	r0, #0
 c00e82e:	6023      	str	r3, [r4, #0]
 c00e830:	b016      	add	sp, #88	; 0x58
 c00e832:	bd70      	pop	{r4, r5, r6, pc}

0c00e834 <__smakebuf_r>:
 c00e834:	898b      	ldrh	r3, [r1, #12]
 c00e836:	b573      	push	{r0, r1, r4, r5, r6, lr}
 c00e838:	079d      	lsls	r5, r3, #30
 c00e83a:	4606      	mov	r6, r0
 c00e83c:	460c      	mov	r4, r1
 c00e83e:	d507      	bpl.n	c00e850 <__smakebuf_r+0x1c>
 c00e840:	f104 0347 	add.w	r3, r4, #71	; 0x47
 c00e844:	6023      	str	r3, [r4, #0]
 c00e846:	6123      	str	r3, [r4, #16]
 c00e848:	2301      	movs	r3, #1
 c00e84a:	6163      	str	r3, [r4, #20]
 c00e84c:	b002      	add	sp, #8
 c00e84e:	bd70      	pop	{r4, r5, r6, pc}
 c00e850:	ab01      	add	r3, sp, #4
 c00e852:	466a      	mov	r2, sp
 c00e854:	f7ff ffca 	bl	c00e7ec <__swhatbuf_r>
 c00e858:	9900      	ldr	r1, [sp, #0]
 c00e85a:	4605      	mov	r5, r0
 c00e85c:	4630      	mov	r0, r6
 c00e85e:	f7ff fc6b 	bl	c00e138 <_malloc_r>
 c00e862:	b948      	cbnz	r0, c00e878 <__smakebuf_r+0x44>
 c00e864:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 c00e868:	059a      	lsls	r2, r3, #22
 c00e86a:	d4ef      	bmi.n	c00e84c <__smakebuf_r+0x18>
 c00e86c:	f023 0303 	bic.w	r3, r3, #3
 c00e870:	f043 0302 	orr.w	r3, r3, #2
 c00e874:	81a3      	strh	r3, [r4, #12]
 c00e876:	e7e3      	b.n	c00e840 <__smakebuf_r+0xc>
 c00e878:	4b0d      	ldr	r3, [pc, #52]	; (c00e8b0 <__smakebuf_r+0x7c>)
 c00e87a:	62b3      	str	r3, [r6, #40]	; 0x28
 c00e87c:	89a3      	ldrh	r3, [r4, #12]
 c00e87e:	6020      	str	r0, [r4, #0]
 c00e880:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c00e884:	6120      	str	r0, [r4, #16]
 c00e886:	81a3      	strh	r3, [r4, #12]
 c00e888:	9b00      	ldr	r3, [sp, #0]
 c00e88a:	6163      	str	r3, [r4, #20]
 c00e88c:	9b01      	ldr	r3, [sp, #4]
 c00e88e:	b15b      	cbz	r3, c00e8a8 <__smakebuf_r+0x74>
 c00e890:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c00e894:	4630      	mov	r0, r6
 c00e896:	f000 fca3 	bl	c00f1e0 <_isatty_r>
 c00e89a:	b128      	cbz	r0, c00e8a8 <__smakebuf_r+0x74>
 c00e89c:	89a3      	ldrh	r3, [r4, #12]
 c00e89e:	f023 0303 	bic.w	r3, r3, #3
 c00e8a2:	f043 0301 	orr.w	r3, r3, #1
 c00e8a6:	81a3      	strh	r3, [r4, #12]
 c00e8a8:	89a3      	ldrh	r3, [r4, #12]
 c00e8aa:	431d      	orrs	r5, r3
 c00e8ac:	81a5      	strh	r5, [r4, #12]
 c00e8ae:	e7cd      	b.n	c00e84c <__smakebuf_r+0x18>
 c00e8b0:	0c00e6a1 	.word	0x0c00e6a1

0c00e8b4 <__malloc_lock>:
 c00e8b4:	4770      	bx	lr

0c00e8b6 <__malloc_unlock>:
 c00e8b6:	4770      	bx	lr

0c00e8b8 <__ssputs_r>:
 c00e8b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c00e8bc:	688e      	ldr	r6, [r1, #8]
 c00e8be:	4682      	mov	sl, r0
 c00e8c0:	460c      	mov	r4, r1
 c00e8c2:	4690      	mov	r8, r2
 c00e8c4:	429e      	cmp	r6, r3
 c00e8c6:	4699      	mov	r9, r3
 c00e8c8:	d837      	bhi.n	c00e93a <__ssputs_r+0x82>
 c00e8ca:	898a      	ldrh	r2, [r1, #12]
 c00e8cc:	f412 6f90 	tst.w	r2, #1152	; 0x480
 c00e8d0:	d031      	beq.n	c00e936 <__ssputs_r+0x7e>
 c00e8d2:	6825      	ldr	r5, [r4, #0]
 c00e8d4:	2302      	movs	r3, #2
 c00e8d6:	6909      	ldr	r1, [r1, #16]
 c00e8d8:	1a6f      	subs	r7, r5, r1
 c00e8da:	6965      	ldr	r5, [r4, #20]
 c00e8dc:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 c00e8e0:	fb95 f5f3 	sdiv	r5, r5, r3
 c00e8e4:	f109 0301 	add.w	r3, r9, #1
 c00e8e8:	443b      	add	r3, r7
 c00e8ea:	429d      	cmp	r5, r3
 c00e8ec:	bf38      	it	cc
 c00e8ee:	461d      	movcc	r5, r3
 c00e8f0:	0553      	lsls	r3, r2, #21
 c00e8f2:	d530      	bpl.n	c00e956 <__ssputs_r+0x9e>
 c00e8f4:	4629      	mov	r1, r5
 c00e8f6:	f7ff fc1f 	bl	c00e138 <_malloc_r>
 c00e8fa:	4606      	mov	r6, r0
 c00e8fc:	b950      	cbnz	r0, c00e914 <__ssputs_r+0x5c>
 c00e8fe:	230c      	movs	r3, #12
 c00e900:	f04f 30ff 	mov.w	r0, #4294967295
 c00e904:	f8ca 3000 	str.w	r3, [sl]
 c00e908:	89a3      	ldrh	r3, [r4, #12]
 c00e90a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 c00e90e:	81a3      	strh	r3, [r4, #12]
 c00e910:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00e914:	463a      	mov	r2, r7
 c00e916:	6921      	ldr	r1, [r4, #16]
 c00e918:	f7ff fb93 	bl	c00e042 <memcpy>
 c00e91c:	89a3      	ldrh	r3, [r4, #12]
 c00e91e:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 c00e922:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 c00e926:	81a3      	strh	r3, [r4, #12]
 c00e928:	6126      	str	r6, [r4, #16]
 c00e92a:	443e      	add	r6, r7
 c00e92c:	6165      	str	r5, [r4, #20]
 c00e92e:	1bed      	subs	r5, r5, r7
 c00e930:	6026      	str	r6, [r4, #0]
 c00e932:	464e      	mov	r6, r9
 c00e934:	60a5      	str	r5, [r4, #8]
 c00e936:	454e      	cmp	r6, r9
 c00e938:	d900      	bls.n	c00e93c <__ssputs_r+0x84>
 c00e93a:	464e      	mov	r6, r9
 c00e93c:	4632      	mov	r2, r6
 c00e93e:	4641      	mov	r1, r8
 c00e940:	6820      	ldr	r0, [r4, #0]
 c00e942:	f7ff fb89 	bl	c00e058 <memmove>
 c00e946:	68a3      	ldr	r3, [r4, #8]
 c00e948:	2000      	movs	r0, #0
 c00e94a:	1b9b      	subs	r3, r3, r6
 c00e94c:	60a3      	str	r3, [r4, #8]
 c00e94e:	6823      	ldr	r3, [r4, #0]
 c00e950:	441e      	add	r6, r3
 c00e952:	6026      	str	r6, [r4, #0]
 c00e954:	e7dc      	b.n	c00e910 <__ssputs_r+0x58>
 c00e956:	462a      	mov	r2, r5
 c00e958:	f000 fc72 	bl	c00f240 <_realloc_r>
 c00e95c:	4606      	mov	r6, r0
 c00e95e:	2800      	cmp	r0, #0
 c00e960:	d1e2      	bne.n	c00e928 <__ssputs_r+0x70>
 c00e962:	6921      	ldr	r1, [r4, #16]
 c00e964:	4650      	mov	r0, sl
 c00e966:	f7ff fb99 	bl	c00e09c <_free_r>
 c00e96a:	e7c8      	b.n	c00e8fe <__ssputs_r+0x46>

0c00e96c <_svfiprintf_r>:
 c00e96c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00e970:	461d      	mov	r5, r3
 c00e972:	898b      	ldrh	r3, [r1, #12]
 c00e974:	b09d      	sub	sp, #116	; 0x74
 c00e976:	4680      	mov	r8, r0
 c00e978:	061f      	lsls	r7, r3, #24
 c00e97a:	460c      	mov	r4, r1
 c00e97c:	4616      	mov	r6, r2
 c00e97e:	d50f      	bpl.n	c00e9a0 <_svfiprintf_r+0x34>
 c00e980:	690b      	ldr	r3, [r1, #16]
 c00e982:	b96b      	cbnz	r3, c00e9a0 <_svfiprintf_r+0x34>
 c00e984:	2140      	movs	r1, #64	; 0x40
 c00e986:	f7ff fbd7 	bl	c00e138 <_malloc_r>
 c00e98a:	6020      	str	r0, [r4, #0]
 c00e98c:	6120      	str	r0, [r4, #16]
 c00e98e:	b928      	cbnz	r0, c00e99c <_svfiprintf_r+0x30>
 c00e990:	230c      	movs	r3, #12
 c00e992:	f8c8 3000 	str.w	r3, [r8]
 c00e996:	f04f 30ff 	mov.w	r0, #4294967295
 c00e99a:	e0c8      	b.n	c00eb2e <_svfiprintf_r+0x1c2>
 c00e99c:	2340      	movs	r3, #64	; 0x40
 c00e99e:	6163      	str	r3, [r4, #20]
 c00e9a0:	2300      	movs	r3, #0
 c00e9a2:	f04f 0b01 	mov.w	fp, #1
 c00e9a6:	9503      	str	r5, [sp, #12]
 c00e9a8:	9309      	str	r3, [sp, #36]	; 0x24
 c00e9aa:	2320      	movs	r3, #32
 c00e9ac:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 c00e9b0:	2330      	movs	r3, #48	; 0x30
 c00e9b2:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 c00e9b6:	4637      	mov	r7, r6
 c00e9b8:	463d      	mov	r5, r7
 c00e9ba:	f815 3b01 	ldrb.w	r3, [r5], #1
 c00e9be:	b10b      	cbz	r3, c00e9c4 <_svfiprintf_r+0x58>
 c00e9c0:	2b25      	cmp	r3, #37	; 0x25
 c00e9c2:	d13e      	bne.n	c00ea42 <_svfiprintf_r+0xd6>
 c00e9c4:	ebb7 0a06 	subs.w	sl, r7, r6
 c00e9c8:	d00b      	beq.n	c00e9e2 <_svfiprintf_r+0x76>
 c00e9ca:	4653      	mov	r3, sl
 c00e9cc:	4632      	mov	r2, r6
 c00e9ce:	4621      	mov	r1, r4
 c00e9d0:	4640      	mov	r0, r8
 c00e9d2:	f7ff ff71 	bl	c00e8b8 <__ssputs_r>
 c00e9d6:	3001      	adds	r0, #1
 c00e9d8:	f000 80a4 	beq.w	c00eb24 <_svfiprintf_r+0x1b8>
 c00e9dc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00e9de:	4453      	add	r3, sl
 c00e9e0:	9309      	str	r3, [sp, #36]	; 0x24
 c00e9e2:	783b      	ldrb	r3, [r7, #0]
 c00e9e4:	2b00      	cmp	r3, #0
 c00e9e6:	f000 809d 	beq.w	c00eb24 <_svfiprintf_r+0x1b8>
 c00e9ea:	2300      	movs	r3, #0
 c00e9ec:	f04f 32ff 	mov.w	r2, #4294967295
 c00e9f0:	9304      	str	r3, [sp, #16]
 c00e9f2:	9307      	str	r3, [sp, #28]
 c00e9f4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 c00e9f8:	931a      	str	r3, [sp, #104]	; 0x68
 c00e9fa:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c00e9fe:	462f      	mov	r7, r5
 c00ea00:	2205      	movs	r2, #5
 c00ea02:	4851      	ldr	r0, [pc, #324]	; (c00eb48 <_svfiprintf_r+0x1dc>)
 c00ea04:	f817 1b01 	ldrb.w	r1, [r7], #1
 c00ea08:	f000 fc0c 	bl	c00f224 <memchr>
 c00ea0c:	9b04      	ldr	r3, [sp, #16]
 c00ea0e:	b9d0      	cbnz	r0, c00ea46 <_svfiprintf_r+0xda>
 c00ea10:	06d9      	lsls	r1, r3, #27
 c00ea12:	bf44      	itt	mi
 c00ea14:	2220      	movmi	r2, #32
 c00ea16:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c00ea1a:	071a      	lsls	r2, r3, #28
 c00ea1c:	bf44      	itt	mi
 c00ea1e:	222b      	movmi	r2, #43	; 0x2b
 c00ea20:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c00ea24:	782a      	ldrb	r2, [r5, #0]
 c00ea26:	2a2a      	cmp	r2, #42	; 0x2a
 c00ea28:	d015      	beq.n	c00ea56 <_svfiprintf_r+0xea>
 c00ea2a:	462f      	mov	r7, r5
 c00ea2c:	9a07      	ldr	r2, [sp, #28]
 c00ea2e:	2000      	movs	r0, #0
 c00ea30:	250a      	movs	r5, #10
 c00ea32:	4639      	mov	r1, r7
 c00ea34:	f811 3b01 	ldrb.w	r3, [r1], #1
 c00ea38:	3b30      	subs	r3, #48	; 0x30
 c00ea3a:	2b09      	cmp	r3, #9
 c00ea3c:	d94d      	bls.n	c00eada <_svfiprintf_r+0x16e>
 c00ea3e:	b1b8      	cbz	r0, c00ea70 <_svfiprintf_r+0x104>
 c00ea40:	e00f      	b.n	c00ea62 <_svfiprintf_r+0xf6>
 c00ea42:	462f      	mov	r7, r5
 c00ea44:	e7b8      	b.n	c00e9b8 <_svfiprintf_r+0x4c>
 c00ea46:	4a40      	ldr	r2, [pc, #256]	; (c00eb48 <_svfiprintf_r+0x1dc>)
 c00ea48:	463d      	mov	r5, r7
 c00ea4a:	1a80      	subs	r0, r0, r2
 c00ea4c:	fa0b f000 	lsl.w	r0, fp, r0
 c00ea50:	4318      	orrs	r0, r3
 c00ea52:	9004      	str	r0, [sp, #16]
 c00ea54:	e7d3      	b.n	c00e9fe <_svfiprintf_r+0x92>
 c00ea56:	9a03      	ldr	r2, [sp, #12]
 c00ea58:	1d11      	adds	r1, r2, #4
 c00ea5a:	6812      	ldr	r2, [r2, #0]
 c00ea5c:	2a00      	cmp	r2, #0
 c00ea5e:	9103      	str	r1, [sp, #12]
 c00ea60:	db01      	blt.n	c00ea66 <_svfiprintf_r+0xfa>
 c00ea62:	9207      	str	r2, [sp, #28]
 c00ea64:	e004      	b.n	c00ea70 <_svfiprintf_r+0x104>
 c00ea66:	4252      	negs	r2, r2
 c00ea68:	f043 0302 	orr.w	r3, r3, #2
 c00ea6c:	9207      	str	r2, [sp, #28]
 c00ea6e:	9304      	str	r3, [sp, #16]
 c00ea70:	783b      	ldrb	r3, [r7, #0]
 c00ea72:	2b2e      	cmp	r3, #46	; 0x2e
 c00ea74:	d10c      	bne.n	c00ea90 <_svfiprintf_r+0x124>
 c00ea76:	787b      	ldrb	r3, [r7, #1]
 c00ea78:	2b2a      	cmp	r3, #42	; 0x2a
 c00ea7a:	d133      	bne.n	c00eae4 <_svfiprintf_r+0x178>
 c00ea7c:	9b03      	ldr	r3, [sp, #12]
 c00ea7e:	3702      	adds	r7, #2
 c00ea80:	1d1a      	adds	r2, r3, #4
 c00ea82:	681b      	ldr	r3, [r3, #0]
 c00ea84:	2b00      	cmp	r3, #0
 c00ea86:	9203      	str	r2, [sp, #12]
 c00ea88:	bfb8      	it	lt
 c00ea8a:	f04f 33ff 	movlt.w	r3, #4294967295
 c00ea8e:	9305      	str	r3, [sp, #20]
 c00ea90:	4d2e      	ldr	r5, [pc, #184]	; (c00eb4c <_svfiprintf_r+0x1e0>)
 c00ea92:	2203      	movs	r2, #3
 c00ea94:	7839      	ldrb	r1, [r7, #0]
 c00ea96:	4628      	mov	r0, r5
 c00ea98:	f000 fbc4 	bl	c00f224 <memchr>
 c00ea9c:	b138      	cbz	r0, c00eaae <_svfiprintf_r+0x142>
 c00ea9e:	2340      	movs	r3, #64	; 0x40
 c00eaa0:	1b40      	subs	r0, r0, r5
 c00eaa2:	3701      	adds	r7, #1
 c00eaa4:	fa03 f000 	lsl.w	r0, r3, r0
 c00eaa8:	9b04      	ldr	r3, [sp, #16]
 c00eaaa:	4303      	orrs	r3, r0
 c00eaac:	9304      	str	r3, [sp, #16]
 c00eaae:	7839      	ldrb	r1, [r7, #0]
 c00eab0:	2206      	movs	r2, #6
 c00eab2:	4827      	ldr	r0, [pc, #156]	; (c00eb50 <_svfiprintf_r+0x1e4>)
 c00eab4:	1c7e      	adds	r6, r7, #1
 c00eab6:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 c00eaba:	f000 fbb3 	bl	c00f224 <memchr>
 c00eabe:	2800      	cmp	r0, #0
 c00eac0:	d038      	beq.n	c00eb34 <_svfiprintf_r+0x1c8>
 c00eac2:	4b24      	ldr	r3, [pc, #144]	; (c00eb54 <_svfiprintf_r+0x1e8>)
 c00eac4:	bb13      	cbnz	r3, c00eb0c <_svfiprintf_r+0x1a0>
 c00eac6:	9b03      	ldr	r3, [sp, #12]
 c00eac8:	3307      	adds	r3, #7
 c00eaca:	f023 0307 	bic.w	r3, r3, #7
 c00eace:	3308      	adds	r3, #8
 c00ead0:	9303      	str	r3, [sp, #12]
 c00ead2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00ead4:	444b      	add	r3, r9
 c00ead6:	9309      	str	r3, [sp, #36]	; 0x24
 c00ead8:	e76d      	b.n	c00e9b6 <_svfiprintf_r+0x4a>
 c00eada:	fb05 3202 	mla	r2, r5, r2, r3
 c00eade:	2001      	movs	r0, #1
 c00eae0:	460f      	mov	r7, r1
 c00eae2:	e7a6      	b.n	c00ea32 <_svfiprintf_r+0xc6>
 c00eae4:	2300      	movs	r3, #0
 c00eae6:	3701      	adds	r7, #1
 c00eae8:	250a      	movs	r5, #10
 c00eaea:	4619      	mov	r1, r3
 c00eaec:	9305      	str	r3, [sp, #20]
 c00eaee:	4638      	mov	r0, r7
 c00eaf0:	f810 2b01 	ldrb.w	r2, [r0], #1
 c00eaf4:	3a30      	subs	r2, #48	; 0x30
 c00eaf6:	2a09      	cmp	r2, #9
 c00eaf8:	d903      	bls.n	c00eb02 <_svfiprintf_r+0x196>
 c00eafa:	2b00      	cmp	r3, #0
 c00eafc:	d0c8      	beq.n	c00ea90 <_svfiprintf_r+0x124>
 c00eafe:	9105      	str	r1, [sp, #20]
 c00eb00:	e7c6      	b.n	c00ea90 <_svfiprintf_r+0x124>
 c00eb02:	fb05 2101 	mla	r1, r5, r1, r2
 c00eb06:	2301      	movs	r3, #1
 c00eb08:	4607      	mov	r7, r0
 c00eb0a:	e7f0      	b.n	c00eaee <_svfiprintf_r+0x182>
 c00eb0c:	ab03      	add	r3, sp, #12
 c00eb0e:	4622      	mov	r2, r4
 c00eb10:	a904      	add	r1, sp, #16
 c00eb12:	4640      	mov	r0, r8
 c00eb14:	9300      	str	r3, [sp, #0]
 c00eb16:	4b10      	ldr	r3, [pc, #64]	; (c00eb58 <_svfiprintf_r+0x1ec>)
 c00eb18:	e000      	b.n	c00eb1c <_svfiprintf_r+0x1b0>
 c00eb1a:	bf00      	nop
 c00eb1c:	f1b0 3fff 	cmp.w	r0, #4294967295
 c00eb20:	4681      	mov	r9, r0
 c00eb22:	d1d6      	bne.n	c00ead2 <_svfiprintf_r+0x166>
 c00eb24:	89a3      	ldrh	r3, [r4, #12]
 c00eb26:	065b      	lsls	r3, r3, #25
 c00eb28:	f53f af35 	bmi.w	c00e996 <_svfiprintf_r+0x2a>
 c00eb2c:	9809      	ldr	r0, [sp, #36]	; 0x24
 c00eb2e:	b01d      	add	sp, #116	; 0x74
 c00eb30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c00eb34:	ab03      	add	r3, sp, #12
 c00eb36:	4622      	mov	r2, r4
 c00eb38:	a904      	add	r1, sp, #16
 c00eb3a:	4640      	mov	r0, r8
 c00eb3c:	9300      	str	r3, [sp, #0]
 c00eb3e:	4b06      	ldr	r3, [pc, #24]	; (c00eb58 <_svfiprintf_r+0x1ec>)
 c00eb40:	f000 f9c4 	bl	c00eecc <_printf_i>
 c00eb44:	e7ea      	b.n	c00eb1c <_svfiprintf_r+0x1b0>
 c00eb46:	bf00      	nop
 c00eb48:	0c0108b8 	.word	0x0c0108b8
 c00eb4c:	0c0108be 	.word	0x0c0108be
 c00eb50:	0c0108c2 	.word	0x0c0108c2
 c00eb54:	00000000 	.word	0x00000000
 c00eb58:	0c00e8b9 	.word	0x0c00e8b9

0c00eb5c <__sfputc_r>:
 c00eb5c:	6893      	ldr	r3, [r2, #8]
 c00eb5e:	3b01      	subs	r3, #1
 c00eb60:	2b00      	cmp	r3, #0
 c00eb62:	6093      	str	r3, [r2, #8]
 c00eb64:	b410      	push	{r4}
 c00eb66:	da08      	bge.n	c00eb7a <__sfputc_r+0x1e>
 c00eb68:	6994      	ldr	r4, [r2, #24]
 c00eb6a:	42a3      	cmp	r3, r4
 c00eb6c:	db01      	blt.n	c00eb72 <__sfputc_r+0x16>
 c00eb6e:	290a      	cmp	r1, #10
 c00eb70:	d103      	bne.n	c00eb7a <__sfputc_r+0x1e>
 c00eb72:	f85d 4b04 	ldr.w	r4, [sp], #4
 c00eb76:	f7ff bc01 	b.w	c00e37c <__swbuf_r>
 c00eb7a:	6813      	ldr	r3, [r2, #0]
 c00eb7c:	1c58      	adds	r0, r3, #1
 c00eb7e:	6010      	str	r0, [r2, #0]
 c00eb80:	4608      	mov	r0, r1
 c00eb82:	7019      	strb	r1, [r3, #0]
 c00eb84:	f85d 4b04 	ldr.w	r4, [sp], #4
 c00eb88:	4770      	bx	lr

0c00eb8a <__sfputs_r>:
 c00eb8a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00eb8c:	4606      	mov	r6, r0
 c00eb8e:	460f      	mov	r7, r1
 c00eb90:	4614      	mov	r4, r2
 c00eb92:	18d5      	adds	r5, r2, r3
 c00eb94:	42ac      	cmp	r4, r5
 c00eb96:	d101      	bne.n	c00eb9c <__sfputs_r+0x12>
 c00eb98:	2000      	movs	r0, #0
 c00eb9a:	e007      	b.n	c00ebac <__sfputs_r+0x22>
 c00eb9c:	463a      	mov	r2, r7
 c00eb9e:	f814 1b01 	ldrb.w	r1, [r4], #1
 c00eba2:	4630      	mov	r0, r6
 c00eba4:	f7ff ffda 	bl	c00eb5c <__sfputc_r>
 c00eba8:	1c43      	adds	r3, r0, #1
 c00ebaa:	d1f3      	bne.n	c00eb94 <__sfputs_r+0xa>
 c00ebac:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0c00ebb0 <_vfiprintf_r>:
 c00ebb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 c00ebb4:	460c      	mov	r4, r1
 c00ebb6:	b09d      	sub	sp, #116	; 0x74
 c00ebb8:	4617      	mov	r7, r2
 c00ebba:	461d      	mov	r5, r3
 c00ebbc:	4606      	mov	r6, r0
 c00ebbe:	b118      	cbz	r0, c00ebc8 <_vfiprintf_r+0x18>
 c00ebc0:	6983      	ldr	r3, [r0, #24]
 c00ebc2:	b90b      	cbnz	r3, c00ebc8 <_vfiprintf_r+0x18>
 c00ebc4:	f7ff fd88 	bl	c00e6d8 <__sinit>
 c00ebc8:	4b7c      	ldr	r3, [pc, #496]	; (c00edbc <_vfiprintf_r+0x20c>)
 c00ebca:	429c      	cmp	r4, r3
 c00ebcc:	d158      	bne.n	c00ec80 <_vfiprintf_r+0xd0>
 c00ebce:	6874      	ldr	r4, [r6, #4]
 c00ebd0:	89a3      	ldrh	r3, [r4, #12]
 c00ebd2:	0718      	lsls	r0, r3, #28
 c00ebd4:	d55e      	bpl.n	c00ec94 <_vfiprintf_r+0xe4>
 c00ebd6:	6923      	ldr	r3, [r4, #16]
 c00ebd8:	2b00      	cmp	r3, #0
 c00ebda:	d05b      	beq.n	c00ec94 <_vfiprintf_r+0xe4>
 c00ebdc:	2300      	movs	r3, #0
 c00ebde:	f04f 0b01 	mov.w	fp, #1
 c00ebe2:	9503      	str	r5, [sp, #12]
 c00ebe4:	9309      	str	r3, [sp, #36]	; 0x24
 c00ebe6:	2320      	movs	r3, #32
 c00ebe8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 c00ebec:	2330      	movs	r3, #48	; 0x30
 c00ebee:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 c00ebf2:	46b8      	mov	r8, r7
 c00ebf4:	4645      	mov	r5, r8
 c00ebf6:	f815 3b01 	ldrb.w	r3, [r5], #1
 c00ebfa:	b10b      	cbz	r3, c00ec00 <_vfiprintf_r+0x50>
 c00ebfc:	2b25      	cmp	r3, #37	; 0x25
 c00ebfe:	d154      	bne.n	c00ecaa <_vfiprintf_r+0xfa>
 c00ec00:	ebb8 0a07 	subs.w	sl, r8, r7
 c00ec04:	d00b      	beq.n	c00ec1e <_vfiprintf_r+0x6e>
 c00ec06:	4653      	mov	r3, sl
 c00ec08:	463a      	mov	r2, r7
 c00ec0a:	4621      	mov	r1, r4
 c00ec0c:	4630      	mov	r0, r6
 c00ec0e:	f7ff ffbc 	bl	c00eb8a <__sfputs_r>
 c00ec12:	3001      	adds	r0, #1
 c00ec14:	f000 80c2 	beq.w	c00ed9c <_vfiprintf_r+0x1ec>
 c00ec18:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00ec1a:	4453      	add	r3, sl
 c00ec1c:	9309      	str	r3, [sp, #36]	; 0x24
 c00ec1e:	f898 3000 	ldrb.w	r3, [r8]
 c00ec22:	2b00      	cmp	r3, #0
 c00ec24:	f000 80ba 	beq.w	c00ed9c <_vfiprintf_r+0x1ec>
 c00ec28:	2300      	movs	r3, #0
 c00ec2a:	f04f 32ff 	mov.w	r2, #4294967295
 c00ec2e:	9304      	str	r3, [sp, #16]
 c00ec30:	9307      	str	r3, [sp, #28]
 c00ec32:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 c00ec36:	931a      	str	r3, [sp, #104]	; 0x68
 c00ec38:	e9cd 2305 	strd	r2, r3, [sp, #20]
 c00ec3c:	46a8      	mov	r8, r5
 c00ec3e:	2205      	movs	r2, #5
 c00ec40:	485f      	ldr	r0, [pc, #380]	; (c00edc0 <_vfiprintf_r+0x210>)
 c00ec42:	f818 1b01 	ldrb.w	r1, [r8], #1
 c00ec46:	f000 faed 	bl	c00f224 <memchr>
 c00ec4a:	9b04      	ldr	r3, [sp, #16]
 c00ec4c:	bb78      	cbnz	r0, c00ecae <_vfiprintf_r+0xfe>
 c00ec4e:	06d9      	lsls	r1, r3, #27
 c00ec50:	bf44      	itt	mi
 c00ec52:	2220      	movmi	r2, #32
 c00ec54:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c00ec58:	071a      	lsls	r2, r3, #28
 c00ec5a:	bf44      	itt	mi
 c00ec5c:	222b      	movmi	r2, #43	; 0x2b
 c00ec5e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 c00ec62:	782a      	ldrb	r2, [r5, #0]
 c00ec64:	2a2a      	cmp	r2, #42	; 0x2a
 c00ec66:	d02a      	beq.n	c00ecbe <_vfiprintf_r+0x10e>
 c00ec68:	46a8      	mov	r8, r5
 c00ec6a:	9a07      	ldr	r2, [sp, #28]
 c00ec6c:	2000      	movs	r0, #0
 c00ec6e:	250a      	movs	r5, #10
 c00ec70:	4641      	mov	r1, r8
 c00ec72:	f811 3b01 	ldrb.w	r3, [r1], #1
 c00ec76:	3b30      	subs	r3, #48	; 0x30
 c00ec78:	2b09      	cmp	r3, #9
 c00ec7a:	d969      	bls.n	c00ed50 <_vfiprintf_r+0x1a0>
 c00ec7c:	b360      	cbz	r0, c00ecd8 <_vfiprintf_r+0x128>
 c00ec7e:	e024      	b.n	c00ecca <_vfiprintf_r+0x11a>
 c00ec80:	4b50      	ldr	r3, [pc, #320]	; (c00edc4 <_vfiprintf_r+0x214>)
 c00ec82:	429c      	cmp	r4, r3
 c00ec84:	d101      	bne.n	c00ec8a <_vfiprintf_r+0xda>
 c00ec86:	68b4      	ldr	r4, [r6, #8]
 c00ec88:	e7a2      	b.n	c00ebd0 <_vfiprintf_r+0x20>
 c00ec8a:	4b4f      	ldr	r3, [pc, #316]	; (c00edc8 <_vfiprintf_r+0x218>)
 c00ec8c:	429c      	cmp	r4, r3
 c00ec8e:	bf08      	it	eq
 c00ec90:	68f4      	ldreq	r4, [r6, #12]
 c00ec92:	e79d      	b.n	c00ebd0 <_vfiprintf_r+0x20>
 c00ec94:	4621      	mov	r1, r4
 c00ec96:	4630      	mov	r0, r6
 c00ec98:	f7ff fbc2 	bl	c00e420 <__swsetup_r>
 c00ec9c:	2800      	cmp	r0, #0
 c00ec9e:	d09d      	beq.n	c00ebdc <_vfiprintf_r+0x2c>
 c00eca0:	f04f 30ff 	mov.w	r0, #4294967295
 c00eca4:	b01d      	add	sp, #116	; 0x74
 c00eca6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 c00ecaa:	46a8      	mov	r8, r5
 c00ecac:	e7a2      	b.n	c00ebf4 <_vfiprintf_r+0x44>
 c00ecae:	4a44      	ldr	r2, [pc, #272]	; (c00edc0 <_vfiprintf_r+0x210>)
 c00ecb0:	4645      	mov	r5, r8
 c00ecb2:	1a80      	subs	r0, r0, r2
 c00ecb4:	fa0b f000 	lsl.w	r0, fp, r0
 c00ecb8:	4318      	orrs	r0, r3
 c00ecba:	9004      	str	r0, [sp, #16]
 c00ecbc:	e7be      	b.n	c00ec3c <_vfiprintf_r+0x8c>
 c00ecbe:	9a03      	ldr	r2, [sp, #12]
 c00ecc0:	1d11      	adds	r1, r2, #4
 c00ecc2:	6812      	ldr	r2, [r2, #0]
 c00ecc4:	2a00      	cmp	r2, #0
 c00ecc6:	9103      	str	r1, [sp, #12]
 c00ecc8:	db01      	blt.n	c00ecce <_vfiprintf_r+0x11e>
 c00ecca:	9207      	str	r2, [sp, #28]
 c00eccc:	e004      	b.n	c00ecd8 <_vfiprintf_r+0x128>
 c00ecce:	4252      	negs	r2, r2
 c00ecd0:	f043 0302 	orr.w	r3, r3, #2
 c00ecd4:	9207      	str	r2, [sp, #28]
 c00ecd6:	9304      	str	r3, [sp, #16]
 c00ecd8:	f898 3000 	ldrb.w	r3, [r8]
 c00ecdc:	2b2e      	cmp	r3, #46	; 0x2e
 c00ecde:	d10e      	bne.n	c00ecfe <_vfiprintf_r+0x14e>
 c00ece0:	f898 3001 	ldrb.w	r3, [r8, #1]
 c00ece4:	2b2a      	cmp	r3, #42	; 0x2a
 c00ece6:	d138      	bne.n	c00ed5a <_vfiprintf_r+0x1aa>
 c00ece8:	9b03      	ldr	r3, [sp, #12]
 c00ecea:	f108 0802 	add.w	r8, r8, #2
 c00ecee:	1d1a      	adds	r2, r3, #4
 c00ecf0:	681b      	ldr	r3, [r3, #0]
 c00ecf2:	2b00      	cmp	r3, #0
 c00ecf4:	9203      	str	r2, [sp, #12]
 c00ecf6:	bfb8      	it	lt
 c00ecf8:	f04f 33ff 	movlt.w	r3, #4294967295
 c00ecfc:	9305      	str	r3, [sp, #20]
 c00ecfe:	4d33      	ldr	r5, [pc, #204]	; (c00edcc <_vfiprintf_r+0x21c>)
 c00ed00:	2203      	movs	r2, #3
 c00ed02:	f898 1000 	ldrb.w	r1, [r8]
 c00ed06:	4628      	mov	r0, r5
 c00ed08:	f000 fa8c 	bl	c00f224 <memchr>
 c00ed0c:	b140      	cbz	r0, c00ed20 <_vfiprintf_r+0x170>
 c00ed0e:	2340      	movs	r3, #64	; 0x40
 c00ed10:	1b40      	subs	r0, r0, r5
 c00ed12:	f108 0801 	add.w	r8, r8, #1
 c00ed16:	fa03 f000 	lsl.w	r0, r3, r0
 c00ed1a:	9b04      	ldr	r3, [sp, #16]
 c00ed1c:	4303      	orrs	r3, r0
 c00ed1e:	9304      	str	r3, [sp, #16]
 c00ed20:	f898 1000 	ldrb.w	r1, [r8]
 c00ed24:	2206      	movs	r2, #6
 c00ed26:	482a      	ldr	r0, [pc, #168]	; (c00edd0 <_vfiprintf_r+0x220>)
 c00ed28:	f108 0701 	add.w	r7, r8, #1
 c00ed2c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 c00ed30:	f000 fa78 	bl	c00f224 <memchr>
 c00ed34:	2800      	cmp	r0, #0
 c00ed36:	d037      	beq.n	c00eda8 <_vfiprintf_r+0x1f8>
 c00ed38:	4b26      	ldr	r3, [pc, #152]	; (c00edd4 <_vfiprintf_r+0x224>)
 c00ed3a:	bb1b      	cbnz	r3, c00ed84 <_vfiprintf_r+0x1d4>
 c00ed3c:	9b03      	ldr	r3, [sp, #12]
 c00ed3e:	3307      	adds	r3, #7
 c00ed40:	f023 0307 	bic.w	r3, r3, #7
 c00ed44:	3308      	adds	r3, #8
 c00ed46:	9303      	str	r3, [sp, #12]
 c00ed48:	9b09      	ldr	r3, [sp, #36]	; 0x24
 c00ed4a:	444b      	add	r3, r9
 c00ed4c:	9309      	str	r3, [sp, #36]	; 0x24
 c00ed4e:	e750      	b.n	c00ebf2 <_vfiprintf_r+0x42>
 c00ed50:	fb05 3202 	mla	r2, r5, r2, r3
 c00ed54:	2001      	movs	r0, #1
 c00ed56:	4688      	mov	r8, r1
 c00ed58:	e78a      	b.n	c00ec70 <_vfiprintf_r+0xc0>
 c00ed5a:	2300      	movs	r3, #0
 c00ed5c:	f108 0801 	add.w	r8, r8, #1
 c00ed60:	250a      	movs	r5, #10
 c00ed62:	4619      	mov	r1, r3
 c00ed64:	9305      	str	r3, [sp, #20]
 c00ed66:	4640      	mov	r0, r8
 c00ed68:	f810 2b01 	ldrb.w	r2, [r0], #1
 c00ed6c:	3a30      	subs	r2, #48	; 0x30
 c00ed6e:	2a09      	cmp	r2, #9
 c00ed70:	d903      	bls.n	c00ed7a <_vfiprintf_r+0x1ca>
 c00ed72:	2b00      	cmp	r3, #0
 c00ed74:	d0c3      	beq.n	c00ecfe <_vfiprintf_r+0x14e>
 c00ed76:	9105      	str	r1, [sp, #20]
 c00ed78:	e7c1      	b.n	c00ecfe <_vfiprintf_r+0x14e>
 c00ed7a:	fb05 2101 	mla	r1, r5, r1, r2
 c00ed7e:	2301      	movs	r3, #1
 c00ed80:	4680      	mov	r8, r0
 c00ed82:	e7f0      	b.n	c00ed66 <_vfiprintf_r+0x1b6>
 c00ed84:	ab03      	add	r3, sp, #12
 c00ed86:	4622      	mov	r2, r4
 c00ed88:	a904      	add	r1, sp, #16
 c00ed8a:	4630      	mov	r0, r6
 c00ed8c:	9300      	str	r3, [sp, #0]
 c00ed8e:	4b12      	ldr	r3, [pc, #72]	; (c00edd8 <_vfiprintf_r+0x228>)
 c00ed90:	e000      	b.n	c00ed94 <_vfiprintf_r+0x1e4>
 c00ed92:	bf00      	nop
 c00ed94:	f1b0 3fff 	cmp.w	r0, #4294967295
 c00ed98:	4681      	mov	r9, r0
 c00ed9a:	d1d5      	bne.n	c00ed48 <_vfiprintf_r+0x198>
 c00ed9c:	89a3      	ldrh	r3, [r4, #12]
 c00ed9e:	065b      	lsls	r3, r3, #25
 c00eda0:	f53f af7e 	bmi.w	c00eca0 <_vfiprintf_r+0xf0>
 c00eda4:	9809      	ldr	r0, [sp, #36]	; 0x24
 c00eda6:	e77d      	b.n	c00eca4 <_vfiprintf_r+0xf4>
 c00eda8:	ab03      	add	r3, sp, #12
 c00edaa:	4622      	mov	r2, r4
 c00edac:	a904      	add	r1, sp, #16
 c00edae:	4630      	mov	r0, r6
 c00edb0:	9300      	str	r3, [sp, #0]
 c00edb2:	4b09      	ldr	r3, [pc, #36]	; (c00edd8 <_vfiprintf_r+0x228>)
 c00edb4:	f000 f88a 	bl	c00eecc <_printf_i>
 c00edb8:	e7ec      	b.n	c00ed94 <_vfiprintf_r+0x1e4>
 c00edba:	bf00      	nop
 c00edbc:	0c010878 	.word	0x0c010878
 c00edc0:	0c0108b8 	.word	0x0c0108b8
 c00edc4:	0c010898 	.word	0x0c010898
 c00edc8:	0c010858 	.word	0x0c010858
 c00edcc:	0c0108be 	.word	0x0c0108be
 c00edd0:	0c0108c2 	.word	0x0c0108c2
 c00edd4:	00000000 	.word	0x00000000
 c00edd8:	0c00eb8b 	.word	0x0c00eb8b

0c00eddc <_printf_common>:
 c00eddc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c00ede0:	4691      	mov	r9, r2
 c00ede2:	461f      	mov	r7, r3
 c00ede4:	688a      	ldr	r2, [r1, #8]
 c00ede6:	4606      	mov	r6, r0
 c00ede8:	690b      	ldr	r3, [r1, #16]
 c00edea:	460c      	mov	r4, r1
 c00edec:	f8dd 8020 	ldr.w	r8, [sp, #32]
 c00edf0:	4293      	cmp	r3, r2
 c00edf2:	bfb8      	it	lt
 c00edf4:	4613      	movlt	r3, r2
 c00edf6:	f8c9 3000 	str.w	r3, [r9]
 c00edfa:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 c00edfe:	b112      	cbz	r2, c00ee06 <_printf_common+0x2a>
 c00ee00:	3301      	adds	r3, #1
 c00ee02:	f8c9 3000 	str.w	r3, [r9]
 c00ee06:	6823      	ldr	r3, [r4, #0]
 c00ee08:	0699      	lsls	r1, r3, #26
 c00ee0a:	bf42      	ittt	mi
 c00ee0c:	f8d9 3000 	ldrmi.w	r3, [r9]
 c00ee10:	3302      	addmi	r3, #2
 c00ee12:	f8c9 3000 	strmi.w	r3, [r9]
 c00ee16:	6825      	ldr	r5, [r4, #0]
 c00ee18:	f015 0506 	ands.w	r5, r5, #6
 c00ee1c:	d107      	bne.n	c00ee2e <_printf_common+0x52>
 c00ee1e:	f104 0a19 	add.w	sl, r4, #25
 c00ee22:	68e3      	ldr	r3, [r4, #12]
 c00ee24:	f8d9 2000 	ldr.w	r2, [r9]
 c00ee28:	1a9b      	subs	r3, r3, r2
 c00ee2a:	42ab      	cmp	r3, r5
 c00ee2c:	dc2b      	bgt.n	c00ee86 <_printf_common+0xaa>
 c00ee2e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 c00ee32:	6822      	ldr	r2, [r4, #0]
 c00ee34:	3300      	adds	r3, #0
 c00ee36:	bf18      	it	ne
 c00ee38:	2301      	movne	r3, #1
 c00ee3a:	0692      	lsls	r2, r2, #26
 c00ee3c:	d430      	bmi.n	c00eea0 <_printf_common+0xc4>
 c00ee3e:	f104 0243 	add.w	r2, r4, #67	; 0x43
 c00ee42:	4639      	mov	r1, r7
 c00ee44:	4630      	mov	r0, r6
 c00ee46:	47c0      	blx	r8
 c00ee48:	3001      	adds	r0, #1
 c00ee4a:	d023      	beq.n	c00ee94 <_printf_common+0xb8>
 c00ee4c:	6823      	ldr	r3, [r4, #0]
 c00ee4e:	341a      	adds	r4, #26
 c00ee50:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 c00ee54:	f003 0306 	and.w	r3, r3, #6
 c00ee58:	f8d9 2000 	ldr.w	r2, [r9]
 c00ee5c:	f04f 0900 	mov.w	r9, #0
 c00ee60:	2b04      	cmp	r3, #4
 c00ee62:	f854 3c12 	ldr.w	r3, [r4, #-18]
 c00ee66:	bf08      	it	eq
 c00ee68:	1aad      	subeq	r5, r5, r2
 c00ee6a:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 c00ee6e:	bf14      	ite	ne
 c00ee70:	2500      	movne	r5, #0
 c00ee72:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 c00ee76:	4293      	cmp	r3, r2
 c00ee78:	bfc4      	itt	gt
 c00ee7a:	1a9b      	subgt	r3, r3, r2
 c00ee7c:	18ed      	addgt	r5, r5, r3
 c00ee7e:	454d      	cmp	r5, r9
 c00ee80:	d11a      	bne.n	c00eeb8 <_printf_common+0xdc>
 c00ee82:	2000      	movs	r0, #0
 c00ee84:	e008      	b.n	c00ee98 <_printf_common+0xbc>
 c00ee86:	2301      	movs	r3, #1
 c00ee88:	4652      	mov	r2, sl
 c00ee8a:	4639      	mov	r1, r7
 c00ee8c:	4630      	mov	r0, r6
 c00ee8e:	47c0      	blx	r8
 c00ee90:	3001      	adds	r0, #1
 c00ee92:	d103      	bne.n	c00ee9c <_printf_common+0xc0>
 c00ee94:	f04f 30ff 	mov.w	r0, #4294967295
 c00ee98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00ee9c:	3501      	adds	r5, #1
 c00ee9e:	e7c0      	b.n	c00ee22 <_printf_common+0x46>
 c00eea0:	18e1      	adds	r1, r4, r3
 c00eea2:	1c5a      	adds	r2, r3, #1
 c00eea4:	2030      	movs	r0, #48	; 0x30
 c00eea6:	3302      	adds	r3, #2
 c00eea8:	4422      	add	r2, r4
 c00eeaa:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 c00eeae:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 c00eeb2:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 c00eeb6:	e7c2      	b.n	c00ee3e <_printf_common+0x62>
 c00eeb8:	2301      	movs	r3, #1
 c00eeba:	4622      	mov	r2, r4
 c00eebc:	4639      	mov	r1, r7
 c00eebe:	4630      	mov	r0, r6
 c00eec0:	47c0      	blx	r8
 c00eec2:	3001      	adds	r0, #1
 c00eec4:	d0e6      	beq.n	c00ee94 <_printf_common+0xb8>
 c00eec6:	f109 0901 	add.w	r9, r9, #1
 c00eeca:	e7d8      	b.n	c00ee7e <_printf_common+0xa2>

0c00eecc <_printf_i>:
 c00eecc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 c00eed0:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 c00eed4:	460c      	mov	r4, r1
 c00eed6:	7e09      	ldrb	r1, [r1, #24]
 c00eed8:	b085      	sub	sp, #20
 c00eeda:	4617      	mov	r7, r2
 c00eedc:	4606      	mov	r6, r0
 c00eede:	296e      	cmp	r1, #110	; 0x6e
 c00eee0:	4698      	mov	r8, r3
 c00eee2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 c00eee4:	f000 80b3 	beq.w	c00f04e <_printf_i+0x182>
 c00eee8:	d822      	bhi.n	c00ef30 <_printf_i+0x64>
 c00eeea:	2963      	cmp	r1, #99	; 0x63
 c00eeec:	d036      	beq.n	c00ef5c <_printf_i+0x90>
 c00eeee:	d80a      	bhi.n	c00ef06 <_printf_i+0x3a>
 c00eef0:	2900      	cmp	r1, #0
 c00eef2:	f000 80b9 	beq.w	c00f068 <_printf_i+0x19c>
 c00eef6:	2958      	cmp	r1, #88	; 0x58
 c00eef8:	f000 8083 	beq.w	c00f002 <_printf_i+0x136>
 c00eefc:	f104 0542 	add.w	r5, r4, #66	; 0x42
 c00ef00:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 c00ef04:	e032      	b.n	c00ef6c <_printf_i+0xa0>
 c00ef06:	2964      	cmp	r1, #100	; 0x64
 c00ef08:	d001      	beq.n	c00ef0e <_printf_i+0x42>
 c00ef0a:	2969      	cmp	r1, #105	; 0x69
 c00ef0c:	d1f6      	bne.n	c00eefc <_printf_i+0x30>
 c00ef0e:	6820      	ldr	r0, [r4, #0]
 c00ef10:	6813      	ldr	r3, [r2, #0]
 c00ef12:	0605      	lsls	r5, r0, #24
 c00ef14:	f103 0104 	add.w	r1, r3, #4
 c00ef18:	d52a      	bpl.n	c00ef70 <_printf_i+0xa4>
 c00ef1a:	681b      	ldr	r3, [r3, #0]
 c00ef1c:	6011      	str	r1, [r2, #0]
 c00ef1e:	2b00      	cmp	r3, #0
 c00ef20:	da03      	bge.n	c00ef2a <_printf_i+0x5e>
 c00ef22:	222d      	movs	r2, #45	; 0x2d
 c00ef24:	425b      	negs	r3, r3
 c00ef26:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 c00ef2a:	486f      	ldr	r0, [pc, #444]	; (c00f0e8 <_printf_i+0x21c>)
 c00ef2c:	220a      	movs	r2, #10
 c00ef2e:	e039      	b.n	c00efa4 <_printf_i+0xd8>
 c00ef30:	2973      	cmp	r1, #115	; 0x73
 c00ef32:	f000 809d 	beq.w	c00f070 <_printf_i+0x1a4>
 c00ef36:	d808      	bhi.n	c00ef4a <_printf_i+0x7e>
 c00ef38:	296f      	cmp	r1, #111	; 0x6f
 c00ef3a:	d020      	beq.n	c00ef7e <_printf_i+0xb2>
 c00ef3c:	2970      	cmp	r1, #112	; 0x70
 c00ef3e:	d1dd      	bne.n	c00eefc <_printf_i+0x30>
 c00ef40:	6823      	ldr	r3, [r4, #0]
 c00ef42:	f043 0320 	orr.w	r3, r3, #32
 c00ef46:	6023      	str	r3, [r4, #0]
 c00ef48:	e003      	b.n	c00ef52 <_printf_i+0x86>
 c00ef4a:	2975      	cmp	r1, #117	; 0x75
 c00ef4c:	d017      	beq.n	c00ef7e <_printf_i+0xb2>
 c00ef4e:	2978      	cmp	r1, #120	; 0x78
 c00ef50:	d1d4      	bne.n	c00eefc <_printf_i+0x30>
 c00ef52:	2378      	movs	r3, #120	; 0x78
 c00ef54:	4865      	ldr	r0, [pc, #404]	; (c00f0ec <_printf_i+0x220>)
 c00ef56:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 c00ef5a:	e055      	b.n	c00f008 <_printf_i+0x13c>
 c00ef5c:	6813      	ldr	r3, [r2, #0]
 c00ef5e:	f104 0542 	add.w	r5, r4, #66	; 0x42
 c00ef62:	1d19      	adds	r1, r3, #4
 c00ef64:	681b      	ldr	r3, [r3, #0]
 c00ef66:	6011      	str	r1, [r2, #0]
 c00ef68:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 c00ef6c:	2301      	movs	r3, #1
 c00ef6e:	e08c      	b.n	c00f08a <_printf_i+0x1be>
 c00ef70:	681b      	ldr	r3, [r3, #0]
 c00ef72:	f010 0f40 	tst.w	r0, #64	; 0x40
 c00ef76:	6011      	str	r1, [r2, #0]
 c00ef78:	bf18      	it	ne
 c00ef7a:	b21b      	sxthne	r3, r3
 c00ef7c:	e7cf      	b.n	c00ef1e <_printf_i+0x52>
 c00ef7e:	6813      	ldr	r3, [r2, #0]
 c00ef80:	6825      	ldr	r5, [r4, #0]
 c00ef82:	1d18      	adds	r0, r3, #4
 c00ef84:	6010      	str	r0, [r2, #0]
 c00ef86:	0628      	lsls	r0, r5, #24
 c00ef88:	d501      	bpl.n	c00ef8e <_printf_i+0xc2>
 c00ef8a:	681b      	ldr	r3, [r3, #0]
 c00ef8c:	e002      	b.n	c00ef94 <_printf_i+0xc8>
 c00ef8e:	0668      	lsls	r0, r5, #25
 c00ef90:	d5fb      	bpl.n	c00ef8a <_printf_i+0xbe>
 c00ef92:	881b      	ldrh	r3, [r3, #0]
 c00ef94:	296f      	cmp	r1, #111	; 0x6f
 c00ef96:	4854      	ldr	r0, [pc, #336]	; (c00f0e8 <_printf_i+0x21c>)
 c00ef98:	bf14      	ite	ne
 c00ef9a:	220a      	movne	r2, #10
 c00ef9c:	2208      	moveq	r2, #8
 c00ef9e:	2100      	movs	r1, #0
 c00efa0:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 c00efa4:	6865      	ldr	r5, [r4, #4]
 c00efa6:	2d00      	cmp	r5, #0
 c00efa8:	60a5      	str	r5, [r4, #8]
 c00efaa:	f2c0 8095 	blt.w	c00f0d8 <_printf_i+0x20c>
 c00efae:	6821      	ldr	r1, [r4, #0]
 c00efb0:	f021 0104 	bic.w	r1, r1, #4
 c00efb4:	6021      	str	r1, [r4, #0]
 c00efb6:	2b00      	cmp	r3, #0
 c00efb8:	d13d      	bne.n	c00f036 <_printf_i+0x16a>
 c00efba:	2d00      	cmp	r5, #0
 c00efbc:	f040 808e 	bne.w	c00f0dc <_printf_i+0x210>
 c00efc0:	4665      	mov	r5, ip
 c00efc2:	2a08      	cmp	r2, #8
 c00efc4:	d10b      	bne.n	c00efde <_printf_i+0x112>
 c00efc6:	6823      	ldr	r3, [r4, #0]
 c00efc8:	07db      	lsls	r3, r3, #31
 c00efca:	d508      	bpl.n	c00efde <_printf_i+0x112>
 c00efcc:	6923      	ldr	r3, [r4, #16]
 c00efce:	6862      	ldr	r2, [r4, #4]
 c00efd0:	429a      	cmp	r2, r3
 c00efd2:	bfde      	ittt	le
 c00efd4:	2330      	movle	r3, #48	; 0x30
 c00efd6:	f805 3c01 	strble.w	r3, [r5, #-1]
 c00efda:	f105 35ff 	addle.w	r5, r5, #4294967295
 c00efde:	ebac 0305 	sub.w	r3, ip, r5
 c00efe2:	6123      	str	r3, [r4, #16]
 c00efe4:	f8cd 8000 	str.w	r8, [sp]
 c00efe8:	463b      	mov	r3, r7
 c00efea:	aa03      	add	r2, sp, #12
 c00efec:	4621      	mov	r1, r4
 c00efee:	4630      	mov	r0, r6
 c00eff0:	f7ff fef4 	bl	c00eddc <_printf_common>
 c00eff4:	3001      	adds	r0, #1
 c00eff6:	d14d      	bne.n	c00f094 <_printf_i+0x1c8>
 c00eff8:	f04f 30ff 	mov.w	r0, #4294967295
 c00effc:	b005      	add	sp, #20
 c00effe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 c00f002:	4839      	ldr	r0, [pc, #228]	; (c00f0e8 <_printf_i+0x21c>)
 c00f004:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 c00f008:	6813      	ldr	r3, [r2, #0]
 c00f00a:	6821      	ldr	r1, [r4, #0]
 c00f00c:	1d1d      	adds	r5, r3, #4
 c00f00e:	681b      	ldr	r3, [r3, #0]
 c00f010:	6015      	str	r5, [r2, #0]
 c00f012:	060a      	lsls	r2, r1, #24
 c00f014:	d50b      	bpl.n	c00f02e <_printf_i+0x162>
 c00f016:	07ca      	lsls	r2, r1, #31
 c00f018:	bf44      	itt	mi
 c00f01a:	f041 0120 	orrmi.w	r1, r1, #32
 c00f01e:	6021      	strmi	r1, [r4, #0]
 c00f020:	b91b      	cbnz	r3, c00f02a <_printf_i+0x15e>
 c00f022:	6822      	ldr	r2, [r4, #0]
 c00f024:	f022 0220 	bic.w	r2, r2, #32
 c00f028:	6022      	str	r2, [r4, #0]
 c00f02a:	2210      	movs	r2, #16
 c00f02c:	e7b7      	b.n	c00ef9e <_printf_i+0xd2>
 c00f02e:	064d      	lsls	r5, r1, #25
 c00f030:	bf48      	it	mi
 c00f032:	b29b      	uxthmi	r3, r3
 c00f034:	e7ef      	b.n	c00f016 <_printf_i+0x14a>
 c00f036:	4665      	mov	r5, ip
 c00f038:	fbb3 f1f2 	udiv	r1, r3, r2
 c00f03c:	fb02 3311 	mls	r3, r2, r1, r3
 c00f040:	5cc3      	ldrb	r3, [r0, r3]
 c00f042:	f805 3d01 	strb.w	r3, [r5, #-1]!
 c00f046:	460b      	mov	r3, r1
 c00f048:	2900      	cmp	r1, #0
 c00f04a:	d1f5      	bne.n	c00f038 <_printf_i+0x16c>
 c00f04c:	e7b9      	b.n	c00efc2 <_printf_i+0xf6>
 c00f04e:	6813      	ldr	r3, [r2, #0]
 c00f050:	6825      	ldr	r5, [r4, #0]
 c00f052:	1d18      	adds	r0, r3, #4
 c00f054:	6961      	ldr	r1, [r4, #20]
 c00f056:	6010      	str	r0, [r2, #0]
 c00f058:	0628      	lsls	r0, r5, #24
 c00f05a:	681b      	ldr	r3, [r3, #0]
 c00f05c:	d501      	bpl.n	c00f062 <_printf_i+0x196>
 c00f05e:	6019      	str	r1, [r3, #0]
 c00f060:	e002      	b.n	c00f068 <_printf_i+0x19c>
 c00f062:	066a      	lsls	r2, r5, #25
 c00f064:	d5fb      	bpl.n	c00f05e <_printf_i+0x192>
 c00f066:	8019      	strh	r1, [r3, #0]
 c00f068:	2300      	movs	r3, #0
 c00f06a:	4665      	mov	r5, ip
 c00f06c:	6123      	str	r3, [r4, #16]
 c00f06e:	e7b9      	b.n	c00efe4 <_printf_i+0x118>
 c00f070:	6813      	ldr	r3, [r2, #0]
 c00f072:	1d19      	adds	r1, r3, #4
 c00f074:	6011      	str	r1, [r2, #0]
 c00f076:	2100      	movs	r1, #0
 c00f078:	681d      	ldr	r5, [r3, #0]
 c00f07a:	6862      	ldr	r2, [r4, #4]
 c00f07c:	4628      	mov	r0, r5
 c00f07e:	f000 f8d1 	bl	c00f224 <memchr>
 c00f082:	b108      	cbz	r0, c00f088 <_printf_i+0x1bc>
 c00f084:	1b40      	subs	r0, r0, r5
 c00f086:	6060      	str	r0, [r4, #4]
 c00f088:	6863      	ldr	r3, [r4, #4]
 c00f08a:	6123      	str	r3, [r4, #16]
 c00f08c:	2300      	movs	r3, #0
 c00f08e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 c00f092:	e7a7      	b.n	c00efe4 <_printf_i+0x118>
 c00f094:	6923      	ldr	r3, [r4, #16]
 c00f096:	462a      	mov	r2, r5
 c00f098:	4639      	mov	r1, r7
 c00f09a:	4630      	mov	r0, r6
 c00f09c:	47c0      	blx	r8
 c00f09e:	3001      	adds	r0, #1
 c00f0a0:	d0aa      	beq.n	c00eff8 <_printf_i+0x12c>
 c00f0a2:	6823      	ldr	r3, [r4, #0]
 c00f0a4:	079b      	lsls	r3, r3, #30
 c00f0a6:	d413      	bmi.n	c00f0d0 <_printf_i+0x204>
 c00f0a8:	68e0      	ldr	r0, [r4, #12]
 c00f0aa:	9b03      	ldr	r3, [sp, #12]
 c00f0ac:	4298      	cmp	r0, r3
 c00f0ae:	bfb8      	it	lt
 c00f0b0:	4618      	movlt	r0, r3
 c00f0b2:	e7a3      	b.n	c00effc <_printf_i+0x130>
 c00f0b4:	2301      	movs	r3, #1
 c00f0b6:	464a      	mov	r2, r9
 c00f0b8:	4639      	mov	r1, r7
 c00f0ba:	4630      	mov	r0, r6
 c00f0bc:	47c0      	blx	r8
 c00f0be:	3001      	adds	r0, #1
 c00f0c0:	d09a      	beq.n	c00eff8 <_printf_i+0x12c>
 c00f0c2:	3501      	adds	r5, #1
 c00f0c4:	68e3      	ldr	r3, [r4, #12]
 c00f0c6:	9a03      	ldr	r2, [sp, #12]
 c00f0c8:	1a9b      	subs	r3, r3, r2
 c00f0ca:	42ab      	cmp	r3, r5
 c00f0cc:	dcf2      	bgt.n	c00f0b4 <_printf_i+0x1e8>
 c00f0ce:	e7eb      	b.n	c00f0a8 <_printf_i+0x1dc>
 c00f0d0:	2500      	movs	r5, #0
 c00f0d2:	f104 0919 	add.w	r9, r4, #25
 c00f0d6:	e7f5      	b.n	c00f0c4 <_printf_i+0x1f8>
 c00f0d8:	2b00      	cmp	r3, #0
 c00f0da:	d1ac      	bne.n	c00f036 <_printf_i+0x16a>
 c00f0dc:	7803      	ldrb	r3, [r0, #0]
 c00f0de:	f104 0542 	add.w	r5, r4, #66	; 0x42
 c00f0e2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 c00f0e6:	e76c      	b.n	c00efc2 <_printf_i+0xf6>
 c00f0e8:	0c0108c9 	.word	0x0c0108c9
 c00f0ec:	0c0108da 	.word	0x0c0108da

0c00f0f0 <__sread>:
 c00f0f0:	b510      	push	{r4, lr}
 c00f0f2:	460c      	mov	r4, r1
 c00f0f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00f0f8:	f000 f8c8 	bl	c00f28c <_read_r>
 c00f0fc:	2800      	cmp	r0, #0
 c00f0fe:	bfab      	itete	ge
 c00f100:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 c00f102:	89a3      	ldrhlt	r3, [r4, #12]
 c00f104:	181b      	addge	r3, r3, r0
 c00f106:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 c00f10a:	bfac      	ite	ge
 c00f10c:	6563      	strge	r3, [r4, #84]	; 0x54
 c00f10e:	81a3      	strhlt	r3, [r4, #12]
 c00f110:	bd10      	pop	{r4, pc}

0c00f112 <__swrite>:
 c00f112:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 c00f116:	461f      	mov	r7, r3
 c00f118:	898b      	ldrh	r3, [r1, #12]
 c00f11a:	4605      	mov	r5, r0
 c00f11c:	460c      	mov	r4, r1
 c00f11e:	05db      	lsls	r3, r3, #23
 c00f120:	4616      	mov	r6, r2
 c00f122:	d505      	bpl.n	c00f130 <__swrite+0x1e>
 c00f124:	2302      	movs	r3, #2
 c00f126:	2200      	movs	r2, #0
 c00f128:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00f12c:	f000 f868 	bl	c00f200 <_lseek_r>
 c00f130:	89a3      	ldrh	r3, [r4, #12]
 c00f132:	4632      	mov	r2, r6
 c00f134:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 c00f138:	4628      	mov	r0, r5
 c00f13a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 c00f13e:	81a3      	strh	r3, [r4, #12]
 c00f140:	463b      	mov	r3, r7
 c00f142:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 c00f146:	f000 b817 	b.w	c00f178 <_write_r>

0c00f14a <__sseek>:
 c00f14a:	b510      	push	{r4, lr}
 c00f14c:	460c      	mov	r4, r1
 c00f14e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00f152:	f000 f855 	bl	c00f200 <_lseek_r>
 c00f156:	1c43      	adds	r3, r0, #1
 c00f158:	89a3      	ldrh	r3, [r4, #12]
 c00f15a:	bf15      	itete	ne
 c00f15c:	6560      	strne	r0, [r4, #84]	; 0x54
 c00f15e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 c00f162:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 c00f166:	81a3      	strheq	r3, [r4, #12]
 c00f168:	bf18      	it	ne
 c00f16a:	81a3      	strhne	r3, [r4, #12]
 c00f16c:	bd10      	pop	{r4, pc}

0c00f16e <__sclose>:
 c00f16e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 c00f172:	f000 b813 	b.w	c00f19c <_close_r>
	...

0c00f178 <_write_r>:
 c00f178:	b538      	push	{r3, r4, r5, lr}
 c00f17a:	4605      	mov	r5, r0
 c00f17c:	4c06      	ldr	r4, [pc, #24]	; (c00f198 <_write_r+0x20>)
 c00f17e:	4608      	mov	r0, r1
 c00f180:	4611      	mov	r1, r2
 c00f182:	2200      	movs	r2, #0
 c00f184:	6022      	str	r2, [r4, #0]
 c00f186:	461a      	mov	r2, r3
 c00f188:	f7fe fee8 	bl	c00df5c <_write>
 c00f18c:	1c43      	adds	r3, r0, #1
 c00f18e:	d102      	bne.n	c00f196 <_write_r+0x1e>
 c00f190:	6823      	ldr	r3, [r4, #0]
 c00f192:	b103      	cbz	r3, c00f196 <_write_r+0x1e>
 c00f194:	602b      	str	r3, [r5, #0]
 c00f196:	bd38      	pop	{r3, r4, r5, pc}
 c00f198:	3003e420 	.word	0x3003e420

0c00f19c <_close_r>:
 c00f19c:	b538      	push	{r3, r4, r5, lr}
 c00f19e:	2300      	movs	r3, #0
 c00f1a0:	4c05      	ldr	r4, [pc, #20]	; (c00f1b8 <_close_r+0x1c>)
 c00f1a2:	4605      	mov	r5, r0
 c00f1a4:	4608      	mov	r0, r1
 c00f1a6:	6023      	str	r3, [r4, #0]
 c00f1a8:	f000 fa42 	bl	c00f630 <_close>
 c00f1ac:	1c43      	adds	r3, r0, #1
 c00f1ae:	d102      	bne.n	c00f1b6 <_close_r+0x1a>
 c00f1b0:	6823      	ldr	r3, [r4, #0]
 c00f1b2:	b103      	cbz	r3, c00f1b6 <_close_r+0x1a>
 c00f1b4:	602b      	str	r3, [r5, #0]
 c00f1b6:	bd38      	pop	{r3, r4, r5, pc}
 c00f1b8:	3003e420 	.word	0x3003e420

0c00f1bc <_fstat_r>:
 c00f1bc:	b538      	push	{r3, r4, r5, lr}
 c00f1be:	2300      	movs	r3, #0
 c00f1c0:	4c06      	ldr	r4, [pc, #24]	; (c00f1dc <_fstat_r+0x20>)
 c00f1c2:	4605      	mov	r5, r0
 c00f1c4:	4608      	mov	r0, r1
 c00f1c6:	4611      	mov	r1, r2
 c00f1c8:	6023      	str	r3, [r4, #0]
 c00f1ca:	f000 fa39 	bl	c00f640 <_fstat>
 c00f1ce:	1c43      	adds	r3, r0, #1
 c00f1d0:	d102      	bne.n	c00f1d8 <_fstat_r+0x1c>
 c00f1d2:	6823      	ldr	r3, [r4, #0]
 c00f1d4:	b103      	cbz	r3, c00f1d8 <_fstat_r+0x1c>
 c00f1d6:	602b      	str	r3, [r5, #0]
 c00f1d8:	bd38      	pop	{r3, r4, r5, pc}
 c00f1da:	bf00      	nop
 c00f1dc:	3003e420 	.word	0x3003e420

0c00f1e0 <_isatty_r>:
 c00f1e0:	b538      	push	{r3, r4, r5, lr}
 c00f1e2:	2300      	movs	r3, #0
 c00f1e4:	4c05      	ldr	r4, [pc, #20]	; (c00f1fc <_isatty_r+0x1c>)
 c00f1e6:	4605      	mov	r5, r0
 c00f1e8:	4608      	mov	r0, r1
 c00f1ea:	6023      	str	r3, [r4, #0]
 c00f1ec:	f000 fa30 	bl	c00f650 <_isatty>
 c00f1f0:	1c43      	adds	r3, r0, #1
 c00f1f2:	d102      	bne.n	c00f1fa <_isatty_r+0x1a>
 c00f1f4:	6823      	ldr	r3, [r4, #0]
 c00f1f6:	b103      	cbz	r3, c00f1fa <_isatty_r+0x1a>
 c00f1f8:	602b      	str	r3, [r5, #0]
 c00f1fa:	bd38      	pop	{r3, r4, r5, pc}
 c00f1fc:	3003e420 	.word	0x3003e420

0c00f200 <_lseek_r>:
 c00f200:	b538      	push	{r3, r4, r5, lr}
 c00f202:	4605      	mov	r5, r0
 c00f204:	4c06      	ldr	r4, [pc, #24]	; (c00f220 <_lseek_r+0x20>)
 c00f206:	4608      	mov	r0, r1
 c00f208:	4611      	mov	r1, r2
 c00f20a:	2200      	movs	r2, #0
 c00f20c:	6022      	str	r2, [r4, #0]
 c00f20e:	461a      	mov	r2, r3
 c00f210:	f000 fa26 	bl	c00f660 <_lseek>
 c00f214:	1c43      	adds	r3, r0, #1
 c00f216:	d102      	bne.n	c00f21e <_lseek_r+0x1e>
 c00f218:	6823      	ldr	r3, [r4, #0]
 c00f21a:	b103      	cbz	r3, c00f21e <_lseek_r+0x1e>
 c00f21c:	602b      	str	r3, [r5, #0]
 c00f21e:	bd38      	pop	{r3, r4, r5, pc}
 c00f220:	3003e420 	.word	0x3003e420

0c00f224 <memchr>:
 c00f224:	b2c9      	uxtb	r1, r1
 c00f226:	4402      	add	r2, r0
 c00f228:	b510      	push	{r4, lr}
 c00f22a:	4290      	cmp	r0, r2
 c00f22c:	4603      	mov	r3, r0
 c00f22e:	d101      	bne.n	c00f234 <memchr+0x10>
 c00f230:	2300      	movs	r3, #0
 c00f232:	e003      	b.n	c00f23c <memchr+0x18>
 c00f234:	781c      	ldrb	r4, [r3, #0]
 c00f236:	3001      	adds	r0, #1
 c00f238:	428c      	cmp	r4, r1
 c00f23a:	d1f6      	bne.n	c00f22a <memchr+0x6>
 c00f23c:	4618      	mov	r0, r3
 c00f23e:	bd10      	pop	{r4, pc}

0c00f240 <_realloc_r>:
 c00f240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00f242:	4607      	mov	r7, r0
 c00f244:	4614      	mov	r4, r2
 c00f246:	460e      	mov	r6, r1
 c00f248:	b921      	cbnz	r1, c00f254 <_realloc_r+0x14>
 c00f24a:	4611      	mov	r1, r2
 c00f24c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 c00f250:	f7fe bf72 	b.w	c00e138 <_malloc_r>
 c00f254:	b922      	cbnz	r2, c00f260 <_realloc_r+0x20>
 c00f256:	4625      	mov	r5, r4
 c00f258:	f7fe ff20 	bl	c00e09c <_free_r>
 c00f25c:	4628      	mov	r0, r5
 c00f25e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 c00f260:	f000 f826 	bl	c00f2b0 <_malloc_usable_size_r>
 c00f264:	42a0      	cmp	r0, r4
 c00f266:	d20f      	bcs.n	c00f288 <_realloc_r+0x48>
 c00f268:	4621      	mov	r1, r4
 c00f26a:	4638      	mov	r0, r7
 c00f26c:	f7fe ff64 	bl	c00e138 <_malloc_r>
 c00f270:	4605      	mov	r5, r0
 c00f272:	2800      	cmp	r0, #0
 c00f274:	d0f2      	beq.n	c00f25c <_realloc_r+0x1c>
 c00f276:	4631      	mov	r1, r6
 c00f278:	4622      	mov	r2, r4
 c00f27a:	f7fe fee2 	bl	c00e042 <memcpy>
 c00f27e:	4631      	mov	r1, r6
 c00f280:	4638      	mov	r0, r7
 c00f282:	f7fe ff0b 	bl	c00e09c <_free_r>
 c00f286:	e7e9      	b.n	c00f25c <_realloc_r+0x1c>
 c00f288:	4635      	mov	r5, r6
 c00f28a:	e7e7      	b.n	c00f25c <_realloc_r+0x1c>

0c00f28c <_read_r>:
 c00f28c:	b538      	push	{r3, r4, r5, lr}
 c00f28e:	4605      	mov	r5, r0
 c00f290:	4c06      	ldr	r4, [pc, #24]	; (c00f2ac <_read_r+0x20>)
 c00f292:	4608      	mov	r0, r1
 c00f294:	4611      	mov	r1, r2
 c00f296:	2200      	movs	r2, #0
 c00f298:	6022      	str	r2, [r4, #0]
 c00f29a:	461a      	mov	r2, r3
 c00f29c:	f000 f9e8 	bl	c00f670 <_read>
 c00f2a0:	1c43      	adds	r3, r0, #1
 c00f2a2:	d102      	bne.n	c00f2aa <_read_r+0x1e>
 c00f2a4:	6823      	ldr	r3, [r4, #0]
 c00f2a6:	b103      	cbz	r3, c00f2aa <_read_r+0x1e>
 c00f2a8:	602b      	str	r3, [r5, #0]
 c00f2aa:	bd38      	pop	{r3, r4, r5, pc}
 c00f2ac:	3003e420 	.word	0x3003e420

0c00f2b0 <_malloc_usable_size_r>:
 c00f2b0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 c00f2b4:	1f18      	subs	r0, r3, #4
 c00f2b6:	2b00      	cmp	r3, #0
 c00f2b8:	bfbc      	itt	lt
 c00f2ba:	580b      	ldrlt	r3, [r1, r0]
 c00f2bc:	18c0      	addlt	r0, r0, r3
 c00f2be:	4770      	bx	lr

0c00f2c0 <__gnu_cmse_nonsecure_call>:
 c00f2c0:	e92d 4fe0 	stmdb	sp!, {r5, r6, r7, r8, r9, sl, fp, lr}
 c00f2c4:	4627      	mov	r7, r4
 c00f2c6:	46a0      	mov	r8, r4
 c00f2c8:	46a1      	mov	r9, r4
 c00f2ca:	46a2      	mov	sl, r4
 c00f2cc:	46a3      	mov	fp, r4
 c00f2ce:	46a4      	mov	ip, r4
 c00f2d0:	ed2d 8b10 	vpush	{d8-d15}
 c00f2d4:	f04f 0500 	mov.w	r5, #0
 c00f2d8:	ec45 5b18 	vmov	d8, r5, r5
 c00f2dc:	ec45 5a19 	vmov	s18, s19, r5, r5
 c00f2e0:	ec45 5a1a 	vmov	s20, s21, r5, r5
 c00f2e4:	ec45 5a1b 	vmov	s22, s23, r5, r5
 c00f2e8:	ec45 5a1c 	vmov	s24, s25, r5, r5
 c00f2ec:	ec45 5a1d 	vmov	s26, s27, r5, r5
 c00f2f0:	ec45 5a1e 	vmov	s28, s29, r5, r5
 c00f2f4:	ec45 5a1f 	vmov	s30, s31, r5, r5
 c00f2f8:	eef1 5a10 	vmrs	r5, fpscr
 c00f2fc:	f64f 7660 	movw	r6, #65376	; 0xff60
 c00f300:	f6c0 76ff 	movt	r6, #4095	; 0xfff
 c00f304:	4035      	ands	r5, r6
 c00f306:	eee1 5a10 	vmsr	fpscr, r5
 c00f30a:	f384 8800 	msr	CPSR_f, r4
 c00f30e:	4625      	mov	r5, r4
 c00f310:	4626      	mov	r6, r4
 c00f312:	47a4      	blxns	r4
 c00f314:	ecbd 8b10 	vpop	{d8-d15}
 c00f318:	e8bd 8fe0 	ldmia.w	sp!, {r5, r6, r7, r8, r9, sl, fp, pc}

0c00f31c <__aeabi_uldivmod>:
 c00f31c:	b953      	cbnz	r3, c00f334 <__aeabi_uldivmod+0x18>
 c00f31e:	b94a      	cbnz	r2, c00f334 <__aeabi_uldivmod+0x18>
 c00f320:	2900      	cmp	r1, #0
 c00f322:	bf08      	it	eq
 c00f324:	2800      	cmpeq	r0, #0
 c00f326:	bf1c      	itt	ne
 c00f328:	f04f 31ff 	movne.w	r1, #4294967295
 c00f32c:	f04f 30ff 	movne.w	r0, #4294967295
 c00f330:	f000 b97c 	b.w	c00f62c <__aeabi_idiv0>
 c00f334:	f1ad 0c08 	sub.w	ip, sp, #8
 c00f338:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 c00f33c:	f000 f806 	bl	c00f34c <__udivmoddi4>
 c00f340:	f8dd e004 	ldr.w	lr, [sp, #4]
 c00f344:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 c00f348:	b004      	add	sp, #16
 c00f34a:	4770      	bx	lr

0c00f34c <__udivmoddi4>:
 c00f34c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 c00f350:	468c      	mov	ip, r1
 c00f352:	9d08      	ldr	r5, [sp, #32]
 c00f354:	4604      	mov	r4, r0
 c00f356:	468a      	mov	sl, r1
 c00f358:	2b00      	cmp	r3, #0
 c00f35a:	d14a      	bne.n	c00f3f2 <__udivmoddi4+0xa6>
 c00f35c:	428a      	cmp	r2, r1
 c00f35e:	4617      	mov	r7, r2
 c00f360:	d962      	bls.n	c00f428 <__udivmoddi4+0xdc>
 c00f362:	fab2 f682 	clz	r6, r2
 c00f366:	b14e      	cbz	r6, c00f37c <__udivmoddi4+0x30>
 c00f368:	f1c6 0e20 	rsb	lr, r6, #32
 c00f36c:	fa01 f306 	lsl.w	r3, r1, r6
 c00f370:	40b7      	lsls	r7, r6
 c00f372:	40b4      	lsls	r4, r6
 c00f374:	fa20 fe0e 	lsr.w	lr, r0, lr
 c00f378:	ea4e 0a03 	orr.w	sl, lr, r3
 c00f37c:	ea4f 4817 	mov.w	r8, r7, lsr #16
 c00f380:	0c23      	lsrs	r3, r4, #16
 c00f382:	fa1f f987 	uxth.w	r9, r7
 c00f386:	fbba fef8 	udiv	lr, sl, r8
 c00f38a:	fb08 aa1e 	mls	sl, r8, lr, sl
 c00f38e:	fb0e f209 	mul.w	r2, lr, r9
 c00f392:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 c00f396:	429a      	cmp	r2, r3
 c00f398:	d90b      	bls.n	c00f3b2 <__udivmoddi4+0x66>
 c00f39a:	18fb      	adds	r3, r7, r3
 c00f39c:	f10e 31ff 	add.w	r1, lr, #4294967295
 c00f3a0:	bf2c      	ite	cs
 c00f3a2:	2001      	movcs	r0, #1
 c00f3a4:	2000      	movcc	r0, #0
 c00f3a6:	429a      	cmp	r2, r3
 c00f3a8:	d902      	bls.n	c00f3b0 <__udivmoddi4+0x64>
 c00f3aa:	2800      	cmp	r0, #0
 c00f3ac:	f000 812a 	beq.w	c00f604 <__udivmoddi4+0x2b8>
 c00f3b0:	468e      	mov	lr, r1
 c00f3b2:	1a9a      	subs	r2, r3, r2
 c00f3b4:	b2a3      	uxth	r3, r4
 c00f3b6:	fbb2 f0f8 	udiv	r0, r2, r8
 c00f3ba:	fb08 2210 	mls	r2, r8, r0, r2
 c00f3be:	fb00 f909 	mul.w	r9, r0, r9
 c00f3c2:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
 c00f3c6:	45a1      	cmp	r9, r4
 c00f3c8:	d907      	bls.n	c00f3da <__udivmoddi4+0x8e>
 c00f3ca:	193c      	adds	r4, r7, r4
 c00f3cc:	f100 33ff 	add.w	r3, r0, #4294967295
 c00f3d0:	d202      	bcs.n	c00f3d8 <__udivmoddi4+0x8c>
 c00f3d2:	45a1      	cmp	r9, r4
 c00f3d4:	f200 8110 	bhi.w	c00f5f8 <__udivmoddi4+0x2ac>
 c00f3d8:	4618      	mov	r0, r3
 c00f3da:	eba4 0409 	sub.w	r4, r4, r9
 c00f3de:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 c00f3e2:	2100      	movs	r1, #0
 c00f3e4:	b11d      	cbz	r5, c00f3ee <__udivmoddi4+0xa2>
 c00f3e6:	40f4      	lsrs	r4, r6
 c00f3e8:	2300      	movs	r3, #0
 c00f3ea:	e9c5 4300 	strd	r4, r3, [r5]
 c00f3ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00f3f2:	428b      	cmp	r3, r1
 c00f3f4:	d908      	bls.n	c00f408 <__udivmoddi4+0xbc>
 c00f3f6:	2d00      	cmp	r5, #0
 c00f3f8:	f000 80f2 	beq.w	c00f5e0 <__udivmoddi4+0x294>
 c00f3fc:	2100      	movs	r1, #0
 c00f3fe:	e9c5 0c00 	strd	r0, ip, [r5]
 c00f402:	4608      	mov	r0, r1
 c00f404:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 c00f408:	fab3 f183 	clz	r1, r3
 c00f40c:	2900      	cmp	r1, #0
 c00f40e:	d14e      	bne.n	c00f4ae <__udivmoddi4+0x162>
 c00f410:	4563      	cmp	r3, ip
 c00f412:	f0c0 80e8 	bcc.w	c00f5e6 <__udivmoddi4+0x29a>
 c00f416:	4282      	cmp	r2, r0
 c00f418:	f240 80e5 	bls.w	c00f5e6 <__udivmoddi4+0x29a>
 c00f41c:	4608      	mov	r0, r1
 c00f41e:	2d00      	cmp	r5, #0
 c00f420:	d0e5      	beq.n	c00f3ee <__udivmoddi4+0xa2>
 c00f422:	e9c5 4a00 	strd	r4, sl, [r5]
 c00f426:	e7e2      	b.n	c00f3ee <__udivmoddi4+0xa2>
 c00f428:	b902      	cbnz	r2, c00f42c <__udivmoddi4+0xe0>
 c00f42a:	deff      	udf	#255	; 0xff
 c00f42c:	fab2 f682 	clz	r6, r2
 c00f430:	2e00      	cmp	r6, #0
 c00f432:	f040 8099 	bne.w	c00f568 <__udivmoddi4+0x21c>
 c00f436:	1a8b      	subs	r3, r1, r2
 c00f438:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 c00f43c:	fa1f f882 	uxth.w	r8, r2
 c00f440:	2101      	movs	r1, #1
 c00f442:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 c00f446:	fbb3 f2fe 	udiv	r2, r3, lr
 c00f44a:	fb0e 3012 	mls	r0, lr, r2, r3
 c00f44e:	fb08 f902 	mul.w	r9, r8, r2
 c00f452:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
 c00f456:	45e1      	cmp	r9, ip
 c00f458:	d908      	bls.n	c00f46c <__udivmoddi4+0x120>
 c00f45a:	eb17 0c0c 	adds.w	ip, r7, ip
 c00f45e:	f102 33ff 	add.w	r3, r2, #4294967295
 c00f462:	d202      	bcs.n	c00f46a <__udivmoddi4+0x11e>
 c00f464:	45e1      	cmp	r9, ip
 c00f466:	f200 80ca 	bhi.w	c00f5fe <__udivmoddi4+0x2b2>
 c00f46a:	461a      	mov	r2, r3
 c00f46c:	ebac 0c09 	sub.w	ip, ip, r9
 c00f470:	b2a3      	uxth	r3, r4
 c00f472:	fbbc f0fe 	udiv	r0, ip, lr
 c00f476:	fb0e cc10 	mls	ip, lr, r0, ip
 c00f47a:	fb08 f800 	mul.w	r8, r8, r0
 c00f47e:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
 c00f482:	45a0      	cmp	r8, r4
 c00f484:	d90e      	bls.n	c00f4a4 <__udivmoddi4+0x158>
 c00f486:	193c      	adds	r4, r7, r4
 c00f488:	f100 33ff 	add.w	r3, r0, #4294967295
 c00f48c:	bf2c      	ite	cs
 c00f48e:	f04f 0c01 	movcs.w	ip, #1
 c00f492:	f04f 0c00 	movcc.w	ip, #0
 c00f496:	45a0      	cmp	r8, r4
 c00f498:	d903      	bls.n	c00f4a2 <__udivmoddi4+0x156>
 c00f49a:	f1bc 0f00 	cmp.w	ip, #0
 c00f49e:	f000 80a8 	beq.w	c00f5f2 <__udivmoddi4+0x2a6>
 c00f4a2:	4618      	mov	r0, r3
 c00f4a4:	eba4 0408 	sub.w	r4, r4, r8
 c00f4a8:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 c00f4ac:	e79a      	b.n	c00f3e4 <__udivmoddi4+0x98>
 c00f4ae:	f1c1 0420 	rsb	r4, r1, #32
 c00f4b2:	408b      	lsls	r3, r1
 c00f4b4:	fa02 fe01 	lsl.w	lr, r2, r1
 c00f4b8:	fa0c f601 	lsl.w	r6, ip, r1
 c00f4bc:	40e2      	lsrs	r2, r4
 c00f4be:	fa20 f704 	lsr.w	r7, r0, r4
 c00f4c2:	fa2c fc04 	lsr.w	ip, ip, r4
 c00f4c6:	fa00 f801 	lsl.w	r8, r0, r1
 c00f4ca:	4313      	orrs	r3, r2
 c00f4cc:	433e      	orrs	r6, r7
 c00f4ce:	0c1f      	lsrs	r7, r3, #16
 c00f4d0:	0c32      	lsrs	r2, r6, #16
 c00f4d2:	fa1f f983 	uxth.w	r9, r3
 c00f4d6:	fbbc f0f7 	udiv	r0, ip, r7
 c00f4da:	fb07 cc10 	mls	ip, r7, r0, ip
 c00f4de:	fb00 fa09 	mul.w	sl, r0, r9
 c00f4e2:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 c00f4e6:	45e2      	cmp	sl, ip
 c00f4e8:	d908      	bls.n	c00f4fc <__udivmoddi4+0x1b0>
 c00f4ea:	eb13 0c0c 	adds.w	ip, r3, ip
 c00f4ee:	f100 32ff 	add.w	r2, r0, #4294967295
 c00f4f2:	d202      	bcs.n	c00f4fa <__udivmoddi4+0x1ae>
 c00f4f4:	45e2      	cmp	sl, ip
 c00f4f6:	f200 8089 	bhi.w	c00f60c <__udivmoddi4+0x2c0>
 c00f4fa:	4610      	mov	r0, r2
 c00f4fc:	ebac 0c0a 	sub.w	ip, ip, sl
 c00f500:	b2b6      	uxth	r6, r6
 c00f502:	fbbc faf7 	udiv	sl, ip, r7
 c00f506:	fb07 cc1a 	mls	ip, r7, sl, ip
 c00f50a:	fb0a f909 	mul.w	r9, sl, r9
 c00f50e:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
 c00f512:	4591      	cmp	r9, r2
 c00f514:	d906      	bls.n	c00f524 <__udivmoddi4+0x1d8>
 c00f516:	189a      	adds	r2, r3, r2
 c00f518:	f10a 36ff 	add.w	r6, sl, #4294967295
 c00f51c:	d201      	bcs.n	c00f522 <__udivmoddi4+0x1d6>
 c00f51e:	4591      	cmp	r9, r2
 c00f520:	d87a      	bhi.n	c00f618 <__udivmoddi4+0x2cc>
 c00f522:	46b2      	mov	sl, r6
 c00f524:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
 c00f528:	eba2 0209 	sub.w	r2, r2, r9
 c00f52c:	fba0 670e 	umull	r6, r7, r0, lr
 c00f530:	42ba      	cmp	r2, r7
 c00f532:	46b4      	mov	ip, r6
 c00f534:	46b9      	mov	r9, r7
 c00f536:	d302      	bcc.n	c00f53e <__udivmoddi4+0x1f2>
 c00f538:	d107      	bne.n	c00f54a <__udivmoddi4+0x1fe>
 c00f53a:	45b0      	cmp	r8, r6
 c00f53c:	d205      	bcs.n	c00f54a <__udivmoddi4+0x1fe>
 c00f53e:	ebb6 0c0e 	subs.w	ip, r6, lr
 c00f542:	eb67 0303 	sbc.w	r3, r7, r3
 c00f546:	3801      	subs	r0, #1
 c00f548:	4699      	mov	r9, r3
 c00f54a:	2d00      	cmp	r5, #0
 c00f54c:	d06b      	beq.n	c00f626 <__udivmoddi4+0x2da>
 c00f54e:	ebb8 030c 	subs.w	r3, r8, ip
 c00f552:	eb62 0209 	sbc.w	r2, r2, r9
 c00f556:	fa02 f404 	lsl.w	r4, r2, r4
 c00f55a:	40cb      	lsrs	r3, r1
 c00f55c:	40ca      	lsrs	r2, r1
 c00f55e:	2100      	movs	r1, #0
 c00f560:	431c      	orrs	r4, r3
 c00f562:	e9c5 4200 	strd	r4, r2, [r5]
 c00f566:	e742      	b.n	c00f3ee <__udivmoddi4+0xa2>
 c00f568:	40b7      	lsls	r7, r6
 c00f56a:	f1c6 0220 	rsb	r2, r6, #32
 c00f56e:	fa01 f306 	lsl.w	r3, r1, r6
 c00f572:	40b4      	lsls	r4, r6
 c00f574:	fa21 fc02 	lsr.w	ip, r1, r2
 c00f578:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 c00f57c:	fa20 f202 	lsr.w	r2, r0, r2
 c00f580:	fa1f f887 	uxth.w	r8, r7
 c00f584:	fbbc f1fe 	udiv	r1, ip, lr
 c00f588:	431a      	orrs	r2, r3
 c00f58a:	fb0e cc11 	mls	ip, lr, r1, ip
 c00f58e:	fb01 f008 	mul.w	r0, r1, r8
 c00f592:	0c13      	lsrs	r3, r2, #16
 c00f594:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 c00f598:	4560      	cmp	r0, ip
 c00f59a:	d907      	bls.n	c00f5ac <__udivmoddi4+0x260>
 c00f59c:	eb17 0c0c 	adds.w	ip, r7, ip
 c00f5a0:	f101 33ff 	add.w	r3, r1, #4294967295
 c00f5a4:	d201      	bcs.n	c00f5aa <__udivmoddi4+0x25e>
 c00f5a6:	4560      	cmp	r0, ip
 c00f5a8:	d833      	bhi.n	c00f612 <__udivmoddi4+0x2c6>
 c00f5aa:	4619      	mov	r1, r3
 c00f5ac:	ebac 0c00 	sub.w	ip, ip, r0
 c00f5b0:	b292      	uxth	r2, r2
 c00f5b2:	fbbc f0fe 	udiv	r0, ip, lr
 c00f5b6:	fb0e cc10 	mls	ip, lr, r0, ip
 c00f5ba:	fb00 f308 	mul.w	r3, r0, r8
 c00f5be:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 c00f5c2:	4563      	cmp	r3, ip
 c00f5c4:	d907      	bls.n	c00f5d6 <__udivmoddi4+0x28a>
 c00f5c6:	eb17 0c0c 	adds.w	ip, r7, ip
 c00f5ca:	f100 32ff 	add.w	r2, r0, #4294967295
 c00f5ce:	d201      	bcs.n	c00f5d4 <__udivmoddi4+0x288>
 c00f5d0:	4563      	cmp	r3, ip
 c00f5d2:	d825      	bhi.n	c00f620 <__udivmoddi4+0x2d4>
 c00f5d4:	4610      	mov	r0, r2
 c00f5d6:	ebac 0303 	sub.w	r3, ip, r3
 c00f5da:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 c00f5de:	e730      	b.n	c00f442 <__udivmoddi4+0xf6>
 c00f5e0:	4629      	mov	r1, r5
 c00f5e2:	4628      	mov	r0, r5
 c00f5e4:	e703      	b.n	c00f3ee <__udivmoddi4+0xa2>
 c00f5e6:	1a84      	subs	r4, r0, r2
 c00f5e8:	eb6c 0303 	sbc.w	r3, ip, r3
 c00f5ec:	2001      	movs	r0, #1
 c00f5ee:	469a      	mov	sl, r3
 c00f5f0:	e715      	b.n	c00f41e <__udivmoddi4+0xd2>
 c00f5f2:	3802      	subs	r0, #2
 c00f5f4:	443c      	add	r4, r7
 c00f5f6:	e755      	b.n	c00f4a4 <__udivmoddi4+0x158>
 c00f5f8:	3802      	subs	r0, #2
 c00f5fa:	443c      	add	r4, r7
 c00f5fc:	e6ed      	b.n	c00f3da <__udivmoddi4+0x8e>
 c00f5fe:	3a02      	subs	r2, #2
 c00f600:	44bc      	add	ip, r7
 c00f602:	e733      	b.n	c00f46c <__udivmoddi4+0x120>
 c00f604:	f1ae 0e02 	sub.w	lr, lr, #2
 c00f608:	443b      	add	r3, r7
 c00f60a:	e6d2      	b.n	c00f3b2 <__udivmoddi4+0x66>
 c00f60c:	3802      	subs	r0, #2
 c00f60e:	449c      	add	ip, r3
 c00f610:	e774      	b.n	c00f4fc <__udivmoddi4+0x1b0>
 c00f612:	3902      	subs	r1, #2
 c00f614:	44bc      	add	ip, r7
 c00f616:	e7c9      	b.n	c00f5ac <__udivmoddi4+0x260>
 c00f618:	f1aa 0a02 	sub.w	sl, sl, #2
 c00f61c:	441a      	add	r2, r3
 c00f61e:	e781      	b.n	c00f524 <__udivmoddi4+0x1d8>
 c00f620:	3802      	subs	r0, #2
 c00f622:	44bc      	add	ip, r7
 c00f624:	e7d7      	b.n	c00f5d6 <__udivmoddi4+0x28a>
 c00f626:	4629      	mov	r1, r5
 c00f628:	e6e1      	b.n	c00f3ee <__udivmoddi4+0xa2>
 c00f62a:	bf00      	nop

0c00f62c <__aeabi_idiv0>:
 c00f62c:	4770      	bx	lr
 c00f62e:	bf00      	nop

0c00f630 <_close>:
 c00f630:	4b02      	ldr	r3, [pc, #8]	; (c00f63c <_close+0xc>)
 c00f632:	2258      	movs	r2, #88	; 0x58
 c00f634:	f04f 30ff 	mov.w	r0, #4294967295
 c00f638:	601a      	str	r2, [r3, #0]
 c00f63a:	4770      	bx	lr
 c00f63c:	3003e420 	.word	0x3003e420

0c00f640 <_fstat>:
 c00f640:	4b02      	ldr	r3, [pc, #8]	; (c00f64c <_fstat+0xc>)
 c00f642:	2258      	movs	r2, #88	; 0x58
 c00f644:	f04f 30ff 	mov.w	r0, #4294967295
 c00f648:	601a      	str	r2, [r3, #0]
 c00f64a:	4770      	bx	lr
 c00f64c:	3003e420 	.word	0x3003e420

0c00f650 <_isatty>:
 c00f650:	4b02      	ldr	r3, [pc, #8]	; (c00f65c <_isatty+0xc>)
 c00f652:	2258      	movs	r2, #88	; 0x58
 c00f654:	2000      	movs	r0, #0
 c00f656:	601a      	str	r2, [r3, #0]
 c00f658:	4770      	bx	lr
 c00f65a:	bf00      	nop
 c00f65c:	3003e420 	.word	0x3003e420

0c00f660 <_lseek>:
 c00f660:	4b02      	ldr	r3, [pc, #8]	; (c00f66c <_lseek+0xc>)
 c00f662:	2258      	movs	r2, #88	; 0x58
 c00f664:	f04f 30ff 	mov.w	r0, #4294967295
 c00f668:	601a      	str	r2, [r3, #0]
 c00f66a:	4770      	bx	lr
 c00f66c:	3003e420 	.word	0x3003e420

0c00f670 <_read>:
 c00f670:	4b02      	ldr	r3, [pc, #8]	; (c00f67c <_read+0xc>)
 c00f672:	2258      	movs	r2, #88	; 0x58
 c00f674:	f04f 30ff 	mov.w	r0, #4294967295
 c00f678:	601a      	str	r2, [r3, #0]
 c00f67a:	4770      	bx	lr
 c00f67c:	3003e420 	.word	0x3003e420

0c00f680 <_sbrk>:
 c00f680:	4b04      	ldr	r3, [pc, #16]	; (c00f694 <_sbrk+0x14>)
 c00f682:	4602      	mov	r2, r0
 c00f684:	6819      	ldr	r1, [r3, #0]
 c00f686:	b909      	cbnz	r1, c00f68c <_sbrk+0xc>
 c00f688:	4903      	ldr	r1, [pc, #12]	; (c00f698 <_sbrk+0x18>)
 c00f68a:	6019      	str	r1, [r3, #0]
 c00f68c:	6818      	ldr	r0, [r3, #0]
 c00f68e:	4402      	add	r2, r0
 c00f690:	601a      	str	r2, [r3, #0]
 c00f692:	4770      	bx	lr
 c00f694:	3003e3f4 	.word	0x3003e3f4
 c00f698:	3003f828 	.word	0x3003f828

0c00f69c <_exit>:
 c00f69c:	e7fe      	b.n	c00f69c <_exit>
	...

0c00f6a0 <_init>:
 c00f6a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00f6a2:	bf00      	nop
 c00f6a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c00f6a6:	bc08      	pop	{r3}
 c00f6a8:	469e      	mov	lr, r3
 c00f6aa:	4770      	bx	lr

0c00f6ac <_fini>:
 c00f6ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c00f6ae:	bf00      	nop
 c00f6b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c00f6b2:	bc08      	pop	{r3}
 c00f6b4:	469e      	mov	lr, r3
 c00f6b6:	4770      	bx	lr
 c00f6b8:	464e495b 	.word	0x464e495b
 c00f6bc:	6e49205d 	.word	0x6e49205d
 c00f6c0:	61697469 	.word	0x61697469
 c00f6c4:	697a696c 	.word	0x697a696c
 c00f6c8:	4220676e 	.word	0x4220676e
 c00f6cc:	4e20324c 	.word	0x4e20324c
 c00f6d0:	72612056 	.word	0x72612056
 c00f6d4:	3a206165 	.word	0x3a206165
 c00f6d8:	776f5020 	.word	0x776f5020
 c00f6dc:	64207265 	.word	0x64207265
 c00f6e0:	2f6e776f 	.word	0x2f6e776f
 c00f6e4:	65736572 	.word	0x65736572
 c00f6e8:	6f6e2074 	.word	0x6f6e2074
 c00f6ec:	75732074 	.word	0x75732074
 c00f6f0:	726f7070 	.word	0x726f7070
 c00f6f4:	2e646574 	.word	0x2e646574
 c00f6f8:	000d2e2e 	.word	0x000d2e2e
 c00f6fc:	5252455b 	.word	0x5252455b
 c00f700:	6e49205d 	.word	0x6e49205d
 c00f704:	42207469 	.word	0x42207469
 c00f708:	4e20324c 	.word	0x4e20324c
 c00f70c:	65482056 	.word	0x65482056
 c00f710:	72656461 	.word	0x72656461
 c00f714:	65726120 	.word	0x65726120
 c00f718:	46203a61 	.word	0x46203a61
 c00f71c:	656c6961 	.word	0x656c6961
 c00f720:	5b000d64 	.word	0x5b000d64
 c00f724:	5d464e49 	.word	0x5d464e49
 c00f728:	696e4920 	.word	0x696e4920
 c00f72c:	4c422074 	.word	0x4c422074
 c00f730:	564e2032 	.word	0x564e2032
 c00f734:	61654820 	.word	0x61654820
 c00f738:	20726564 	.word	0x20726564
 c00f73c:	61657261 	.word	0x61657261
 c00f740:	6f44203a 	.word	0x6f44203a
 c00f744:	000d656e 	.word	0x000d656e
 c00f748:	464e495b 	.word	0x464e495b
 c00f74c:	6e49205d 	.word	0x6e49205d
 c00f750:	61697469 	.word	0x61697469
 c00f754:	697a696c 	.word	0x697a696c
 c00f758:	4220676e 	.word	0x4220676e
 c00f75c:	4e20324c 	.word	0x4e20324c
 c00f760:	6f432056 	.word	0x6f432056
 c00f764:	65746e75 	.word	0x65746e75
 c00f768:	000d7372 	.word	0x000d7372
 c00f76c:	464e495b 	.word	0x464e495b
 c00f770:	6843205d 	.word	0x6843205d
 c00f774:	696b6365 	.word	0x696b6365
 c00f778:	4220676e 	.word	0x4220676e
 c00f77c:	4e20324c 	.word	0x4e20324c
 c00f780:	72612056 	.word	0x72612056
 c00f784:	000d6165 	.word	0x000d6165
 c00f788:	464e495b 	.word	0x464e495b
 c00f78c:	6843205d 	.word	0x6843205d
 c00f790:	696b6365 	.word	0x696b6365
 c00f794:	4220676e 	.word	0x4220676e
 c00f798:	4e20324c 	.word	0x4e20324c
 c00f79c:	72612056 	.word	0x72612056
 c00f7a0:	68206165 	.word	0x68206165
 c00f7a4:	65646165 	.word	0x65646165
 c00f7a8:	5b000d72 	.word	0x5b000d72
 c00f7ac:	5d525245 	.word	0x5d525245
 c00f7b0:	6f725720 	.word	0x6f725720
 c00f7b4:	4220676e 	.word	0x4220676e
 c00f7b8:	4e20324c 	.word	0x4e20324c
 c00f7bc:	72412056 	.word	0x72412056
 c00f7c0:	68206165 	.word	0x68206165
 c00f7c4:	65646165 	.word	0x65646165
 c00f7c8:	5b000d72 	.word	0x5b000d72
 c00f7cc:	5d464e49 	.word	0x5d464e49
 c00f7d0:	65684320 	.word	0x65684320
 c00f7d4:	6e696b63 	.word	0x6e696b63
 c00f7d8:	4c422067 	.word	0x4c422067
 c00f7dc:	564e2032 	.word	0x564e2032
 c00f7e0:	756f4320 	.word	0x756f4320
 c00f7e4:	7265746e 	.word	0x7265746e
 c00f7e8:	6e6f6320 	.word	0x6e6f6320
 c00f7ec:	74736973 	.word	0x74736973
 c00f7f0:	79636e65 	.word	0x79636e65
 c00f7f4:	455b000d 	.word	0x455b000d
 c00f7f8:	205d5252 	.word	0x205d5252
 c00f7fc:	4320564e 	.word	0x4320564e
 c00f800:	746e756f 	.word	0x746e756f
 c00f804:	4e207265 	.word	0x4e207265
 c00f808:	6320746f 	.word	0x6320746f
 c00f80c:	69736e6f 	.word	0x69736e6f
 c00f810:	6e657473 	.word	0x6e657473
 c00f814:	64252074 	.word	0x64252074
 c00f818:	5b000a0d 	.word	0x5b000a0d
 c00f81c:	5d464e49 	.word	0x5d464e49
 c00f820:	6e6f4320 	.word	0x6e6f4320
 c00f824:	74736973 	.word	0x74736973
 c00f828:	20746e65 	.word	0x20746e65
 c00f82c:	20324c42 	.word	0x20324c42
 c00f830:	4320564e 	.word	0x4320564e
 c00f834:	746e756f 	.word	0x746e756f
 c00f838:	25207265 	.word	0x25207265
 c00f83c:	3d202064 	.word	0x3d202064
 c00f840:	25783020 	.word	0x25783020
 c00f844:	000a0d78 	.word	0x000a0d78
 c00f848:	5252455b 	.word	0x5252455b
 c00f84c:	6e49205d 	.word	0x6e49205d
 c00f850:	42207469 	.word	0x42207469
 c00f854:	4e20324c 	.word	0x4e20324c
 c00f858:	6f632056 	.word	0x6f632056
 c00f85c:	65746e75 	.word	0x65746e75
 c00f860:	3a207372 	.word	0x3a207372
 c00f864:	69614620 	.word	0x69614620
 c00f868:	0d64656c 	.word	0x0d64656c
 c00f86c:	4e495b00 	.word	0x4e495b00
 c00f870:	49205d46 	.word	0x49205d46
 c00f874:	2074696e 	.word	0x2074696e
 c00f878:	20324c42 	.word	0x20324c42
 c00f87c:	6320564e 	.word	0x6320564e
 c00f880:	746e756f 	.word	0x746e756f
 c00f884:	20737265 	.word	0x20737265
 c00f888:	30206f74 	.word	0x30206f74
 c00f88c:	44203a20 	.word	0x44203a20
 c00f890:	0d656e6f 	.word	0x0d656e6f
 c00f894:	4e495b00 	.word	0x4e495b00
 c00f898:	42205d46 	.word	0x42205d46
 c00f89c:	4e20324c 	.word	0x4e20324c
 c00f8a0:	72412056 	.word	0x72412056
 c00f8a4:	49206165 	.word	0x49206165
 c00f8a8:	6974696e 	.word	0x6974696e
 c00f8ac:	7a696c61 	.word	0x7a696c61
 c00f8b0:	3a206465 	.word	0x3a206465
 c00f8b4:	776f5020 	.word	0x776f5020
 c00f8b8:	44207265 	.word	0x44207265
 c00f8bc:	2f6e776f 	.word	0x2f6e776f
 c00f8c0:	65736572 	.word	0x65736572
 c00f8c4:	75732074 	.word	0x75732074
 c00f8c8:	726f7070 	.word	0x726f7070
 c00f8cc:	0d646574 	.word	0x0d646574
 c00f8d0:	00          	.byte	0x00
 c00f8d1:	5b          	.byte	0x5b
 c00f8d2:	4e49      	.short	0x4e49
 c00f8d4:	43205d46 	.word	0x43205d46
 c00f8d8:	746e756f 	.word	0x746e756f
 c00f8dc:	25207265 	.word	0x25207265
 c00f8e0:	65732064 	.word	0x65732064
 c00f8e4:	6f742074 	.word	0x6f742074
 c00f8e8:	25783020 	.word	0x25783020
 c00f8ec:	000a0d78 	.word	0x000a0d78
 c00f8f0:	5252455b 	.word	0x5252455b
 c00f8f4:	7245205d 	.word	0x7245205d
 c00f8f8:	20726f72 	.word	0x20726f72
 c00f8fc:	6c696877 	.word	0x6c696877
 c00f900:	6e692065 	.word	0x6e692065
 c00f904:	61697469 	.word	0x61697469
 c00f908:	697a696c 	.word	0x697a696c
 c00f90c:	4620676e 	.word	0x4620676e
 c00f910:	6873616c 	.word	0x6873616c
 c00f914:	746e4920 	.word	0x746e4920
 c00f918:	61667265 	.word	0x61667265
 c00f91c:	000d6563 	.word	0x000d6563
 c00f920:	5252455b 	.word	0x5252455b
 c00f924:	7245205d 	.word	0x7245205d
 c00f928:	20726f72 	.word	0x20726f72
 c00f92c:	6c696877 	.word	0x6c696877
 c00f930:	6e692065 	.word	0x6e692065
 c00f934:	61697469 	.word	0x61697469
 c00f938:	697a696c 	.word	0x697a696c
 c00f93c:	6f20676e 	.word	0x6f20676e
 c00f940:	20697073 	.word	0x20697073
 c00f944:	73616c46 	.word	0x73616c46
 c00f948:	6e492068 	.word	0x6e492068
 c00f94c:	66726574 	.word	0x66726574
 c00f950:	0d656361 	.word	0x0d656361
 c00f954:	00          	.byte	0x00
 c00f955:	5b          	.byte	0x5b
 c00f956:	4e49      	.short	0x4e49
 c00f958:	6f205d46 	.word	0x6f205d46
 c00f95c:	65646674 	.word	0x65646674
 c00f960:	656b2063 	.word	0x656b2063
 c00f964:	78252079 	.word	0x78252079
 c00f968:	7825202c 	.word	0x7825202c
 c00f96c:	7825202c 	.word	0x7825202c
 c00f970:	7825202c 	.word	0x7825202c
 c00f974:	7825202c 	.word	0x7825202c
 c00f978:	7825202c 	.word	0x7825202c
 c00f97c:	7825202c 	.word	0x7825202c
 c00f980:	7825202c 	.word	0x7825202c
 c00f984:	000a0d2c 	.word	0x000a0d2c
 c00f988:	464e495b 	.word	0x464e495b
 c00f98c:	746f205d 	.word	0x746f205d
 c00f990:	63656466 	.word	0x63656466
 c00f994:	79656b20 	.word	0x79656b20
 c00f998:	2c782520 	.word	0x2c782520
 c00f99c:	2c782520 	.word	0x2c782520
 c00f9a0:	2c782520 	.word	0x2c782520
 c00f9a4:	2c782520 	.word	0x2c782520
 c00f9a8:	2c782520 	.word	0x2c782520
 c00f9ac:	2c782520 	.word	0x2c782520
 c00f9b0:	2c782520 	.word	0x2c782520
 c00f9b4:	2c782520 	.word	0x2c782520
 c00f9b8:	0a0d0a0d 	.word	0x0a0d0a0d
 c00f9bc:	00000000 	.word	0x00000000

0c00f9c0 <otfdec_magic>:
 c00f9c0:	5a8b324f c66da104 5252455b 7245205d     O2.Z..m.[ERR] Er
 c00f9d0:	20726f72 6c696877 6f642065 656c6275     ror while double
 c00f9e0:	6e6f6320 6c6f7274 676e696c 616d6920      controlling ima
 c00f9f0:	20736567 696c6176 69746164 000d6e6f     ges validation..
 c00fa00:	5252455b 7245205d 20726f72 6c696877     [ERR] Error whil
 c00fa10:	6f632065 6769666e 6e697275 736f2067     e configuring os
 c00fa20:	66206970 6873616c 206e6920 63657865     pi flash in exec
 c00fa30:	6f697475 5b000d6e 5d525245 72724520     ution..[ERR] Err
 c00fa40:	7720726f 656c6968 6e6f6320 75676966     or while configu
 c00fa50:	676e6972 66746f20 20636564 206e6f28     ring otfdec (on 
 c00fa60:	20656874 20796c66 72636564 69747079     the fly decrypti
 c00fa70:	0d296e6f                                 on)...

0c00fa76 <DriverVersion>:
 c00fa76:	02020203                                 ......

0c00fa7c <TFM_Driver_USART0>:
 c00fa7c:	0c003715 0c003729 0c0037a5 0c00372d     .7..)7...7..-7..
 c00fa8c:	0c003731 0c003781 0c003761 0c003737     17...7..a7..77..
 c00fa9c:	0c00373d 0c00385b 0c003743 0c003747     =7..[8..C7..G7..
 c00faac:	0c003855 0c003753                       U8..S7..

0c00fab4 <ARM_FLASH0_DEV_DATA>:
 c00fab4:	00000000 00000080 00001000 00000800     ................
 c00fac4:	00000008 000000ff                       ........

0c00facc <DriverVersion>:
 c00facc:	01000201                                ....

0c00fad0 <TFM_Driver_FLASH0>:
 c00fad0:	0c003861 0c003875 0c0038ad 0c003879     a8..u8...8..y8..
 c00fae0:	0c00387d 0c003a75 0c0038ed 0c0039bd     }8..u:...8...9..
 c00faf0:	0c003893 0c003899 0c0038a5              .8...8...8..

0c00fafc <ARM_OSPI_FLASH0_DEV_DATA>:
 c00fafc:	00000000 00004000 00001000 00000100     .....@..........
 c00fb0c:	00000002 000000ff                       ........

0c00fb14 <DriverVersion>:
 c00fb14:	01000201                                ....

0c00fb18 <TFM_Driver_OSPI_FLASH0>:
 c00fb18:	0c003b5d 0c003b71 0c003c97 0c003c85     ];..q;...<...<..
 c00fb28:	0c003b75 0c003ba5 0c003d2d 0c003cb9     u;...;..-=...<..
 c00fb38:	0c003b8b 0c003b91 0c003b9d              .;...;...;..

0c00fb44 <AHBPrescTable>:
	...
 c00fb4c:	04030201 09080706                       ........

0c00fb54 <APBPrescTable>:
 c00fb54:	00000000 04030201                       ........

0c00fb5c <MSIRangeTable>:
 c00fb5c:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 c00fb6c:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 c00fb7c:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
 c00fb9c:	5252455b 4c42205d 4f422032 5320544f     [ERR] BL2 BOOT S
 c00fbac:	20444545 656e6567 69746172 46206e6f     EED generation F
 c00fbbc:	656c6961 21212064 455b000d 205d5252     ailed !!..[ERR] 
 c00fbcc:	20324c42 204b5548 20746573 20324c42     BL2 HUK set BL2 
 c00fbdc:	52414853 44204445 20415441 6c696146     SHARED DATA Fail
 c00fbec:	21206465 5b000d21 5d464e49 324c4220     ed !!..[INF] BL2
 c00fbfc:	4b554820 20732520 20746573 42206f74      HUK %s set to B
 c00fc0c:	5320324c 45524148 41442044 0a0d4154     L2 SHARED DATA..
 c00fc1c:	4e495b00 43205d46 2065646f 25207825     .[INF] Code %x %
 c00fc2c:	000a0d78 464e495b 6168205d 54206873     x...[INF] hash T
 c00fc3c:	535f4d46 55465342 6f6f425f 25202074     FM_SBSFU_Boot  %
 c00fc4c:	25782578 20782578 25202e2e 25782578     x%x%x%x .. %x%x%
 c00fc5c:	0d782578 455b000a 205d5252 78656e55     x%x...[ERR] Unex
 c00fc6c:	74636570 76206465 65756c61 726f6620     pected value for
 c00fc7c:	455a5420 6176204e 0d65756c 52455b00      TZEN value..[ER
 c00fc8c:	55205d52 7078656e 65746365 61762064     R] Unexpected va
 c00fc9c:	2065756c 20726f66 6c617564 6e616220     lue for dual ban
 c00fcac:	6f63206b 6769666e 74617275 0d6e6f69     k configuration.
 c00fcbc:	52455b00 55205d52 7078656e 65746365     .[ERR] Unexpecte
 c00fccc:	61762064 2065756c 20726f66 70617773     d value for swap
 c00fcdc:	6e616220 6f63206b 6769666e 74617275      bank configurat
 c00fcec:	0d6e6f69 4e495b00 42205d46 41746f6f     ion..[INF] BootA
 c00fcfc:	20726464 78257830 5b000a0d 5d525245     ddr 0x%x...[ERR]
 c00fd0c:	656e5520 63657078 20646574 756c6176      Unexpected valu
 c00fd1c:	6f662065 45532072 4f422043 4120544f     e for SEC BOOT A
 c00fd2c:	65726464 000d7373 464e495b 4142205d     ddress..[INF] BA
 c00fd3c:	31204b4e 63657320 20657275 73616c66     NK 1 secure flas
 c00fd4c:	255b2068 25202c64 3a205d64 20424f20     h [%d, %d] : OB 
 c00fd5c:	2c64255b 5d642520 5b000a0d 5d525245     [%d, %d]...[ERR]
 c00fd6c:	656e5520 63657078 20646574 756c6176      Unexpected valu
 c00fd7c:	6f662065 65732072 65727563 616c6620     e for secure fla
 c00fd8c:	70206873 65746f72 6f697463 73203a6e     sh protection: s
 c00fd9c:	77207465 6365736d 5b000d31 5d464e49     et wmsec1..[INF]
 c00fdac:	4e414220 2032204b 75636573 66206572      BANK 2 secure f
 c00fdbc:	6873616c 64255b20 6425202c 203a205d     lash [%d, %d] : 
 c00fdcc:	5b20424f 202c6425 0d5d6425 495b000a     OB [%d, %d]...[I
 c00fddc:	205d464e 4b4e4142 66203120 6873616c     NF] BANK 1 flash
 c00fdec:	69727720 70206574 65746f72 6f697463      write protectio
 c00fdfc:	255b206e 25202c64 3a205d64 20424f20     n [%d, %d] : OB 
 c00fe0c:	2c64255b 5d642520 5b000a0d 5d525245     [%d, %d]...[ERR]
 c00fe1c:	656e5520 63657078 20646574 756c6176      Unexpected valu
 c00fe2c:	6f662065 72772072 20657469 746f7270     e for write prot
 c00fe3c:	69746365 3a206e6f 74657320 70727720     ection : set wrp
 c00fe4c:	5b000d31 5d464e49 4e414220 2032204b     1..[INF] BANK 2 
 c00fe5c:	73616c66 72772068 20657469 746f7270     flash write prot
 c00fe6c:	69746365 5b206e6f 202c6425 205d6425     ection [%d, %d] 
 c00fe7c:	424f203a 64255b20 6425202c 000a0d5d     : OB [%d, %d]...
 c00fe8c:	5252455b 6e55205d 65707865 64657463     [ERR] Unexpected
 c00fe9c:	6c617620 66206575 7720726f 65746972      value for write
 c00feac:	6f727020 74636574 206e6f69 6573203a      protection : se
 c00febc:	72772074 000d3270 464e495b 4142205d     t wrp2..[INF] BA
 c00fecc:	31204b4e 63657320 20657275 72657375     NK 1 secure user
 c00fedc:	616c6620 5b206873 202c6425 205d6425      flash [%d, %d] 
 c00feec:	424f203a 64255b20 6425202c 000a0d5d     : OB [%d, %d]...
 c00fefc:	5252455b 6e55205d 65707865 64657463     [ERR] Unexpected
 c00ff0c:	6c617620 66206575 7320726f 72756365      value for secur
 c00ff1c:	73752065 66207265 6873616c 6f727020     e user flash pro
 c00ff2c:	74636574 206e6f69 6573203a 64682074     tection : set hd
 c00ff3c:	000d3170 5252455b 6e55205d 65707865     p1..[ERR] Unexpe
 c00ff4c:	64657463 6c617620 66206575 5320726f     cted value for S
 c00ff5c:	324d4152 41524520 61204553 65522074     RAM2 ERASE at Re
 c00ff6c:	0d746573 52455b00 55205d52 7078656e     set..[ERR] Unexp
 c00ff7c:	65746365 61762064 2065756c 20726f66     ected value for 
 c00ff8c:	5220424f 74205044 7270206f 6172676f     OB RDP to progra
 c00ff9c:	5b000d6d 5d525245 656e5520 63657078     m..[ERR] Unexpec
 c00ffac:	20646574 756c6176 6f662065 61622072     ted value for ba
 c00ffbc:	32206b6e 20424f20 20505257 41455241     nk 2 OB WRP AREA
 c00ffcc:	206f7420 676f7270 0d6d6172 52455b00      to program..[ER
 c00ffdc:	55205d52 7078656e 65746365 61762064     R] Unexpected va
 c00ffec:	2065756c 20726f66 6b6e6162 4f203120     lue for bank 1 O
 c00fffc:	52572042 52412050 74204145 7270206f     B WRP AREA to pr
 c01000c:	6172676f 5b000d6d 5d525245 72724520     ogram..[ERR] Err
 c01001c:	7720726f 656c6968 74657320 676e6974     or while setting
 c01002c:	20424f20 6b6e6142 6f632031 6769666e      OB Bank1 config
 c01003c:	455b000d 205d5252 6f727245 68772072     ..[ERR] Error wh
 c01004c:	20656c69 63657865 6f697475 424f206e     ile execution OB
 c01005c:	75614c5f 0d68636e 4e495b00 42205d46     _Launch..[INF] B
 c01006c:	4c746f6f 206b636f 78257830 5b000a0d     ootLock 0x%x...[
 c01007c:	5d525245 656e5520 63657078 20646574     ERR] Unexpected 
 c01008c:	756c6176 6f662065 45532072 4f422043     value for SEC BO
 c01009c:	4c20544f 0d4b434f 4e495b00 52205d46     OT LOCK..[INF] R
 c0100ac:	654c5044 206c6576 78257830 78302820     DPLevel 0x%x (0x
 c0100bc:	0d297825 455b000a 205d5252 78656e55     %x)...[ERR] Unex
 c0100cc:	74636570 76206465 65756c61 726f6620     pected value for
 c0100dc:	50445220 76656c20 000d6c65 464e495b      RDP level..[INF
 c0100ec:	7250205d 6172676f 6e696d6d 44522067     ] Programming RD
 c0100fc:	6f742050 0d782520 495b000a 205d464e     P to %x...[INF] 
 c01010c:	6c706e55 502f6775 2067756c 706d756a     Unplug/Plug jump
 c01011c:	4a207265 28203250 29444449 455b000d     er JP2 (IDD)..[E
 c01012c:	205d5252 6f727245 68772072 20656c69     RR] Error while 
 c01013c:	74746573 20676e69 20504452 6576656c     setting RDP leve
 c01014c:	00000d6c 00000000 ff000000 ffff0000     l...............
 c01015c:	ffffff00 00000000 0000ff00 0000ffff     ................
 c01016c:	ff00ffff 00000000 000000ff 0000ffff     ................
 c01017c:	00ffffff aa55aa55 00000003 00000018     ....U.U.........
 c01018c:	000000c0                                ....

0c010190 <CSWTCH.58>:
 c010190:	08020401                                ....

0c010194 <CSWTCH.59>:
 c010194:	10101000 10101004 10101002               ..............

0c0101a2 <UARTPrescTable>:
 c0101a2:	00020001 00060004 000a0008 0010000c     ................
 c0101b2:	00400020 01000080                         .@.......

0c0101bc <mbedtls_sha224_info>:
 c0101bc:	00000005 0c010223 0000001c 00000040     ....#.......@...
 c0101cc:	0c00bb99 0c00bb95 0c00bb91 0c00bb85     ................
 c0101dc:	0c00bb6d 0c00bb5b 0c00bb57 0c00bb53     m...[...W...S...

0c0101ec <mbedtls_sha256_info>:
 c0101ec:	00000006 0c01021c 00000020 00000040     ........ ...@...
 c0101fc:	0c00bb9f 0c00bb95 0c00bb91 0c00bb8b     ................
 c01020c:	0c00bb6d 0c00bb5b 0c00bb57 0c00bb53     m...[...W...S...
 c01021c:	32414853 53003635 32324148 00000034     SHA256.SHA224...

0c01022c <boot_img_magic>:
 c01022c:	f395c277 7fefd260 0f505235 8079b62c     w...`...5RP.,.y.

0c01023c <boot_swap_tables>:
 c01023c:	03040104 01040204 03040104 04030301     ................
 c01024c:	65700401 74006d72 00747365 3b475542     ..perm.test.BUG;
 c01025c:	6e616320 68207427 65707061 6572006e      can't happen.re
 c01026c:	74726576 4e495b00 53205d46 20706177     vert.[INF] Swap 
 c01027c:	65707974 7325203a 5b000a0d 5d464e49     type: %s...[INF]
 c01028c:	61775320 79742070 203a6570 656e6f6e      Swap type: none
 c01029c:	495b000d 205d464e 202c7825 202c7825     ..[INF] %x, %x, 
 c0102ac:	202c7825 202c7825 202c7825 2c207825     %x, %x, %x, %x ,
 c0102bc:	20782520 2c78252c                         %x ,%x,...

0c0102c7 <pss_zeros>:
	...
 c0102cf:	464e495b 6576205d 79666972 67697320     [INF] verify sig
 c0102df:	79656b20 20646920 0a0d6425 4e495b00      key id %d...[IN
 c0102ef:	73205d46 616e6769 65727574 0d4b4f20     F] signature OK.
 c0102ff:	4e495b00 76205d46 66697265 6f632079     .[INF] verify co
 c01030f:	65746e75 25202072 78252064 0d782520     unter  %d %x %x.
 c01031f:	495b000a 205d464e 6e756f63 20726574     ..[INF] counter 
 c01032f:	20642520 6b6f203a 5b000a0d 5d464e49      %d : ok...[INF]
 c01033f:	656e7520 63657078 20646574 20564c54      unexpected TLV 
 c01034f:	0d207825 495b000a 205d464e 64616572     %x ...[INF] read
 c01035f:	69616620 2064656c 0d207825 495b000a      failed %x ...[I
 c01036f:	205d464e 61746164 6f727720 6120676e     NF] data wrong a
 c01037f:	78252074 70000a0d 616d6972 73007972     t %x...primary.s
 c01038f:	6e6f6365 79726164 52455b00 49205d52     econdary.[ERR] I
 c01039f:	6567616d 206e6920 20656874 73207325     mage in the %s s
 c0103af:	20746f6c 6e207369 7620746f 64696c61     lot is not valid
 c0103bf:	000a0d21 4e52575b 6146205d 64656c69     !...[WRN] Failed
 c0103cf:	61657220 676e6964 63657320 73726f74      reading sectors
 c0103df:	4f42203b 4d5f544f 495f5841 535f474d     ; BOOT_MAX_IMG_S
 c0103ef:	4f544345 253d5352 202d2064 206f6f74     ECTORS=%d - too 
 c0103ff:	6c616d73 0a0d3f6c 52575b00 46205d4e     small?...[WRN] F
 c01040f:	656c6961 65722064 6e696461 6d692067     ailed reading im
 c01041f:	20656761 64616568 3b737265 616d4920     age headers; Ima
 c01042f:	253d6567 000a0d75 464e495b 6d49205d     ge=%u...[INF] Im
 c01043f:	20656761 72677075 20656461 6f636573     age upgrade seco
 c01044f:	7261646e 6c732079 2d20746f 7270203e     ndary slot -> pr
 c01045f:	72616d69 6c732079 000d746f 464e495b     imary slot..[INF
 c01046f:	7245205d 6e697361 68742067 72702065     ] Erasing the pr
 c01047f:	72616d69 6c732079 000d746f 464e495b     imary slot..[INF
 c01048f:	6f43205d 6e697970 68742067 65732065     ] Copying the se
 c01049f:	646e6f63 20797261 746f6c73 206f7420     condary slot to 
 c0104af:	20656874 6d697270 20797261 746f6c73     the primary slot
 c0104bf:	7830203a 62207825 73657479 5b000a0d     : 0x%x bytes...[
 c0104cf:	5d525245 63655320 74697275 6f632079     ERR] Security co
 c0104df:	65746e75 70752072 65746164 69616620     unter update fai
 c0104ef:	2064656c 65746661 6d692072 20656761     led after image 
 c0104ff:	72677075 2e656461 455b000d 205d5252     upgrade...[ERR] 
 c01050f:	696e6170 000d2163 5252455b 6553205d     panic!..[ERR] Se
 c01051f:	69727563 63207974 746e756f 75207265     curity counter u
 c01052f:	74616470 61662065 64656c69 74666120     pdate failed aft
 c01053f:	69207265 6567616d 6c617620 74616469     er image validat
 c01054f:	2e6e6f69 455b000d 205d5252 6c696146     ion...[ERR] Fail
 c01055f:	74206465 6461206f 6d492064 20656761     ed to add Image 
 c01056f:	64207525 20617461 73206f74 65726168     %u data to share
 c01057f:	656d2064 79726f6d 65726120 000a0d61     d memory area...
 c01058f:	4e52575b 6143205d 746f6e6e 67707520     [WRN] Cannot upg
 c01059f:	65646172 6f6d203a 73206572 6f746365     rade: more secto
 c0105af:	74207372 206e6168 6f6c6c61 0d646577     rs than allowed.
 c0105bf:	52575b00 43205d4e 6f6e6e61 70752074     .[WRN] Cannot up
 c0105cf:	64617267 73203a65 73746f6c 76616820     grade: slots hav
 c0105df:	6f6e2065 6f632d6e 7461706d 656c6269     e non-compatible
 c0105ef:	63657320 73726f74 575b000d 205d4e52      sectors..[WRN] 
 c0105ff:	6e6e6143 7520746f 61726770 203a6564     Cannot upgrade: 
 c01060f:	746f6c73 72612073 6f6e2065 6f632074     slots are not co
 c01061f:	7461706d 656c6269 495b000d 205d464e     mpatible..[INF] 
 c01062f:	72617453 676e6974 6f6f6220 616f6c74     Starting bootloa
 c01063f:	0d726564 52455b00 45205d52 726f7272     der..[ERR] Error
 c01064f:	69687720 6920656c 6974696e 7a696c61      while initializ
 c01065f:	20676e69 20656874 75636573 79746972     ing the security
 c01066f:	756f6320 7265746e 455b000d 205d5252      counter..[ERR] 
 c01067f:	62616e55 7420656c 6966206f 6220646e     Unable to find b
 c01068f:	61746f6f 20656c62 67616d69 5b000d65     ootable image..[
 c01069f:	5d464e49 6f6f4220 616f6c74 20726564     INF] Bootloader 
 c0106af:	69616863 616f6c6e 64612064 73657264     chainload addres
 c0106bf:	666f2073 74657366 7830203a 0a0d7825     s offset: 0x%x..
 c0106cf:	4e495b00 4a205d46 69706d75 7420676e     .[INF] Jumping t
 c0106df:	6874206f 69662065 20747372 67616d69     o the first imag
 c0106ef:	6c732065 000d746f 5252455b 7245205d     e slot..[ERR] Er
 c0106ff:	20726f72 6c696877 6e752065 74696e69     ror while uninit
 c01070f:	696c6169 676e697a 616c4620 49206873     ializing Flash I
 c01071f:	7265746e 65636166 455b000d 205d5252     nterface..[ERR] 
 c01072f:	6576654e 68732072 646c756f 74656720     Never should get
 c01073f:	72656820 25000d65 75252e75 0075252e      here..%u.%u.%u.

0c01074f <sw_comp_ns.11963>:
 c01074f:	4550534e                                 NSPE.

0c010754 <sw_comp_ns_s.11964>:
 c010754:	4550534e 4550535f                        NSPE_SPE.

0c01075d <sw_comp_s.11962>:
 c01075d:	00455053                                 SPE....

0c010764 <flash_map>:
 c010764:	00000001 00017000 00024000 00000103     .....p...@......
 c010774:	00100000 00024000 00000102 00000000     .....@..........
 c010784:	00100000 00000104 00124000 00100000     .........@......
 c010794:	00006405 00001000 00000000 5252455b     .d..........[ERR
 c0107a4:	6e69205d 696c6176 6c662064 20687361     ] invalid flash 
 c0107b4:	61657261 0d444920 52455b00 69205d52     area ID..[ERR] i
 c0107c4:	6c61766e 66206469 6873616c 20444920     nvalid flash ID 
 c0107d4:	203b6425 65707865 64657463 20642520     %d; expected %d 
 c0107e4:	2520726f 000a0d64 5252455b 7261205d     or %d...[ERR] ar
 c0107f4:	25206165 69732064 3020657a 20782578     ea %d size 0x%x 
 c010804:	20746f6e 69766964 6c626973 79622065     not divisible by
 c010814:	63657320 20726f74 657a6973 25783020      sector size 0x%
 c010824:	000a0d78 5252455b 6c66205d 20687361     x...[ERR] flash 
 c010834:	61657261 20642520 74636573 6320726f     area %d sector c
 c010844:	746e756f 65766f20 6f6c6672 000a0d77     ount overflow...

0c010854 <_global_impure_ptr>:
 c010854:	300300ec                                ...0

0c010858 <__sf_fake_stderr>:
	...

0c010878 <__sf_fake_stdin>:
	...

0c010898 <__sf_fake_stdout>:
	...
 c0108b8:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 c0108c8:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 c0108d8:	31300046 35343332 39383736 64636261     F.0123456789abcd
 c0108e8:	00006665                                ef..

0c0108ec <__EH_FRAME_BEGIN__>:
 c0108ec:	00000000                                ....
