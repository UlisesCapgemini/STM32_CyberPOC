
TFM_Appli_NonSecure.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005a90  90000400  90000400  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  90005e90  90005e90  00005e90  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .copy.table   00000018  90005e98  90005e98  00005e98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .zero.table   00000010  90005eb0  90005eb0  00005eb0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .testprotection 00000004  20000000  20000000  00010000  2**2
                  ALLOC
  5 .data         00000094  20000100  90005ec0  00010100  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000000c8  20000194  90005f54  00010194  2**2
                  ALLOC
  7 .msp_stack    00000400  20000260  90006020  00010194  2**5
                  ALLOC
  8 .psp_stack    00000c00  20000660  90006420  00010194  2**5
                  ALLOC
  9 .heap         00001000  20001260  90007020  00010194  2**3
                  ALLOC
 10 .ARM.attributes 00000034  00000000  00000000  00010194  2**0
                  CONTENTS, READONLY
 11 .comment      0000007b  00000000  00000000  000101c8  2**0
                  CONTENTS, READONLY
 12 .debug_line   0000eb53  00000000  00000000  00010243  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00017fc2  00000000  00000000  0001ed96  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00003b39  00000000  00000000  00036d58  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000b70  00000000  00000000  0003a898  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0010db0a  00000000  00000000  0003b408  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc    000091a4  00000000  00000000  00148f12  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges 00000d50  00000000  00000000  001520b6  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macro  0002b86c  00000000  00000000  00152e06  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_frame  00002a24  00000000  00000000  0017e674  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stab         00000084  00000000  00000000  00181098  2**2
                  CONTENTS, READONLY, DEBUGGING
 22 .stabstr      00000117  00000000  00000000  0018111c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

90000400 <__Vectors>:
90000400:	20000660 	.word	0x20000660
90000404:	900006a9 	.word	0x900006a9
90000408:	90000b4d 	.word	0x90000b4d
9000040c:	90000b4f 	.word	0x90000b4f
90000410:	90000b51 	.word	0x90000b51
90000414:	90000b53 	.word	0x90000b53
90000418:	90000b55 	.word	0x90000b55
9000041c:	9000070d 	.word	0x9000070d
	...
9000042c:	90000711 	.word	0x90000711
90000430:	90000b57 	.word	0x90000b57
90000434:	00000000 	.word	0x00000000
90000438:	90000719 	.word	0x90000719
9000043c:	90000b59 	.word	0x90000b59
90000440:	90000721 	.word	0x90000721
90000444:	90000725 	.word	0x90000725
90000448:	90000729 	.word	0x90000729
9000044c:	9000072d 	.word	0x9000072d
90000450:	90000731 	.word	0x90000731
90000454:	90000735 	.word	0x90000735
90000458:	90000b5d 	.word	0x90000b5d
9000045c:	9000073d 	.word	0x9000073d
90000460:	90000741 	.word	0x90000741
90000464:	90000745 	.word	0x90000745
90000468:	90000749 	.word	0x90000749
9000046c:	9000074d 	.word	0x9000074d
90000470:	90000751 	.word	0x90000751
90000474:	90000755 	.word	0x90000755
90000478:	90000759 	.word	0x90000759
9000047c:	9000075d 	.word	0x9000075d
90000480:	90000761 	.word	0x90000761
90000484:	90000765 	.word	0x90000765
90000488:	90000769 	.word	0x90000769
9000048c:	9000076d 	.word	0x9000076d
90000490:	90000771 	.word	0x90000771
90000494:	90000775 	.word	0x90000775
90000498:	90000779 	.word	0x90000779
9000049c:	9000077d 	.word	0x9000077d
900004a0:	90000781 	.word	0x90000781
900004a4:	90000785 	.word	0x90000785
900004a8:	90000789 	.word	0x90000789
900004ac:	9000078d 	.word	0x9000078d
900004b0:	90000791 	.word	0x90000791
900004b4:	90000795 	.word	0x90000795
900004b8:	90000799 	.word	0x90000799
900004bc:	9000079d 	.word	0x9000079d
900004c0:	900007a1 	.word	0x900007a1
900004c4:	900007a5 	.word	0x900007a5
900004c8:	900007a9 	.word	0x900007a9
900004cc:	900007ad 	.word	0x900007ad
900004d0:	900007b1 	.word	0x900007b1
900004d4:	900007b5 	.word	0x900007b5
900004d8:	900007b9 	.word	0x900007b9
900004dc:	900007bd 	.word	0x900007bd
900004e0:	900007c1 	.word	0x900007c1
900004e4:	900007c5 	.word	0x900007c5
900004e8:	900007c9 	.word	0x900007c9
900004ec:	900007cd 	.word	0x900007cd
900004f0:	900007d1 	.word	0x900007d1
900004f4:	900007d5 	.word	0x900007d5
900004f8:	900007d9 	.word	0x900007d9
900004fc:	900007dd 	.word	0x900007dd
90000500:	900007e1 	.word	0x900007e1
90000504:	900007e5 	.word	0x900007e5
90000508:	900007e9 	.word	0x900007e9
9000050c:	900007ed 	.word	0x900007ed
90000510:	900007f1 	.word	0x900007f1
90000514:	900007f5 	.word	0x900007f5
90000518:	900007f9 	.word	0x900007f9
9000051c:	900007fd 	.word	0x900007fd
90000520:	90000801 	.word	0x90000801
90000524:	90000805 	.word	0x90000805
90000528:	90000809 	.word	0x90000809
9000052c:	9000080d 	.word	0x9000080d
90000530:	90000811 	.word	0x90000811
90000534:	90000815 	.word	0x90000815
90000538:	90000819 	.word	0x90000819
9000053c:	9000081d 	.word	0x9000081d
90000540:	90000821 	.word	0x90000821
90000544:	90000825 	.word	0x90000825
90000548:	90000829 	.word	0x90000829
9000054c:	9000082d 	.word	0x9000082d
90000550:	90000831 	.word	0x90000831
90000554:	90000835 	.word	0x90000835
90000558:	90000839 	.word	0x90000839
9000055c:	9000083d 	.word	0x9000083d
90000560:	90000841 	.word	0x90000841
90000564:	90000845 	.word	0x90000845
90000568:	90000849 	.word	0x90000849
9000056c:	9000084d 	.word	0x9000084d
90000570:	90000851 	.word	0x90000851
90000574:	00000000 	.word	0x00000000
90000578:	90000855 	.word	0x90000855
9000057c:	00000000 	.word	0x00000000
90000580:	90000859 	.word	0x90000859
90000584:	9000085d 	.word	0x9000085d
90000588:	90000861 	.word	0x90000861
9000058c:	90000865 	.word	0x90000865
90000590:	90000869 	.word	0x90000869
90000594:	9000086d 	.word	0x9000086d
90000598:	90000871 	.word	0x90000871
9000059c:	90000875 	.word	0x90000875
900005a0:	90000879 	.word	0x90000879
900005a4:	9000087d 	.word	0x9000087d
900005a8:	90000881 	.word	0x90000881
900005ac:	90000885 	.word	0x90000885
900005b0:	90000889 	.word	0x90000889
900005b4:	00000000 	.word	0x00000000
900005b8:	9000088d 	.word	0x9000088d
900005bc:	90000891 	.word	0x90000891
	...
900005c8:	90000895 	.word	0x90000895
900005cc:	90000899 	.word	0x90000899
900005d0:	9000089d 	.word	0x9000089d
900005d4:	900008a1 	.word	0x900008a1
900005d8:	900008a5 	.word	0x900008a5
900005dc:	900008a9 	.word	0x900008a9
900005e0:	900008ad 	.word	0x900008ad
900005e4:	900008b1 	.word	0x900008b1
900005e8:	900008b5 	.word	0x900008b5
900005ec:	900008b9 	.word	0x900008b9
900005f0:	900008bd 	.word	0x900008bd

900005f4 <__do_global_dtors_aux>:
900005f4:	b510      	push	{r4, lr}
900005f6:	4c05      	ldr	r4, [pc, #20]	; (9000060c <__do_global_dtors_aux+0x18>)
900005f8:	7823      	ldrb	r3, [r4, #0]
900005fa:	b933      	cbnz	r3, 9000060a <__do_global_dtors_aux+0x16>
900005fc:	4b04      	ldr	r3, [pc, #16]	; (90000610 <__do_global_dtors_aux+0x1c>)
900005fe:	b113      	cbz	r3, 90000606 <__do_global_dtors_aux+0x12>
90000600:	4804      	ldr	r0, [pc, #16]	; (90000614 <__do_global_dtors_aux+0x20>)
90000602:	e000      	b.n	90000606 <__do_global_dtors_aux+0x12>
90000604:	bf00      	nop
90000606:	2301      	movs	r3, #1
90000608:	7023      	strb	r3, [r4, #0]
9000060a:	bd10      	pop	{r4, pc}
9000060c:	20000194 	.word	0x20000194
90000610:	00000000 	.word	0x00000000
90000614:	90005e8c 	.word	0x90005e8c

90000618 <frame_dummy>:
90000618:	b508      	push	{r3, lr}
9000061a:	4b03      	ldr	r3, [pc, #12]	; (90000628 <frame_dummy+0x10>)
9000061c:	b11b      	cbz	r3, 90000626 <frame_dummy+0xe>
9000061e:	4903      	ldr	r1, [pc, #12]	; (9000062c <frame_dummy+0x14>)
90000620:	4803      	ldr	r0, [pc, #12]	; (90000630 <frame_dummy+0x18>)
90000622:	e000      	b.n	90000626 <frame_dummy+0xe>
90000624:	bf00      	nop
90000626:	bd08      	pop	{r3, pc}
90000628:	00000000 	.word	0x00000000
9000062c:	20000198 	.word	0x20000198
90000630:	90005e8c 	.word	0x90005e8c

90000634 <_mainCRTStartup>:
90000634:	4b15      	ldr	r3, [pc, #84]	; (9000068c <_mainCRTStartup+0x58>)
90000636:	2b00      	cmp	r3, #0
90000638:	bf08      	it	eq
9000063a:	4b13      	ldreq	r3, [pc, #76]	; (90000688 <_mainCRTStartup+0x54>)
9000063c:	469d      	mov	sp, r3
9000063e:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
90000642:	2100      	movs	r1, #0
90000644:	468b      	mov	fp, r1
90000646:	460f      	mov	r7, r1
90000648:	4813      	ldr	r0, [pc, #76]	; (90000698 <_mainCRTStartup+0x64>)
9000064a:	4a14      	ldr	r2, [pc, #80]	; (9000069c <_mainCRTStartup+0x68>)
9000064c:	1a12      	subs	r2, r2, r0
9000064e:	f002 ffc5 	bl	900035dc <memset>
90000652:	4b0f      	ldr	r3, [pc, #60]	; (90000690 <_mainCRTStartup+0x5c>)
90000654:	2b00      	cmp	r3, #0
90000656:	d000      	beq.n	9000065a <_mainCRTStartup+0x26>
90000658:	4798      	blx	r3
9000065a:	4b0e      	ldr	r3, [pc, #56]	; (90000694 <_mainCRTStartup+0x60>)
9000065c:	2b00      	cmp	r3, #0
9000065e:	d000      	beq.n	90000662 <_mainCRTStartup+0x2e>
90000660:	4798      	blx	r3
90000662:	2000      	movs	r0, #0
90000664:	2100      	movs	r1, #0
90000666:	0004      	movs	r4, r0
90000668:	000d      	movs	r5, r1
9000066a:	480d      	ldr	r0, [pc, #52]	; (900006a0 <_mainCRTStartup+0x6c>)
9000066c:	2800      	cmp	r0, #0
9000066e:	d002      	beq.n	90000676 <_mainCRTStartup+0x42>
90000670:	480c      	ldr	r0, [pc, #48]	; (900006a4 <_mainCRTStartup+0x70>)
90000672:	e000      	b.n	90000676 <_mainCRTStartup+0x42>
90000674:	bf00      	nop
90000676:	f002 ff73 	bl	90003560 <__libc_init_array>
9000067a:	0020      	movs	r0, r4
9000067c:	0029      	movs	r1, r5
9000067e:	f000 f9fd 	bl	90000a7c <main>
90000682:	f002 ff59 	bl	90003538 <exit>
90000686:	bf00      	nop
90000688:	00080000 	.word	0x00080000
9000068c:	20001260 	.word	0x20001260
	...
90000698:	20000194 	.word	0x20000194
9000069c:	2000025c 	.word	0x2000025c
	...

900006a8 <Reset_Handler>:
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr    r4, =__copy_table_start__
900006a8:	4c0f      	ldr	r4, [pc, #60]	; (900006e8 <Reset_Handler+0x40>)
    ldr    r5, =__copy_table_end__
900006aa:	4d10      	ldr	r5, [pc, #64]	; (900006ec <Reset_Handler+0x44>)

.L_loop0:
    cmp    r4, r5
900006ac:	42ac      	cmp	r4, r5
    bge    .L_loop0_done
900006ae:	da09      	bge.n	900006c4 <Reset_Handler+0x1c>
    ldr    r1, [r4]
900006b0:	6821      	ldr	r1, [r4, #0]
    ldr    r2, [r4, #4]
900006b2:	6862      	ldr	r2, [r4, #4]
    ldr    r3, [r4, #8]
900006b4:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
    subs    r3, #4
900006b6:	3b04      	subs	r3, #4
    ittt    ge
900006b8:	bfa2      	ittt	ge
    ldrge    r0, [r1, r3]
900006ba:	58c8      	ldrge	r0, [r1, r3]
    strge    r0, [r2, r3]
900006bc:	50d0      	strge	r0, [r2, r3]
    bge    .L_loop0_0
900006be:	e7fa      	bge.n	900006b6 <Reset_Handler+0xe>

    adds    r4, #12
900006c0:	340c      	adds	r4, #12
    b    .L_loop0
900006c2:	e7f3      	b.n	900006ac <Reset_Handler+0x4>
 *  Between symbol address __copy_table_start__ and __copy_table_end__,
 *  there are array of tuples specifying:
 *    offset 0: Start of a BSS section
 *    offset 4: Size of this BSS section. Must be multiply of 4
 */
    ldr    r3, =__zero_table_start__
900006c4:	4b0a      	ldr	r3, [pc, #40]	; (900006f0 <Reset_Handler+0x48>)
    ldr    r4, =__zero_table_end__
900006c6:	4c0b      	ldr	r4, [pc, #44]	; (900006f4 <Reset_Handler+0x4c>)

.L_loop2:
    cmp    r3, r4
900006c8:	42a3      	cmp	r3, r4
    bge    .L_loop2_done
900006ca:	da08      	bge.n	900006de <Reset_Handler+0x36>
    ldr    r1, [r3]
900006cc:	6819      	ldr	r1, [r3, #0]
    ldr    r2, [r3, #4]
900006ce:	685a      	ldr	r2, [r3, #4]
    movs    r0, 0
900006d0:	2000      	movs	r0, #0

.L_loop2_0:
    subs    r2, #4
900006d2:	3a04      	subs	r2, #4
    itt    ge
900006d4:	bfa4      	itt	ge
    strge    r0, [r1, r2]
900006d6:	5088      	strge	r0, [r1, r2]
    bge    .L_loop2_0
900006d8:	e7fb      	bge.n	900006d2 <Reset_Handler+0x2a>

    adds    r3, #8
900006da:	3308      	adds	r3, #8
    b    .L_loop2
900006dc:	e7f4      	b.n	900006c8 <Reset_Handler+0x20>

/*    mrs     r0, control   */ /* Get control value */
/*   orr     r0, r0, #1     *//* Select switch to unprivilage mode */
 /*   orr     r0, r0, #2    */ /* Select switch to PSP */
/*    msr     control, r0 */
    bl    SystemInit
900006de:	f000 fa3f 	bl	90000b60 <SystemInit>


#ifndef __START
#define __START _start
#endif
    bl    __START
900006e2:	f7ff ffa7 	bl	90000634 <_mainCRTStartup>
900006e6:	0000      	.short	0x0000
    ldr    r4, =__copy_table_start__
900006e8:	90005e98 	.word	0x90005e98
    ldr    r5, =__copy_table_end__
900006ec:	90005eb0 	.word	0x90005eb0
    ldr    r3, =__zero_table_start__
900006f0:	90005eb0 	.word	0x90005eb0
    ldr    r4, =__zero_table_end__
900006f4:	90005ec0 	.word	0x90005ec0
    .weak    \handler_name
    \handler_name:
    b        \handler_name
    .endm

   def_irq_handler             NMI_Handler
900006f8:	f000 ba28 	b.w	90000b4c <NMI_Handler>
   def_irq_handler             HardFault_Handler
900006fc:	f000 ba27 	b.w	90000b4e <HardFault_Handler>
   def_irq_handler             MemManage_Handler
90000700:	f000 ba26 	b.w	90000b50 <MemManage_Handler>
   def_irq_handler             BusFault_Handler
90000704:	f000 ba25 	b.w	90000b52 <BusFault_Handler>
   def_irq_handler             UsageFault_Handler
90000708:	f000 ba24 	b.w	90000b54 <UsageFault_Handler>

9000070c <SecureFault_Handler>:
   def_irq_handler             SecureFault_Handler
9000070c:	f7ff bffe 	b.w	9000070c <SecureFault_Handler>

90000710 <SVC_Handler>:
   def_irq_handler             SVC_Handler
90000710:	f7ff bffe 	b.w	90000710 <SVC_Handler>
   def_irq_handler             DebugMon_Handler
90000714:	f000 ba1f 	b.w	90000b56 <DebugMon_Handler>

90000718 <PendSV_Handler>:
   def_irq_handler             PendSV_Handler
90000718:	f7ff bffe 	b.w	90000718 <PendSV_Handler>
   def_irq_handler             SysTick_Handler
9000071c:	f000 ba1c 	b.w	90000b58 <SysTick_Handler>

90000720 <WWDG_IRQHandler>:
   def_irq_handler             WWDG_IRQHandler
90000720:	f7ff bffe 	b.w	90000720 <WWDG_IRQHandler>

90000724 <PVD_PVM_IRQHandler>:
   def_irq_handler             PVD_PVM_IRQHandler
90000724:	f7ff bffe 	b.w	90000724 <PVD_PVM_IRQHandler>

90000728 <RTC_IRQHandler>:
   def_irq_handler             RTC_IRQHandler
90000728:	f7ff bffe 	b.w	90000728 <RTC_IRQHandler>

9000072c <RTC_IRQHandler_S>:
   def_irq_handler             RTC_IRQHandler_S
9000072c:	f7ff bffe 	b.w	9000072c <RTC_IRQHandler_S>

90000730 <TAMP_IRQHandler>:
   def_irq_handler             TAMP_IRQHandler
90000730:	f7ff bffe 	b.w	90000730 <TAMP_IRQHandler>

90000734 <TAMP_IRQHandler_S>:
   def_irq_handler             TAMP_IRQHandler_S
90000734:	f7ff bffe 	b.w	90000734 <TAMP_IRQHandler_S>
   def_irq_handler             FLASH_IRQHandler
90000738:	f000 ba10 	b.w	90000b5c <FLASH_IRQHandler>

9000073c <FLASH_IRQHandler_S>:
   def_irq_handler             FLASH_IRQHandler_S
9000073c:	f7ff bffe 	b.w	9000073c <FLASH_IRQHandler_S>

90000740 <SERR_IRQHandler>:
   def_irq_handler             SERR_IRQHandler
90000740:	f7ff bffe 	b.w	90000740 <SERR_IRQHandler>

90000744 <RCC_IRQHandler>:
   def_irq_handler             RCC_IRQHandler
90000744:	f7ff bffe 	b.w	90000744 <RCC_IRQHandler>

90000748 <RCC_IRQHandler_S>:
   def_irq_handler             RCC_IRQHandler_S
90000748:	f7ff bffe 	b.w	90000748 <RCC_IRQHandler_S>

9000074c <EXTI0_IRQHandler>:
   def_irq_handler             EXTI0_IRQHandler
9000074c:	f7ff bffe 	b.w	9000074c <EXTI0_IRQHandler>

90000750 <EXTI1_IRQHandler>:
   def_irq_handler             EXTI1_IRQHandler
90000750:	f7ff bffe 	b.w	90000750 <EXTI1_IRQHandler>

90000754 <EXTI2_IRQHandler>:
   def_irq_handler             EXTI2_IRQHandler
90000754:	f7ff bffe 	b.w	90000754 <EXTI2_IRQHandler>

90000758 <EXTI3_IRQHandler>:
   def_irq_handler             EXTI3_IRQHandler
90000758:	f7ff bffe 	b.w	90000758 <EXTI3_IRQHandler>

9000075c <EXTI4_IRQHandler>:
   def_irq_handler             EXTI4_IRQHandler
9000075c:	f7ff bffe 	b.w	9000075c <EXTI4_IRQHandler>

90000760 <EXTI5_IRQHandler>:
   def_irq_handler             EXTI5_IRQHandler
90000760:	f7ff bffe 	b.w	90000760 <EXTI5_IRQHandler>

90000764 <EXTI6_IRQHandler>:
   def_irq_handler             EXTI6_IRQHandler
90000764:	f7ff bffe 	b.w	90000764 <EXTI6_IRQHandler>

90000768 <EXTI7_IRQHandler>:
   def_irq_handler             EXTI7_IRQHandler
90000768:	f7ff bffe 	b.w	90000768 <EXTI7_IRQHandler>

9000076c <EXTI8_IRQHandler>:
   def_irq_handler             EXTI8_IRQHandler
9000076c:	f7ff bffe 	b.w	9000076c <EXTI8_IRQHandler>

90000770 <EXTI9_IRQHandler>:
   def_irq_handler             EXTI9_IRQHandler
90000770:	f7ff bffe 	b.w	90000770 <EXTI9_IRQHandler>

90000774 <EXTI10_IRQHandler>:
   def_irq_handler             EXTI10_IRQHandler
90000774:	f7ff bffe 	b.w	90000774 <EXTI10_IRQHandler>

90000778 <EXTI11_IRQHandler>:
   def_irq_handler             EXTI11_IRQHandler
90000778:	f7ff bffe 	b.w	90000778 <EXTI11_IRQHandler>

9000077c <EXTI12_IRQHandler>:
   def_irq_handler             EXTI12_IRQHandler
9000077c:	f7ff bffe 	b.w	9000077c <EXTI12_IRQHandler>

90000780 <EXTI13_IRQHandler>:
   def_irq_handler             EXTI13_IRQHandler
90000780:	f7ff bffe 	b.w	90000780 <EXTI13_IRQHandler>

90000784 <EXTI14_IRQHandler>:
   def_irq_handler             EXTI14_IRQHandler
90000784:	f7ff bffe 	b.w	90000784 <EXTI14_IRQHandler>

90000788 <EXTI15_IRQHandler>:
   def_irq_handler             EXTI15_IRQHandler
90000788:	f7ff bffe 	b.w	90000788 <EXTI15_IRQHandler>

9000078c <DMAMUX1_IRQHandler>:
   def_irq_handler             DMAMUX1_IRQHandler
9000078c:	f7ff bffe 	b.w	9000078c <DMAMUX1_IRQHandler>

90000790 <DMAMUX1_IRQHandler_S>:
   def_irq_handler             DMAMUX1_IRQHandler_S
90000790:	f7ff bffe 	b.w	90000790 <DMAMUX1_IRQHandler_S>

90000794 <DMA1_Channel1_IRQHandler>:
   def_irq_handler             DMA1_Channel1_IRQHandler
90000794:	f7ff bffe 	b.w	90000794 <DMA1_Channel1_IRQHandler>

90000798 <DMA1_Channel2_IRQHandler>:
   def_irq_handler             DMA1_Channel2_IRQHandler
90000798:	f7ff bffe 	b.w	90000798 <DMA1_Channel2_IRQHandler>

9000079c <DMA1_Channel3_IRQHandler>:
   def_irq_handler             DMA1_Channel3_IRQHandler
9000079c:	f7ff bffe 	b.w	9000079c <DMA1_Channel3_IRQHandler>

900007a0 <DMA1_Channel4_IRQHandler>:
   def_irq_handler             DMA1_Channel4_IRQHandler
900007a0:	f7ff bffe 	b.w	900007a0 <DMA1_Channel4_IRQHandler>

900007a4 <DMA1_Channel5_IRQHandler>:
   def_irq_handler             DMA1_Channel5_IRQHandler
900007a4:	f7ff bffe 	b.w	900007a4 <DMA1_Channel5_IRQHandler>

900007a8 <DMA1_Channel6_IRQHandler>:
   def_irq_handler             DMA1_Channel6_IRQHandler
900007a8:	f7ff bffe 	b.w	900007a8 <DMA1_Channel6_IRQHandler>

900007ac <DMA1_Channel7_IRQHandler>:
   def_irq_handler             DMA1_Channel7_IRQHandler
900007ac:	f7ff bffe 	b.w	900007ac <DMA1_Channel7_IRQHandler>

900007b0 <DMA1_Channel8_IRQHandler>:
   def_irq_handler             DMA1_Channel8_IRQHandler
900007b0:	f7ff bffe 	b.w	900007b0 <DMA1_Channel8_IRQHandler>

900007b4 <ADC1_2_IRQHandler>:
   def_irq_handler             ADC1_2_IRQHandler
900007b4:	f7ff bffe 	b.w	900007b4 <ADC1_2_IRQHandler>

900007b8 <DAC_IRQHandler>:
   def_irq_handler             DAC_IRQHandler
900007b8:	f7ff bffe 	b.w	900007b8 <DAC_IRQHandler>

900007bc <FDCAN1_IT0_IRQHandler>:
   def_irq_handler             FDCAN1_IT0_IRQHandler
900007bc:	f7ff bffe 	b.w	900007bc <FDCAN1_IT0_IRQHandler>

900007c0 <FDCAN1_IT1_IRQHandler>:
   def_irq_handler             FDCAN1_IT1_IRQHandler
900007c0:	f7ff bffe 	b.w	900007c0 <FDCAN1_IT1_IRQHandler>

900007c4 <TIM1_BRK_IRQHandler>:
   def_irq_handler             TIM1_BRK_IRQHandler
900007c4:	f7ff bffe 	b.w	900007c4 <TIM1_BRK_IRQHandler>

900007c8 <TIM1_UP_IRQHandler>:
   def_irq_handler             TIM1_UP_IRQHandler
900007c8:	f7ff bffe 	b.w	900007c8 <TIM1_UP_IRQHandler>

900007cc <TIM1_TRG_COM_IRQHandler>:
   def_irq_handler             TIM1_TRG_COM_IRQHandler
900007cc:	f7ff bffe 	b.w	900007cc <TIM1_TRG_COM_IRQHandler>

900007d0 <TIM1_CC_IRQHandler>:
   def_irq_handler             TIM1_CC_IRQHandler
900007d0:	f7ff bffe 	b.w	900007d0 <TIM1_CC_IRQHandler>

900007d4 <TIM2_IRQHandler>:
   def_irq_handler             TIM2_IRQHandler
900007d4:	f7ff bffe 	b.w	900007d4 <TIM2_IRQHandler>

900007d8 <TIM3_IRQHandler>:
   def_irq_handler             TIM3_IRQHandler
900007d8:	f7ff bffe 	b.w	900007d8 <TIM3_IRQHandler>

900007dc <TIM4_IRQHandler>:
   def_irq_handler             TIM4_IRQHandler
900007dc:	f7ff bffe 	b.w	900007dc <TIM4_IRQHandler>

900007e0 <TIM5_IRQHandler>:
   def_irq_handler             TIM5_IRQHandler
900007e0:	f7ff bffe 	b.w	900007e0 <TIM5_IRQHandler>

900007e4 <TIM6_IRQHandler>:
   def_irq_handler             TIM6_IRQHandler
900007e4:	f7ff bffe 	b.w	900007e4 <TIM6_IRQHandler>

900007e8 <TIM7_IRQHandler>:
   def_irq_handler             TIM7_IRQHandler
900007e8:	f7ff bffe 	b.w	900007e8 <TIM7_IRQHandler>

900007ec <TIM8_BRK_IRQHandler>:
   def_irq_handler             TIM8_BRK_IRQHandler
900007ec:	f7ff bffe 	b.w	900007ec <TIM8_BRK_IRQHandler>

900007f0 <TIM8_UP_IRQHandler>:
   def_irq_handler             TIM8_UP_IRQHandler
900007f0:	f7ff bffe 	b.w	900007f0 <TIM8_UP_IRQHandler>

900007f4 <TIM8_TRG_COM_IRQHandler>:
   def_irq_handler             TIM8_TRG_COM_IRQHandler
900007f4:	f7ff bffe 	b.w	900007f4 <TIM8_TRG_COM_IRQHandler>

900007f8 <TIM8_CC_IRQHandler>:
   def_irq_handler             TIM8_CC_IRQHandler
900007f8:	f7ff bffe 	b.w	900007f8 <TIM8_CC_IRQHandler>

900007fc <I2C1_EV_IRQHandler>:
   def_irq_handler             I2C1_EV_IRQHandler
900007fc:	f7ff bffe 	b.w	900007fc <I2C1_EV_IRQHandler>

90000800 <I2C1_ER_IRQHandler>:
   def_irq_handler             I2C1_ER_IRQHandler
90000800:	f7ff bffe 	b.w	90000800 <I2C1_ER_IRQHandler>

90000804 <I2C2_EV_IRQHandler>:
   def_irq_handler             I2C2_EV_IRQHandler
90000804:	f7ff bffe 	b.w	90000804 <I2C2_EV_IRQHandler>

90000808 <I2C2_ER_IRQHandler>:
   def_irq_handler             I2C2_ER_IRQHandler
90000808:	f7ff bffe 	b.w	90000808 <I2C2_ER_IRQHandler>

9000080c <SPI1_IRQHandler>:
   def_irq_handler             SPI1_IRQHandler
9000080c:	f7ff bffe 	b.w	9000080c <SPI1_IRQHandler>

90000810 <SPI2_IRQHandler>:
   def_irq_handler             SPI2_IRQHandler
90000810:	f7ff bffe 	b.w	90000810 <SPI2_IRQHandler>

90000814 <USART1_IRQHandler>:
   def_irq_handler             USART1_IRQHandler
90000814:	f7ff bffe 	b.w	90000814 <USART1_IRQHandler>

90000818 <USART2_IRQHandler>:
   def_irq_handler             USART2_IRQHandler
90000818:	f7ff bffe 	b.w	90000818 <USART2_IRQHandler>

9000081c <USART3_IRQHandler>:
   def_irq_handler             USART3_IRQHandler
9000081c:	f7ff bffe 	b.w	9000081c <USART3_IRQHandler>

90000820 <UART4_IRQHandler>:
   def_irq_handler             UART4_IRQHandler
90000820:	f7ff bffe 	b.w	90000820 <UART4_IRQHandler>

90000824 <UART5_IRQHandler>:
   def_irq_handler             UART5_IRQHandler
90000824:	f7ff bffe 	b.w	90000824 <UART5_IRQHandler>

90000828 <LPUART1_IRQHandler>:
   def_irq_handler             LPUART1_IRQHandler
90000828:	f7ff bffe 	b.w	90000828 <LPUART1_IRQHandler>

9000082c <LPTIM1_IRQHandler>:
   def_irq_handler             LPTIM1_IRQHandler
9000082c:	f7ff bffe 	b.w	9000082c <LPTIM1_IRQHandler>

90000830 <LPTIM2_IRQHandler>:
   def_irq_handler             LPTIM2_IRQHandler
90000830:	f7ff bffe 	b.w	90000830 <LPTIM2_IRQHandler>

90000834 <TIM15_IRQHandler>:
   def_irq_handler             TIM15_IRQHandler
90000834:	f7ff bffe 	b.w	90000834 <TIM15_IRQHandler>

90000838 <TIM16_IRQHandler>:
   def_irq_handler             TIM16_IRQHandler
90000838:	f7ff bffe 	b.w	90000838 <TIM16_IRQHandler>

9000083c <TIM17_IRQHandler>:
   def_irq_handler             TIM17_IRQHandler
9000083c:	f7ff bffe 	b.w	9000083c <TIM17_IRQHandler>

90000840 <COMP_IRQHandler>:
   def_irq_handler             COMP_IRQHandler
90000840:	f7ff bffe 	b.w	90000840 <COMP_IRQHandler>

90000844 <USB_FS_IRQHandler>:
   def_irq_handler             USB_FS_IRQHandler
90000844:	f7ff bffe 	b.w	90000844 <USB_FS_IRQHandler>

90000848 <CRS_IRQHandler>:
   def_irq_handler             CRS_IRQHandler
90000848:	f7ff bffe 	b.w	90000848 <CRS_IRQHandler>

9000084c <FMC_IRQHandler>:
   def_irq_handler             FMC_IRQHandler
9000084c:	f7ff bffe 	b.w	9000084c <FMC_IRQHandler>

90000850 <OCTOSPI1_IRQHandler>:
   def_irq_handler             OCTOSPI1_IRQHandler
90000850:	f7ff bffe 	b.w	90000850 <OCTOSPI1_IRQHandler>

90000854 <SDMMC1_IRQHandler>:
   def_irq_handler             SDMMC1_IRQHandler
90000854:	f7ff bffe 	b.w	90000854 <SDMMC1_IRQHandler>

90000858 <DMA2_Channel1_IRQHandler>:
   def_irq_handler             DMA2_Channel1_IRQHandler
90000858:	f7ff bffe 	b.w	90000858 <DMA2_Channel1_IRQHandler>

9000085c <DMA2_Channel2_IRQHandler>:
   def_irq_handler             DMA2_Channel2_IRQHandler
9000085c:	f7ff bffe 	b.w	9000085c <DMA2_Channel2_IRQHandler>

90000860 <DMA2_Channel3_IRQHandler>:
   def_irq_handler             DMA2_Channel3_IRQHandler
90000860:	f7ff bffe 	b.w	90000860 <DMA2_Channel3_IRQHandler>

90000864 <DMA2_Channel4_IRQHandler>:
   def_irq_handler             DMA2_Channel4_IRQHandler
90000864:	f7ff bffe 	b.w	90000864 <DMA2_Channel4_IRQHandler>

90000868 <DMA2_Channel5_IRQHandler>:
   def_irq_handler             DMA2_Channel5_IRQHandler
90000868:	f7ff bffe 	b.w	90000868 <DMA2_Channel5_IRQHandler>

9000086c <DMA2_Channel6_IRQHandler>:
   def_irq_handler             DMA2_Channel6_IRQHandler
9000086c:	f7ff bffe 	b.w	9000086c <DMA2_Channel6_IRQHandler>

90000870 <DMA2_Channel7_IRQHandler>:
   def_irq_handler             DMA2_Channel7_IRQHandler
90000870:	f7ff bffe 	b.w	90000870 <DMA2_Channel7_IRQHandler>

90000874 <DMA2_Channel8_IRQHandler>:
   def_irq_handler             DMA2_Channel8_IRQHandler
90000874:	f7ff bffe 	b.w	90000874 <DMA2_Channel8_IRQHandler>

90000878 <I2C3_EV_IRQHandler>:
   def_irq_handler             I2C3_EV_IRQHandler
90000878:	f7ff bffe 	b.w	90000878 <I2C3_EV_IRQHandler>

9000087c <I2C3_ER_IRQHandler>:
   def_irq_handler             I2C3_ER_IRQHandler
9000087c:	f7ff bffe 	b.w	9000087c <I2C3_ER_IRQHandler>

90000880 <SAI1_IRQHandler>:
   def_irq_handler             SAI1_IRQHandler
90000880:	f7ff bffe 	b.w	90000880 <SAI1_IRQHandler>

90000884 <SAI2_IRQHandler>:
   def_irq_handler             SAI2_IRQHandler
90000884:	f7ff bffe 	b.w	90000884 <SAI2_IRQHandler>

90000888 <TSC_IRQHandler>:
   def_irq_handler             TSC_IRQHandler
90000888:	f7ff bffe 	b.w	90000888 <TSC_IRQHandler>

9000088c <RNG_IRQHandler>:
   def_irq_handler             RNG_IRQHandler
9000088c:	f7ff bffe 	b.w	9000088c <RNG_IRQHandler>

90000890 <FPU_IRQHandler>:
   def_irq_handler             FPU_IRQHandler
90000890:	f7ff bffe 	b.w	90000890 <FPU_IRQHandler>

90000894 <LPTIM3_IRQHandler>:
   def_irq_handler             LPTIM3_IRQHandler
90000894:	f7ff bffe 	b.w	90000894 <LPTIM3_IRQHandler>

90000898 <SPI3_IRQHandler>:
   def_irq_handler             SPI3_IRQHandler
90000898:	f7ff bffe 	b.w	90000898 <SPI3_IRQHandler>

9000089c <I2C4_ER_IRQHandler>:
   def_irq_handler             I2C4_ER_IRQHandler
9000089c:	f7ff bffe 	b.w	9000089c <I2C4_ER_IRQHandler>

900008a0 <I2C4_EV_IRQHandler>:
   def_irq_handler             I2C4_EV_IRQHandler
900008a0:	f7ff bffe 	b.w	900008a0 <I2C4_EV_IRQHandler>

900008a4 <DFSDM1_FLT0_IRQHandler>:
   def_irq_handler             DFSDM1_FLT0_IRQHandler
900008a4:	f7ff bffe 	b.w	900008a4 <DFSDM1_FLT0_IRQHandler>

900008a8 <DFSDM1_FLT1_IRQHandler>:
   def_irq_handler             DFSDM1_FLT1_IRQHandler
900008a8:	f7ff bffe 	b.w	900008a8 <DFSDM1_FLT1_IRQHandler>

900008ac <DFSDM1_FLT2_IRQHandler>:
   def_irq_handler             DFSDM1_FLT2_IRQHandler
900008ac:	f7ff bffe 	b.w	900008ac <DFSDM1_FLT2_IRQHandler>

900008b0 <DFSDM1_FLT3_IRQHandler>:
   def_irq_handler             DFSDM1_FLT3_IRQHandler
900008b0:	f7ff bffe 	b.w	900008b0 <DFSDM1_FLT3_IRQHandler>

900008b4 <UCPD1_IRQHandler>:
   def_irq_handler             UCPD1_IRQHandler
900008b4:	f7ff bffe 	b.w	900008b4 <UCPD1_IRQHandler>

900008b8 <ICACHE_IRQHandler>:
   def_irq_handler             ICACHE_IRQHandler
900008b8:	f7ff bffe 	b.w	900008b8 <ICACHE_IRQHandler>

900008bc <OTFDEC1_IRQHandler>:
   def_irq_handler             OTFDEC1_IRQHandler
900008bc:	f7ff bffe 	b.w	900008bc <OTFDEC1_IRQHandler>

900008c0 <COM_Init>:
  * @brief  Initialize COM module.
  * @param  None.
  * @retval HAL Status.
  */
HAL_StatusTypeDef  COM_Init(void)
{
900008c0:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
900008c2:	4b10      	ldr	r3, [pc, #64]	; (90000904 <COM_Init+0x44>)
900008c4:	2202      	movs	r2, #2
900008c6:	6818      	ldr	r0, [r3, #0]
900008c8:	2300      	movs	r3, #0
900008ca:	6880      	ldr	r0, [r0, #8]
900008cc:	4619      	mov	r1, r3
900008ce:	f002 ff09 	bl	900036e4 <setvbuf>
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = COM_UART;
  UartHandle.Init.BaudRate = 115200U;
900008d2:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  UartHandle.Instance = COM_UART;
900008d6:	480c      	ldr	r0, [pc, #48]	; (90000908 <COM_Init+0x48>)
  UartHandle.Init.BaudRate = 115200U;
900008d8:	4a0c      	ldr	r2, [pc, #48]	; (9000090c <COM_Init+0x4c>)
900008da:	e9c0 2300 	strd	r2, r3, [r0]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
900008de:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
900008e0:	e9c0 3302 	strd	r3, r3, [r0, #8]
  UartHandle.Init.Parity = UART_PARITY_NONE;
900008e4:	6103      	str	r3, [r0, #16]
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
900008e6:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
900008e8:	230c      	movs	r3, #12
900008ea:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
900008ec:	2310      	movs	r3, #16
900008ee:	6283      	str	r3, [r0, #40]	; 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
900008f0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
900008f4:	63c3      	str	r3, [r0, #60]	; 0x3c
  UartHandle.FifoMode = UART_FIFOMODE_ENABLE;
900008f6:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
900008fa:	6643      	str	r3, [r0, #100]	; 0x64
  return HAL_UART_Init(&UartHandle);
}
900008fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return HAL_UART_Init(&UartHandle);
90000900:	f001 bd4d 	b.w	9000239e <HAL_UART_Init>
90000904:	20000128 	.word	0x20000128
90000908:	200001b0 	.word	0x200001b0
9000090c:	40013800 	.word	0x40013800

90000910 <HAL_UART_MspInit>:
  * @brief  UART MSP Init.
  * @param  huart: UART handler pointer.
  * @retval None.
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
90000910:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == COM_UART)
90000912:	6802      	ldr	r2, [r0, #0]
90000914:	4b1e      	ldr	r3, [pc, #120]	; (90000990 <HAL_UART_MspInit+0x80>)
{
90000916:	b089      	sub	sp, #36	; 0x24
  if (huart->Instance == COM_UART)
90000918:	429a      	cmp	r2, r3
9000091a:	d136      	bne.n	9000098a <HAL_UART_MspInit+0x7a>
  {
    /* Peripheral Clock Enable */
    COM_UART_CLK_ENABLE();
9000091c:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
90000920:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    COM_UART_TX_GPIO_CLK_ENABLE();
    COM_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : COM_UART_TX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000922:	2702      	movs	r7, #2
    COM_UART_CLK_ENABLE();
90000924:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
90000928:	661a      	str	r2, [r3, #96]	; 0x60
9000092a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
9000092c:	2600      	movs	r6, #0
    COM_UART_CLK_ENABLE();
9000092e:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
90000932:	9200      	str	r2, [sp, #0]
90000934:	9a00      	ldr	r2, [sp, #0]
    COM_UART_TX_GPIO_CLK_ENABLE();
90000936:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000938:	2503      	movs	r5, #3
    COM_UART_TX_GPIO_CLK_ENABLE();
9000093a:	f042 0201 	orr.w	r2, r2, #1
9000093e:	64da      	str	r2, [r3, #76]	; 0x4c
90000940:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
90000942:	2407      	movs	r4, #7
    COM_UART_TX_GPIO_CLK_ENABLE();
90000944:	f002 0201 	and.w	r2, r2, #1
90000948:	9201      	str	r2, [sp, #4]
9000094a:	9a01      	ldr	r2, [sp, #4]
    COM_UART_RX_GPIO_CLK_ENABLE();
9000094c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
9000094e:	a903      	add	r1, sp, #12
    COM_UART_RX_GPIO_CLK_ENABLE();
90000950:	f042 0201 	orr.w	r2, r2, #1
90000954:	64da      	str	r2, [r3, #76]	; 0x4c
90000956:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
90000958:	480e      	ldr	r0, [pc, #56]	; (90000994 <HAL_UART_MspInit+0x84>)
    COM_UART_RX_GPIO_CLK_ENABLE();
9000095a:	f003 0301 	and.w	r3, r3, #1
9000095e:	9302      	str	r3, [sp, #8]
90000960:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
90000962:	f44f 7300 	mov.w	r3, #512	; 0x200
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000966:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000096a:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
9000096e:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
90000970:	f001 f8b8 	bl	90001ae4 <HAL_GPIO_Init>

    /*Configure GPIO pins : COM_UART_RX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_RX_PIN;
90000974:	f44f 6380 	mov.w	r3, #1024	; 0x400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
90000978:	a903      	add	r1, sp, #12
9000097a:	4806      	ldr	r0, [pc, #24]	; (90000994 <HAL_UART_MspInit+0x84>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
9000097c:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
90000980:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
90000984:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
90000986:	f001 f8ad 	bl	90001ae4 <HAL_GPIO_Init>

  }

}
9000098a:	b009      	add	sp, #36	; 0x24
9000098c:	bdf0      	pop	{r4, r5, r6, r7, pc}
9000098e:	bf00      	nop
90000990:	40013800 	.word	0x40013800
90000994:	42020000 	.word	0x42020000

90000998 <COM_Transmit>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Transmit operation.
  */
HAL_StatusTypeDef COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
90000998:	4613      	mov	r3, r2
9000099a:	460a      	mov	r2, r1
9000099c:	4601      	mov	r1, r0
9000099e:	4801      	ldr	r0, [pc, #4]	; (900009a4 <COM_Transmit+0xc>)
900009a0:	f001 bbf6 	b.w	90002190 <HAL_UART_Transmit>
900009a4:	200001b0 	.word	0x200001b0

900009a8 <COM_Receive>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Receive operation.
  */
HAL_StatusTypeDef COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
900009a8:	4613      	mov	r3, r2
900009aa:	460a      	mov	r2, r1
900009ac:	4601      	mov	r1, r0
900009ae:	4801      	ldr	r0, [pc, #4]	; (900009b4 <COM_Receive+0xc>)
900009b0:	f001 bc4a 	b.w	90002248 <HAL_UART_Receive>
900009b4:	200001b0 	.word	0x200001b0

900009b8 <COM_Flush>:
  * @retval HAL_Status.
  */
HAL_StatusTypeDef COM_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
900009b8:	4b05      	ldr	r3, [pc, #20]	; (900009d0 <COM_Flush+0x18>)
  return HAL_OK;
}
900009ba:	2000      	movs	r0, #0
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
900009bc:	681b      	ldr	r3, [r3, #0]
900009be:	699a      	ldr	r2, [r3, #24]
900009c0:	f042 0208 	orr.w	r2, r2, #8
900009c4:	619a      	str	r2, [r3, #24]
900009c6:	699a      	ldr	r2, [r3, #24]
900009c8:	f042 0210 	orr.w	r2, r2, #16
900009cc:	619a      	str	r2, [r3, #24]
}
900009ce:	4770      	bx	lr
900009d0:	200001b0 	.word	0x200001b0

900009d4 <_write>:
  return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
900009d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
900009d6:	460e      	mov	r6, r1
900009d8:	4615      	mov	r5, r2
  int i;

  for (i = 0; i < len; i++)
900009da:	460c      	mov	r4, r1
900009dc:	1ba3      	subs	r3, r4, r6
900009de:	429d      	cmp	r5, r3
900009e0:	dc02      	bgt.n	900009e8 <_write+0x14>
    uart_putc(str[i]);
  }

  /* Return the number of characters written */
  return len;
}
900009e2:	4628      	mov	r0, r5
900009e4:	b002      	add	sp, #8
900009e6:	bd70      	pop	{r4, r5, r6, pc}
    uart_putc(str[i]);
900009e8:	f814 3b01 	ldrb.w	r3, [r4], #1
  COM_Transmit(&c, 1, 1000U);
900009ec:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
900009f0:	2101      	movs	r1, #1
900009f2:	f10d 0007 	add.w	r0, sp, #7
900009f6:	f88d 3007 	strb.w	r3, [sp, #7]
900009fa:	f7ff ffcd 	bl	90000998 <COM_Transmit>
900009fe:	e7ed      	b.n	900009dc <_write+0x8>

90000a00 <FW_APP_PrintMainMenu>:
  * @brief  Display the TEST Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
void FW_APP_PrintMainMenu(void)
{
90000a00:	b508      	push	{r3, lr}
  printf("\r\n=================== Main Menu ============================\r\n\n");
90000a02:	4807      	ldr	r0, [pc, #28]	; (90000a20 <FW_APP_PrintMainMenu+0x20>)
90000a04:	f002 fe66 	bl	900036d4 <puts>
  printf("  Test Protections -------------------------------------- 1\r\n\n");
90000a08:	4806      	ldr	r0, [pc, #24]	; (90000a24 <FW_APP_PrintMainMenu+0x24>)
90000a0a:	f002 fe63 	bl	900036d4 <puts>
  printf("  Test TFM ---------------------------------------------- 2\r\n\n");
90000a0e:	4806      	ldr	r0, [pc, #24]	; (90000a28 <FW_APP_PrintMainMenu+0x28>)
90000a10:	f002 fe60 	bl	900036d4 <puts>
#if !defined(TFM_EXTERNAL_FLASH_ENABLE)
  printf("  Download a new Fw Image ------------------------------- 3\r\n\n");
#endif /* !TFM_EXTERNAL_FLASH_ENABLE */
  printf("  Selection :\r\n\n");
}
90000a14:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Selection :\r\n\n");
90000a18:	4804      	ldr	r0, [pc, #16]	; (90000a2c <FW_APP_PrintMainMenu+0x2c>)
90000a1a:	f002 be5b 	b.w	900036d4 <puts>
90000a1e:	bf00      	nop
90000a20:	900049c0 	.word	0x900049c0
90000a24:	900049ff 	.word	0x900049ff
90000a28:	90004a3d 	.word	0x90004a3d
90000a2c:	90004a7b 	.word	0x90004a7b

90000a30 <FW_APP_Run>:
  * @param  None.
  * @retval None.
  */
void FW_APP_Run(void)
{
  uint8_t key = 0U;
90000a30:	2300      	movs	r3, #0
{
90000a32:	b507      	push	{r0, r1, r2, lr}
  uint8_t key = 0U;
90000a34:	ac02      	add	r4, sp, #8
90000a36:	f804 3d01 	strb.w	r3, [r4, #-1]!

  /*##1- Print Main Menu message*/
  FW_APP_PrintMainMenu();
90000a3a:	f7ff ffe1 	bl	90000a00 <FW_APP_PrintMainMenu>
        case '3' :
          FW_UPDATE_Run();
          break;
#endif /* !TFM_EXTERNAL_FLASH_ENABLE */
        default:
          printf("Invalid Number !\r");
90000a3e:	4d0e      	ldr	r5, [pc, #56]	; (90000a78 <FW_APP_Run+0x48>)
    COM_Flush();
90000a40:	f7ff ffba 	bl	900009b8 <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
90000a44:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
90000a48:	2101      	movs	r1, #1
90000a4a:	4620      	mov	r0, r4
90000a4c:	f7ff ffac 	bl	900009a8 <COM_Receive>
90000a50:	2800      	cmp	r0, #0
90000a52:	d1f5      	bne.n	90000a40 <FW_APP_Run+0x10>
      switch (key)
90000a54:	f89d 3007 	ldrb.w	r3, [sp, #7]
90000a58:	2b31      	cmp	r3, #49	; 0x31
90000a5a:	d005      	beq.n	90000a68 <FW_APP_Run+0x38>
90000a5c:	2b32      	cmp	r3, #50	; 0x32
90000a5e:	d008      	beq.n	90000a72 <FW_APP_Run+0x42>
          printf("Invalid Number !\r");
90000a60:	4628      	mov	r0, r5
90000a62:	f002 fdc3 	bl	900035ec <iprintf>
          break;
90000a66:	e001      	b.n	90000a6c <FW_APP_Run+0x3c>
          TEST_PROTECTIONS_Run();
90000a68:	f000 f9cc 	bl	90000e04 <TEST_PROTECTIONS_Run>
      }

      /*Print Main Menu message*/
      FW_APP_PrintMainMenu();
90000a6c:	f7ff ffc8 	bl	90000a00 <FW_APP_PrintMainMenu>
90000a70:	e7e6      	b.n	90000a40 <FW_APP_Run+0x10>
          tfm_app_menu();
90000a72:	f000 fbc1 	bl	900011f8 <tfm_app_menu>
          break;
90000a76:	e7f9      	b.n	90000a6c <FW_APP_Run+0x3c>
90000a78:	90004a8b 	.word	0x90004a8b

90000a7c <main>:
{
90000a7c:	b508      	push	{r3, lr}
  pUserAppId = (uint8_t *)&UserAppId;
90000a7e:	4c12      	ldr	r4, [pc, #72]	; (90000ac8 <main+0x4c>)
90000a80:	4b12      	ldr	r3, [pc, #72]	; (90000acc <main+0x50>)
90000a82:	6023      	str	r3, [r4, #0]
  HAL_Init();
90000a84:	f000 fe24 	bl	900016d0 <HAL_Init>
  COM_Init();
90000a88:	f7ff ff1a 	bl	900008c0 <COM_Init>
  if (TestNumber & TEST_PROTECTION_MASK)
90000a8c:	4b10      	ldr	r3, [pc, #64]	; (90000ad0 <main+0x54>)
90000a8e:	681a      	ldr	r2, [r3, #0]
90000a90:	4b10      	ldr	r3, [pc, #64]	; (90000ad4 <main+0x58>)
90000a92:	421a      	tst	r2, r3
90000a94:	d001      	beq.n	90000a9a <main+0x1e>
    TEST_PROTECTIONS_Run_SecUserMem();
90000a96:	f000 f8d7 	bl	90000c48 <TEST_PROTECTIONS_Run_SecUserMem>
  printf("\r\n======================================================================");
90000a9a:	480f      	ldr	r0, [pc, #60]	; (90000ad8 <main+0x5c>)
90000a9c:	f002 fda6 	bl	900035ec <iprintf>
  printf("\r\n=              (C) COPYRIGHT 2019 STMicroelectronics                 =");
90000aa0:	480e      	ldr	r0, [pc, #56]	; (90000adc <main+0x60>)
90000aa2:	f002 fda3 	bl	900035ec <iprintf>
  printf("\r\n=                                                                    =");
90000aa6:	480e      	ldr	r0, [pc, #56]	; (90000ae0 <main+0x64>)
90000aa8:	f002 fda0 	bl	900035ec <iprintf>
  printf("\r\n=                          User App #%c                               =", *pUserAppId);
90000aac:	6823      	ldr	r3, [r4, #0]
90000aae:	480d      	ldr	r0, [pc, #52]	; (90000ae4 <main+0x68>)
90000ab0:	7819      	ldrb	r1, [r3, #0]
90000ab2:	f002 fd9b 	bl	900035ec <iprintf>
  printf("\r\n======================================================================");
90000ab6:	4808      	ldr	r0, [pc, #32]	; (90000ad8 <main+0x5c>)
90000ab8:	f002 fd98 	bl	900035ec <iprintf>
  printf("\r\n\r\n");
90000abc:	480a      	ldr	r0, [pc, #40]	; (90000ae8 <main+0x6c>)
90000abe:	f002 fe09 	bl	900036d4 <puts>
  FW_APP_Run();
90000ac2:	f7ff ffb5 	bl	90000a30 <FW_APP_Run>
90000ac6:	bf00      	nop
90000ac8:	20000250 	.word	0x20000250
90000acc:	90004a9d 	.word	0x90004a9d
90000ad0:	20000000 	.word	0x20000000
90000ad4:	dead0000 	.word	0xdead0000
90000ad8:	90004a9e 	.word	0x90004a9e
90000adc:	90004ae7 	.word	0x90004ae7
90000ae0:	90004b30 	.word	0x90004b30
90000ae4:	90004b79 	.word	0x90004b79
90000ae8:	90004bc3 	.word	0x90004bc3

90000aec <mpu_armv8m_region_enable>:
  uint32_t ctrl_before;
  uint32_t base_cfg;
  uint32_t limit_cfg;

  /*FIXME : Add complete error checking*/
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
90000aec:	684a      	ldr	r2, [r1, #4]
{
90000aee:	b530      	push	{r4, r5, lr}
  if ((region_cfg->region_base & ~MPU_RBAR_BASE_Msk) != 0)
90000af0:	f012 051f 	ands.w	r5, r2, #31
90000af4:	d128      	bne.n	90000b48 <mpu_armv8m_region_enable+0x5c>
  MPU_Type *mpu = (MPU_Type *)dev->base;
90000af6:	6804      	ldr	r4, [r0, #0]
   */

  ctrl_before = mpu->CTRL;
  mpu->CTRL = 0;

  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
90000af8:	780b      	ldrb	r3, [r1, #0]
  ctrl_before = mpu->CTRL;
90000afa:	6860      	ldr	r0, [r4, #4]
  mpu->CTRL = 0;
90000afc:	6065      	str	r5, [r4, #4]
  mpu->RNR  = region_cfg->region_nr & MPU_RNR_REGION_Msk;
90000afe:	60a3      	str	r3, [r4, #8]

  /* This 0s the lower bits of the base address */
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
90000b00:	7c0b      	ldrb	r3, [r1, #16]
  base_cfg = region_cfg->region_base & MPU_RBAR_BASE_Msk;
90000b02:	f022 021f 	bic.w	r2, r2, #31
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
90000b06:	f003 0301 	and.w	r3, r3, #1
90000b0a:	4313      	orrs	r3, r2
  base_cfg |= (region_cfg->attr_sh << MPU_RBAR_SH_Pos) & MPU_RBAR_SH_Msk;
90000b0c:	7c8a      	ldrb	r2, [r1, #18]
90000b0e:	00d2      	lsls	r2, r2, #3
90000b10:	f002 0218 	and.w	r2, r2, #24
90000b14:	431a      	orrs	r2, r3
  base_cfg |= (region_cfg->attr_access << MPU_RBAR_AP_Pos) & MPU_RBAR_AP_Msk;
90000b16:	7c4b      	ldrb	r3, [r1, #17]
90000b18:	005b      	lsls	r3, r3, #1
90000b1a:	f003 0306 	and.w	r3, r3, #6
  base_cfg |= (region_cfg->attr_exec << MPU_RBAR_XN_Pos) & MPU_RBAR_XN_Msk;
90000b1e:	4313      	orrs	r3, r2

  mpu->RBAR = base_cfg;
90000b20:	60e3      	str	r3, [r4, #12]

  /*This 0s the lower bits of base address but they are treated as 1 */
  limit_cfg = (region_cfg->region_limit - 1) & MPU_RLAR_LIMIT_Msk;
90000b22:	688b      	ldr	r3, [r1, #8]
90000b24:	3b01      	subs	r3, #1
90000b26:	f023 021f 	bic.w	r2, r3, #31

  limit_cfg |= (region_cfg->region_attridx << MPU_RLAR_AttrIndx_Pos) &
90000b2a:	68cb      	ldr	r3, [r1, #12]
90000b2c:	005b      	lsls	r3, r3, #1
90000b2e:	f003 030e 	and.w	r3, r3, #14
90000b32:	4313      	orrs	r3, r2
               MPU_RLAR_AttrIndx_Msk;

  limit_cfg |= MPU_RLAR_EN_Msk;
90000b34:	f043 0301 	orr.w	r3, r3, #1

  mpu->RLAR = limit_cfg;
90000b38:	6123      	str	r3, [r4, #16]

  /*Restore main MPU control*/
  mpu->CTRL = ctrl_before;
90000b3a:	6060      	str	r0, [r4, #4]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
90000b3c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
90000b40:	f3bf 8f6f 	isb	sy

  /* Enable MPU before the next instruction */
  __DSB();
  __ISB();

  return ret_val;
90000b44:	4628      	mov	r0, r5
}
90000b46:	bd30      	pop	{r4, r5, pc}
    return MPU_ARMV8M_ERROR;
90000b48:	2001      	movs	r0, #1
90000b4a:	e7fc      	b.n	90000b46 <mpu_armv8m_region_enable+0x5a>

90000b4c <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
90000b4c:	4770      	bx	lr

90000b4e <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
90000b4e:	e7fe      	b.n	90000b4e <HardFault_Handler>

90000b50 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
90000b50:	e7fe      	b.n	90000b50 <MemManage_Handler>

90000b52 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
90000b52:	e7fe      	b.n	90000b52 <BusFault_Handler>

90000b54 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
90000b54:	e7fe      	b.n	90000b54 <UsageFault_Handler>

90000b56 <DebugMon_Handler>:
90000b56:	4770      	bx	lr

90000b58 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
90000b58:	f000 bdcc 	b.w	900016f4 <HAL_IncTick>

90000b5c <FLASH_IRQHandler>:
  * @param  None
  * @retval None
  */
void FLASH_IRQHandler(void)
{
  HAL_FLASH_IRQHandler();
90000b5c:	f000 be4c 	b.w	900017f8 <HAL_FLASH_IRQHandler>

90000b60 <SystemInit>:

void SystemInit(void)
{
#if defined (__VTOR_PRESENT) && (__VTOR_PRESENT == 1U)
extern uint32_t __Vectors;
  SCB->VTOR = (uint32_t) &__Vectors;
90000b60:	4b04      	ldr	r3, [pc, #16]	; (90000b74 <SystemInit+0x14>)
90000b62:	4a05      	ldr	r2, [pc, #20]	; (90000b78 <SystemInit+0x18>)
90000b64:	609a      	str	r2, [r3, #8]
#endif
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
90000b66:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
90000b6a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
90000b6e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif
}
90000b72:	4770      	bx	lr
90000b74:	e000ed00 	.word	0xe000ed00
90000b78:	90000400 	.word	0x90000400

90000b7c <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
90000b7c:	4a21      	ldr	r2, [pc, #132]	; (90000c04 <SystemCoreClockUpdate+0x88>)
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
90000b7e:	4922      	ldr	r1, [pc, #136]	; (90000c08 <SystemCoreClockUpdate+0x8c>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
90000b80:	6813      	ldr	r3, [r2, #0]
{
90000b82:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
90000b84:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
90000b86:	bf55      	itete	pl
90000b88:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
90000b8c:	6813      	ldrmi	r3, [r2, #0]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
90000b8e:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
90000b92:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  msirange = MSIRangeTable[msirange];
90000b96:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
90000b9a:	6891      	ldr	r1, [r2, #8]
90000b9c:	481b      	ldr	r0, [pc, #108]	; (90000c0c <SystemCoreClockUpdate+0x90>)
90000b9e:	f001 010c 	and.w	r1, r1, #12
90000ba2:	2908      	cmp	r1, #8
90000ba4:	d003      	beq.n	90000bae <SystemCoreClockUpdate+0x32>
90000ba6:	290c      	cmp	r1, #12
90000ba8:	d00c      	beq.n	90000bc4 <SystemCoreClockUpdate+0x48>
90000baa:	2904      	cmp	r1, #4
90000bac:	d127      	bne.n	90000bfe <SystemCoreClockUpdate+0x82>
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
      break;

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
90000bae:	4b18      	ldr	r3, [pc, #96]	; (90000c10 <SystemCoreClockUpdate+0x94>)
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
      SystemCoreClock = pllvco/pllr;
90000bb0:	6003      	str	r3, [r0, #0]
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
90000bb2:	6893      	ldr	r3, [r2, #8]
90000bb4:	4a17      	ldr	r2, [pc, #92]	; (90000c14 <SystemCoreClockUpdate+0x98>)
90000bb6:	f3c3 1303 	ubfx	r3, r3, #4, #4
90000bba:	5cd2      	ldrb	r2, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
90000bbc:	6803      	ldr	r3, [r0, #0]
90000bbe:	40d3      	lsrs	r3, r2
90000bc0:	6003      	str	r3, [r0, #0]
}
90000bc2:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
90000bc4:	68d1      	ldr	r1, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
90000bc6:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
90000bc8:	f001 0103 	and.w	r1, r1, #3
      switch (pllsource)
90000bcc:	3902      	subs	r1, #2
90000bce:	2901      	cmp	r1, #1
          pllvco = (HSE_VALUE / pllm);
90000bd0:	bf98      	it	ls
90000bd2:	490f      	ldrls	r1, [pc, #60]	; (90000c10 <SystemCoreClockUpdate+0x94>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
90000bd4:	f3c3 1303 	ubfx	r3, r3, #4, #4
90000bd8:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
90000bdc:	bf94      	ite	ls
90000bde:	fbb1 f3f3 	udivls	r3, r1, r3
          pllvco = (msirange / pllm);
90000be2:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
90000be6:	68d4      	ldr	r4, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
90000be8:	68d1      	ldr	r1, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
90000bea:	f3c4 2406 	ubfx	r4, r4, #8, #7
90000bee:	4363      	muls	r3, r4
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
90000bf0:	f3c1 6141 	ubfx	r1, r1, #25, #2
90000bf4:	3101      	adds	r1, #1
90000bf6:	0049      	lsls	r1, r1, #1
      SystemCoreClock = pllvco/pllr;
90000bf8:	fbb3 f3f1 	udiv	r3, r3, r1
90000bfc:	e7d8      	b.n	90000bb0 <SystemCoreClockUpdate+0x34>
      SystemCoreClock = msirange;
90000bfe:	6004      	str	r4, [r0, #0]
      break;
90000c00:	e7d7      	b.n	90000bb2 <SystemCoreClockUpdate+0x36>
90000c02:	bf00      	nop
90000c04:	40021000 	.word	0x40021000
90000c08:	90004be0 	.word	0x90004be0
90000c0c:	20000100 	.word	0x20000100
90000c10:	00f42400 	.word	0x00f42400
90000c14:	90004bc7 	.word	0x90004bc7

90000c18 <TEST_PROTECTIONS_PrintTestingMenu>:
  * @brief  Display the TEST Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void TEST_PROTECTIONS_PrintTestingMenu(void)
{
90000c18:	b508      	push	{r3, lr}
  printf("\r\n=================== Test Menu ============================\r\n\n");
90000c1a:	4807      	ldr	r0, [pc, #28]	; (90000c38 <TEST_PROTECTIONS_PrintTestingMenu+0x20>)
90000c1c:	f002 fd5a 	bl	900036d4 <puts>
  printf("  Test Protection : NonSecure try to access to Secure --- 1\r\n\n");
90000c20:	4806      	ldr	r0, [pc, #24]	; (90000c3c <TEST_PROTECTIONS_PrintTestingMenu+0x24>)
90000c22:	f002 fd57 	bl	900036d4 <puts>
  printf("  RDP Regression ---------------------------------------- 2\r\n\n");
90000c26:	4806      	ldr	r0, [pc, #24]	; (90000c40 <TEST_PROTECTIONS_PrintTestingMenu+0x28>)
90000c28:	f002 fd54 	bl	900036d4 <puts>
  printf("  Previous Menu ----------------------------------------- x\r\n\n");
}
90000c2c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Previous Menu ----------------------------------------- x\r\n\n");
90000c30:	4804      	ldr	r0, [pc, #16]	; (90000c44 <TEST_PROTECTIONS_PrintTestingMenu+0x2c>)
90000c32:	f002 bd4f 	b.w	900036d4 <puts>
90000c36:	bf00      	nop
90000c38:	90004c20 	.word	0x90004c20
90000c3c:	90004c5f 	.word	0x90004c5f
90000c40:	90004c9d 	.word	0x90004c9d
90000c44:	90004cdb 	.word	0x90004cdb

90000c48 <TEST_PROTECTIONS_Run_SecUserMem>:
  uint32_t page_error = 0U;
90000c48:	2300      	movs	r3, #0
{
90000c4a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
90000c4e:	4d5f      	ldr	r5, [pc, #380]	; (90000dcc <TEST_PROTECTIONS_Run_SecUserMem+0x184>)
{
90000c50:	b089      	sub	sp, #36	; 0x24
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
90000c52:	682a      	ldr	r2, [r5, #0]
  uint32_t page_error = 0U;
90000c54:	9301      	str	r3, [sp, #4]
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
90000c56:	4b5e      	ldr	r3, [pc, #376]	; (90000dd0 <TEST_PROTECTIONS_Run_SecUserMem+0x188>)
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
90000c58:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 90000e00 <TEST_PROTECTIONS_Run_SecUserMem+0x1b8>
  if ((TestNumber & TEST_PROTECTION_MASK) == 0)
90000c5c:	4213      	tst	r3, r2
      if (on)
      {
        __HAL_RCC_RNG_CLK_ENABLE();
      }
      else
        __HAL_RCC_RNG_CLK_DISABLE();
90000c5e:	4f5d      	ldr	r7, [pc, #372]	; (90000dd4 <TEST_PROTECTIONS_Run_SecUserMem+0x18c>)
    TestNumber = TEST_PROTECTION_MASK;
90000c60:	bf08      	it	eq
90000c62:	602b      	streq	r3, [r5, #0]
    HAL_Delay(100);
90000c64:	2064      	movs	r0, #100	; 0x64
90000c66:	f000 fd57 	bl	90001718 <HAL_Delay>
    test_idx = TestNumber & 0xffff;
90000c6a:	882e      	ldrh	r6, [r5, #0]
    if (test_idx > (sizeof(aProtectTests) / sizeof(TestProtection_t) -1))
90000c6c:	2e08      	cmp	r6, #8
90000c6e:	d902      	bls.n	90000c76 <TEST_PROTECTIONS_Run_SecUserMem+0x2e>
    TestNumber = 0;            /* no more test in progress */
90000c70:	2300      	movs	r3, #0
90000c72:	602b      	str	r3, [r5, #0]
90000c74:	e045      	b.n	90000d02 <TEST_PROTECTIONS_Run_SecUserMem+0xba>
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
90000c76:	f04f 0a28 	mov.w	sl, #40	; 0x28
    printf("\r\n= [TEST] %s @ %s %08x", \
90000c7a:	2014      	movs	r0, #20
    TestNumber = TEST_PROTECTION_MASK | ((test_idx + 1) & 0xffff);
90000c7c:	1c73      	adds	r3, r6, #1
90000c7e:	f043 435e 	orr.w	r3, r3, #3724541952	; 0xde000000
90000c82:	f443 032d 	orr.w	r3, r3, #11337728	; 0xad0000
90000c86:	602b      	str	r3, [r5, #0]
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
90000c88:	fb0a f306 	mul.w	r3, sl, r6
90000c8c:	eb09 0203 	add.w	r2, r9, r3
90000c90:	f892 b024 	ldrb.w	fp, [r2, #36]	; 0x24
90000c94:	f103 0804 	add.w	r8, r3, #4
90000c98:	f859 4003 	ldr.w	r4, [r9, r3]
    printf("\r\n= [TEST] %s @ %s %08x", \
90000c9c:	494e      	ldr	r1, [pc, #312]	; (90000dd8 <TEST_PROTECTIONS_Run_SecUserMem+0x190>)
           aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg, (int)aProtectTests[test_idx].address);
90000c9e:	44c8      	add	r8, r9
    printf("\r\n= [TEST] %s @ %s %08x", \
90000ca0:	4623      	mov	r3, r4
90000ca2:	fb00 110b 	mla	r1, r0, fp, r1
90000ca6:	4642      	mov	r2, r8
90000ca8:	484c      	ldr	r0, [pc, #304]	; (90000ddc <TEST_PROTECTIONS_Run_SecUserMem+0x194>)
90000caa:	f002 fc9f 	bl	900035ec <iprintf>
    switch (aProtectTests[test_idx].type)
90000cae:	f1bb 0f07 	cmp.w	fp, #7
90000cb2:	d8d7      	bhi.n	90000c64 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
90000cb4:	e8df f00b 	tbb	[pc, fp]
90000cb8:	4a362804 	.word	0x4a362804
90000cbc:	7f58564d 	.word	0x7f58564d
        HAL_FLASH_Unlock();
90000cc0:	f000 fdf4 	bl	900018ac <HAL_FLASH_Unlock>
        HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, aProtectTests[test_idx].address, pattern);
90000cc4:	2200      	movs	r2, #0
90000cc6:	4621      	mov	r1, r4
90000cc8:	2300      	movs	r3, #0
90000cca:	2001      	movs	r0, #1
90000ccc:	f000 fe3e 	bl	9000194c <HAL_FLASH_Program>
        HAL_FLASH_Lock();
90000cd0:	f000 fdfe 	bl	900018d0 <HAL_FLASH_Lock>
        flashErrCode = HAL_FLASH_GetError();
90000cd4:	f000 fe08 	bl	900018e8 <HAL_FLASH_GetError>
90000cd8:	4604      	mov	r4, r0
        printf("\r\nflash error code: %x",(int)flashErrCode);
90000cda:	4601      	mov	r1, r0
90000cdc:	4840      	ldr	r0, [pc, #256]	; (90000de0 <TEST_PROTECTIONS_Run_SecUserMem+0x198>)
90000cde:	f002 fc85 	bl	900035ec <iprintf>
          status = TEST_ERROR;
90000ce2:	f014 0f10 	tst.w	r4, #16
        if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
90000ce6:	f04f 0205 	mov.w	r2, #5
90000cea:	4641      	mov	r1, r8
90000cec:	483d      	ldr	r0, [pc, #244]	; (90000de4 <TEST_PROTECTIONS_Run_SecUserMem+0x19c>)
          status = TEST_ERROR;
90000cee:	bf14      	ite	ne
90000cf0:	2600      	movne	r6, #0
90000cf2:	2602      	moveq	r6, #2
        if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
90000cf4:	f002 fda2 	bl	9000383c <strncmp>
90000cf8:	2800      	cmp	r0, #0
90000cfa:	d157      	bne.n	90000dac <TEST_PROTECTIONS_Run_SecUserMem+0x164>
    printf("\r\n TEST_PROTECTIONS_Run_SecUserMem : Failed");
90000cfc:	483a      	ldr	r0, [pc, #232]	; (90000de8 <TEST_PROTECTIONS_Run_SecUserMem+0x1a0>)
90000cfe:	f002 fc75 	bl	900035ec <iprintf>
}
90000d02:	b009      	add	sp, #36	; 0x24
90000d04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        tmp = *(uint8_t *)(aProtectTests[test_idx].address);
90000d08:	7823      	ldrb	r3, [r4, #0]
        HAL_Delay(1);        /* ensure Flag is set */
90000d0a:	2001      	movs	r0, #1
        tmp = *(uint8_t *)(aProtectTests[test_idx].address);
90000d0c:	f88d 3003 	strb.w	r3, [sp, #3]
        HAL_Delay(1);        /* ensure Flag is set */
90000d10:	f000 fd02 	bl	90001718 <HAL_Delay>
        if (0 == strncmp("Isolated", (const char *)aProtectTests[test_idx].msg, 8))
90000d14:	2208      	movs	r2, #8
90000d16:	4641      	mov	r1, r8
90000d18:	4834      	ldr	r0, [pc, #208]	; (90000dec <TEST_PROTECTIONS_Run_SecUserMem+0x1a4>)
90000d1a:	f002 fd8f 	bl	9000383c <strncmp>
90000d1e:	2800      	cmp	r0, #0
90000d20:	d1a0      	bne.n	90000c64 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
90000d22:	e7eb      	b.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        HAL_FLASH_Unlock();
90000d24:	f000 fdc2 	bl	900018ac <HAL_FLASH_Unlock>
        p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
90000d28:	2301      	movs	r3, #1
90000d2a:	2202      	movs	r2, #2
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
90000d2c:	a901      	add	r1, sp, #4
        p_erase_init.Page        = (aProtectTests[test_idx].address) / 0x800;
90000d2e:	0ae4      	lsrs	r4, r4, #11
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
90000d30:	a804      	add	r0, sp, #16
        p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
90000d32:	e9cd 2304 	strd	r2, r3, [sp, #16]
        p_erase_init.NbPages     = 1;
90000d36:	e9cd 4306 	strd	r4, r3, [sp, #24]
        HAL_FLASHEx_Erase(&p_erase_init, &page_error);
90000d3a:	f000 fe85 	bl	90001a48 <HAL_FLASHEx_Erase>
        HAL_FLASH_Lock();
90000d3e:	f000 fdc7 	bl	900018d0 <HAL_FLASH_Lock>
        if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) == 0U)
90000d42:	f000 fdd1 	bl	900018e8 <HAL_FLASH_GetError>
90000d46:	06c3      	lsls	r3, r0, #27
90000d48:	d48c      	bmi.n	90000c64 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
90000d4a:	e7d7      	b.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        *(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
90000d4c:	2300      	movs	r3, #0
90000d4e:	6023      	str	r3, [r4, #0]
90000d50:	e7d4      	b.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        tmp = *(uint8_t *)aProtectTests[test_idx].address;
90000d52:	7823      	ldrb	r3, [r4, #0]
        printf(" value : %d ", tmp);
90000d54:	4826      	ldr	r0, [pc, #152]	; (90000df0 <TEST_PROTECTIONS_Run_SecUserMem+0x1a8>)
        tmp = *(uint8_t *)aProtectTests[test_idx].address;
90000d56:	f88d 3003 	strb.w	r3, [sp, #3]
        printf(" value : %d ", tmp);
90000d5a:	f89d 1003 	ldrb.w	r1, [sp, #3]
90000d5e:	f002 fc45 	bl	900035ec <iprintf>
90000d62:	e7cb      	b.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        func();
90000d64:	47a0      	blx	r4
90000d66:	e7c9      	b.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        set_periph(aProtectTests[test_idx].periph, 1);
90000d68:	fb0a 9606 	mla	r6, sl, r6, r9
90000d6c:	f896 6025 	ldrb.w	r6, [r6, #37]	; 0x25
  switch (periph)
90000d70:	b946      	cbnz	r6, 90000d84 <TEST_PROTECTIONS_Run_SecUserMem+0x13c>
        __HAL_RCC_RNG_CLK_ENABLE();
90000d72:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90000d74:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
90000d78:	64fb      	str	r3, [r7, #76]	; 0x4c
90000d7a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90000d7c:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
90000d80:	9303      	str	r3, [sp, #12]
90000d82:	9b03      	ldr	r3, [sp, #12]
          status = TEST_ERROR;
90000d84:	230a      	movs	r3, #10
          tmp_reg = *((__IO uint32_t *)aProtectTests[test_idx].address);
90000d86:	6822      	ldr	r2, [r4, #0]
90000d88:	9202      	str	r2, [sp, #8]
          if (tmp_reg != 0)
90000d8a:	9a02      	ldr	r2, [sp, #8]
90000d8c:	b90a      	cbnz	r2, 90000d92 <TEST_PROTECTIONS_Run_SecUserMem+0x14a>
        for (i = 0; i < 10; i++)
90000d8e:	3b01      	subs	r3, #1
90000d90:	d1f9      	bne.n	90000d86 <TEST_PROTECTIONS_Run_SecUserMem+0x13e>
        if (tmp_reg != 0)
90000d92:	9b02      	ldr	r3, [sp, #8]
90000d94:	b1b3      	cbz	r3, 90000dc4 <TEST_PROTECTIONS_Run_SecUserMem+0x17c>
          printf(" value : %x ",(int)tmp_reg);
90000d96:	9902      	ldr	r1, [sp, #8]
90000d98:	4816      	ldr	r0, [pc, #88]	; (90000df4 <TEST_PROTECTIONS_Run_SecUserMem+0x1ac>)
90000d9a:	f002 fc27 	bl	900035ec <iprintf>
  switch (periph)
90000d9e:	2e00      	cmp	r6, #0
90000da0:	d1ac      	bne.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
          status = TEST_ERROR;
90000da2:	2602      	movs	r6, #2
        __HAL_RCC_RNG_CLK_DISABLE();
90000da4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
90000da6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
90000daa:	64fb      	str	r3, [r7, #76]	; 0x4c
  } while (status == TEST_IN_PROGRESS) ;
90000dac:	2e00      	cmp	r6, #0
90000dae:	f43f af59 	beq.w	90000c64 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
  if (status == TEST_ERROR)
90000db2:	b11e      	cbz	r6, 90000dbc <TEST_PROTECTIONS_Run_SecUserMem+0x174>
90000db4:	e7a2      	b.n	90000cfc <TEST_PROTECTIONS_Run_SecUserMem+0xb4>
        printf("\r\n TEST_PROTECTIONS_Run_SecUserMem : Passed");
90000db6:	4810      	ldr	r0, [pc, #64]	; (90000df8 <TEST_PROTECTIONS_Run_SecUserMem+0x1b0>)
90000db8:	f002 fc18 	bl	900035ec <iprintf>
    printf("\b\b\b\b\b\b\b\b");
90000dbc:	480f      	ldr	r0, [pc, #60]	; (90000dfc <TEST_PROTECTIONS_Run_SecUserMem+0x1b4>)
90000dbe:	f002 fc15 	bl	900035ec <iprintf>
90000dc2:	e755      	b.n	90000c70 <TEST_PROTECTIONS_Run_SecUserMem+0x28>
  switch (periph)
90000dc4:	2e00      	cmp	r6, #0
90000dc6:	f47f af4d 	bne.w	90000c64 <TEST_PROTECTIONS_Run_SecUserMem+0x1c>
90000dca:	e7eb      	b.n	90000da4 <TEST_PROTECTIONS_Run_SecUserMem+0x15c>
90000dcc:	20000000 	.word	0x20000000
90000dd0:	dead0000 	.word	0xdead0000
90000dd4:	40021000 	.word	0x40021000
90000dd8:	90004fac 	.word	0x90004fac
90000ddc:	90004d8b 	.word	0x90004d8b
90000de0:	90004da3 	.word	0x90004da3
90000de4:	90004dba 	.word	0x90004dba
90000de8:	90004e0f 	.word	0x90004e0f
90000dec:	90004dc0 	.word	0x90004dc0
90000df0:	90004dc9 	.word	0x90004dc9
90000df4:	90004dd6 	.word	0x90004dd6
90000df8:	90004de3 	.word	0x90004de3
90000dfc:	90004e3b 	.word	0x90004e3b
90000e00:	90004e44 	.word	0x90004e44

90000e04 <TEST_PROTECTIONS_Run>:
{
90000e04:	b570      	push	{r4, r5, r6, lr}
  uint8_t key = 0U;
90000e06:	2400      	movs	r4, #0
{
90000e08:	b088      	sub	sp, #32
  uint8_t key = 0U;
90000e0a:	ad08      	add	r5, sp, #32
90000e0c:	f805 4d19 	strb.w	r4, [r5, #-25]!
  TEST_PROTECTIONS_PrintTestingMenu();
90000e10:	f7ff ff02 	bl	90000c18 <TEST_PROTECTIONS_PrintTestingMenu>
          printf("Invalid Number !\r");
90000e14:	4e26      	ldr	r6, [pc, #152]	; (90000eb0 <TEST_PROTECTIONS_Run+0xac>)
    key = 0U;
90000e16:	f88d 4007 	strb.w	r4, [sp, #7]
    COM_Flush();
90000e1a:	f7ff fdcd 	bl	900009b8 <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
90000e1e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
90000e22:	2101      	movs	r1, #1
90000e24:	4628      	mov	r0, r5
90000e26:	f7ff fdbf 	bl	900009a8 <COM_Receive>
90000e2a:	2800      	cmp	r0, #0
90000e2c:	d1f3      	bne.n	90000e16 <TEST_PROTECTIONS_Run+0x12>
      switch (key)
90000e2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
90000e32:	2b32      	cmp	r3, #50	; 0x32
90000e34:	d008      	beq.n	90000e48 <TEST_PROTECTIONS_Run+0x44>
90000e36:	2b78      	cmp	r3, #120	; 0x78
90000e38:	d031      	beq.n	90000e9e <TEST_PROTECTIONS_Run+0x9a>
90000e3a:	2b31      	cmp	r3, #49	; 0x31
90000e3c:	d133      	bne.n	90000ea6 <TEST_PROTECTIONS_Run+0xa2>
          TEST_PROTECTIONS_Run_SecUserMem();
90000e3e:	f7ff ff03 	bl	90000c48 <TEST_PROTECTIONS_Run_SecUserMem>
      TEST_PROTECTIONS_PrintTestingMenu();
90000e42:	f7ff fee9 	bl	90000c18 <TEST_PROTECTIONS_PrintTestingMenu>
90000e46:	e7e6      	b.n	90000e16 <TEST_PROTECTIONS_Run+0x12>
  region_cfg.region_nr = 2U;
90000e48:	2302      	movs	r3, #2
90000e4a:	4a1a      	ldr	r2, [pc, #104]	; (90000eb4 <TEST_PROTECTIONS_Run+0xb0>)
  region_cfg.region_limit = NS_DATA_LIMIT;
90000e4c:	491a      	ldr	r1, [pc, #104]	; (90000eb8 <TEST_PROTECTIONS_Run+0xb4>)
  region_cfg.region_nr = 2U;
90000e4e:	e9cd 2302 	strd	r2, r3, [sp, #8]
  region_cfg.region_limit = NS_DATA_LIMIT;
90000e52:	4a1a      	ldr	r2, [pc, #104]	; (90000ebc <TEST_PROTECTIONS_Run+0xb8>)
  region_cfg.attr_access = MPU_ARMV8M_AP_RW_PRIV_ONLY;
90000e54:	f88d 001d 	strb.w	r0, [sp, #29]
  region_cfg.region_limit = NS_DATA_LIMIT;
90000e58:	e9cd 1204 	strd	r1, r2, [sp, #16]
  region_cfg.attr_sh = MPU_ARMV8M_SH_NONE;
90000e5c:	f88d 001e 	strb.w	r0, [sp, #30]
  region_cfg.attr_exec = MPU_ARMV8M_XN_EXEC_OK;
90000e60:	f88d 001c 	strb.w	r0, [sp, #28]
  mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg);
90000e64:	a903      	add	r1, sp, #12
90000e66:	a802      	add	r0, sp, #8
  region_cfg.region_attridx = MPU_ARMV8M_MAIR_ATTR_DATA_IDX;
90000e68:	9306      	str	r3, [sp, #24]
  mpu_armv8m_region_enable(&dev_mpu_ns, &region_cfg);
90000e6a:	f7ff fe3f 	bl	90000aec <mpu_armv8m_region_enable>
  __ASM volatile ("cpsid i" : : : "memory");
90000e6e:	b672      	cpsid	i
    *pt = WHILE_1_OPCODE;
90000e70:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
90000e74:	f24e 72fe 	movw	r2, #59390	; 0xe7fe
90000e78:	801a      	strh	r2, [r3, #0]
  __ASM volatile ("dsb 0xF":::"memory");
90000e7a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
90000e7e:	f3bf 8f6f 	isb	sy
    printf("\r\n Device ready for regression : \r\n");
90000e82:	480f      	ldr	r0, [pc, #60]	; (90000ec0 <TEST_PROTECTIONS_Run+0xbc>)
90000e84:	f002 fc26 	bl	900036d4 <puts>
    printf("\r\n - Connect STM32CubeProgrammer mode=HotPlug");
90000e88:	480e      	ldr	r0, [pc, #56]	; (90000ec4 <TEST_PROTECTIONS_Run+0xc0>)
90000e8a:	f002 fbaf 	bl	900035ec <iprintf>
    printf("\r\n - Perform RDP Regression ");
90000e8e:	480e      	ldr	r0, [pc, #56]	; (90000ec8 <TEST_PROTECTIONS_Run+0xc4>)
90000e90:	f002 fbac 	bl	900035ec <iprintf>
    printf("\r\n ");
90000e94:	480d      	ldr	r0, [pc, #52]	; (90000ecc <TEST_PROTECTIONS_Run+0xc8>)
90000e96:	f002 fba9 	bl	900035ec <iprintf>
    nsfptr();
90000e9a:	4b0d      	ldr	r3, [pc, #52]	; (90000ed0 <TEST_PROTECTIONS_Run+0xcc>)
90000e9c:	4798      	blx	r3
      TEST_PROTECTIONS_PrintTestingMenu();
90000e9e:	f7ff febb 	bl	90000c18 <TEST_PROTECTIONS_PrintTestingMenu>
}
90000ea2:	b008      	add	sp, #32
90000ea4:	bd70      	pop	{r4, r5, r6, pc}
          printf("Invalid Number !\r");
90000ea6:	4630      	mov	r0, r6
90000ea8:	f002 fba0 	bl	900035ec <iprintf>
          break;
90000eac:	e7c9      	b.n	90000e42 <TEST_PROTECTIONS_Run+0x3e>
90000eae:	bf00      	nop
90000eb0:	90004a8b 	.word	0x90004a8b
90000eb4:	e000ed90 	.word	0xe000ed90
90000eb8:	20000020 	.word	0x20000020
90000ebc:	2002ffff 	.word	0x2002ffff
90000ec0:	90004d19 	.word	0x90004d19
90000ec4:	90004d3c 	.word	0x90004d3c
90000ec8:	90004d6a 	.word	0x90004d6a
90000ecc:	90004d87 	.word	0x90004d87
90000ed0:	20000001 	.word	0x20000001

90000ed4 <tfm_app_print_menu>:
  * @brief  Display the TEST TFM App Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void tfm_app_print_menu(void)
{
90000ed4:	b508      	push	{r3, lr}
  printf("\r\n======================= TFM Examples Menu ===========================\r\n\n");
90000ed6:	4817      	ldr	r0, [pc, #92]	; (90000f34 <tfm_app_print_menu+0x60>)
90000ed8:	f002 fbfc 	bl	900036d4 <puts>
  printf("  TFM - Test All                                   --------------------- 0\r\n\n");
90000edc:	4816      	ldr	r0, [pc, #88]	; (90000f38 <tfm_app_print_menu+0x64>)
90000ede:	f002 fbf9 	bl	900036d4 <puts>
  printf("  TFM - Test AES-GCM                               --------------------- 1\r\n\n");
90000ee2:	4816      	ldr	r0, [pc, #88]	; (90000f3c <tfm_app_print_menu+0x68>)
90000ee4:	f002 fbf6 	bl	900036d4 <puts>
  printf("  TFM - Test AES-CBC                               --------------------- 2\r\n\n");
90000ee8:	4815      	ldr	r0, [pc, #84]	; (90000f40 <tfm_app_print_menu+0x6c>)
90000eea:	f002 fbf3 	bl	900036d4 <puts>
  printf("  TFM - Test AES-CCM                               --------------------- 3\r\n\n");
90000eee:	4815      	ldr	r0, [pc, #84]	; (90000f44 <tfm_app_print_menu+0x70>)
90000ef0:	f002 fbf0 	bl	900036d4 <puts>
  printf("  TFM - Test SST set UID                           --------------------- 4\r\n\n");
90000ef4:	4814      	ldr	r0, [pc, #80]	; (90000f48 <tfm_app_print_menu+0x74>)
90000ef6:	f002 fbed 	bl	900036d4 <puts>
  printf("  TFM - Test SST read / check UID                  --------------------- 5\r\n\n");
90000efa:	4814      	ldr	r0, [pc, #80]	; (90000f4c <tfm_app_print_menu+0x78>)
90000efc:	f002 fbea 	bl	900036d4 <puts>
  printf("  TFM - Test SST remove UID                        --------------------- 6\r\n\n");
90000f00:	4813      	ldr	r0, [pc, #76]	; (90000f50 <tfm_app_print_menu+0x7c>)
90000f02:	f002 fbe7 	bl	900036d4 <puts>
  printf("  TFM - Test EAT                                   --------------------- 7\r\n\n");
90000f06:	4813      	ldr	r0, [pc, #76]	; (90000f54 <tfm_app_print_menu+0x80>)
90000f08:	f002 fbe4 	bl	900036d4 <puts>
  printf("  TFM - Test ITS set UID                           --------------------- 8\r\n\n");
90000f0c:	4812      	ldr	r0, [pc, #72]	; (90000f58 <tfm_app_print_menu+0x84>)
90000f0e:	f002 fbe1 	bl	900036d4 <puts>
  printf("  TFM - Test ITS read / check UID                  --------------------- 9\r\n\n");
90000f12:	4812      	ldr	r0, [pc, #72]	; (90000f5c <tfm_app_print_menu+0x88>)
90000f14:	f002 fbde 	bl	900036d4 <puts>
  printf("  TFM - Test ITS remove UID                        --------------------- a\r\n\n");
90000f18:	4811      	ldr	r0, [pc, #68]	; (90000f60 <tfm_app_print_menu+0x8c>)
90000f1a:	f002 fbdb 	bl	900036d4 <puts>
  printf("  TFM - Test SHA224                                --------------------- b\r\n\n");
90000f1e:	4811      	ldr	r0, [pc, #68]	; (90000f64 <tfm_app_print_menu+0x90>)
90000f20:	f002 fbd8 	bl	900036d4 <puts>
  printf("  TFM - Test SHA256                                --------------------- c\r\n\n");
90000f24:	4810      	ldr	r0, [pc, #64]	; (90000f68 <tfm_app_print_menu+0x94>)
90000f26:	f002 fbd5 	bl	900036d4 <puts>
  printf("  Exit TFM Examples Menu                           --------------------- x\r\n\n");
}
90000f2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Exit TFM Examples Menu                           --------------------- x\r\n\n");
90000f2e:	480f      	ldr	r0, [pc, #60]	; (90000f6c <tfm_app_print_menu+0x98>)
90000f30:	f002 bbd0 	b.w	900036d4 <puts>
90000f34:	9000519c 	.word	0x9000519c
90000f38:	900051e6 	.word	0x900051e6
90000f3c:	90005233 	.word	0x90005233
90000f40:	90005280 	.word	0x90005280
90000f44:	900052cd 	.word	0x900052cd
90000f48:	9000531a 	.word	0x9000531a
90000f4c:	90005367 	.word	0x90005367
90000f50:	900053b4 	.word	0x900053b4
90000f54:	90005401 	.word	0x90005401
90000f58:	9000544e 	.word	0x9000544e
90000f5c:	9000549b 	.word	0x9000549b
90000f60:	900054e8 	.word	0x900054e8
90000f64:	90005535 	.word	0x90005535
90000f68:	90005582 	.word	0x90005582
90000f6c:	900055cf 	.word	0x900055cf

90000f70 <tfm_sst_set_uid.isra.0>:
/**
  * @brief  Write in SST a TEST UID
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_sst_set_uid(struct test_result_t *ret)
90000f70:	b5f0      	push	{r4, r5, r6, r7, lr}
90000f72:	b08b      	sub	sp, #44	; 0x2c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  const psa_ps_create_flags_t flags = PSA_PS_FLAG_NONE;
  const uint32_t write_len = TEST_DATA_SIZE;
  const uint8_t write_data[] = TEST_DATA;
90000f74:	ac03      	add	r4, sp, #12
static void tfm_sst_set_uid(struct test_result_t *ret)
90000f76:	4606      	mov	r6, r0
90000f78:	4623      	mov	r3, r4
  const uint8_t write_data[] = TEST_DATA;
90000f7a:	4a0d      	ldr	r2, [pc, #52]	; (90000fb0 <tfm_sst_set_uid.isra.0+0x40>)
90000f7c:	f102 0718 	add.w	r7, r2, #24
90000f80:	4625      	mov	r5, r4
90000f82:	6810      	ldr	r0, [r2, #0]
90000f84:	6851      	ldr	r1, [r2, #4]
90000f86:	3208      	adds	r2, #8
90000f88:	c503      	stmia	r5!, {r0, r1}
90000f8a:	42ba      	cmp	r2, r7
90000f8c:	462c      	mov	r4, r5
90000f8e:	d1f7      	bne.n	90000f80 <tfm_sst_set_uid.isra.0+0x10>
90000f90:	8812      	ldrh	r2, [r2, #0]
  /* Set a UIDtime */
  status = psa_ps_set(uid, write_len, write_data, flags);
90000f92:	2100      	movs	r1, #0
  const uint8_t write_data[] = TEST_DATA;
90000f94:	802a      	strh	r2, [r5, #0]
  status = psa_ps_set(uid, write_len, write_data, flags);
90000f96:	2200      	movs	r2, #0
90000f98:	2002      	movs	r0, #2
90000f9a:	9200      	str	r2, [sp, #0]
90000f9c:	2219      	movs	r2, #25
90000f9e:	f001 fe71 	bl	90002c84 <psa_ps_set>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
90000fa2:	3000      	adds	r0, #0
90000fa4:	bf18      	it	ne
90000fa6:	2001      	movne	r0, #1
90000fa8:	7030      	strb	r0, [r6, #0]
  return;
}
90000faa:	b00b      	add	sp, #44	; 0x2c
90000fac:	bdf0      	pop	{r4, r5, r6, r7, pc}
90000fae:	bf00      	nop
90000fb0:	9000568b 	.word	0x9000568b

90000fb4 <tfm_sst_read_uid.isra.1>:
/**
  * @brief  Read ITS TEST UID and compare its value
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_sst_read_uid(struct test_result_t *ret)
90000fb4:	b5f0      	push	{r4, r5, r6, r7, lr}
90000fb6:	b097      	sub	sp, #92	; 0x5c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  uint8_t read_data[] = TEST_READ_DATA ;
90000fb8:	aa0a      	add	r2, sp, #40	; 0x28
static void tfm_sst_read_uid(struct test_result_t *ret)
90000fba:	4605      	mov	r5, r0
90000fbc:	4616      	mov	r6, r2
  uint8_t read_data[] = TEST_READ_DATA ;
90000fbe:	4b19      	ldr	r3, [pc, #100]	; (90001024 <tfm_sst_read_uid.isra.1+0x70>)
90000fc0:	f103 0728 	add.w	r7, r3, #40	; 0x28
90000fc4:	4614      	mov	r4, r2
90000fc6:	6818      	ldr	r0, [r3, #0]
90000fc8:	6859      	ldr	r1, [r3, #4]
90000fca:	3308      	adds	r3, #8
90000fcc:	c403      	stmia	r4!, {r0, r1}
90000fce:	42bb      	cmp	r3, r7
90000fd0:	4622      	mov	r2, r4
90000fd2:	d1f7      	bne.n	90000fc4 <tfm_sst_read_uid.isra.1+0x10>
  uint8_t expected_data[] = TEST_DATA;
90000fd4:	aa03      	add	r2, sp, #12
90000fd6:	4617      	mov	r7, r2
  uint8_t read_data[] = TEST_READ_DATA ;
90000fd8:	6818      	ldr	r0, [r3, #0]
90000fda:	791b      	ldrb	r3, [r3, #4]
90000fdc:	6020      	str	r0, [r4, #0]
90000fde:	7123      	strb	r3, [r4, #4]
  uint8_t expected_data[] = TEST_DATA;
90000fe0:	4b11      	ldr	r3, [pc, #68]	; (90001028 <tfm_sst_read_uid.isra.1+0x74>)
90000fe2:	f103 0c18 	add.w	ip, r3, #24
90000fe6:	4614      	mov	r4, r2
90000fe8:	6818      	ldr	r0, [r3, #0]
90000fea:	6859      	ldr	r1, [r3, #4]
90000fec:	3308      	adds	r3, #8
90000fee:	c403      	stmia	r4!, {r0, r1}
90000ff0:	4563      	cmp	r3, ip
90000ff2:	4622      	mov	r2, r4
90000ff4:	d1f7      	bne.n	90000fe6 <tfm_sst_read_uid.isra.1+0x32>
90000ff6:	881b      	ldrh	r3, [r3, #0]
  /* read UID */
  status = psa_ps_get(uid, 0, TEST_DATA_SIZE, read_data);
90000ff8:	2200      	movs	r2, #0
  uint8_t expected_data[] = TEST_DATA;
90000ffa:	8023      	strh	r3, [r4, #0]
  status = psa_ps_get(uid, 0, TEST_DATA_SIZE, read_data);
90000ffc:	2002      	movs	r0, #2
90000ffe:	9600      	str	r6, [sp, #0]
90001000:	2319      	movs	r3, #25
90001002:	2100      	movs	r1, #0
90001004:	f001 fe69 	bl	90002cda <psa_ps_get>
  if ((status == PSA_SUCCESS) && (!memcmp(read_data, expected_data, TEST_DATA_SIZE)))
90001008:	b940      	cbnz	r0, 9000101c <tfm_sst_read_uid.isra.1+0x68>
9000100a:	2219      	movs	r2, #25
9000100c:	4639      	mov	r1, r7
9000100e:	4630      	mov	r0, r6
90001010:	f002 faca 	bl	900035a8 <memcmp>
90001014:	b910      	cbnz	r0, 9000101c <tfm_sst_read_uid.isra.1+0x68>
  {
    ret->val = TEST_PASSED;
90001016:	7028      	strb	r0, [r5, #0]
  else
  {
    ret->val = TEST_FAILED;
  }
  return;
}
90001018:	b017      	add	sp, #92	; 0x5c
9000101a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret->val = TEST_FAILED;
9000101c:	2301      	movs	r3, #1
9000101e:	702b      	strb	r3, [r5, #0]
90001020:	e7fa      	b.n	90001018 <tfm_sst_read_uid.isra.1+0x64>
90001022:	bf00      	nop
90001024:	9000565e 	.word	0x9000565e
90001028:	9000568b 	.word	0x9000568b

9000102c <tfm_its_set_uid.isra.3>:
/**
  * @brief  Write in ITS a TEST UID
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_its_set_uid(struct test_result_t *ret)
9000102c:	b5f0      	push	{r4, r5, r6, r7, lr}
9000102e:	b08b      	sub	sp, #44	; 0x2c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  const psa_ps_create_flags_t flags = PSA_PS_FLAG_NONE;
  const uint32_t write_len = TEST_DATA_SIZE;
  const uint8_t write_data[] = TEST_DATA;
90001030:	ac03      	add	r4, sp, #12
static void tfm_its_set_uid(struct test_result_t *ret)
90001032:	4606      	mov	r6, r0
90001034:	4623      	mov	r3, r4
  const uint8_t write_data[] = TEST_DATA;
90001036:	4a0d      	ldr	r2, [pc, #52]	; (9000106c <tfm_its_set_uid.isra.3+0x40>)
90001038:	f102 0718 	add.w	r7, r2, #24
9000103c:	4625      	mov	r5, r4
9000103e:	6810      	ldr	r0, [r2, #0]
90001040:	6851      	ldr	r1, [r2, #4]
90001042:	3208      	adds	r2, #8
90001044:	c503      	stmia	r5!, {r0, r1}
90001046:	42ba      	cmp	r2, r7
90001048:	462c      	mov	r4, r5
9000104a:	d1f7      	bne.n	9000103c <tfm_its_set_uid.isra.3+0x10>
9000104c:	8812      	ldrh	r2, [r2, #0]
  /* Set a UIDtime */
  status = psa_its_set(uid, write_len, write_data, flags);
9000104e:	2100      	movs	r1, #0
  const uint8_t write_data[] = TEST_DATA;
90001050:	802a      	strh	r2, [r5, #0]
  status = psa_its_set(uid, write_len, write_data, flags);
90001052:	2200      	movs	r2, #0
90001054:	2002      	movs	r0, #2
90001056:	9200      	str	r2, [sp, #0]
90001058:	2219      	movs	r2, #25
9000105a:	f001 fd68 	bl	90002b2e <psa_its_set>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
9000105e:	3000      	adds	r0, #0
90001060:	bf18      	it	ne
90001062:	2001      	movne	r0, #1
90001064:	7030      	strb	r0, [r6, #0]
  return;
}
90001066:	b00b      	add	sp, #44	; 0x2c
90001068:	bdf0      	pop	{r4, r5, r6, r7, pc}
9000106a:	bf00      	nop
9000106c:	9000568b 	.word	0x9000568b

90001070 <tfm_its_read_uid.isra.4>:
/**
  * @brief  Read TEST UID and compare its value
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_its_read_uid(struct test_result_t *ret)
90001070:	b5f0      	push	{r4, r5, r6, r7, lr}
90001072:	b097      	sub	sp, #92	; 0x5c
{
  psa_ps_status_t status;
  const psa_ps_uid_t uid = TEST_UID;
  size_t data_len;
  uint8_t read_data[] = TEST_READ_DATA ;
90001074:	aa0a      	add	r2, sp, #40	; 0x28
static void tfm_its_read_uid(struct test_result_t *ret)
90001076:	4605      	mov	r5, r0
90001078:	4616      	mov	r6, r2
  uint8_t read_data[] = TEST_READ_DATA ;
9000107a:	4b1b      	ldr	r3, [pc, #108]	; (900010e8 <tfm_its_read_uid.isra.4+0x78>)
9000107c:	f103 0728 	add.w	r7, r3, #40	; 0x28
90001080:	4614      	mov	r4, r2
90001082:	6818      	ldr	r0, [r3, #0]
90001084:	6859      	ldr	r1, [r3, #4]
90001086:	3308      	adds	r3, #8
90001088:	c403      	stmia	r4!, {r0, r1}
9000108a:	42bb      	cmp	r3, r7
9000108c:	4622      	mov	r2, r4
9000108e:	d1f7      	bne.n	90001080 <tfm_its_read_uid.isra.4+0x10>
  uint8_t expected_data[] = TEST_DATA;
90001090:	aa03      	add	r2, sp, #12
90001092:	4617      	mov	r7, r2
  uint8_t read_data[] = TEST_READ_DATA ;
90001094:	6818      	ldr	r0, [r3, #0]
90001096:	791b      	ldrb	r3, [r3, #4]
90001098:	6020      	str	r0, [r4, #0]
9000109a:	7123      	strb	r3, [r4, #4]
  uint8_t expected_data[] = TEST_DATA;
9000109c:	4b13      	ldr	r3, [pc, #76]	; (900010ec <tfm_its_read_uid.isra.4+0x7c>)
9000109e:	f103 0c18 	add.w	ip, r3, #24
900010a2:	4614      	mov	r4, r2
900010a4:	6818      	ldr	r0, [r3, #0]
900010a6:	6859      	ldr	r1, [r3, #4]
900010a8:	3308      	adds	r3, #8
900010aa:	c403      	stmia	r4!, {r0, r1}
900010ac:	4563      	cmp	r3, ip
900010ae:	4622      	mov	r2, r4
900010b0:	d1f7      	bne.n	900010a2 <tfm_its_read_uid.isra.4+0x32>
900010b2:	881b      	ldrh	r3, [r3, #0]
  /* read UID */
  status = psa_its_get(uid, 0, TEST_DATA_SIZE, read_data, &data_len);
900010b4:	2200      	movs	r2, #0
  uint8_t expected_data[] = TEST_DATA;
900010b6:	8023      	strh	r3, [r4, #0]
  status = psa_its_get(uid, 0, TEST_DATA_SIZE, read_data, &data_len);
900010b8:	ab02      	add	r3, sp, #8
900010ba:	e9cd 6300 	strd	r6, r3, [sp]
900010be:	2002      	movs	r0, #2
900010c0:	2319      	movs	r3, #25
900010c2:	2100      	movs	r1, #0
900010c4:	f001 fd5c 	bl	90002b80 <psa_its_get>
  if ((status == PSA_SUCCESS) && (data_len == TEST_DATA_SIZE)
900010c8:	b950      	cbnz	r0, 900010e0 <tfm_its_read_uid.isra.4+0x70>
900010ca:	9a02      	ldr	r2, [sp, #8]
900010cc:	2a19      	cmp	r2, #25
900010ce:	d107      	bne.n	900010e0 <tfm_its_read_uid.isra.4+0x70>
      && (!memcmp(read_data, expected_data, TEST_DATA_SIZE)))
900010d0:	4639      	mov	r1, r7
900010d2:	4630      	mov	r0, r6
900010d4:	f002 fa68 	bl	900035a8 <memcmp>
900010d8:	b910      	cbnz	r0, 900010e0 <tfm_its_read_uid.isra.4+0x70>
  {
    ret->val = TEST_PASSED;
900010da:	7028      	strb	r0, [r5, #0]
  else
  {
    ret->val = TEST_FAILED;
  }
  return;
}
900010dc:	b017      	add	sp, #92	; 0x5c
900010de:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret->val = TEST_FAILED;
900010e0:	2301      	movs	r3, #1
900010e2:	702b      	strb	r3, [r5, #0]
900010e4:	e7fa      	b.n	900010dc <tfm_its_read_uid.isra.4+0x6c>
900010e6:	bf00      	nop
900010e8:	9000565e 	.word	0x9000565e
900010ec:	9000568b 	.word	0x9000568b

900010f0 <dump_eat_token>:
void dump_eat_token(struct q_useful_buf_c *token)
{
900010f0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t len = token->len;
  int32_t n_item_per_line;
  int32_t i, index = 0;
  uint8_t *byte = (uint8_t *)token->ptr;
900010f4:	e9d0 8700 	ldrd	r8, r7, [r0]
  int32_t i, index = 0;
900010f8:	2400      	movs	r4, #0
  while (index < len)
  {
    n_item_per_line = (len-index) >= 20 ? 20 : (len-index);
    for (i = 0; i < n_item_per_line; i++)
    {
      printf("%2.2x", byte[index + i]);
900010fa:	f8df 9044 	ldr.w	r9, [pc, #68]	; 90001140 <dump_eat_token+0x50>
    }
    printf("\r\n");
900010fe:	f8df a03c 	ldr.w	sl, [pc, #60]	; 9000113c <dump_eat_token+0x4c>
  while (index < len)
90001102:	42bc      	cmp	r4, r7
90001104:	db04      	blt.n	90001110 <dump_eat_token+0x20>
    index += n_item_per_line;

  }
  printf("\r\n");

}
90001106:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  printf("\r\n");
9000110a:	480c      	ldr	r0, [pc, #48]	; (9000113c <dump_eat_token+0x4c>)
9000110c:	f002 bae2 	b.w	900036d4 <puts>
    n_item_per_line = (len-index) >= 20 ? 20 : (len-index);
90001110:	1b3d      	subs	r5, r7, r4
90001112:	2d14      	cmp	r5, #20
90001114:	eb08 0604 	add.w	r6, r8, r4
90001118:	bfa8      	it	ge
9000111a:	2514      	movge	r5, #20
9000111c:	46b3      	mov	fp, r6
    for (i = 0; i < n_item_per_line; i++)
9000111e:	eba6 030b 	sub.w	r3, r6, fp
90001122:	429d      	cmp	r5, r3
90001124:	dc04      	bgt.n	90001130 <dump_eat_token+0x40>
    printf("\r\n");
90001126:	4650      	mov	r0, sl
90001128:	f002 fad4 	bl	900036d4 <puts>
    index += n_item_per_line;
9000112c:	442c      	add	r4, r5
9000112e:	e7e8      	b.n	90001102 <dump_eat_token+0x12>
      printf("%2.2x", byte[index + i]);
90001130:	f816 1b01 	ldrb.w	r1, [r6], #1
90001134:	4648      	mov	r0, r9
90001136:	f002 fa59 	bl	900035ec <iprintf>
9000113a:	e7f0      	b.n	9000111e <dump_eat_token+0x2e>
9000113c:	90004bc5 	.word	0x90004bc5
90001140:	9000504c 	.word	0x9000504c

90001144 <tfm_eat_test_circuit_sig.isra.6.constprop.7>:
  * @brief  request eat short cicuit, check result and
  * display response result buffer.
  * @param  struct test_result_t
  * @retval None
  */
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
90001144:	b5f0      	push	{r4, r5, r6, r7, lr}
  Q_USEFUL_BUF_MAKE_STACK_UB(token_storage, ATTEST_TOKEN_MAX_SIZE);
  struct q_useful_buf_c completed_token;
  struct q_useful_buf_c tmp;

  /* -- Make a token with all the claims -- */
  tmp = TOKEN_TEST_VALUE_NONCE;
90001146:	2440      	movs	r4, #64	; 0x40
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
90001148:	f5ad 7d31 	sub.w	sp, sp, #708	; 0x2c4
  tmp = TOKEN_TEST_VALUE_NONCE;
9000114c:	ab10      	add	r3, sp, #64	; 0x40
9000114e:	4622      	mov	r2, r4
90001150:	2100      	movs	r1, #0
static void tfm_eat_test_circuit_sig(uint32_t encode_options, struct test_result_t *ret)
90001152:	4606      	mov	r6, r0
  tmp = TOKEN_TEST_VALUE_NONCE;
90001154:	4618      	mov	r0, r3
90001156:	f002 fa41 	bl	900035dc <memset>
9000115a:	e9cd 0406 	strd	r0, r4, [sp, #24]
  printf("token request value :\r\n");
9000115e:	4823      	ldr	r0, [pc, #140]	; (900011ec <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xa8>)
90001160:	f002 fab8 	bl	900036d4 <puts>
  dump_eat_token(&tmp);
90001164:	a806      	add	r0, sp, #24
90001166:	f7ff ffc3 	bl	900010f0 <dump_eat_token>
9000116a:	e9dd 5406 	ldrd	r5, r4, [sp, #24]
  enum psa_attest_err_t return_value;
  uint32_t completed_token_len;
  struct q_useful_buf_c        actual_nonce;
  Q_USEFUL_BUF_MAKE_STACK_UB(actual_nonce_storage, 64);

  if (nonce.len == 64 && q_useful_buf_is_value(nonce, 0))
9000116e:	2c40      	cmp	r4, #64	; 0x40
90001170:	d11c      	bne.n	900011ac <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x68>
90001172:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
90001176:	ab0a      	add	r3, sp, #40	; 0x28
}

static inline size_t q_useful_buf_is_value(const struct q_useful_buf_c buf,
                                           uint8_t uValue)
{
    return UsefulBuf_IsValue(buf, uValue);
90001178:	2200      	movs	r2, #0
9000117a:	e893 0003 	ldmia.w	r3, {r0, r1}
9000117e:	f001 f95b 	bl	90002438 <UsefulBuf_IsValue>
90001182:	b198      	cbz	r0, 900011ac <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x68>
90001184:	e9cd 540e 	strd	r5, r4, [sp, #56]	; 0x38
90001188:	af20      	add	r7, sp, #128	; 0x80
9000118a:	ab0e      	add	r3, sp, #56	; 0x38
}


static inline UsefulBufC UsefulBuf_Copy(UsefulBuf Dest, const UsefulBufC Src)
{
   return UsefulBuf_CopyOffset(Dest, 0, Src);
9000118c:	e893 0003 	ldmia.w	r3, {r0, r1}
90001190:	e9cd 740c 	strd	r7, r4, [sp, #48]	; 0x30
90001194:	e88d 0003 	stmia.w	sp, {r0, r1}
90001198:	aa0c      	add	r2, sp, #48	; 0x30
9000119a:	2300      	movs	r3, #0
9000119c:	ca06      	ldmia	r2, {r1, r2}
9000119e:	a808      	add	r0, sp, #32
900011a0:	f001 f92d 	bl	900023fe <UsefulBuf_CopyOffset>
    return UsefulBuf_Copy(dest, src);
900011a4:	e9dd 5408 	ldrd	r5, r4, [sp, #32]
  {
    /* Go into special option-packed nonce mode */
    actual_nonce = q_useful_buf_copy(actual_nonce_storage, nonce);
    /* Use memcpy as it always works and avoids type punning */
    memcpy((uint8_t *)actual_nonce_storage.ptr,
900011a8:	2300      	movs	r3, #0
900011aa:	603b      	str	r3, [r7, #0]
  else
  {
    actual_nonce = nonce;
  }

  completed_token_len = (uint32_t)buffer.len;
900011ac:	f44f 7300 	mov.w	r3, #512	; 0x200
  return_value = psa_initial_attest_get_token(actual_nonce.ptr,
900011b0:	af30      	add	r7, sp, #192	; 0xc0
  completed_token_len = (uint32_t)buffer.len;
900011b2:	9303      	str	r3, [sp, #12]
  return_value = psa_initial_attest_get_token(actual_nonce.ptr,
900011b4:	4621      	mov	r1, r4
900011b6:	ab03      	add	r3, sp, #12
900011b8:	463a      	mov	r2, r7
900011ba:	4628      	mov	r0, r5
900011bc:	f001 fc92 	bl	90002ae4 <psa_initial_attest_get_token>
                                              (uint32_t)actual_nonce.len,
                                              buffer.ptr,
                                              &completed_token_len);

  *completed_token = (struct q_useful_buf_c)
900011c0:	9b03      	ldr	r3, [sp, #12]
  if (status == PSA_ATTEST_ERR_SUCCESS)
900011c2:	4601      	mov	r1, r0
  *completed_token = (struct q_useful_buf_c)
900011c4:	e9cd 7304 	strd	r7, r3, [sp, #16]
  if (status == PSA_ATTEST_ERR_SUCCESS)
900011c8:	b948      	cbnz	r0, 900011de <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x9a>
    ret->val = TEST_PASSED;
900011ca:	7030      	strb	r0, [r6, #0]
    printf("token response value :\r\n");
900011cc:	4808      	ldr	r0, [pc, #32]	; (900011f0 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xac>)
900011ce:	f002 fa81 	bl	900036d4 <puts>
    dump_eat_token(&completed_token);
900011d2:	a804      	add	r0, sp, #16
900011d4:	f7ff ff8c 	bl	900010f0 <dump_eat_token>
}
900011d8:	f50d 7d31 	add.w	sp, sp, #708	; 0x2c4
900011dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    printf("failed status %d\r\n", status);
900011de:	4805      	ldr	r0, [pc, #20]	; (900011f4 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0xb0>)
900011e0:	f002 fa04 	bl	900035ec <iprintf>
    ret->val = TEST_FAILED;
900011e4:	2301      	movs	r3, #1
900011e6:	7033      	strb	r3, [r6, #0]
900011e8:	e7f6      	b.n	900011d8 <tfm_eat_test_circuit_sig.isra.6.constprop.7+0x94>
900011ea:	bf00      	nop
900011ec:	9000561c 	.word	0x9000561c
900011f0:	90005633 	.word	0x90005633
900011f4:	9000564b 	.word	0x9000564b

900011f8 <tfm_app_menu>:
  uint8_t key = 0;
900011f8:	2300      	movs	r3, #0
{
900011fa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
900011fe:	b086      	sub	sp, #24
  uint8_t key = 0;
90001200:	f88d 3007 	strb.w	r3, [sp, #7]
  tfm_app_print_menu();
90001204:	f7ff fe66 	bl	90000ed4 <tfm_app_print_menu>
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001208:	4daf      	ldr	r5, [pc, #700]	; (900014c8 <tfm_app_menu+0x2d0>)
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_CCM, &ret);
9000120a:	f8df 930c 	ldr.w	r9, [pc, #780]	; 90001518 <tfm_app_menu+0x320>
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
9000120e:	f8df a30c 	ldr.w	sl, [pc, #780]	; 9000151c <tfm_app_menu+0x324>
    key = 0U;
90001212:	2400      	movs	r4, #0
90001214:	f88d 4007 	strb.w	r4, [sp, #7]
    COM_Flush();
90001218:	f7ff fbce 	bl	900009b8 <COM_Flush>
    if (COM_Receive(&key, 1U, COM_UART_TIMEOUT_MAX) == HAL_OK)
9000121c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
90001220:	2101      	movs	r1, #1
90001222:	f10d 0007 	add.w	r0, sp, #7
90001226:	f7ff fbbf 	bl	900009a8 <COM_Receive>
9000122a:	2800      	cmp	r0, #0
9000122c:	d1f2      	bne.n	90001214 <tfm_app_menu+0x1c>
      switch (key)
9000122e:	f89d 3007 	ldrb.w	r3, [sp, #7]
90001232:	2b36      	cmp	r3, #54	; 0x36
90001234:	f000 81a3 	beq.w	9000157e <tfm_app_menu+0x386>
90001238:	d821      	bhi.n	9000127e <tfm_app_menu+0x86>
9000123a:	2b32      	cmp	r3, #50	; 0x32
9000123c:	f000 8170 	beq.w	90001520 <tfm_app_menu+0x328>
90001240:	d808      	bhi.n	90001254 <tfm_app_menu+0x5c>
90001242:	2b30      	cmp	r3, #48	; 0x30
90001244:	d037      	beq.n	900012b6 <tfm_app_menu+0xbe>
90001246:	2b31      	cmp	r3, #49	; 0x31
90001248:	f000 812b 	beq.w	900014a2 <tfm_app_menu+0x2aa>
          printf("Invalid Number !\r");
9000124c:	489f      	ldr	r0, [pc, #636]	; (900014cc <tfm_app_menu+0x2d4>)
9000124e:	f002 f9cd 	bl	900035ec <iprintf>
90001252:	e123      	b.n	9000149c <tfm_app_menu+0x2a4>
      switch (key)
90001254:	2b34      	cmp	r3, #52	; 0x34
90001256:	f04f 0301 	mov.w	r3, #1
9000125a:	f000 8182 	beq.w	90001562 <tfm_app_menu+0x36a>
9000125e:	f240 8170 	bls.w	90001542 <tfm_app_menu+0x34a>
          tfm_sst_read_uid(&ret);
90001262:	a802      	add	r0, sp, #8
          ret.val = TEST_FAILED;
90001264:	f88d 3008 	strb.w	r3, [sp, #8]
          tfm_sst_read_uid(&ret);
90001268:	f7ff fea4 	bl	90000fb4 <tfm_sst_read_uid.isra.1>
          printf("SST read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
9000126c:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001270:	4b97      	ldr	r3, [pc, #604]	; (900014d0 <tfm_app_menu+0x2d8>)
90001272:	4898      	ldr	r0, [pc, #608]	; (900014d4 <tfm_app_menu+0x2dc>)
90001274:	2900      	cmp	r1, #0
90001276:	bf0c      	ite	eq
90001278:	4629      	moveq	r1, r5
9000127a:	4619      	movne	r1, r3
9000127c:	e121      	b.n	900014c2 <tfm_app_menu+0x2ca>
      switch (key)
9000127e:	2b61      	cmp	r3, #97	; 0x61
90001280:	f000 81a5 	beq.w	900015ce <tfm_app_menu+0x3d6>
90001284:	d80d      	bhi.n	900012a2 <tfm_app_menu+0xaa>
90001286:	2b38      	cmp	r3, #56	; 0x38
90001288:	f000 819a 	beq.w	900015c0 <tfm_app_menu+0x3c8>
9000128c:	f0c0 8189 	bcc.w	900015a2 <tfm_app_menu+0x3aa>
90001290:	2b39      	cmp	r3, #57	; 0x39
90001292:	d1db      	bne.n	9000124c <tfm_app_menu+0x54>
          ret.val = TEST_FAILED;
90001294:	2301      	movs	r3, #1
90001296:	a806      	add	r0, sp, #24
90001298:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_its_read_uid(&ret);
9000129c:	f7ff fee8 	bl	90001070 <tfm_its_read_uid.isra.4>
900012a0:	e7e4      	b.n	9000126c <tfm_app_menu+0x74>
      switch (key)
900012a2:	2b63      	cmp	r3, #99	; 0x63
900012a4:	f000 81ab 	beq.w	900015fe <tfm_app_menu+0x406>
900012a8:	f0c0 8199 	bcc.w	900015de <tfm_app_menu+0x3e6>
900012ac:	2b78      	cmp	r3, #120	; 0x78
900012ae:	d1cd      	bne.n	9000124c <tfm_app_menu+0x54>
}
900012b0:	b006      	add	sp, #24
900012b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          ret.val = TEST_FAILED;
900012b6:	f04f 0801 	mov.w	r8, #1
900012ba:	af06      	add	r7, sp, #24
900012bc:	f807 8d10 	strb.w	r8, [r7, #-16]!
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
900012c0:	463a      	mov	r2, r7
900012c2:	4651      	mov	r1, sl
900012c4:	4884      	ldr	r0, [pc, #528]	; (900014d8 <tfm_app_menu+0x2e0>)
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900012c6:	4e82      	ldr	r6, [pc, #520]	; (900014d0 <tfm_app_menu+0x2d8>)
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
900012c8:	f001 ffe0 	bl	9000328c <psa_aead_test>
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900012cc:	f89d 1008 	ldrb.w	r1, [sp, #8]
900012d0:	4882      	ldr	r0, [pc, #520]	; (900014dc <tfm_app_menu+0x2e4>)
900012d2:	2900      	cmp	r1, #0
900012d4:	bf0c      	ite	eq
900012d6:	4629      	moveq	r1, r5
900012d8:	4631      	movne	r1, r6
900012da:	f002 f987 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900012de:	f89d 4008 	ldrb.w	r4, [sp, #8]
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
900012e2:	463a      	mov	r2, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900012e4:	fab4 f484 	clz	r4, r4
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
900012e8:	497d      	ldr	r1, [pc, #500]	; (900014e0 <tfm_app_menu+0x2e8>)
900012ea:	487b      	ldr	r0, [pc, #492]	; (900014d8 <tfm_app_menu+0x2e0>)
          ret.val = TEST_FAILED;
900012ec:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
900012f0:	f001 fd44 	bl	90002d7c <psa_cipher_test>
          printf("AES CBC test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900012f4:	f89d 1008 	ldrb.w	r1, [sp, #8]
900012f8:	487a      	ldr	r0, [pc, #488]	; (900014e4 <tfm_app_menu+0x2ec>)
900012fa:	2900      	cmp	r1, #0
900012fc:	bf0c      	ite	eq
900012fe:	4629      	moveq	r1, r5
90001300:	4631      	movne	r1, r6
90001302:	f002 f973 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001306:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000130a:	0964      	lsrs	r4, r4, #5
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000130c:	2b00      	cmp	r3, #0
9000130e:	bf08      	it	eq
90001310:	3401      	addeq	r4, #1
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_CCM, &ret);
90001312:	463a      	mov	r2, r7
90001314:	4649      	mov	r1, r9
90001316:	4870      	ldr	r0, [pc, #448]	; (900014d8 <tfm_app_menu+0x2e0>)
          ret.val = TEST_FAILED;
90001318:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_CCM, &ret);
9000131c:	f001 ffb6 	bl	9000328c <psa_aead_test>
          printf("AES CCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001320:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001324:	4870      	ldr	r0, [pc, #448]	; (900014e8 <tfm_app_menu+0x2f0>)
90001326:	2900      	cmp	r1, #0
90001328:	bf0c      	ite	eq
9000132a:	4629      	moveq	r1, r5
9000132c:	4631      	movne	r1, r6
9000132e:	f002 f95d 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001332:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_sst_set_uid(&ret);
90001336:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001338:	2b00      	cmp	r3, #0
9000133a:	bf08      	it	eq
9000133c:	3401      	addeq	r4, #1
          tfm_sst_set_uid(&ret);
9000133e:	f7ff fe17 	bl	90000f70 <tfm_sst_set_uid.isra.0>
          printf("SST set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001342:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001346:	4869      	ldr	r0, [pc, #420]	; (900014ec <tfm_app_menu+0x2f4>)
90001348:	2900      	cmp	r1, #0
9000134a:	bf0c      	ite	eq
9000134c:	4629      	moveq	r1, r5
9000134e:	4631      	movne	r1, r6
90001350:	f002 f94c 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001354:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_sst_read_uid(&ret);
90001358:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000135a:	2b00      	cmp	r3, #0
9000135c:	bf08      	it	eq
9000135e:	3401      	addeq	r4, #1
          tfm_sst_read_uid(&ret);
90001360:	f7ff fe28 	bl	90000fb4 <tfm_sst_read_uid.isra.1>
          printf("SST read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001364:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001368:	485a      	ldr	r0, [pc, #360]	; (900014d4 <tfm_app_menu+0x2dc>)
9000136a:	2900      	cmp	r1, #0
9000136c:	bf0c      	ite	eq
9000136e:	4629      	moveq	r1, r5
90001370:	4631      	movne	r1, r6
90001372:	f002 f93b 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001376:	f89d 3008 	ldrb.w	r3, [sp, #8]
  status = psa_ps_remove(uid);
9000137a:	2100      	movs	r1, #0
9000137c:	2002      	movs	r0, #2
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000137e:	2b00      	cmp	r3, #0
90001380:	bf08      	it	eq
90001382:	3401      	addeq	r4, #1
  status = psa_ps_remove(uid);
90001384:	f001 fcd5 	bl	90002d32 <psa_ps_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
90001388:	2800      	cmp	r0, #0
9000138a:	bf13      	iteet	ne
9000138c:	4643      	movne	r3, r8
9000138e:	2300      	moveq	r3, #0
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001390:	4629      	moveq	r1, r5
90001392:	4631      	movne	r1, r6
90001394:	4856      	ldr	r0, [pc, #344]	; (900014f0 <tfm_app_menu+0x2f8>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
90001396:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
9000139a:	f002 f927 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000139e:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
900013a2:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900013a4:	2b00      	cmp	r3, #0
900013a6:	bf08      	it	eq
900013a8:	3401      	addeq	r4, #1
          ret.val = TEST_FAILED;
900013aa:	f88d 8008 	strb.w	r8, [sp, #8]
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
900013ae:	f7ff fec9 	bl	90001144 <tfm_eat_test_circuit_sig.isra.6.constprop.7>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900013b2:	f89d 1008 	ldrb.w	r1, [sp, #8]
900013b6:	484f      	ldr	r0, [pc, #316]	; (900014f4 <tfm_app_menu+0x2fc>)
900013b8:	2900      	cmp	r1, #0
900013ba:	bf0c      	ite	eq
900013bc:	4629      	moveq	r1, r5
900013be:	4631      	movne	r1, r6
900013c0:	f002 f914 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900013c4:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_its_set_uid(&ret);
900013c8:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900013ca:	2b00      	cmp	r3, #0
900013cc:	bf08      	it	eq
900013ce:	3401      	addeq	r4, #1
          tfm_its_set_uid(&ret);
900013d0:	f7ff fe2c 	bl	9000102c <tfm_its_set_uid.isra.3>
          printf("ITS set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900013d4:	f89d 1008 	ldrb.w	r1, [sp, #8]
900013d8:	4847      	ldr	r0, [pc, #284]	; (900014f8 <tfm_app_menu+0x300>)
900013da:	2900      	cmp	r1, #0
900013dc:	bf0c      	ite	eq
900013de:	4629      	moveq	r1, r5
900013e0:	4631      	movne	r1, r6
900013e2:	f002 f903 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900013e6:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tfm_its_read_uid(&ret);
900013ea:	4638      	mov	r0, r7
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
900013ec:	2b00      	cmp	r3, #0
900013ee:	bf08      	it	eq
900013f0:	3401      	addeq	r4, #1
          tfm_its_read_uid(&ret);
900013f2:	f7ff fe3d 	bl	90001070 <tfm_its_read_uid.isra.4>
          printf("ITS read / check UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900013f6:	f89d 1008 	ldrb.w	r1, [sp, #8]
900013fa:	4840      	ldr	r0, [pc, #256]	; (900014fc <tfm_app_menu+0x304>)
900013fc:	2900      	cmp	r1, #0
900013fe:	bf0c      	ite	eq
90001400:	4629      	moveq	r1, r5
90001402:	4631      	movne	r1, r6
90001404:	f002 f8f2 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001408:	f89d 3008 	ldrb.w	r3, [sp, #8]
  status = psa_its_remove(uid);
9000140c:	2100      	movs	r1, #0
9000140e:	2002      	movs	r0, #2
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001410:	2b00      	cmp	r3, #0
90001412:	bf08      	it	eq
90001414:	3401      	addeq	r4, #1
  status = psa_its_remove(uid);
90001416:	f001 fbe5 	bl	90002be4 <psa_its_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
9000141a:	2800      	cmp	r0, #0
9000141c:	bf13      	iteet	ne
9000141e:	4643      	movne	r3, r8
90001420:	2300      	moveq	r3, #0
          printf("ITS remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001422:	4629      	moveq	r1, r5
90001424:	4631      	movne	r1, r6
90001426:	4836      	ldr	r0, [pc, #216]	; (90001500 <tfm_app_menu+0x308>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
90001428:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("ITS remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
9000142c:	f002 f8de 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001430:	f89d 3008 	ldrb.w	r3, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001434:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001436:	2b00      	cmp	r3, #0
90001438:	bf08      	it	eq
9000143a:	3401      	addeq	r4, #1
          psa_hash_test(PSA_ALG_SHA_224, &ret);
9000143c:	4639      	mov	r1, r7
9000143e:	4831      	ldr	r0, [pc, #196]	; (90001504 <tfm_app_menu+0x30c>)
          ret.val = TEST_FAILED;
90001440:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_224, &ret);
90001444:	f001 fe7e 	bl	90003144 <psa_hash_test>
          printf("SHA224 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001448:	f89d 1008 	ldrb.w	r1, [sp, #8]
9000144c:	482e      	ldr	r0, [pc, #184]	; (90001508 <tfm_app_menu+0x310>)
9000144e:	2900      	cmp	r1, #0
90001450:	bf0c      	ite	eq
90001452:	4629      	moveq	r1, r5
90001454:	4631      	movne	r1, r6
90001456:	f002 f8c9 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000145a:	f89d 1008 	ldrb.w	r1, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000145e:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001460:	2900      	cmp	r1, #0
90001462:	bf08      	it	eq
90001464:	3401      	addeq	r4, #1
          psa_hash_test(PSA_ALG_SHA_256, &ret);
90001466:	4829      	ldr	r0, [pc, #164]	; (9000150c <tfm_app_menu+0x314>)
90001468:	4639      	mov	r1, r7
          ret.val = TEST_FAILED;
9000146a:	f88d 8008 	strb.w	r8, [sp, #8]
          psa_hash_test(PSA_ALG_SHA_256, &ret);
9000146e:	f001 fe69 	bl	90003144 <psa_hash_test>
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001472:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001476:	4826      	ldr	r0, [pc, #152]	; (90001510 <tfm_app_menu+0x318>)
90001478:	2900      	cmp	r1, #0
9000147a:	bf0c      	ite	eq
9000147c:	4629      	moveq	r1, r5
9000147e:	4631      	movne	r1, r6
90001480:	f002 f8b4 	bl	900035ec <iprintf>
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001484:	f89d 1008 	ldrb.w	r1, [sp, #8]
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
90001488:	b2e4      	uxtb	r4, r4
          tests_success += (ret.val == TEST_PASSED) ? 1 : 0;
9000148a:	2900      	cmp	r1, #0
9000148c:	bf14      	ite	ne
9000148e:	4621      	movne	r1, r4
90001490:	1c61      	addeq	r1, r4, #1
          printf("CUMULATIVE RESULT: %d/%d success\r\n", tests_success, tests_executed);
90001492:	220c      	movs	r2, #12
90001494:	b2c9      	uxtb	r1, r1
90001496:	481f      	ldr	r0, [pc, #124]	; (90001514 <tfm_app_menu+0x31c>)
90001498:	f002 f8a8 	bl	900035ec <iprintf>
          tfm_app_print_menu();
9000149c:	f7ff fd1a 	bl	90000ed4 <tfm_app_print_menu>
          break;
900014a0:	e6b7      	b.n	90001212 <tfm_app_menu+0x1a>
          ret.val = TEST_FAILED;
900014a2:	2301      	movs	r3, #1
900014a4:	aa06      	add	r2, sp, #24
900014a6:	f802 3d10 	strb.w	r3, [r2, #-16]!
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_GCM, &ret);
900014aa:	4651      	mov	r1, sl
900014ac:	480a      	ldr	r0, [pc, #40]	; (900014d8 <tfm_app_menu+0x2e0>)
900014ae:	f001 feed 	bl	9000328c <psa_aead_test>
          printf("AES GCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900014b2:	f89d 1008 	ldrb.w	r1, [sp, #8]
900014b6:	4b06      	ldr	r3, [pc, #24]	; (900014d0 <tfm_app_menu+0x2d8>)
900014b8:	4808      	ldr	r0, [pc, #32]	; (900014dc <tfm_app_menu+0x2e4>)
900014ba:	2900      	cmp	r1, #0
900014bc:	bf0c      	ite	eq
900014be:	4629      	moveq	r1, r5
900014c0:	4619      	movne	r1, r3
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900014c2:	f002 f893 	bl	900035ec <iprintf>
900014c6:	e7e9      	b.n	9000149c <tfm_app_menu+0x2a4>
900014c8:	90005052 	.word	0x90005052
900014cc:	90004a8b 	.word	0x90004a8b
900014d0:	9000505d 	.word	0x9000505d
900014d4:	900050b0 	.word	0x900050b0
900014d8:	40000001 	.word	0x40000001
900014dc:	90005064 	.word	0x90005064
900014e0:	04600100 	.word	0x04600100
900014e4:	90005076 	.word	0x90005076
900014e8:	90005088 	.word	0x90005088
900014ec:	9000509a 	.word	0x9000509a
900014f0:	900050cf 	.word	0x900050cf
900014f4:	900050e8 	.word	0x900050e8
900014f8:	90005109 	.word	0x90005109
900014fc:	9000511f 	.word	0x9000511f
90001500:	9000513e 	.word	0x9000513e
90001504:	01000008 	.word	0x01000008
90001508:	90005157 	.word	0x90005157
9000150c:	01000009 	.word	0x01000009
90001510:	90005168 	.word	0x90005168
90001514:	90005179 	.word	0x90005179
90001518:	06001001 	.word	0x06001001
9000151c:	06001002 	.word	0x06001002
          ret.val = TEST_FAILED;
90001520:	2301      	movs	r3, #1
90001522:	aa06      	add	r2, sp, #24
90001524:	f802 3d10 	strb.w	r3, [r2, #-16]!
          psa_cipher_test(PSA_KEY_TYPE_AES, PSA_ALG_CBC_NO_PADDING, &ret);;
90001528:	493d      	ldr	r1, [pc, #244]	; (90001620 <tfm_app_menu+0x428>)
9000152a:	483e      	ldr	r0, [pc, #248]	; (90001624 <tfm_app_menu+0x42c>)
9000152c:	f001 fc26 	bl	90002d7c <psa_cipher_test>
          printf("AES CBC test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001530:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001534:	4b3c      	ldr	r3, [pc, #240]	; (90001628 <tfm_app_menu+0x430>)
90001536:	483d      	ldr	r0, [pc, #244]	; (9000162c <tfm_app_menu+0x434>)
90001538:	2900      	cmp	r1, #0
9000153a:	bf0c      	ite	eq
9000153c:	4629      	moveq	r1, r5
9000153e:	4619      	movne	r1, r3
90001540:	e7bf      	b.n	900014c2 <tfm_app_menu+0x2ca>
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_CCM, &ret);
90001542:	4649      	mov	r1, r9
90001544:	4837      	ldr	r0, [pc, #220]	; (90001624 <tfm_app_menu+0x42c>)
90001546:	aa02      	add	r2, sp, #8
          ret.val = TEST_FAILED;
90001548:	f88d 3008 	strb.w	r3, [sp, #8]
          psa_aead_test(PSA_KEY_TYPE_AES, PSA_ALG_CCM, &ret);
9000154c:	f001 fe9e 	bl	9000328c <psa_aead_test>
          printf("AES CCM test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001550:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001554:	4b34      	ldr	r3, [pc, #208]	; (90001628 <tfm_app_menu+0x430>)
90001556:	4836      	ldr	r0, [pc, #216]	; (90001630 <tfm_app_menu+0x438>)
90001558:	2900      	cmp	r1, #0
9000155a:	bf0c      	ite	eq
9000155c:	4629      	moveq	r1, r5
9000155e:	4619      	movne	r1, r3
90001560:	e7af      	b.n	900014c2 <tfm_app_menu+0x2ca>
          tfm_sst_set_uid(&ret);
90001562:	a802      	add	r0, sp, #8
          ret.val = TEST_FAILED;
90001564:	f88d 3008 	strb.w	r3, [sp, #8]
          tfm_sst_set_uid(&ret);
90001568:	f7ff fd02 	bl	90000f70 <tfm_sst_set_uid.isra.0>
          printf("SST set UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
9000156c:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001570:	4b2d      	ldr	r3, [pc, #180]	; (90001628 <tfm_app_menu+0x430>)
90001572:	4830      	ldr	r0, [pc, #192]	; (90001634 <tfm_app_menu+0x43c>)
90001574:	2900      	cmp	r1, #0
90001576:	bf0c      	ite	eq
90001578:	4629      	moveq	r1, r5
9000157a:	4619      	movne	r1, r3
9000157c:	e7a1      	b.n	900014c2 <tfm_app_menu+0x2ca>
          ret.val = TEST_FAILED;
9000157e:	2301      	movs	r3, #1
  status = psa_ps_remove(uid);
90001580:	2002      	movs	r0, #2
90001582:	2100      	movs	r1, #0
          ret.val = TEST_FAILED;
90001584:	f88d 3008 	strb.w	r3, [sp, #8]
  status = psa_ps_remove(uid);
90001588:	f001 fbd3 	bl	90002d32 <psa_ps_remove>
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
9000158c:	2800      	cmp	r0, #0
9000158e:	bf14      	ite	ne
90001590:	2301      	movne	r3, #1
90001592:	2300      	moveq	r3, #0
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
90001594:	4924      	ldr	r1, [pc, #144]	; (90001628 <tfm_app_menu+0x430>)
  ret->val = status == PSA_SUCCESS ? TEST_PASSED : TEST_FAILED;
90001596:	f88d 3008 	strb.w	r3, [sp, #8]
          printf("SST remove UID test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
9000159a:	bf08      	it	eq
9000159c:	4629      	moveq	r1, r5
9000159e:	4826      	ldr	r0, [pc, #152]	; (90001638 <tfm_app_menu+0x440>)
900015a0:	e78f      	b.n	900014c2 <tfm_app_menu+0x2ca>
          ret.val = TEST_FAILED;
900015a2:	2301      	movs	r3, #1
900015a4:	a806      	add	r0, sp, #24
900015a6:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_eat_test_circuit_sig(TOKEN_OPT_NORMAL_CIRCUIT_SIGN, &ret);
900015aa:	f7ff fdcb 	bl	90001144 <tfm_eat_test_circuit_sig.isra.6.constprop.7>
          printf("EAT normal circuit sig test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900015ae:	f89d 1008 	ldrb.w	r1, [sp, #8]
900015b2:	4b1d      	ldr	r3, [pc, #116]	; (90001628 <tfm_app_menu+0x430>)
900015b4:	4821      	ldr	r0, [pc, #132]	; (9000163c <tfm_app_menu+0x444>)
900015b6:	2900      	cmp	r1, #0
900015b8:	bf0c      	ite	eq
900015ba:	4629      	moveq	r1, r5
900015bc:	4619      	movne	r1, r3
900015be:	e780      	b.n	900014c2 <tfm_app_menu+0x2ca>
          ret.val = TEST_FAILED;
900015c0:	2301      	movs	r3, #1
900015c2:	a806      	add	r0, sp, #24
900015c4:	f800 3d10 	strb.w	r3, [r0, #-16]!
          tfm_its_set_uid(&ret);
900015c8:	f7ff fd30 	bl	9000102c <tfm_its_set_uid.isra.3>
900015cc:	e7ce      	b.n	9000156c <tfm_app_menu+0x374>
          ret.val = TEST_FAILED;
900015ce:	2301      	movs	r3, #1
  status = psa_its_remove(uid);
900015d0:	2100      	movs	r1, #0
900015d2:	2002      	movs	r0, #2
          ret.val = TEST_FAILED;
900015d4:	f88d 3008 	strb.w	r3, [sp, #8]
  status = psa_its_remove(uid);
900015d8:	f001 fb04 	bl	90002be4 <psa_its_remove>
900015dc:	e7d6      	b.n	9000158c <tfm_app_menu+0x394>
          ret.val = TEST_FAILED;
900015de:	2301      	movs	r3, #1
900015e0:	a906      	add	r1, sp, #24
900015e2:	f801 3d10 	strb.w	r3, [r1, #-16]!
          psa_hash_test(PSA_ALG_SHA_224, &ret);
900015e6:	4816      	ldr	r0, [pc, #88]	; (90001640 <tfm_app_menu+0x448>)
900015e8:	f001 fdac 	bl	90003144 <psa_hash_test>
          printf("SHA224 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
900015ec:	f89d 1008 	ldrb.w	r1, [sp, #8]
900015f0:	4b0d      	ldr	r3, [pc, #52]	; (90001628 <tfm_app_menu+0x430>)
900015f2:	4814      	ldr	r0, [pc, #80]	; (90001644 <tfm_app_menu+0x44c>)
900015f4:	2900      	cmp	r1, #0
900015f6:	bf0c      	ite	eq
900015f8:	4629      	moveq	r1, r5
900015fa:	4619      	movne	r1, r3
900015fc:	e761      	b.n	900014c2 <tfm_app_menu+0x2ca>
          ret.val = TEST_FAILED;
900015fe:	2301      	movs	r3, #1
90001600:	a906      	add	r1, sp, #24
90001602:	f801 3d10 	strb.w	r3, [r1, #-16]!
          psa_hash_test(PSA_ALG_SHA_256, &ret);
90001606:	4810      	ldr	r0, [pc, #64]	; (90001648 <tfm_app_menu+0x450>)
90001608:	f001 fd9c 	bl	90003144 <psa_hash_test>
          printf("SHA256 test %s\r\n", (ret.val == TEST_PASSED) ? "SUCCESSFUL" : "FAILED");
9000160c:	f89d 1008 	ldrb.w	r1, [sp, #8]
90001610:	4b05      	ldr	r3, [pc, #20]	; (90001628 <tfm_app_menu+0x430>)
90001612:	480e      	ldr	r0, [pc, #56]	; (9000164c <tfm_app_menu+0x454>)
90001614:	2900      	cmp	r1, #0
90001616:	bf0c      	ite	eq
90001618:	4629      	moveq	r1, r5
9000161a:	4619      	movne	r1, r3
9000161c:	e751      	b.n	900014c2 <tfm_app_menu+0x2ca>
9000161e:	bf00      	nop
90001620:	04600100 	.word	0x04600100
90001624:	40000001 	.word	0x40000001
90001628:	9000505d 	.word	0x9000505d
9000162c:	90005076 	.word	0x90005076
90001630:	90005088 	.word	0x90005088
90001634:	9000509a 	.word	0x9000509a
90001638:	900050cf 	.word	0x900050cf
9000163c:	900050e8 	.word	0x900050e8
90001640:	01000008 	.word	0x01000008
90001644:	90005157 	.word	0x90005157
90001648:	01000009 	.word	0x01000009
9000164c:	90005168 	.word	0x90005168

90001650 <tfm_ns_interface_dispatch>:
  * \brief NS world, NS lock based dispatcher
  */
int32_t tfm_ns_interface_dispatch(veneer_fn fn,
                                  uint32_t arg0, uint32_t arg1,
                                  uint32_t arg2, uint32_t arg3)
{
90001650:	b570      	push	{r4, r5, r6, lr}
90001652:	4606      	mov	r6, r0
90001654:	4608      	mov	r0, r1
90001656:	4611      	mov	r1, r2
90001658:	461a      	mov	r2, r3
__STATIC_FORCEINLINE uint8_t __LDREXB(volatile uint8_t *addr)
{
    uint32_t result;

#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
9000165a:	4c08      	ldr	r4, [pc, #32]	; (9000167c <tfm_ns_interface_dispatch+0x2c>)
9000165c:	e8d4 3f4f 	ldrexb	r3, [r4]
    newValue = __LDREXB(valuePtr) + delta;
90001660:	3301      	adds	r3, #1
90001662:	b2db      	uxtb	r3, r3
 */
__STATIC_FORCEINLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
{
   uint32_t result;

   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
90001664:	e8c4 3f45 	strexb	r5, r3, [r4]
  } while (__STREXB(newValue, valuePtr));
90001668:	2d00      	cmp	r5, #0
9000166a:	d1f7      	bne.n	9000165c <tfm_ns_interface_dispatch+0xc>
  uint32_t ret;
  /*  We're only supporting a single user of RNG */
  if (core_util_atomic_incr_u8(&users, 1) > 1)
9000166c:	2b01      	cmp	r3, #1
9000166e:	d900      	bls.n	90001672 <tfm_ns_interface_dispatch+0x22>
90001670:	e7fe      	b.n	90001670 <tfm_ns_interface_dispatch+0x20>
  {
    while (1);
  }
  ret = (uint32_t)fn(arg0, arg1, arg2, arg3);
90001672:	9b04      	ldr	r3, [sp, #16]
90001674:	47b0      	blx	r6
  users = 0;
90001676:	7025      	strb	r5, [r4, #0]
  return ret;
}
90001678:	bd70      	pop	{r4, r5, r6, pc}
9000167a:	bf00      	nop
9000167c:	20000240 	.word	0x20000240

90001680 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
90001680:	4770      	bx	lr
	...

90001684 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
90001684:	b538      	push	{r3, r4, r5, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
90001686:	4b0f      	ldr	r3, [pc, #60]	; (900016c4 <HAL_InitTick+0x40>)
{
90001688:	4605      	mov	r5, r0
  if ((uint32_t)uwTickFreq != 0U)
9000168a:	7818      	ldrb	r0, [r3, #0]
9000168c:	b908      	cbnz	r0, 90001692 <HAL_InitTick+0xe>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
9000168e:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
90001690:	bd38      	pop	{r3, r4, r5, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
90001692:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
90001696:	fbb3 f3f0 	udiv	r3, r3, r0
9000169a:	4a0b      	ldr	r2, [pc, #44]	; (900016c8 <HAL_InitTick+0x44>)
9000169c:	6810      	ldr	r0, [r2, #0]
9000169e:	fbb0 f0f3 	udiv	r0, r0, r3
900016a2:	f000 f891 	bl	900017c8 <HAL_SYSTICK_Config>
900016a6:	4604      	mov	r4, r0
900016a8:	2800      	cmp	r0, #0
900016aa:	d1f0      	bne.n	9000168e <HAL_InitTick+0xa>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
900016ac:	2d07      	cmp	r5, #7
900016ae:	d8ee      	bhi.n	9000168e <HAL_InitTick+0xa>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
900016b0:	4602      	mov	r2, r0
900016b2:	4629      	mov	r1, r5
900016b4:	f04f 30ff 	mov.w	r0, #4294967295
900016b8:	f000 f852 	bl	90001760 <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
900016bc:	4b03      	ldr	r3, [pc, #12]	; (900016cc <HAL_InitTick+0x48>)
900016be:	4620      	mov	r0, r4
900016c0:	601d      	str	r5, [r3, #0]
900016c2:	e7e5      	b.n	90001690 <HAL_InitTick+0xc>
900016c4:	20000104 	.word	0x20000104
900016c8:	20000100 	.word	0x20000100
900016cc:	20000108 	.word	0x20000108

900016d0 <HAL_Init>:
{
900016d0:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
900016d2:	2004      	movs	r0, #4
900016d4:	f000 f832 	bl	9000173c <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
900016d8:	f7ff fa50 	bl	90000b7c <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
900016dc:	2007      	movs	r0, #7
900016de:	f7ff ffd1 	bl	90001684 <HAL_InitTick>
900016e2:	4604      	mov	r4, r0
900016e4:	b918      	cbnz	r0, 900016ee <HAL_Init+0x1e>
    HAL_MspInit();
900016e6:	f7ff ffcb 	bl	90001680 <HAL_MspInit>
}
900016ea:	4620      	mov	r0, r4
900016ec:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
900016ee:	2401      	movs	r4, #1
900016f0:	e7fb      	b.n	900016ea <HAL_Init+0x1a>
	...

900016f4 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
900016f4:	4a03      	ldr	r2, [pc, #12]	; (90001704 <HAL_IncTick+0x10>)
900016f6:	4b04      	ldr	r3, [pc, #16]	; (90001708 <HAL_IncTick+0x14>)
900016f8:	6811      	ldr	r1, [r2, #0]
900016fa:	781b      	ldrb	r3, [r3, #0]
900016fc:	440b      	add	r3, r1
900016fe:	6013      	str	r3, [r2, #0]
}
90001700:	4770      	bx	lr
90001702:	bf00      	nop
90001704:	20000254 	.word	0x20000254
90001708:	20000104 	.word	0x20000104

9000170c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
9000170c:	4b01      	ldr	r3, [pc, #4]	; (90001714 <HAL_GetTick+0x8>)
9000170e:	6818      	ldr	r0, [r3, #0]
}
90001710:	4770      	bx	lr
90001712:	bf00      	nop
90001714:	20000254 	.word	0x20000254

90001718 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
90001718:	b538      	push	{r3, r4, r5, lr}
9000171a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
9000171c:	f7ff fff6 	bl	9000170c <HAL_GetTick>
90001720:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
90001722:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)uwTickFreq;
90001724:	bf1e      	ittt	ne
90001726:	4b04      	ldrne	r3, [pc, #16]	; (90001738 <HAL_Delay+0x20>)
90001728:	781b      	ldrbne	r3, [r3, #0]
9000172a:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
9000172c:	f7ff ffee 	bl	9000170c <HAL_GetTick>
90001730:	1b40      	subs	r0, r0, r5
90001732:	42a0      	cmp	r0, r4
90001734:	d3fa      	bcc.n	9000172c <HAL_Delay+0x14>
  {
  }
}
90001736:	bd38      	pop	{r3, r4, r5, pc}
90001738:	20000104 	.word	0x20000104

9000173c <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
9000173c:	4a07      	ldr	r2, [pc, #28]	; (9000175c <HAL_NVIC_SetPriorityGrouping+0x20>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
9000173e:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
90001740:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
90001742:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
90001746:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
9000174a:	041b      	lsls	r3, r3, #16
9000174c:	0c1b      	lsrs	r3, r3, #16
9000174e:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
90001752:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
90001756:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
90001758:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
9000175a:	4770      	bx	lr
9000175c:	e000ed00 	.word	0xe000ed00

90001760 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
90001760:	4b17      	ldr	r3, [pc, #92]	; (900017c0 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 7
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
90001762:	b570      	push	{r4, r5, r6, lr}
90001764:	68dc      	ldr	r4, [r3, #12]

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001766:	f04f 36ff 	mov.w	r6, #4294967295
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
9000176a:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
9000176e:	f1c4 0507 	rsb	r5, r4, #7
90001772:	2d03      	cmp	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
90001774:	f104 0303 	add.w	r3, r4, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
90001778:	bf28      	it	cs
9000177a:	2503      	movcs	r5, #3
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
9000177c:	2b06      	cmp	r3, #6
9000177e:	bf98      	it	ls
90001780:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
90001782:	fa06 f305 	lsl.w	r3, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
90001786:	bf88      	it	hi
90001788:	3c04      	subhi	r4, #4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
9000178a:	ea21 0303 	bic.w	r3, r1, r3
9000178e:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
90001790:	fa06 f404 	lsl.w	r4, r6, r4
90001794:	ea22 0404 	bic.w	r4, r2, r4
  if ((int32_t)(IRQn) >= 0)
90001798:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
9000179a:	ea43 0304 	orr.w	r3, r3, r4
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
9000179e:	bfa8      	it	ge
900017a0:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
900017a4:	ea4f 1343 	mov.w	r3, r3, lsl #5
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017a8:	bfb8      	it	lt
900017aa:	4a06      	ldrlt	r2, [pc, #24]	; (900017c4 <HAL_NVIC_SetPriority+0x64>)
900017ac:	b2db      	uxtb	r3, r3
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017ae:	bfab      	itete	ge
900017b0:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017b4:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017b8:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017bc:	5413      	strblt	r3, [r2, r0]
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
900017be:	bd70      	pop	{r4, r5, r6, pc}
900017c0:	e000ed00 	.word	0xe000ed00
900017c4:	e000ed14 	.word	0xe000ed14

900017c8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
900017c8:	3801      	subs	r0, #1
900017ca:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
900017ce:	d20a      	bcs.n	900017e6 <HAL_SYSTICK_Config+0x1e>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017d0:	21e0      	movs	r1, #224	; 0xe0
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
900017d2:	4b06      	ldr	r3, [pc, #24]	; (900017ec <HAL_SYSTICK_Config+0x24>)
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017d4:	4a06      	ldr	r2, [pc, #24]	; (900017f0 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
900017d6:	6058      	str	r0, [r3, #4]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
900017d8:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
900017dc:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
900017de:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
900017e0:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
900017e2:	601a      	str	r2, [r3, #0]
900017e4:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
900017e6:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
900017e8:	4770      	bx	lr
900017ea:	bf00      	nop
900017ec:	e000e010 	.word	0xe000e010
900017f0:	e000ed00 	.word	0xe000ed00

900017f4 <HAL_FLASH_EndOfOperationCallback>:
  UNUSED(ReturnValue);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
   */
}
900017f4:	4770      	bx	lr

900017f6 <HAL_FLASH_OperationErrorCallback>:
900017f6:	4770      	bx	lr

900017f8 <HAL_FLASH_IRQHandler>:
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
900017f8:	4a29      	ldr	r2, [pc, #164]	; (900018a0 <HAL_FLASH_IRQHandler+0xa8>)
{
900017fa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
900017fe:	4c29      	ldr	r4, [pc, #164]	; (900018a4 <HAL_FLASH_IRQHandler+0xac>)
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
90001800:	6813      	ldr	r3, [r2, #0]
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
90001802:	68a5      	ldr	r5, [r4, #8]
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
90001804:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
  type = (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK));
90001808:	f025 4500 	bic.w	r5, r5, #2147483648	; 0x80000000
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
9000180c:	f023 0305 	bic.w	r3, r3, #5
90001810:	049b      	lsls	r3, r3, #18
  if(type == FLASH_TYPEERASE_PAGES)
90001812:	2d02      	cmp	r5, #2
  error = (*reg_sr) & FLASH_FLAG_SR_ERRORS;
90001814:	ea4f 4393 	mov.w	r3, r3, lsr #18
90001818:	4690      	mov	r8, r2
  if(type == FLASH_TYPEERASE_PAGES)
9000181a:	d12f      	bne.n	9000187c <HAL_FLASH_IRQHandler+0x84>
    param = pFlash.Page;
9000181c:	6967      	ldr	r7, [r4, #20]
  CLEAR_BIT((*reg), type);
9000181e:	4e22      	ldr	r6, [pc, #136]	; (900018a8 <HAL_FLASH_IRQHandler+0xb0>)
90001820:	6832      	ldr	r2, [r6, #0]
90001822:	ea22 0205 	bic.w	r2, r2, r5
90001826:	6032      	str	r2, [r6, #0]
  if(error != 0U)
90001828:	b14b      	cbz	r3, 9000183e <HAL_FLASH_IRQHandler+0x46>
    pFlash.ErrorCode |= error;
9000182a:	6862      	ldr	r2, [r4, #4]
    HAL_FLASH_OperationErrorCallback(param);
9000182c:	4638      	mov	r0, r7
    pFlash.ErrorCode |= error;
9000182e:	431a      	orrs	r2, r3
90001830:	6062      	str	r2, [r4, #4]
    (*reg_sr) = error;
90001832:	f8c8 3000 	str.w	r3, [r8]
    pFlash.ProcedureOnGoing = 0U;
90001836:	2300      	movs	r3, #0
90001838:	60a3      	str	r3, [r4, #8]
    HAL_FLASH_OperationErrorCallback(param);
9000183a:	f7ff ffdc 	bl	900017f6 <HAL_FLASH_OperationErrorCallback>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
9000183e:	f8d8 3000 	ldr.w	r3, [r8]
90001842:	07db      	lsls	r3, r3, #31
90001844:	d511      	bpl.n	9000186a <HAL_FLASH_IRQHandler+0x72>
    (*reg_sr) = FLASH_FLAG_EOP;
90001846:	2301      	movs	r3, #1
    if(type == FLASH_TYPEERASE_PAGES)
90001848:	2d02      	cmp	r5, #2
    (*reg_sr) = FLASH_FLAG_EOP;
9000184a:	f8c8 3000 	str.w	r3, [r8]
    if(type == FLASH_TYPEERASE_PAGES)
9000184e:	d124      	bne.n	9000189a <HAL_FLASH_IRQHandler+0xa2>
      pFlash.NbPagesToErase--;
90001850:	69a3      	ldr	r3, [r4, #24]
90001852:	3b01      	subs	r3, #1
90001854:	61a3      	str	r3, [r4, #24]
      if(pFlash.NbPagesToErase != 0U)
90001856:	b1e3      	cbz	r3, 90001892 <HAL_FLASH_IRQHandler+0x9a>
        pFlash.Page++;
90001858:	6960      	ldr	r0, [r4, #20]
        FLASH_PageErase(pFlash.Page, pFlash.Bank);
9000185a:	6921      	ldr	r1, [r4, #16]
        pFlash.Page++;
9000185c:	3001      	adds	r0, #1
9000185e:	6160      	str	r0, [r4, #20]
        FLASH_PageErase(pFlash.Page, pFlash.Bank);
90001860:	f000 f8ce 	bl	90001a00 <FLASH_PageErase>
    HAL_FLASH_EndOfOperationCallback(param);
90001864:	4638      	mov	r0, r7
90001866:	f7ff ffc5 	bl	900017f4 <HAL_FLASH_EndOfOperationCallback>
  if(pFlash.ProcedureOnGoing == 0U)
9000186a:	68a2      	ldr	r2, [r4, #8]
9000186c:	b922      	cbnz	r2, 90001878 <HAL_FLASH_IRQHandler+0x80>
    (*reg) &= ~(FLASH_IT_EOP | FLASH_IT_OPERR);
9000186e:	6833      	ldr	r3, [r6, #0]
90001870:	f023 7340 	bic.w	r3, r3, #50331648	; 0x3000000
90001874:	6033      	str	r3, [r6, #0]
    __HAL_UNLOCK(&pFlash);
90001876:	7022      	strb	r2, [r4, #0]
}
90001878:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if(type == FLASH_TYPEERASE_MASSERASE)
9000187c:	f248 0204 	movw	r2, #32772	; 0x8004
90001880:	4295      	cmp	r5, r2
90001882:	d101      	bne.n	90001888 <HAL_FLASH_IRQHandler+0x90>
    param = pFlash.Bank;
90001884:	6927      	ldr	r7, [r4, #16]
90001886:	e7ca      	b.n	9000181e <HAL_FLASH_IRQHandler+0x26>
  else if(type == FLASH_TYPEPROGRAM_DOUBLEWORD)
90001888:	2d01      	cmp	r5, #1
    param = pFlash.Address;
9000188a:	bf0c      	ite	eq
9000188c:	68e7      	ldreq	r7, [r4, #12]
  uint32_t param = 0U;
9000188e:	2700      	movne	r7, #0
90001890:	e7c5      	b.n	9000181e <HAL_FLASH_IRQHandler+0x26>
        pFlash.ProcedureOnGoing = 0U;
90001892:	60a3      	str	r3, [r4, #8]
        param = 0xFFFFFFFFU;
90001894:	f04f 37ff 	mov.w	r7, #4294967295
90001898:	e7e4      	b.n	90001864 <HAL_FLASH_IRQHandler+0x6c>
      pFlash.ProcedureOnGoing = 0U;
9000189a:	2300      	movs	r3, #0
9000189c:	60a3      	str	r3, [r4, #8]
9000189e:	e7e1      	b.n	90001864 <HAL_FLASH_IRQHandler+0x6c>
900018a0:	40022020 	.word	0x40022020
900018a4:	2000010c 	.word	0x2000010c
900018a8:	40022028 	.word	0x40022028

900018ac <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if(READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
900018ac:	4b06      	ldr	r3, [pc, #24]	; (900018c8 <HAL_FLASH_Unlock+0x1c>)
900018ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
900018b0:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY1);
900018b2:	bfbf      	itttt	lt
900018b4:	4a05      	ldrlt	r2, [pc, #20]	; (900018cc <HAL_FLASH_Unlock+0x20>)
900018b6:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->NSKEYR, FLASH_KEY2);
900018b8:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
900018bc:	609a      	strlt	r2, [r3, #8]

    /* verify Flash is unlocked */
    if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
900018be:	bfba      	itte	lt
900018c0:	6a98      	ldrlt	r0, [r3, #40]	; 0x28
  HAL_StatusTypeDef status = HAL_OK;
900018c2:	0fc0      	lsrlt	r0, r0, #31
900018c4:	2000      	movge	r0, #0
    }
  }
#endif

  return status;
}
900018c6:	4770      	bx	lr
900018c8:	40022000 	.word	0x40022000
900018cc:	45670123 	.word	0x45670123

900018d0 <HAL_FLASH_Lock>:
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  HAL_StatusTypeDef status = HAL_ERROR;

  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK);
900018d0:	4b04      	ldr	r3, [pc, #16]	; (900018e4 <HAL_FLASH_Lock+0x14>)
900018d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
900018d4:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
900018d8:	629a      	str	r2, [r3, #40]	; 0x28

  /* verify Flash is locked */
  if (READ_BIT(FLASH->NSCR, FLASH_NSCR_NSLOCK) != 0u)
900018da:	6a98      	ldr	r0, [r3, #40]	; 0x28
    }
  }
#endif

  return status;
}
900018dc:	43c0      	mvns	r0, r0
900018de:	0fc0      	lsrs	r0, r0, #31
900018e0:	4770      	bx	lr
900018e2:	bf00      	nop
900018e4:	40022000 	.word	0x40022000

900018e8 <HAL_FLASH_GetError>:
  *            @arg HAL_FLASH_ERROR_OPTW: FLASH Option modification error
  */
uint32_t HAL_FLASH_GetError(void)
{
   return pFlash.ErrorCode;
}
900018e8:	4b01      	ldr	r3, [pc, #4]	; (900018f0 <HAL_FLASH_GetError+0x8>)
900018ea:	6858      	ldr	r0, [r3, #4]
900018ec:	4770      	bx	lr
900018ee:	bf00      	nop
900018f0:	2000010c 	.word	0x2000010c

900018f4 <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
900018f4:	b570      	push	{r4, r5, r6, lr}
900018f6:	4604      	mov	r4, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t timeout = HAL_GetTick() + Timeout;
900018f8:	f7ff ff08 	bl	9000170c <HAL_GetTick>
  uint32_t error;
  __IO uint32_t *reg_sr;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
900018fc:	4d10      	ldr	r5, [pc, #64]	; (90001940 <FLASH_WaitForLastOperation+0x4c>)
  uint32_t timeout = HAL_GetTick() + Timeout;
900018fe:	1906      	adds	r6, r0, r4
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
90001900:	6a2b      	ldr	r3, [r5, #32]
90001902:	03db      	lsls	r3, r3, #15
90001904:	d40c      	bmi.n	90001920 <FLASH_WaitForLastOperation+0x2c>
  
  /* Access to SECSR or NSSR registers depends on operation type */
  reg_sr = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECSR) : &(FLASH_NS->NSSR);

  /* Check FLASH operation error flags */
  error = ((*reg_sr) & FLASH_FLAG_SR_ERRORS);
90001906:	f242 02fa 	movw	r2, #8442	; 0x20fa
9000190a:	490e      	ldr	r1, [pc, #56]	; (90001944 <FLASH_WaitForLastOperation+0x50>)
9000190c:	6808      	ldr	r0, [r1, #0]
#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  error |= (FLASH->NSSR & FLASH_FLAG_OPTWERR);
#endif /* __ARM_FEATURE_CMSE */ 

  if(error != 0u)
9000190e:	4002      	ands	r2, r0
90001910:	d00e      	beq.n	90001930 <FLASH_WaitForLastOperation+0x3c>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
90001912:	480d      	ldr	r0, [pc, #52]	; (90001948 <FLASH_WaitForLastOperation+0x54>)
90001914:	6843      	ldr	r3, [r0, #4]
90001916:	4313      	orrs	r3, r2
90001918:	6043      	str	r3, [r0, #4]
    {
      FLASH->NSSR = FLASH_FLAG_OPTWERR;
    }
#endif /* __ARM_FEATURE_CMSE */

    return HAL_ERROR;
9000191a:	2001      	movs	r0, #1
    (*reg_sr) = error;
9000191c:	600a      	str	r2, [r1, #0]
    (*reg_sr) = FLASH_FLAG_EOP;
  }

  /* If there is an error flag set */
  return HAL_OK;
}
9000191e:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
90001920:	1c62      	adds	r2, r4, #1
90001922:	d0ed      	beq.n	90001900 <FLASH_WaitForLastOperation+0xc>
      if(HAL_GetTick() >= timeout)
90001924:	f7ff fef2 	bl	9000170c <HAL_GetTick>
90001928:	42b0      	cmp	r0, r6
9000192a:	d3e9      	bcc.n	90001900 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
9000192c:	2003      	movs	r0, #3
9000192e:	e7f6      	b.n	9000191e <FLASH_WaitForLastOperation+0x2a>
  if (((*reg_sr) & FLASH_FLAG_EOP) != 0U)
90001930:	6808      	ldr	r0, [r1, #0]
90001932:	f010 0001 	ands.w	r0, r0, #1
90001936:	d0f2      	beq.n	9000191e <FLASH_WaitForLastOperation+0x2a>
    (*reg_sr) = FLASH_FLAG_EOP;
90001938:	2301      	movs	r3, #1
9000193a:	4610      	mov	r0, r2
9000193c:	600b      	str	r3, [r1, #0]
9000193e:	e7ee      	b.n	9000191e <FLASH_WaitForLastOperation+0x2a>
90001940:	40022000 	.word	0x40022000
90001944:	40022020 	.word	0x40022020
90001948:	2000010c 	.word	0x2000010c

9000194c <HAL_FLASH_Program>:
{
9000194c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
90001950:	4c18      	ldr	r4, [pc, #96]	; (900019b4 <HAL_FLASH_Program+0x68>)
{
90001952:	461f      	mov	r7, r3
  __HAL_LOCK(&pFlash);
90001954:	7823      	ldrb	r3, [r4, #0]
{
90001956:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
90001958:	2b01      	cmp	r3, #1
{
9000195a:	460e      	mov	r6, r1
9000195c:	4690      	mov	r8, r2
  __HAL_LOCK(&pFlash);
9000195e:	d027      	beq.n	900019b0 <HAL_FLASH_Program+0x64>
90001960:	2301      	movs	r3, #1
90001962:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
90001964:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
90001966:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
9000196a:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
9000196c:	f7ff ffc2 	bl	900018f4 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
90001970:	b9d0      	cbnz	r0, 900019a8 <HAL_FLASH_Program+0x5c>
    pFlash.ProcedureOnGoing = TypeProgram;
90001972:	60a5      	str	r5, [r4, #8]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
90001974:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
90001978:	b672      	cpsid	i
  /* Disable interrupts to avoid any interruption during the double word programming */
  primask_bit = __get_PRIMASK();
  __disable_irq();

  /* Set PG bit */
  SET_BIT((*reg), FLASH_NSCR_NSPG);
9000197a:	4d0f      	ldr	r5, [pc, #60]	; (900019b8 <HAL_FLASH_Program+0x6c>)
9000197c:	6828      	ldr	r0, [r5, #0]
9000197e:	f040 0001 	orr.w	r0, r0, #1
90001982:	6028      	str	r0, [r5, #0]

  /* Program first word */
  *(uint32_t*)Address = (uint32_t)Data;
90001984:	f8c6 8000 	str.w	r8, [r6]
  __ASM volatile ("isb 0xF":::"memory");
90001988:	f3bf 8f6f 	isb	sy
  /* Barrier to ensure programming is performed in 2 steps, in right order
    (independently of compiler optimization behavior) */
  __ISB();

  /* Program second word */
  *(uint32_t*)(Address+4U) = (uint32_t)(Data >> 32U);
9000198c:	6077      	str	r7, [r6, #4]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
9000198e:	f381 8810 	msr	PRIMASK, r1
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
90001992:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
90001996:	f7ff ffad 	bl	900018f4 <FLASH_WaitForLastOperation>
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
9000199a:	68a2      	ldr	r2, [r4, #8]
9000199c:	682b      	ldr	r3, [r5, #0]
9000199e:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
900019a2:	ea23 0302 	bic.w	r3, r3, r2
900019a6:	602b      	str	r3, [r5, #0]
  __HAL_UNLOCK(&pFlash);
900019a8:	2300      	movs	r3, #0
900019aa:	7023      	strb	r3, [r4, #0]
}
900019ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  __HAL_LOCK(&pFlash);
900019b0:	2002      	movs	r0, #2
900019b2:	e7fb      	b.n	900019ac <HAL_FLASH_Program+0x60>
900019b4:	2000010c 	.word	0x2000010c
900019b8:	40022028 	.word	0x40022028

900019bc <FLASH_MassErase>:
#endif
  
  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
900019bc:	4b0e      	ldr	r3, [pc, #56]	; (900019f8 <FLASH_MassErase+0x3c>)
900019be:	6c1b      	ldr	r3, [r3, #64]	; 0x40
900019c0:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
900019c4:	4b0d      	ldr	r3, [pc, #52]	; (900019fc <FLASH_MassErase+0x40>)
900019c6:	d010      	beq.n	900019ea <FLASH_MassErase+0x2e>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
900019c8:	07c1      	lsls	r1, r0, #31
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER1);
900019ca:	bf42      	ittt	mi
900019cc:	681a      	ldrmi	r2, [r3, #0]
900019ce:	f042 0204 	orrmi.w	r2, r2, #4
900019d2:	601a      	strmi	r2, [r3, #0]
    }

    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
900019d4:	0782      	lsls	r2, r0, #30
900019d6:	d503      	bpl.n	900019e0 <FLASH_MassErase+0x24>
    {
      SET_BIT((*reg), FLASH_NSCR_NSMER2);
900019d8:	681a      	ldr	r2, [r3, #0]
900019da:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
    }
  }
  else
  {
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
900019de:	601a      	str	r2, [r3, #0]
  }

  /* Proceed to erase all sectors */
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
900019e0:	681a      	ldr	r2, [r3, #0]
900019e2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
900019e6:	601a      	str	r2, [r3, #0]

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
900019e8:	4770      	bx	lr
    SET_BIT((*reg), (FLASH_NSCR_NSMER1 | FLASH_NSCR_NSMER2));
900019ea:	681a      	ldr	r2, [r3, #0]
900019ec:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
900019f0:	f042 0204 	orr.w	r2, r2, #4
900019f4:	e7f3      	b.n	900019de <FLASH_MassErase+0x22>
900019f6:	bf00      	nop
900019f8:	40022000 	.word	0x40022000
900019fc:	40022028 	.word	0x40022028

90001a00 <FLASH_PageErase>:
#endif

  /* Access to SECCR or NSCR registers depends on operation type */
  reg = IS_FLASH_SECURE_OPERATION() ? &(FLASH->SECCR) : &(FLASH_NS->NSCR);

  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
90001a00:	4b0f      	ldr	r3, [pc, #60]	; (90001a40 <FLASH_PageErase+0x40>)
90001a02:	6c1b      	ldr	r3, [r3, #64]	; 0x40
90001a04:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
90001a08:	4b0e      	ldr	r3, [pc, #56]	; (90001a44 <FLASH_PageErase+0x44>)
90001a0a:	d112      	bne.n	90001a32 <FLASH_PageErase+0x32>
  {
    CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
90001a0c:	6819      	ldr	r1, [r3, #0]
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
    {
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
90001a0e:	f421 6100 	bic.w	r1, r1, #2048	; 0x800
    }
    else
    {
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
90001a12:	6019      	str	r1, [r3, #0]
    }
  }

  /* Proceed to erase the page */
  MODIFY_REG((*reg), (FLASH_NSCR_NSPNB | FLASH_NSCR_NSPER), ((Page << FLASH_NSCR_NSPNB_Pos) | FLASH_NSCR_NSPER));
90001a14:	681a      	ldr	r2, [r3, #0]
90001a16:	f422 727e 	bic.w	r2, r2, #1016	; 0x3f8
90001a1a:	f022 0202 	bic.w	r2, r2, #2
90001a1e:	f042 0202 	orr.w	r2, r2, #2
90001a22:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
90001a26:	6018      	str	r0, [r3, #0]
  SET_BIT((*reg), FLASH_NSCR_NSSTRT);
90001a28:	681a      	ldr	r2, [r3, #0]
90001a2a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
90001a2e:	601a      	str	r2, [r3, #0]

#if defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3U)
  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
#endif
}
90001a30:	4770      	bx	lr
    if((Banks & FLASH_BANK_1) != 0U)
90001a32:	f011 0f01 	tst.w	r1, #1
      CLEAR_BIT((*reg), FLASH_NSCR_NSBKER);
90001a36:	6819      	ldr	r1, [r3, #0]
    if((Banks & FLASH_BANK_1) != 0U)
90001a38:	d1e9      	bne.n	90001a0e <FLASH_PageErase+0xe>
      SET_BIT((*reg), FLASH_NSCR_NSBKER);
90001a3a:	f441 6100 	orr.w	r1, r1, #2048	; 0x800
90001a3e:	e7e8      	b.n	90001a12 <FLASH_PageErase+0x12>
90001a40:	40022000 	.word	0x40022000
90001a44:	40022028 	.word	0x40022028

90001a48 <HAL_FLASHEx_Erase>:
{
90001a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(&pFlash);
90001a4c:	4c23      	ldr	r4, [pc, #140]	; (90001adc <HAL_FLASHEx_Erase+0x94>)
{
90001a4e:	4605      	mov	r5, r0
  __HAL_LOCK(&pFlash);
90001a50:	7823      	ldrb	r3, [r4, #0]
{
90001a52:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
90001a54:	2b01      	cmp	r3, #1
90001a56:	d03e      	beq.n	90001ad6 <HAL_FLASHEx_Erase+0x8e>
90001a58:	2301      	movs	r3, #1
90001a5a:	7023      	strb	r3, [r4, #0]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
90001a5c:	2300      	movs	r3, #0
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
90001a5e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
90001a62:	6063      	str	r3, [r4, #4]
  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
90001a64:	f7ff ff46 	bl	900018f4 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
90001a68:	4606      	mov	r6, r0
90001a6a:	b9b8      	cbnz	r0, 90001a9c <HAL_FLASHEx_Erase+0x54>
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
90001a6c:	f248 0204 	movw	r2, #32772	; 0x8004
    pFlash.ProcedureOnGoing = pEraseInit->TypeErase;
90001a70:	682b      	ldr	r3, [r5, #0]
90001a72:	60a3      	str	r3, [r4, #8]
    if ((pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)) == FLASH_TYPEERASE_MASSERASE)
90001a74:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
90001a78:	4293      	cmp	r3, r2
90001a7a:	d114      	bne.n	90001aa6 <HAL_FLASHEx_Erase+0x5e>
      FLASH_MassErase(pEraseInit->Banks);
90001a7c:	6868      	ldr	r0, [r5, #4]
90001a7e:	f7ff ff9d 	bl	900019bc <FLASH_MassErase>
      status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
90001a82:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
90001a86:	f7ff ff35 	bl	900018f4 <FLASH_WaitForLastOperation>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
90001a8a:	4606      	mov	r6, r0
    CLEAR_BIT((*reg), (pFlash.ProcedureOnGoing & ~(FLASH_NON_SECURE_MASK)));
90001a8c:	4914      	ldr	r1, [pc, #80]	; (90001ae0 <HAL_FLASHEx_Erase+0x98>)
90001a8e:	68a2      	ldr	r2, [r4, #8]
90001a90:	680b      	ldr	r3, [r1, #0]
90001a92:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
90001a96:	ea23 0302 	bic.w	r3, r3, r2
90001a9a:	600b      	str	r3, [r1, #0]
  __HAL_UNLOCK(&pFlash);
90001a9c:	2300      	movs	r3, #0
90001a9e:	7023      	strb	r3, [r4, #0]
}
90001aa0:	4630      	mov	r0, r6
90001aa2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      *PageError = 0xFFFFFFFFU;
90001aa6:	f04f 33ff 	mov.w	r3, #4294967295
90001aaa:	f8c8 3000 	str.w	r3, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
90001aae:	68af      	ldr	r7, [r5, #8]
90001ab0:	e9d5 3202 	ldrd	r3, r2, [r5, #8]
90001ab4:	4413      	add	r3, r2
90001ab6:	42bb      	cmp	r3, r7
90001ab8:	d9e8      	bls.n	90001a8c <HAL_FLASHEx_Erase+0x44>
        FLASH_PageErase(page_index, pEraseInit->Banks);
90001aba:	4638      	mov	r0, r7
90001abc:	6869      	ldr	r1, [r5, #4]
90001abe:	f7ff ff9f 	bl	90001a00 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
90001ac2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
90001ac6:	f7ff ff15 	bl	900018f4 <FLASH_WaitForLastOperation>
        if (status != HAL_OK)
90001aca:	b110      	cbz	r0, 90001ad2 <HAL_FLASHEx_Erase+0x8a>
          *PageError = page_index;
90001acc:	f8c8 7000 	str.w	r7, [r8]
90001ad0:	e7db      	b.n	90001a8a <HAL_FLASHEx_Erase+0x42>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
90001ad2:	3701      	adds	r7, #1
90001ad4:	e7ec      	b.n	90001ab0 <HAL_FLASHEx_Erase+0x68>
  __HAL_LOCK(&pFlash);
90001ad6:	2602      	movs	r6, #2
90001ad8:	e7e2      	b.n	90001aa0 <HAL_FLASHEx_Erase+0x58>
90001ada:	bf00      	nop
90001adc:	2000010c 	.word	0x2000010c
90001ae0:	40022028 	.word	0x40022028

90001ae4 <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
90001ae4:	2300      	movs	r3, #0
{
90001ae6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
90001aea:	4a5f      	ldr	r2, [pc, #380]	; (90001c68 <HAL_GPIO_Init+0x184>)
  while (((GPIO_Init->Pin) >> position) != 0U)
90001aec:	f8d1 8000 	ldr.w	r8, [r1]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
90001af0:	f8df 917c 	ldr.w	r9, [pc, #380]	; 90001c70 <HAL_GPIO_Init+0x18c>
  while (((GPIO_Init->Pin) >> position) != 0U)
90001af4:	fa38 f403 	lsrs.w	r4, r8, r3
90001af8:	d101      	bne.n	90001afe <HAL_GPIO_Init+0x1a>
      }
    }

    position++;
  }
}
90001afa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
90001afe:	f04f 0c01 	mov.w	ip, #1
90001b02:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
90001b06:	ea1c 0608 	ands.w	r6, ip, r8
90001b0a:	f000 809f 	beq.w	90001c4c <HAL_GPIO_Init+0x168>
90001b0e:	2503      	movs	r5, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
90001b10:	684c      	ldr	r4, [r1, #4]
90001b12:	ea4f 0e43 	mov.w	lr, r3, lsl #1
90001b16:	f024 0a10 	bic.w	sl, r4, #16
90001b1a:	f10a 37ff 	add.w	r7, sl, #4294967295
90001b1e:	fa05 f50e 	lsl.w	r5, r5, lr
90001b22:	2f01      	cmp	r7, #1
90001b24:	ea6f 0505 	mvn.w	r5, r5
90001b28:	d811      	bhi.n	90001b4e <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
90001b2a:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
90001b2c:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
90001b30:	68cf      	ldr	r7, [r1, #12]
90001b32:	fa07 f70e 	lsl.w	r7, r7, lr
90001b36:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
90001b3a:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
90001b3c:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
90001b3e:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
90001b42:	f3c4 1700 	ubfx	r7, r4, #4, #1
90001b46:	409f      	lsls	r7, r3
90001b48:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
90001b4c:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
90001b4e:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
90001b50:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
90001b54:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
90001b58:	688f      	ldr	r7, [r1, #8]
90001b5a:	fa07 f70e 	lsl.w	r7, r7, lr
90001b5e:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
90001b62:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
90001b64:	d116      	bne.n	90001b94 <HAL_GPIO_Init+0xb0>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
90001b66:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
90001b6a:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
90001b6e:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
90001b72:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
90001b76:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
90001b7a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
90001b7e:	fa0c fc0b 	lsl.w	ip, ip, fp
90001b82:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
90001b86:	690f      	ldr	r7, [r1, #16]
90001b88:	fa07 f70b 	lsl.w	r7, r7, fp
90001b8c:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
90001b90:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
90001b94:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
90001b96:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
90001b98:	f004 0703 	and.w	r7, r4, #3
90001b9c:	fa07 fe0e 	lsl.w	lr, r7, lr
90001ba0:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
90001ba4:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
90001ba6:	00e5      	lsls	r5, r4, #3
90001ba8:	d550      	bpl.n	90001c4c <HAL_GPIO_Init+0x168>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
90001baa:	f04f 0c0f 	mov.w	ip, #15
90001bae:	f023 0703 	bic.w	r7, r3, #3
90001bb2:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
90001bb6:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
90001bba:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
90001bbe:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
90001bc0:	ea4f 0ece 	mov.w	lr, lr, lsl #3
90001bc4:	fa0c fc0e 	lsl.w	ip, ip, lr
90001bc8:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
90001bcc:	4d27      	ldr	r5, [pc, #156]	; (90001c6c <HAL_GPIO_Init+0x188>)
90001bce:	42a8      	cmp	r0, r5
90001bd0:	d03e      	beq.n	90001c50 <HAL_GPIO_Init+0x16c>
90001bd2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90001bd6:	42a8      	cmp	r0, r5
90001bd8:	d03c      	beq.n	90001c54 <HAL_GPIO_Init+0x170>
90001bda:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90001bde:	42a8      	cmp	r0, r5
90001be0:	d03a      	beq.n	90001c58 <HAL_GPIO_Init+0x174>
90001be2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90001be6:	42a8      	cmp	r0, r5
90001be8:	d038      	beq.n	90001c5c <HAL_GPIO_Init+0x178>
90001bea:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90001bee:	42a8      	cmp	r0, r5
90001bf0:	d036      	beq.n	90001c60 <HAL_GPIO_Init+0x17c>
90001bf2:	f505 6580 	add.w	r5, r5, #1024	; 0x400
90001bf6:	42a8      	cmp	r0, r5
90001bf8:	d034      	beq.n	90001c64 <HAL_GPIO_Init+0x180>
90001bfa:	4548      	cmp	r0, r9
90001bfc:	bf14      	ite	ne
90001bfe:	2507      	movne	r5, #7
90001c00:	2506      	moveq	r5, #6
90001c02:	fa05 f50e 	lsl.w	r5, r5, lr
90001c06:	ea45 050c 	orr.w	r5, r5, ip
        EXTI->EXTICR[position >> 2U] = temp;
90001c0a:	663d      	str	r5, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
90001c0c:	43f7      	mvns	r7, r6
        temp = EXTI->IMR1;
90001c0e:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
90001c12:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
90001c16:	bf0c      	ite	eq
90001c18:	403d      	andeq	r5, r7
          temp |= iocurrent;
90001c1a:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
90001c1c:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        temp = EXTI->EMR1;
90001c20:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
90001c24:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
90001c28:	bf0c      	ite	eq
90001c2a:	403d      	andeq	r5, r7
          temp |= iocurrent;
90001c2c:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
90001c2e:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        temp = EXTI->RTSR1;
90001c32:	6815      	ldr	r5, [r2, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
90001c34:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
90001c38:	bf0c      	ite	eq
90001c3a:	403d      	andeq	r5, r7
          temp |= iocurrent;
90001c3c:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
90001c3e:	6015      	str	r5, [r2, #0]
        temp = EXTI->FTSR1;
90001c40:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
90001c42:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
90001c44:	bf54      	ite	pl
90001c46:	403d      	andpl	r5, r7
          temp |= iocurrent;
90001c48:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
90001c4a:	6055      	str	r5, [r2, #4]
    position++;
90001c4c:	3301      	adds	r3, #1
90001c4e:	e751      	b.n	90001af4 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
90001c50:	2500      	movs	r5, #0
90001c52:	e7d6      	b.n	90001c02 <HAL_GPIO_Init+0x11e>
90001c54:	2501      	movs	r5, #1
90001c56:	e7d4      	b.n	90001c02 <HAL_GPIO_Init+0x11e>
90001c58:	2502      	movs	r5, #2
90001c5a:	e7d2      	b.n	90001c02 <HAL_GPIO_Init+0x11e>
90001c5c:	2503      	movs	r5, #3
90001c5e:	e7d0      	b.n	90001c02 <HAL_GPIO_Init+0x11e>
90001c60:	2504      	movs	r5, #4
90001c62:	e7ce      	b.n	90001c02 <HAL_GPIO_Init+0x11e>
90001c64:	2505      	movs	r5, #5
90001c66:	e7cc      	b.n	90001c02 <HAL_GPIO_Init+0x11e>
90001c68:	4002f400 	.word	0x4002f400
90001c6c:	42020000 	.word	0x42020000
90001c70:	42021800 	.word	0x42021800

90001c74 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
90001c74:	4b23      	ldr	r3, [pc, #140]	; (90001d04 <HAL_RCC_GetSysClockFreq+0x90>)
90001c76:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
90001c78:	68d9      	ldr	r1, [r3, #12]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
90001c7a:	f012 020c 	ands.w	r2, r2, #12
90001c7e:	d005      	beq.n	90001c8c <HAL_RCC_GetSysClockFreq+0x18>
90001c80:	2a0c      	cmp	r2, #12
90001c82:	d115      	bne.n	90001cb0 <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
90001c84:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
90001c88:	2901      	cmp	r1, #1
90001c8a:	d118      	bne.n	90001cbe <HAL_RCC_GetSysClockFreq+0x4a>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
90001c8c:	6819      	ldr	r1, [r3, #0]
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in Hz*/
    msirange = MSIRangeTable[msirange];
90001c8e:	481e      	ldr	r0, [pc, #120]	; (90001d08 <HAL_RCC_GetSysClockFreq+0x94>)
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
90001c90:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
90001c92:	bf55      	itete	pl
90001c94:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
90001c98:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
90001c9a:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
90001c9e:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
90001ca2:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
90001ca6:	b112      	cbz	r2, 90001cae <HAL_RCC_GetSysClockFreq+0x3a>
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
90001ca8:	2a0c      	cmp	r2, #12
90001caa:	d009      	beq.n	90001cc0 <HAL_RCC_GetSysClockFreq+0x4c>
90001cac:	2000      	movs	r0, #0
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
90001cae:	4770      	bx	lr
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
90001cb0:	2a04      	cmp	r2, #4
90001cb2:	d024      	beq.n	90001cfe <HAL_RCC_GetSysClockFreq+0x8a>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
90001cb4:	2a08      	cmp	r2, #8
90001cb6:	4815      	ldr	r0, [pc, #84]	; (90001d0c <HAL_RCC_GetSysClockFreq+0x98>)
90001cb8:	bf18      	it	ne
90001cba:	2000      	movne	r0, #0
90001cbc:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
90001cbe:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
90001cc0:	68d9      	ldr	r1, [r3, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
90001cc2:	68da      	ldr	r2, [r3, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
90001cc4:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
90001cc8:	f3c2 1203 	ubfx	r2, r2, #4, #4
    switch (pllsource)
90001ccc:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
90001cce:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
90001cd2:	d005      	beq.n	90001ce0 <HAL_RCC_GetSysClockFreq+0x6c>
90001cd4:	2903      	cmp	r1, #3
90001cd6:	d003      	beq.n	90001ce0 <HAL_RCC_GetSysClockFreq+0x6c>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
90001cd8:	68d9      	ldr	r1, [r3, #12]
90001cda:	f3c1 2106 	ubfx	r1, r1, #8, #7
90001cde:	e003      	b.n	90001ce8 <HAL_RCC_GetSysClockFreq+0x74>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
90001ce0:	68d9      	ldr	r1, [r3, #12]
90001ce2:	480a      	ldr	r0, [pc, #40]	; (90001d0c <HAL_RCC_GetSysClockFreq+0x98>)
90001ce4:	f3c1 2106 	ubfx	r1, r1, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
90001ce8:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
90001cec:	68db      	ldr	r3, [r3, #12]
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
90001cee:	4348      	muls	r0, r1
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
90001cf0:	f3c3 6341 	ubfx	r3, r3, #25, #2
90001cf4:	3301      	adds	r3, #1
90001cf6:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
90001cf8:	fbb0 f0f3 	udiv	r0, r0, r3
90001cfc:	4770      	bx	lr
90001cfe:	4803      	ldr	r0, [pc, #12]	; (90001d0c <HAL_RCC_GetSysClockFreq+0x98>)
90001d00:	4770      	bx	lr
90001d02:	bf00      	nop
90001d04:	40021000 	.word	0x40021000
90001d08:	90004be0 	.word	0x90004be0
90001d0c:	00f42400 	.word	0x00f42400

90001d10 <HAL_RCC_GetHCLKFreq>:
  * @note   Each time HCLK changes, this function must be called to update the
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
90001d10:	b508      	push	{r3, lr}
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
90001d12:	f7ff ffaf 	bl	90001c74 <HAL_RCC_GetSysClockFreq>
90001d16:	4b04      	ldr	r3, [pc, #16]	; (90001d28 <HAL_RCC_GetHCLKFreq+0x18>)
90001d18:	4a04      	ldr	r2, [pc, #16]	; (90001d2c <HAL_RCC_GetHCLKFreq+0x1c>)
90001d1a:	689b      	ldr	r3, [r3, #8]
90001d1c:	f3c3 1303 	ubfx	r3, r3, #4, #4
90001d20:	5cd3      	ldrb	r3, [r2, r3]
}
90001d22:	40d8      	lsrs	r0, r3
90001d24:	bd08      	pop	{r3, pc}
90001d26:	bf00      	nop
90001d28:	40021000 	.word	0x40021000
90001d2c:	90004bc7 	.word	0x90004bc7

90001d30 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
90001d30:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
90001d32:	f7ff ffed 	bl	90001d10 <HAL_RCC_GetHCLKFreq>
90001d36:	4b04      	ldr	r3, [pc, #16]	; (90001d48 <HAL_RCC_GetPCLK1Freq+0x18>)
90001d38:	4a04      	ldr	r2, [pc, #16]	; (90001d4c <HAL_RCC_GetPCLK1Freq+0x1c>)
90001d3a:	689b      	ldr	r3, [r3, #8]
90001d3c:	f3c3 2302 	ubfx	r3, r3, #8, #3
90001d40:	5cd3      	ldrb	r3, [r2, r3]
}
90001d42:	40d8      	lsrs	r0, r3
90001d44:	bd08      	pop	{r3, pc}
90001d46:	bf00      	nop
90001d48:	40021000 	.word	0x40021000
90001d4c:	90004bd7 	.word	0x90004bd7

90001d50 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
90001d50:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
90001d52:	f7ff ffdd 	bl	90001d10 <HAL_RCC_GetHCLKFreq>
90001d56:	4b04      	ldr	r3, [pc, #16]	; (90001d68 <HAL_RCC_GetPCLK2Freq+0x18>)
90001d58:	4a04      	ldr	r2, [pc, #16]	; (90001d6c <HAL_RCC_GetPCLK2Freq+0x1c>)
90001d5a:	689b      	ldr	r3, [r3, #8]
90001d5c:	f3c3 23c2 	ubfx	r3, r3, #11, #3
90001d60:	5cd3      	ldrb	r3, [r2, r3]
}
90001d62:	40d8      	lsrs	r0, r3
90001d64:	bd08      	pop	{r3, pc}
90001d66:	bf00      	nop
90001d68:	40021000 	.word	0x40021000
90001d6c:	90004bd7 	.word	0x90004bd7

90001d70 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
90001d70:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
90001d74:	4604      	mov	r4, r0
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
90001d76:	6921      	ldr	r1, [r4, #16]
90001d78:	68a2      	ldr	r2, [r4, #8]
  if (UART_INSTANCE_LOWPOWER(huart))
90001d7a:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
90001d7c:	430a      	orrs	r2, r1
90001d7e:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
90001d80:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
90001d82:	69c0      	ldr	r0, [r0, #28]
90001d84:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
90001d86:	49a7      	ldr	r1, [pc, #668]	; (90002024 <UART_SetConfig+0x2b4>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
90001d88:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
90001d8a:	4029      	ands	r1, r5
90001d8c:	430a      	orrs	r2, r1
90001d8e:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
90001d90:	685a      	ldr	r2, [r3, #4]
90001d92:	68e1      	ldr	r1, [r4, #12]
90001d94:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
90001d98:	430a      	orrs	r2, r1
90001d9a:	605a      	str	r2, [r3, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
90001d9c:	4aa2      	ldr	r2, [pc, #648]	; (90002028 <UART_SetConfig+0x2b8>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
90001d9e:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
90001da0:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
90001da2:	bf1c      	itt	ne
90001da4:	6a22      	ldrne	r2, [r4, #32]
90001da6:	4311      	orrne	r1, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
90001da8:	689a      	ldr	r2, [r3, #8]
90001daa:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
90001dae:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
90001db2:	430a      	orrs	r2, r1
90001db4:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
90001db6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
90001db8:	6a61      	ldr	r1, [r4, #36]	; 0x24
90001dba:	f022 020f 	bic.w	r2, r2, #15
90001dbe:	430a      	orrs	r2, r1
90001dc0:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
90001dc2:	4a9a      	ldr	r2, [pc, #616]	; (9000202c <UART_SetConfig+0x2bc>)
90001dc4:	4293      	cmp	r3, r2
90001dc6:	d117      	bne.n	90001df8 <UART_SetConfig+0x88>
90001dc8:	4b99      	ldr	r3, [pc, #612]	; (90002030 <UART_SetConfig+0x2c0>)
90001dca:	4a9a      	ldr	r2, [pc, #616]	; (90002034 <UART_SetConfig+0x2c4>)
90001dcc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90001dd0:	f003 0303 	and.w	r3, r3, #3
        }
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
90001dd4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
90001dd8:	5cd3      	ldrb	r3, [r2, r3]
90001dda:	f040 80a9 	bne.w	90001f30 <UART_SetConfig+0x1c0>
  {
    switch (clocksource)
90001dde:	2b08      	cmp	r3, #8
90001de0:	d839      	bhi.n	90001e56 <UART_SetConfig+0xe6>
90001de2:	e8df f013 	tbh	[pc, r3, lsl #1]
90001de6:	00fc      	.short	0x00fc
90001de8:	00a3009d 	.word	0x00a3009d
90001dec:	00f00038 	.word	0x00f00038
90001df0:	00380038 	.word	0x00380038
90001df4:	00a00038 	.word	0x00a00038
  UART_GETCLOCKSOURCE(huart, clocksource);
90001df8:	4a8f      	ldr	r2, [pc, #572]	; (90002038 <UART_SetConfig+0x2c8>)
90001dfa:	4293      	cmp	r3, r2
90001dfc:	d106      	bne.n	90001e0c <UART_SetConfig+0x9c>
90001dfe:	4b8c      	ldr	r3, [pc, #560]	; (90002030 <UART_SetConfig+0x2c0>)
90001e00:	4a8e      	ldr	r2, [pc, #568]	; (9000203c <UART_SetConfig+0x2cc>)
90001e02:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
90001e06:	f003 030c 	and.w	r3, r3, #12
90001e0a:	e7e3      	b.n	90001dd4 <UART_SetConfig+0x64>
90001e0c:	4a8c      	ldr	r2, [pc, #560]	; (90002040 <UART_SetConfig+0x2d0>)
90001e0e:	4293      	cmp	r3, r2
90001e10:	d123      	bne.n	90001e5a <UART_SetConfig+0xea>
90001e12:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
90001e16:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
90001e1a:	f002 0230 	and.w	r2, r2, #48	; 0x30
90001e1e:	2a10      	cmp	r2, #16
90001e20:	f000 80c8 	beq.w	90001fb4 <UART_SetConfig+0x244>
90001e24:	d811      	bhi.n	90001e4a <UART_SetConfig+0xda>
90001e26:	b9b2      	cbnz	r2, 90001e56 <UART_SetConfig+0xe6>
  if (UART_INSTANCE_LOWPOWER(huart))
90001e28:	4a7f      	ldr	r2, [pc, #508]	; (90002028 <UART_SetConfig+0x2b8>)
90001e2a:	4293      	cmp	r3, r2
90001e2c:	f040 80d4 	bne.w	90001fd8 <UART_SetConfig+0x268>
        pclk = HAL_RCC_GetPCLK1Freq();
90001e30:	f7ff ff7e 	bl	90001d30 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
90001e34:	2800      	cmp	r0, #0
90001e36:	d14a      	bne.n	90001ece <UART_SetConfig+0x15e>
90001e38:	2000      	movs	r0, #0
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;
90001e3a:	f04f 1301 	mov.w	r3, #65537	; 0x10001
90001e3e:	66a3      	str	r3, [r4, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
90001e40:	2300      	movs	r3, #0
  huart->TxISR = NULL;
90001e42:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70

  return ret;
}
90001e46:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
90001e4a:	2a20      	cmp	r2, #32
90001e4c:	f000 80a4 	beq.w	90001f98 <UART_SetConfig+0x228>
90001e50:	2a30      	cmp	r2, #48	; 0x30
90001e52:	f000 80a9 	beq.w	90001fa8 <UART_SetConfig+0x238>
        ret = HAL_ERROR;
90001e56:	2001      	movs	r0, #1
90001e58:	e7ef      	b.n	90001e3a <UART_SetConfig+0xca>
  UART_GETCLOCKSOURCE(huart, clocksource);
90001e5a:	4a7a      	ldr	r2, [pc, #488]	; (90002044 <UART_SetConfig+0x2d4>)
90001e5c:	4293      	cmp	r3, r2
90001e5e:	d10e      	bne.n	90001e7e <UART_SetConfig+0x10e>
90001e60:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
90001e64:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
90001e68:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
90001e6c:	2a40      	cmp	r2, #64	; 0x40
90001e6e:	f000 80a1 	beq.w	90001fb4 <UART_SetConfig+0x244>
90001e72:	d9d8      	bls.n	90001e26 <UART_SetConfig+0xb6>
90001e74:	2a80      	cmp	r2, #128	; 0x80
90001e76:	f000 808f 	beq.w	90001f98 <UART_SetConfig+0x228>
90001e7a:	2ac0      	cmp	r2, #192	; 0xc0
90001e7c:	e7e9      	b.n	90001e52 <UART_SetConfig+0xe2>
90001e7e:	4a72      	ldr	r2, [pc, #456]	; (90002048 <UART_SetConfig+0x2d8>)
90001e80:	4293      	cmp	r3, r2
90001e82:	d110      	bne.n	90001ea6 <UART_SetConfig+0x136>
90001e84:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
90001e88:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
90001e8c:	f402 7240 	and.w	r2, r2, #768	; 0x300
90001e90:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
90001e94:	f000 808e 	beq.w	90001fb4 <UART_SetConfig+0x244>
90001e98:	d9c5      	bls.n	90001e26 <UART_SetConfig+0xb6>
90001e9a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
90001e9e:	d07b      	beq.n	90001f98 <UART_SetConfig+0x228>
90001ea0:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
90001ea4:	e7d5      	b.n	90001e52 <UART_SetConfig+0xe2>
90001ea6:	4a60      	ldr	r2, [pc, #384]	; (90002028 <UART_SetConfig+0x2b8>)
90001ea8:	4293      	cmp	r3, r2
90001eaa:	d1d4      	bne.n	90001e56 <UART_SetConfig+0xe6>
90001eac:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
90001eb0:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
90001eb4:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
90001eb8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
90001ebc:	d07a      	beq.n	90001fb4 <UART_SetConfig+0x244>
90001ebe:	d9b2      	bls.n	90001e26 <UART_SetConfig+0xb6>
90001ec0:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
90001ec4:	d068      	beq.n	90001f98 <UART_SetConfig+0x228>
90001ec6:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
90001eca:	e7c2      	b.n	90001e52 <UART_SetConfig+0xe2>
        pclk = (uint32_t) HSI_VALUE;
90001ecc:	485f      	ldr	r0, [pc, #380]	; (9000204c <UART_SetConfig+0x2dc>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
90001ece:	4b60      	ldr	r3, [pc, #384]	; (90002050 <UART_SetConfig+0x2e0>)
90001ed0:	6a62      	ldr	r2, [r4, #36]	; 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
90001ed2:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
90001ed4:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
90001ed8:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
90001edc:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
90001ee0:	4299      	cmp	r1, r3
90001ee2:	d8b8      	bhi.n	90001e56 <UART_SetConfig+0xe6>
90001ee4:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
90001ee8:	d8b5      	bhi.n	90001e56 <UART_SetConfig+0xe6>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate, huart->Init.ClockPrescaler));
90001eea:	2300      	movs	r3, #0
90001eec:	2100      	movs	r1, #0
90001eee:	f002 fb99 	bl	90004624 <__aeabi_uldivmod>
90001ef2:	020f      	lsls	r7, r1, #8
90001ef4:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
90001ef8:	0206      	lsls	r6, r0, #8
90001efa:	0868      	lsrs	r0, r5, #1
90001efc:	eb16 0b00 	adds.w	fp, r6, r0
90001f00:	f147 0c00 	adc.w	ip, r7, #0
90001f04:	462a      	mov	r2, r5
90001f06:	2300      	movs	r3, #0
90001f08:	4658      	mov	r0, fp
90001f0a:	4661      	mov	r1, ip
90001f0c:	f002 fb8a 	bl	90004624 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
90001f10:	4b50      	ldr	r3, [pc, #320]	; (90002054 <UART_SetConfig+0x2e4>)
90001f12:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
90001f16:	429a      	cmp	r2, r3
90001f18:	d89d      	bhi.n	90001e56 <UART_SetConfig+0xe6>
        huart->Instance->BRR = usartdiv;
90001f1a:	6823      	ldr	r3, [r4, #0]
90001f1c:	60d8      	str	r0, [r3, #12]
90001f1e:	e78b      	b.n	90001e38 <UART_SetConfig+0xc8>
        pclk = HAL_RCC_GetPCLK2Freq();
90001f20:	f7ff ff16 	bl	90001d50 <HAL_RCC_GetPCLK2Freq>
        break;
90001f24:	e05d      	b.n	90001fe2 <UART_SetConfig+0x272>
        pclk = (uint32_t) LSE_VALUE;
90001f26:	f44f 4000 	mov.w	r0, #32768	; 0x8000
90001f2a:	e05d      	b.n	90001fe8 <UART_SetConfig+0x278>
        pclk = (uint32_t) HSI_VALUE;
90001f2c:	4847      	ldr	r0, [pc, #284]	; (9000204c <UART_SetConfig+0x2dc>)
90001f2e:	e05b      	b.n	90001fe8 <UART_SetConfig+0x278>
    switch (clocksource)
90001f30:	2b08      	cmp	r3, #8
90001f32:	d890      	bhi.n	90001e56 <UART_SetConfig+0xe6>
90001f34:	a201      	add	r2, pc, #4	; (adr r2, 90001f3c <UART_SetConfig+0x1cc>)
90001f36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
90001f3a:	bf00      	nop
90001f3c:	90001f61 	.word	0x90001f61
90001f40:	90001f8d 	.word	0x90001f8d
90001f44:	90001fa5 	.word	0x90001fa5
90001f48:	90001e57 	.word	0x90001e57
90001f4c:	90001f93 	.word	0x90001f93
90001f50:	90001e57 	.word	0x90001e57
90001f54:	90001e57 	.word	0x90001e57
90001f58:	90001e57 	.word	0x90001e57
90001f5c:	90001fd3 	.word	0x90001fd3
        pclk = HAL_RCC_GetPCLK1Freq();
90001f60:	f7ff fee6 	bl	90001d30 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
90001f64:	2800      	cmp	r0, #0
90001f66:	f43f af67 	beq.w	90001e38 <UART_SetConfig+0xc8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
90001f6a:	6a61      	ldr	r1, [r4, #36]	; 0x24
90001f6c:	4a38      	ldr	r2, [pc, #224]	; (90002050 <UART_SetConfig+0x2e0>)
90001f6e:	6863      	ldr	r3, [r4, #4]
90001f70:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
90001f74:	fbb0 f0f2 	udiv	r0, r0, r2
90001f78:	eb00 0053 	add.w	r0, r0, r3, lsr #1
90001f7c:	fbb0 f0f3 	udiv	r0, r0, r3
90001f80:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
90001f82:	f1a0 0210 	sub.w	r2, r0, #16
90001f86:	f64f 73ef 	movw	r3, #65519	; 0xffef
90001f8a:	e7c4      	b.n	90001f16 <UART_SetConfig+0x1a6>
        pclk = HAL_RCC_GetPCLK2Freq();
90001f8c:	f7ff fee0 	bl	90001d50 <HAL_RCC_GetPCLK2Freq>
        break;
90001f90:	e7e8      	b.n	90001f64 <UART_SetConfig+0x1f4>
        pclk = HAL_RCC_GetSysClockFreq();
90001f92:	f7ff fe6f 	bl	90001c74 <HAL_RCC_GetSysClockFreq>
        break;
90001f96:	e7e5      	b.n	90001f64 <UART_SetConfig+0x1f4>
  if (UART_INSTANCE_LOWPOWER(huart))
90001f98:	4a23      	ldr	r2, [pc, #140]	; (90002028 <UART_SetConfig+0x2b8>)
90001f9a:	4293      	cmp	r3, r2
90001f9c:	d096      	beq.n	90001ecc <UART_SetConfig+0x15c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
90001f9e:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
90001fa2:	d0c3      	beq.n	90001f2c <UART_SetConfig+0x1bc>
        pclk = (uint32_t) HSI_VALUE;
90001fa4:	4829      	ldr	r0, [pc, #164]	; (9000204c <UART_SetConfig+0x2dc>)
90001fa6:	e7e0      	b.n	90001f6a <UART_SetConfig+0x1fa>
  if (UART_INSTANCE_LOWPOWER(huart))
90001fa8:	4a1f      	ldr	r2, [pc, #124]	; (90002028 <UART_SetConfig+0x2b8>)
90001faa:	4293      	cmp	r3, r2
90001fac:	d10e      	bne.n	90001fcc <UART_SetConfig+0x25c>
        pclk = (uint32_t) LSE_VALUE;
90001fae:	f44f 4000 	mov.w	r0, #32768	; 0x8000
90001fb2:	e78c      	b.n	90001ece <UART_SetConfig+0x15e>
  if (UART_INSTANCE_LOWPOWER(huart))
90001fb4:	4a1c      	ldr	r2, [pc, #112]	; (90002028 <UART_SetConfig+0x2b8>)
90001fb6:	4293      	cmp	r3, r2
90001fb8:	d102      	bne.n	90001fc0 <UART_SetConfig+0x250>
        pclk = HAL_RCC_GetSysClockFreq();
90001fba:	f7ff fe5b 	bl	90001c74 <HAL_RCC_GetSysClockFreq>
        break;
90001fbe:	e739      	b.n	90001e34 <UART_SetConfig+0xc4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
90001fc0:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
90001fc4:	d1e5      	bne.n	90001f92 <UART_SetConfig+0x222>
        pclk = HAL_RCC_GetSysClockFreq();
90001fc6:	f7ff fe55 	bl	90001c74 <HAL_RCC_GetSysClockFreq>
        break;
90001fca:	e00a      	b.n	90001fe2 <UART_SetConfig+0x272>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
90001fcc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
90001fd0:	d00a      	beq.n	90001fe8 <UART_SetConfig+0x278>
        pclk = (uint32_t) LSE_VALUE;
90001fd2:	f44f 4000 	mov.w	r0, #32768	; 0x8000
90001fd6:	e7c8      	b.n	90001f6a <UART_SetConfig+0x1fa>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
90001fd8:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
90001fdc:	d1c0      	bne.n	90001f60 <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetPCLK1Freq();
90001fde:	f7ff fea7 	bl	90001d30 <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
90001fe2:	2800      	cmp	r0, #0
90001fe4:	f43f af28 	beq.w	90001e38 <UART_SetConfig+0xc8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
90001fe8:	6a61      	ldr	r1, [r4, #36]	; 0x24
90001fea:	4b19      	ldr	r3, [pc, #100]	; (90002050 <UART_SetConfig+0x2e0>)
90001fec:	6862      	ldr	r2, [r4, #4]
90001fee:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
90001ff2:	fbb0 f3f3 	udiv	r3, r0, r3
90001ff6:	0850      	lsrs	r0, r2, #1
90001ff8:	eb00 0043 	add.w	r0, r0, r3, lsl #1
90001ffc:	fbb0 f0f2 	udiv	r0, r0, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
90002000:	f64f 72ef 	movw	r2, #65519	; 0xffef
90002004:	b283      	uxth	r3, r0
90002006:	f1a3 0110 	sub.w	r1, r3, #16
9000200a:	4291      	cmp	r1, r2
9000200c:	f63f af23 	bhi.w	90001e56 <UART_SetConfig+0xe6>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
90002010:	f020 000f 	bic.w	r0, r0, #15
90002014:	b280      	uxth	r0, r0
        huart->Instance->BRR = brrtemp;
90002016:	6822      	ldr	r2, [r4, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
90002018:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
9000201c:	4318      	orrs	r0, r3
9000201e:	60d0      	str	r0, [r2, #12]
90002020:	e70a      	b.n	90001e38 <UART_SetConfig+0xc8>
90002022:	bf00      	nop
90002024:	cfff69f3 	.word	0xcfff69f3
90002028:	40008000 	.word	0x40008000
9000202c:	40013800 	.word	0x40013800
90002030:	40021000 	.word	0x40021000
90002034:	900056a5 	.word	0x900056a5
90002038:	40004400 	.word	0x40004400
9000203c:	900056a9 	.word	0x900056a9
90002040:	40004800 	.word	0x40004800
90002044:	40004c00 	.word	0x40004c00
90002048:	40005000 	.word	0x40005000
9000204c:	00f42400 	.word	0x00f42400
90002050:	900056b6 	.word	0x900056b6
90002054:	000ffcff 	.word	0x000ffcff

90002058 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
90002058:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
9000205a:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
9000205c:	07da      	lsls	r2, r3, #31
9000205e:	d506      	bpl.n	9000206e <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
90002060:	6801      	ldr	r1, [r0, #0]
90002062:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
90002064:	684a      	ldr	r2, [r1, #4]
90002066:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
9000206a:	4322      	orrs	r2, r4
9000206c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
9000206e:	079c      	lsls	r4, r3, #30
90002070:	d506      	bpl.n	90002080 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
90002072:	6801      	ldr	r1, [r0, #0]
90002074:	6b04      	ldr	r4, [r0, #48]	; 0x30
90002076:	684a      	ldr	r2, [r1, #4]
90002078:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
9000207c:	4322      	orrs	r2, r4
9000207e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
90002080:	0759      	lsls	r1, r3, #29
90002082:	d506      	bpl.n	90002092 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
90002084:	6801      	ldr	r1, [r0, #0]
90002086:	6b44      	ldr	r4, [r0, #52]	; 0x34
90002088:	684a      	ldr	r2, [r1, #4]
9000208a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
9000208e:	4322      	orrs	r2, r4
90002090:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
90002092:	071a      	lsls	r2, r3, #28
90002094:	d506      	bpl.n	900020a4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
90002096:	6801      	ldr	r1, [r0, #0]
90002098:	6b84      	ldr	r4, [r0, #56]	; 0x38
9000209a:	684a      	ldr	r2, [r1, #4]
9000209c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
900020a0:	4322      	orrs	r2, r4
900020a2:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
900020a4:	06dc      	lsls	r4, r3, #27
900020a6:	d506      	bpl.n	900020b6 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
900020a8:	6801      	ldr	r1, [r0, #0]
900020aa:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
900020ac:	688a      	ldr	r2, [r1, #8]
900020ae:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
900020b2:	4322      	orrs	r2, r4
900020b4:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
900020b6:	0699      	lsls	r1, r3, #26
900020b8:	d506      	bpl.n	900020c8 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
900020ba:	6801      	ldr	r1, [r0, #0]
900020bc:	6c04      	ldr	r4, [r0, #64]	; 0x40
900020be:	688a      	ldr	r2, [r1, #8]
900020c0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
900020c4:	4322      	orrs	r2, r4
900020c6:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
900020c8:	065a      	lsls	r2, r3, #25
900020ca:	d510      	bpl.n	900020ee <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
900020cc:	6801      	ldr	r1, [r0, #0]
900020ce:	6c44      	ldr	r4, [r0, #68]	; 0x44
900020d0:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
900020d2:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
900020d6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
900020da:	ea42 0204 	orr.w	r2, r2, r4
900020de:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
900020e0:	d105      	bne.n	900020ee <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
900020e2:	684a      	ldr	r2, [r1, #4]
900020e4:	6c84      	ldr	r4, [r0, #72]	; 0x48
900020e6:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
900020ea:	4322      	orrs	r2, r4
900020ec:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
900020ee:	061b      	lsls	r3, r3, #24
900020f0:	d506      	bpl.n	90002100 <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
900020f2:	6802      	ldr	r2, [r0, #0]
900020f4:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
900020f6:	6853      	ldr	r3, [r2, #4]
900020f8:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
900020fc:	430b      	orrs	r3, r1
900020fe:	6053      	str	r3, [r2, #4]
  }
}
90002100:	bd10      	pop	{r4, pc}

90002102 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
90002102:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
90002106:	4604      	mov	r4, r0
90002108:	460f      	mov	r7, r1
9000210a:	4616      	mov	r6, r2
9000210c:	4698      	mov	r8, r3
9000210e:	9d06      	ldr	r5, [sp, #24]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
90002110:	6821      	ldr	r1, [r4, #0]
90002112:	69ca      	ldr	r2, [r1, #28]
90002114:	ea37 0302 	bics.w	r3, r7, r2
90002118:	bf0c      	ite	eq
9000211a:	2201      	moveq	r2, #1
9000211c:	2200      	movne	r2, #0
9000211e:	42b2      	cmp	r2, r6
90002120:	d001      	beq.n	90002126 <UART_WaitOnFlagUntilTimeout+0x24>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
90002122:	2000      	movs	r0, #0
90002124:	e01a      	b.n	9000215c <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
90002126:	1c68      	adds	r0, r5, #1
90002128:	d0f3      	beq.n	90002112 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
9000212a:	f7ff faef 	bl	9000170c <HAL_GetTick>
9000212e:	eba0 0008 	sub.w	r0, r0, r8
90002132:	42a8      	cmp	r0, r5
90002134:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
90002136:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
90002138:	d800      	bhi.n	9000213c <UART_WaitOnFlagUntilTimeout+0x3a>
9000213a:	b98d      	cbnz	r5, 90002160 <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
9000213c:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
90002140:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
90002142:	6883      	ldr	r3, [r0, #8]
90002144:	f023 0301 	bic.w	r3, r3, #1
90002148:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
9000214a:	2320      	movs	r3, #32
9000214c:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
90002150:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
90002154:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
90002156:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
90002158:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
9000215c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
90002160:	075a      	lsls	r2, r3, #29
90002162:	d5d5      	bpl.n	90002110 <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
90002164:	69c3      	ldr	r3, [r0, #28]
90002166:	051b      	lsls	r3, r3, #20
90002168:	d5d2      	bpl.n	90002110 <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
9000216a:	f44f 6300 	mov.w	r3, #2048	; 0x800
9000216e:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
90002170:	6803      	ldr	r3, [r0, #0]
90002172:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
90002176:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
90002178:	6883      	ldr	r3, [r0, #8]
9000217a:	f023 0301 	bic.w	r3, r3, #1
9000217e:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
90002180:	2320      	movs	r3, #32
90002182:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
90002186:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
9000218a:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
9000218e:	e7e1      	b.n	90002154 <UART_WaitOnFlagUntilTimeout+0x52>

90002190 <HAL_UART_Transmit>:
{
90002190:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
90002194:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
90002196:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
9000219a:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
9000219c:	2b20      	cmp	r3, #32
{
9000219e:	460e      	mov	r6, r1
900021a0:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
900021a2:	d14f      	bne.n	90002244 <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
900021a4:	2900      	cmp	r1, #0
900021a6:	d04b      	beq.n	90002240 <HAL_UART_Transmit+0xb0>
900021a8:	2a00      	cmp	r2, #0
900021aa:	d049      	beq.n	90002240 <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
900021ac:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
900021b0:	2b01      	cmp	r3, #1
900021b2:	d047      	beq.n	90002244 <HAL_UART_Transmit+0xb4>
900021b4:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
900021b6:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
900021b8:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
900021bc:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
900021be:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
900021c2:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
900021c6:	f7ff faa1 	bl	9000170c <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
900021ca:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
900021cc:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
900021ce:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
900021d2:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
900021d6:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
900021da:	d103      	bne.n	900021e4 <HAL_UART_Transmit+0x54>
900021dc:	6923      	ldr	r3, [r4, #16]
900021de:	b90b      	cbnz	r3, 900021e4 <HAL_UART_Transmit+0x54>
900021e0:	4635      	mov	r5, r6
      pdata8bits  = NULL;
900021e2:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
900021e4:	2300      	movs	r3, #0
900021e6:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->TxXferCount > 0U)
900021ea:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
900021ee:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
900021f2:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
900021f4:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
900021f6:	b942      	cbnz	r2, 9000220a <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
900021f8:	2140      	movs	r1, #64	; 0x40
900021fa:	4620      	mov	r0, r4
900021fc:	f7ff ff81 	bl	90002102 <UART_WaitOnFlagUntilTimeout>
90002200:	b948      	cbnz	r0, 90002216 <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
90002202:	2320      	movs	r3, #32
90002204:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    return HAL_OK;
90002208:	e006      	b.n	90002218 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
9000220a:	2200      	movs	r2, #0
9000220c:	2180      	movs	r1, #128	; 0x80
9000220e:	4620      	mov	r0, r4
90002210:	f7ff ff77 	bl	90002102 <UART_WaitOnFlagUntilTimeout>
90002214:	b118      	cbz	r0, 9000221e <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
90002216:	2003      	movs	r0, #3
}
90002218:	b003      	add	sp, #12
9000221a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
9000221e:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
90002220:	b95e      	cbnz	r6, 9000223a <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
90002222:	f835 3b02 	ldrh.w	r3, [r5], #2
90002226:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
9000222a:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
9000222c:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
90002230:	3b01      	subs	r3, #1
90002232:	b29b      	uxth	r3, r3
90002234:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
90002238:	e7d7      	b.n	900021ea <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
9000223a:	f816 3b01 	ldrb.w	r3, [r6], #1
9000223e:	e7f4      	b.n	9000222a <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
90002240:	2001      	movs	r0, #1
90002242:	e7e9      	b.n	90002218 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
90002244:	2002      	movs	r0, #2
90002246:	e7e7      	b.n	90002218 <HAL_UART_Transmit+0x88>

90002248 <HAL_UART_Receive>:
{
90002248:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
9000224c:	4699      	mov	r9, r3
  if (huart->RxState == HAL_UART_STATE_READY)
9000224e:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
{
90002252:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
90002254:	2b20      	cmp	r3, #32
{
90002256:	460d      	mov	r5, r1
90002258:	4617      	mov	r7, r2
  if (huart->RxState == HAL_UART_STATE_READY)
9000225a:	d168      	bne.n	9000232e <HAL_UART_Receive+0xe6>
    if ((pData == NULL) || (Size == 0U))
9000225c:	2900      	cmp	r1, #0
9000225e:	d064      	beq.n	9000232a <HAL_UART_Receive+0xe2>
90002260:	2a00      	cmp	r2, #0
90002262:	d062      	beq.n	9000232a <HAL_UART_Receive+0xe2>
    __HAL_LOCK(huart);
90002264:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
90002268:	2b01      	cmp	r3, #1
9000226a:	d060      	beq.n	9000232e <HAL_UART_Receive+0xe6>
9000226c:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
9000226e:	2600      	movs	r6, #0
    __HAL_LOCK(huart);
90002270:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->RxState = HAL_UART_STATE_BUSY_RX;
90002274:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
90002276:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
9000227a:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
9000227e:	66c6      	str	r6, [r0, #108]	; 0x6c
    tickstart = HAL_GetTick();
90002280:	f7ff fa44 	bl	9000170c <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
90002284:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
90002286:	4680      	mov	r8, r0
    UART_MASK_COMPUTATION(huart);
90002288:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferSize  = Size;
9000228c:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
    huart->RxXferCount = Size;
90002290:	f8a4 705e 	strh.w	r7, [r4, #94]	; 0x5e
    UART_MASK_COMPUTATION(huart);
90002294:	d11d      	bne.n	900022d2 <HAL_UART_Receive+0x8a>
90002296:	6922      	ldr	r2, [r4, #16]
90002298:	b9ca      	cbnz	r2, 900022ce <HAL_UART_Receive+0x86>
9000229a:	f240 12ff 	movw	r2, #511	; 0x1ff
9000229e:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
900022a2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    uhMask = huart->Mask;
900022a6:	f8b4 7060 	ldrh.w	r7, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
900022aa:	d123      	bne.n	900022f4 <HAL_UART_Receive+0xac>
900022ac:	6923      	ldr	r3, [r4, #16]
900022ae:	bb0b      	cbnz	r3, 900022f4 <HAL_UART_Receive+0xac>
900022b0:	462e      	mov	r6, r5
      pdata8bits  = NULL;
900022b2:	461d      	mov	r5, r3
    __HAL_UNLOCK(huart);
900022b4:	2300      	movs	r3, #0
900022b6:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->RxXferCount > 0U)
900022ba:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
900022be:	b280      	uxth	r0, r0
900022c0:	b9d0      	cbnz	r0, 900022f8 <HAL_UART_Receive+0xb0>
    huart->RxState = HAL_UART_STATE_READY;
900022c2:	2320      	movs	r3, #32
900022c4:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
}
900022c8:	b003      	add	sp, #12
900022ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
900022ce:	22ff      	movs	r2, #255	; 0xff
900022d0:	e7e5      	b.n	9000229e <HAL_UART_Receive+0x56>
900022d2:	b923      	cbnz	r3, 900022de <HAL_UART_Receive+0x96>
900022d4:	6922      	ldr	r2, [r4, #16]
900022d6:	2a00      	cmp	r2, #0
900022d8:	d0f9      	beq.n	900022ce <HAL_UART_Receive+0x86>
900022da:	227f      	movs	r2, #127	; 0x7f
900022dc:	e7df      	b.n	9000229e <HAL_UART_Receive+0x56>
900022de:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
900022e2:	d104      	bne.n	900022ee <HAL_UART_Receive+0xa6>
900022e4:	6922      	ldr	r2, [r4, #16]
900022e6:	2a00      	cmp	r2, #0
900022e8:	d0f7      	beq.n	900022da <HAL_UART_Receive+0x92>
900022ea:	223f      	movs	r2, #63	; 0x3f
900022ec:	e7d7      	b.n	9000229e <HAL_UART_Receive+0x56>
900022ee:	f8a4 6060 	strh.w	r6, [r4, #96]	; 0x60
900022f2:	e7d6      	b.n	900022a2 <HAL_UART_Receive+0x5a>
      pdata16bits = NULL;
900022f4:	2600      	movs	r6, #0
900022f6:	e7dd      	b.n	900022b4 <HAL_UART_Receive+0x6c>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
900022f8:	f8cd 9000 	str.w	r9, [sp]
900022fc:	4643      	mov	r3, r8
900022fe:	2200      	movs	r2, #0
90002300:	2120      	movs	r1, #32
90002302:	4620      	mov	r0, r4
90002304:	f7ff fefd 	bl	90002102 <UART_WaitOnFlagUntilTimeout>
90002308:	b998      	cbnz	r0, 90002332 <HAL_UART_Receive+0xea>
9000230a:	6823      	ldr	r3, [r4, #0]
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
9000230c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
9000230e:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
90002310:	b945      	cbnz	r5, 90002324 <HAL_UART_Receive+0xdc>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
90002312:	f826 3b02 	strh.w	r3, [r6], #2
      huart->RxXferCount--;
90002316:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
9000231a:	3b01      	subs	r3, #1
9000231c:	b29b      	uxth	r3, r3
9000231e:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
90002322:	e7ca      	b.n	900022ba <HAL_UART_Receive+0x72>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
90002324:	f805 3b01 	strb.w	r3, [r5], #1
90002328:	e7f5      	b.n	90002316 <HAL_UART_Receive+0xce>
      return  HAL_ERROR;
9000232a:	2001      	movs	r0, #1
9000232c:	e7cc      	b.n	900022c8 <HAL_UART_Receive+0x80>
    return HAL_BUSY;
9000232e:	2002      	movs	r0, #2
90002330:	e7ca      	b.n	900022c8 <HAL_UART_Receive+0x80>
        return HAL_TIMEOUT;
90002332:	2003      	movs	r0, #3
90002334:	e7c8      	b.n	900022c8 <HAL_UART_Receive+0x80>

90002336 <UART_CheckIdleState>:
{
90002336:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
90002338:	2600      	movs	r6, #0
{
9000233a:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
9000233c:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
90002340:	f7ff f9e4 	bl	9000170c <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
90002344:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
90002346:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
90002348:	681b      	ldr	r3, [r3, #0]
9000234a:	071a      	lsls	r2, r3, #28
9000234c:	d418      	bmi.n	90002380 <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
9000234e:	6823      	ldr	r3, [r4, #0]
90002350:	681b      	ldr	r3, [r3, #0]
90002352:	075b      	lsls	r3, r3, #29
90002354:	d50a      	bpl.n	9000236c <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
90002356:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
9000235a:	2200      	movs	r2, #0
9000235c:	9300      	str	r3, [sp, #0]
9000235e:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
90002362:	462b      	mov	r3, r5
90002364:	4620      	mov	r0, r4
90002366:	f7ff fecc 	bl	90002102 <UART_WaitOnFlagUntilTimeout>
9000236a:	b9a8      	cbnz	r0, 90002398 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
9000236c:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
9000236e:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
90002370:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
90002374:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
90002378:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
9000237c:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
9000237e:	e00c      	b.n	9000239a <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
90002380:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
90002384:	4632      	mov	r2, r6
90002386:	9300      	str	r3, [sp, #0]
90002388:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
9000238c:	4603      	mov	r3, r0
9000238e:	4620      	mov	r0, r4
90002390:	f7ff feb7 	bl	90002102 <UART_WaitOnFlagUntilTimeout>
90002394:	2800      	cmp	r0, #0
90002396:	d0da      	beq.n	9000234e <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
90002398:	2003      	movs	r0, #3
}
9000239a:	b002      	add	sp, #8
9000239c:	bd70      	pop	{r4, r5, r6, pc}

9000239e <HAL_UART_Init>:
{
9000239e:	b510      	push	{r4, lr}
  if (huart == NULL)
900023a0:	4604      	mov	r4, r0
900023a2:	b350      	cbz	r0, 900023fa <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
900023a4:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
900023a8:	b91b      	cbnz	r3, 900023b2 <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
900023aa:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
900023ae:	f7fe faaf 	bl	90000910 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
900023b2:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
900023b4:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
900023b6:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
900023ba:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
900023bc:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
900023be:	f023 0301 	bic.w	r3, r3, #1
900023c2:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
900023c4:	f7ff fcd4 	bl	90001d70 <UART_SetConfig>
900023c8:	2801      	cmp	r0, #1
900023ca:	d016      	beq.n	900023fa <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
900023cc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
900023ce:	b113      	cbz	r3, 900023d6 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
900023d0:	4620      	mov	r0, r4
900023d2:	f7ff fe41 	bl	90002058 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
900023d6:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
900023d8:	4620      	mov	r0, r4
}
900023da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
900023de:	685a      	ldr	r2, [r3, #4]
900023e0:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
900023e4:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
900023e6:	689a      	ldr	r2, [r3, #8]
900023e8:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
900023ec:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
900023ee:	681a      	ldr	r2, [r3, #0]
900023f0:	f042 0201 	orr.w	r2, r2, #1
900023f4:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
900023f6:	f7ff bf9e 	b.w	90002336 <UART_CheckIdleState>
}
900023fa:	2001      	movs	r0, #1
900023fc:	bd10      	pop	{r4, pc}

900023fe <UsefulBuf_CopyOffset>:

/*
 Public function -- see UsefulBuf.h
 */
UsefulBufC UsefulBuf_CopyOffset(UsefulBuf Dest, size_t uOffset, const UsefulBufC Src)
{
900023fe:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
90002400:	4605      	mov	r5, r0
90002402:	a802      	add	r0, sp, #8
90002404:	e900 0006 	stmdb	r0, {r1, r2}
90002408:	9a01      	ldr	r2, [sp, #4]
9000240a:	461c      	mov	r4, r3
   // Do this with subtraction so it doesn't give erroneous result if uOffset + Src.len overflows
   if(uOffset > Dest.len || Src.len > Dest.len - uOffset) { // uOffset + Src.len > Dest.len
9000240c:	4293      	cmp	r3, r2
9000240e:	d803      	bhi.n	90002418 <UsefulBuf_CopyOffset+0x1a>
90002410:	9e09      	ldr	r6, [sp, #36]	; 0x24
90002412:	1ad2      	subs	r2, r2, r3
90002414:	42b2      	cmp	r2, r6
90002416:	d205      	bcs.n	90002424 <UsefulBuf_CopyOffset+0x26>
      return NULLUsefulBufC;
90002418:	2300      	movs	r3, #0
9000241a:	e9c5 3300 	strd	r3, r3, [r5]
   }

   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);

   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
}
9000241e:	4628      	mov	r0, r5
90002420:	b003      	add	sp, #12
90002422:	bdf0      	pop	{r4, r5, r6, r7, pc}
90002424:	9f00      	ldr	r7, [sp, #0]
   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);
90002426:	4632      	mov	r2, r6
90002428:	9908      	ldr	r1, [sp, #32]
9000242a:	18f8      	adds	r0, r7, r3
   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
9000242c:	4434      	add	r4, r6
   memcpy((uint8_t *)Dest.ptr + uOffset, Src.ptr, Src.len);
9000242e:	f001 f8ca 	bl	900035c6 <memcpy>
   return (UsefulBufC){Dest.ptr, Src.len + uOffset};
90002432:	602f      	str	r7, [r5, #0]
90002434:	606c      	str	r4, [r5, #4]
90002436:	e7f2      	b.n	9000241e <UsefulBuf_CopyOffset+0x20>

90002438 <UsefulBuf_IsValue>:

/*
 Public function -- see UsefulBuf.h
 */
size_t UsefulBuf_IsValue(const UsefulBufC UB, uint8_t uValue)
{
90002438:	b537      	push	{r0, r1, r2, r4, r5, lr}
9000243a:	ab02      	add	r3, sp, #8
9000243c:	e903 0003 	stmdb	r3, {r0, r1}
90002440:	9801      	ldr	r0, [sp, #4]
   return UsefulBuf_IsEmptyC(UB) || UsefulBuf_IsNULLC(UB);
90002442:	b168      	cbz	r0, 90002460 <UsefulBuf_IsValue+0x28>
90002444:	9b00      	ldr	r3, [sp, #0]
90002446:	b17b      	cbz	r3, 90002468 <UsefulBuf_IsValue+0x30>
   if(UsefulBuf_IsNULLOrEmptyC(UB)) {
      /* Not a match */
      return 0;
   }

   const uint8_t * const pEnd = (uint8_t *)UB.ptr + UB.len;
90002448:	1819      	adds	r1, r3, r0
9000244a:	4618      	mov	r0, r3
   for(const uint8_t *p = UB.ptr; p < pEnd; p++) {
9000244c:	4288      	cmp	r0, r1
9000244e:	d302      	bcc.n	90002456 <UsefulBuf_IsValue+0x1e>
         return p - (uint8_t *)UB.ptr;
      }
   }

   /* Success. All bytes matched */
   return SIZE_MAX;
90002450:	f04f 30ff 	mov.w	r0, #4294967295
90002454:	e004      	b.n	90002460 <UsefulBuf_IsValue+0x28>
      if(*p != uValue) {
90002456:	7805      	ldrb	r5, [r0, #0]
90002458:	1c44      	adds	r4, r0, #1
9000245a:	4295      	cmp	r5, r2
9000245c:	d002      	beq.n	90002464 <UsefulBuf_IsValue+0x2c>
         return p - (uint8_t *)UB.ptr;
9000245e:	1ac0      	subs	r0, r0, r3
}
90002460:	b003      	add	sp, #12
90002462:	bd30      	pop	{r4, r5, pc}
90002464:	4620      	mov	r0, r4
90002466:	e7f1      	b.n	9000244c <UsefulBuf_IsValue+0x14>
      return 0;
90002468:	4618      	mov	r0, r3
9000246a:	e7f9      	b.n	90002460 <UsefulBuf_IsValue+0x28>

9000246c <psa_allocate_key>:
     */
    return PSA_SUCCESS;
}

psa_status_t psa_allocate_key(psa_key_handle_t *handle)
{
9000246c:	b530      	push	{r4, r5, lr}
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    const struct tfm_crypto_pack_iovec iov = {
9000246e:	2434      	movs	r4, #52	; 0x34
{
90002470:	b095      	sub	sp, #84	; 0x54
    const struct tfm_crypto_pack_iovec iov = {
90002472:	ab07      	add	r3, sp, #28
{
90002474:	4605      	mov	r5, r0
    const struct tfm_crypto_pack_iovec iov = {
90002476:	4622      	mov	r2, r4
90002478:	2100      	movs	r1, #0
9000247a:	4618      	mov	r0, r3
9000247c:	f001 f8ae 	bl	900035dc <memset>
        .sfn_id = TFM_CRYPTO_ALLOCATE_KEY_SID,
    };
    psa_invec in_vec[] = {
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
90002480:	2302      	movs	r3, #2
    psa_invec in_vec[] = {
90002482:	e9cd 0403 	strd	r0, r4, [sp, #12]
        {.base = handle, .len = sizeof(psa_key_handle_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
90002486:	2101      	movs	r1, #1
90002488:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
9000248a:	9505      	str	r5, [sp, #20]
9000248c:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
9000248e:	f000 fbc9 	bl	90002c24 <psa_connect>
90002492:	1e05      	subs	r5, r0, #0
90002494:	dd0e      	ble.n	900024b4 <psa_allocate_key+0x48>

    status = API_DISPATCH(tfm_crypto_allocate_key,
90002496:	2301      	movs	r3, #1
90002498:	aa05      	add	r2, sp, #20
9000249a:	9200      	str	r2, [sp, #0]
9000249c:	9301      	str	r3, [sp, #4]
9000249e:	aa03      	add	r2, sp, #12
900024a0:	2100      	movs	r1, #0
900024a2:	f000 fbcd 	bl	90002c40 <psa_call>
900024a6:	4604      	mov	r4, r0
                          TFM_CRYPTO_ALLOCATE_KEY);

    PSA_CLOSE();
900024a8:	4628      	mov	r0, r5
900024aa:	f000 fbdd 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
900024ae:	4620      	mov	r0, r4
900024b0:	b015      	add	sp, #84	; 0x54
900024b2:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
900024b4:	f06f 0483 	mvn.w	r4, #131	; 0x83
900024b8:	e7f9      	b.n	900024ae <psa_allocate_key+0x42>

900024ba <psa_import_key>:

psa_status_t psa_import_key(psa_key_handle_t handle,
                            psa_key_type_t type,
                            const uint8_t *data,
                            size_t data_length)
{
900024ba:	b5f0      	push	{r4, r5, r6, r7, lr}
900024bc:	b095      	sub	sp, #84	; 0x54
900024be:	4615      	mov	r5, r2
900024c0:	4607      	mov	r7, r0
900024c2:	460e      	mov	r6, r1
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
900024c4:	222e      	movs	r2, #46	; 0x2e
900024c6:	2100      	movs	r1, #0
900024c8:	f10d 0022 	add.w	r0, sp, #34	; 0x22
{
900024cc:	461c      	mov	r4, r3
    struct tfm_crypto_pack_iovec iov = {
900024ce:	f001 f885 	bl	900035dc <memset>
        .sfn_id = TFM_CRYPTO_IMPORT_KEY_SID,
        .key_handle = handle,
        .type = type,
    };
    psa_invec in_vec[] = {
900024d2:	ab07      	add	r3, sp, #28
    struct tfm_crypto_pack_iovec iov = {
900024d4:	2101      	movs	r1, #1
    psa_invec in_vec[] = {
900024d6:	9303      	str	r3, [sp, #12]
900024d8:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = data, .len = data_length}
    };

    PSA_CONNECT(TFM_CRYPTO);
900024da:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
900024dc:	e9cd 3504 	strd	r3, r5, [sp, #16]
    struct tfm_crypto_pack_iovec iov = {
900024e0:	9107      	str	r1, [sp, #28]
900024e2:	f8ad 7020 	strh.w	r7, [sp, #32]
900024e6:	9609      	str	r6, [sp, #36]	; 0x24
    psa_invec in_vec[] = {
900024e8:	9406      	str	r4, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
900024ea:	f000 fb9b 	bl	90002c24 <psa_connect>
900024ee:	1e05      	subs	r5, r0, #0
900024f0:	dd0d      	ble.n	9000250e <psa_import_key+0x54>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_import_key,
900024f2:	2100      	movs	r1, #0
900024f4:	2302      	movs	r3, #2
900024f6:	e9cd 1100 	strd	r1, r1, [sp]
900024fa:	aa03      	add	r2, sp, #12
900024fc:	f000 fba0 	bl	90002c40 <psa_call>
90002500:	4604      	mov	r4, r0
                                    TFM_CRYPTO_IMPORT_KEY);

    PSA_CLOSE();
90002502:	4628      	mov	r0, r5
90002504:	f000 fbb0 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
90002508:	4620      	mov	r0, r4
9000250a:	b015      	add	sp, #84	; 0x54
9000250c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
9000250e:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002512:	e7f9      	b.n	90002508 <psa_import_key+0x4e>

90002514 <psa_destroy_key>:

psa_status_t psa_destroy_key(psa_key_handle_t handle)
{
90002514:	b530      	push	{r4, r5, lr}
90002516:	b093      	sub	sp, #76	; 0x4c
90002518:	4604      	mov	r4, r0
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000251a:	222e      	movs	r2, #46	; 0x2e
9000251c:	2100      	movs	r1, #0
9000251e:	f10d 001a 	add.w	r0, sp, #26
90002522:	f001 f85b 	bl	900035dc <memset>
90002526:	2302      	movs	r3, #2
90002528:	9305      	str	r3, [sp, #20]
        .sfn_id = TFM_CRYPTO_DESTROY_KEY_SID,
        .key_handle = handle,
    };
    psa_invec in_vec[] = {
9000252a:	ab05      	add	r3, sp, #20
9000252c:	9303      	str	r3, [sp, #12]
9000252e:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };

    PSA_CONNECT(TFM_CRYPTO);
90002530:	2101      	movs	r1, #1
90002532:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
90002534:	f8ad 4018 	strh.w	r4, [sp, #24]
    psa_invec in_vec[] = {
90002538:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
9000253a:	f000 fb73 	bl	90002c24 <psa_connect>
9000253e:	1e05      	subs	r5, r0, #0
90002540:	dd0d      	ble.n	9000255e <psa_destroy_key+0x4a>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_destroy_key,
90002542:	2100      	movs	r1, #0
90002544:	2301      	movs	r3, #1
90002546:	e9cd 1100 	strd	r1, r1, [sp]
9000254a:	aa03      	add	r2, sp, #12
9000254c:	f000 fb78 	bl	90002c40 <psa_call>
90002550:	4604      	mov	r4, r0
                                    TFM_CRYPTO_DESTROY_KEY);

    PSA_CLOSE();
90002552:	4628      	mov	r0, r5
90002554:	f000 fb88 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
90002558:	4620      	mov	r0, r4
9000255a:	b013      	add	sp, #76	; 0x4c
9000255c:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
9000255e:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002562:	e7f9      	b.n	90002558 <psa_destroy_key+0x44>

90002564 <psa_get_key_information>:

psa_status_t psa_get_key_information(psa_key_handle_t handle,
                                     psa_key_type_t *type,
                                     size_t *bits)
{
90002564:	b570      	push	{r4, r5, r6, lr}
90002566:	b096      	sub	sp, #88	; 0x58
90002568:	460d      	mov	r5, r1
9000256a:	4606      	mov	r6, r0
9000256c:	4614      	mov	r4, r2
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000256e:	2100      	movs	r1, #0
90002570:	222e      	movs	r2, #46	; 0x2e
90002572:	f10d 002a 	add.w	r0, sp, #42	; 0x2a
90002576:	f001 f831 	bl	900035dc <memset>
9000257a:	2303      	movs	r3, #3
9000257c:	9309      	str	r3, [sp, #36]	; 0x24
        .sfn_id = TFM_CRYPTO_GET_KEY_INFORMATION_SID,
        .key_handle = handle,
    };
    psa_invec in_vec[] = {
9000257e:	ab09      	add	r3, sp, #36	; 0x24
90002580:	9303      	str	r3, [sp, #12]
90002582:	2334      	movs	r3, #52	; 0x34
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
    };
    psa_outvec out_vec[] = {
90002584:	e9cd 3504 	strd	r3, r5, [sp, #16]
90002588:	2304      	movs	r3, #4
        {.base = type, .len = sizeof(psa_key_type_t)},
        {.base = bits, .len = sizeof(size_t)}
    };

    PSA_CONNECT(TFM_CRYPTO);
9000258a:	2101      	movs	r1, #1
9000258c:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
9000258e:	f8ad 6028 	strh.w	r6, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
90002592:	e9cd 3406 	strd	r3, r4, [sp, #24]
90002596:	9308      	str	r3, [sp, #32]
    PSA_CONNECT(TFM_CRYPTO);
90002598:	f000 fb44 	bl	90002c24 <psa_connect>
9000259c:	1e05      	subs	r5, r0, #0
9000259e:	dd0f      	ble.n	900025c0 <psa_get_key_information+0x5c>

    status = API_DISPATCH(tfm_crypto_get_key_information,
900025a0:	2302      	movs	r3, #2
900025a2:	9301      	str	r3, [sp, #4]
900025a4:	ab05      	add	r3, sp, #20
900025a6:	9300      	str	r3, [sp, #0]
900025a8:	aa03      	add	r2, sp, #12
900025aa:	2301      	movs	r3, #1
900025ac:	2100      	movs	r1, #0
900025ae:	f000 fb47 	bl	90002c40 <psa_call>
900025b2:	4604      	mov	r4, r0
                          TFM_CRYPTO_GET_KEY_INFORMATION);

    PSA_CLOSE();
900025b4:	4628      	mov	r0, r5
900025b6:	f000 fb57 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
900025ba:	4620      	mov	r0, r4
900025bc:	b016      	add	sp, #88	; 0x58
900025be:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
900025c0:	f06f 0483 	mvn.w	r4, #131	; 0x83
900025c4:	e7f9      	b.n	900025ba <psa_get_key_information+0x56>

900025c6 <psa_key_policy_set_usage>:
void psa_key_policy_set_usage(psa_key_policy_t *policy,
                              psa_key_usage_t usage,
                              psa_algorithm_t alg)
{
    policy->usage = usage;
    policy->alg = alg;
900025c6:	e9c0 1200 	strd	r1, r2, [r0]
}
900025ca:	4770      	bx	lr

900025cc <psa_set_key_policy>:
    return policy->alg;
}

psa_status_t psa_set_key_policy(psa_key_handle_t handle,
                                const psa_key_policy_t *policy)
{
900025cc:	b530      	push	{r4, r5, lr}
900025ce:	b095      	sub	sp, #84	; 0x54
900025d0:	4605      	mov	r5, r0
900025d2:	460c      	mov	r4, r1
#if (TFM_CRYPTO_KEY_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
900025d4:	222e      	movs	r2, #46	; 0x2e
900025d6:	2100      	movs	r1, #0
900025d8:	f10d 0022 	add.w	r0, sp, #34	; 0x22
900025dc:	f000 fffe 	bl	900035dc <memset>
900025e0:	2307      	movs	r3, #7
900025e2:	9307      	str	r3, [sp, #28]
        .sfn_id = TFM_CRYPTO_SET_KEY_POLICY_SID,
        .key_handle = handle,
    };

    psa_invec in_vec[] = {
900025e4:	ab07      	add	r3, sp, #28
900025e6:	9303      	str	r3, [sp, #12]
900025e8:	2334      	movs	r3, #52	; 0x34
900025ea:	e9cd 3404 	strd	r3, r4, [sp, #16]
900025ee:	230c      	movs	r3, #12
        {.base = &iov, .len = sizeof(struct tfm_crypto_pack_iovec)},
        {.base = policy, .len = sizeof(psa_key_policy_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
900025f0:	2101      	movs	r1, #1
900025f2:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
900025f4:	f8ad 5020 	strh.w	r5, [sp, #32]
    psa_invec in_vec[] = {
900025f8:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
900025fa:	f000 fb13 	bl	90002c24 <psa_connect>
900025fe:	1e05      	subs	r5, r0, #0
90002600:	dd0d      	ble.n	9000261e <psa_set_key_policy+0x52>

    status = API_DISPATCH_NO_OUTVEC(tfm_crypto_set_key_policy,
90002602:	2100      	movs	r1, #0
90002604:	2302      	movs	r3, #2
90002606:	e9cd 1100 	strd	r1, r1, [sp]
9000260a:	aa03      	add	r2, sp, #12
9000260c:	f000 fb18 	bl	90002c40 <psa_call>
90002610:	4604      	mov	r4, r0
                                    TFM_CRYPTO_SET_KEY_POLICY);

    PSA_CLOSE();
90002612:	4628      	mov	r0, r5
90002614:	f000 fb28 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_KEY_MODULE_DISABLED */
}
90002618:	4620      	mov	r0, r4
9000261a:	b015      	add	sp, #84	; 0x54
9000261c:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
9000261e:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002622:	e7f9      	b.n	90002618 <psa_set_key_policy+0x4c>

90002624 <psa_cipher_set_iv>:
}

psa_status_t psa_cipher_set_iv(psa_cipher_operation_t *operation,
                               const unsigned char *iv,
                               size_t iv_length)
{
90002624:	b570      	push	{r4, r5, r6, lr}
90002626:	b096      	sub	sp, #88	; 0x58
90002628:	4604      	mov	r4, r0
9000262a:	4615      	mov	r5, r2
9000262c:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000262e:	2230      	movs	r2, #48	; 0x30
90002630:	2100      	movs	r1, #0
90002632:	a80a      	add	r0, sp, #40	; 0x28
90002634:	f000 ffd2 	bl	900035dc <memset>
90002638:	230b      	movs	r3, #11
9000263a:	9309      	str	r3, [sp, #36]	; 0x24
9000263c:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
9000263e:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
90002640:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
90002642:	ab09      	add	r3, sp, #36	; 0x24
90002644:	9305      	str	r3, [sp, #20]
90002646:	2334      	movs	r3, #52	; 0x34
90002648:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
9000264c:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
9000264e:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
90002650:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
90002652:	9403      	str	r4, [sp, #12]
90002654:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
90002656:	f000 fae5 	bl	90002c24 <psa_connect>
9000265a:	1e05      	subs	r5, r0, #0
9000265c:	dd0f      	ble.n	9000267e <psa_cipher_set_iv+0x5a>

    status = API_DISPATCH(tfm_crypto_cipher_set_iv,
9000265e:	2301      	movs	r3, #1
90002660:	9301      	str	r3, [sp, #4]
90002662:	ab03      	add	r3, sp, #12
90002664:	9300      	str	r3, [sp, #0]
90002666:	aa05      	add	r2, sp, #20
90002668:	2302      	movs	r3, #2
9000266a:	2100      	movs	r1, #0
9000266c:	f000 fae8 	bl	90002c40 <psa_call>
90002670:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_SET_IV);

    PSA_CLOSE();
90002672:	4628      	mov	r0, r5
90002674:	f000 faf8 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
90002678:	4620      	mov	r0, r4
9000267a:	b016      	add	sp, #88	; 0x58
9000267c:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
9000267e:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002682:	e7f9      	b.n	90002678 <psa_cipher_set_iv+0x54>

90002684 <psa_cipher_encrypt_setup>:

psa_status_t psa_cipher_encrypt_setup(psa_cipher_operation_t *operation,
                                      psa_key_handle_t handle,
                                      psa_algorithm_t alg)
{
90002684:	b570      	push	{r4, r5, r6, lr}
90002686:	b094      	sub	sp, #80	; 0x50
90002688:	4604      	mov	r4, r0
9000268a:	4615      	mov	r5, r2
9000268c:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000268e:	222e      	movs	r2, #46	; 0x2e
90002690:	2100      	movs	r1, #0
90002692:	f10d 0022 	add.w	r0, sp, #34	; 0x22
90002696:	f000 ffa1 	bl	900035dc <memset>
9000269a:	230c      	movs	r3, #12
9000269c:	9307      	str	r3, [sp, #28]
9000269e:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
900026a0:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
900026a2:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
900026a4:	ab07      	add	r3, sp, #28
900026a6:	9303      	str	r3, [sp, #12]
900026a8:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
900026aa:	e9cd 3404 	strd	r3, r4, [sp, #16]
900026ae:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
900026b0:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
900026b2:	950b      	str	r5, [sp, #44]	; 0x2c
900026b4:	f8ad 6020 	strh.w	r6, [sp, #32]
    psa_outvec out_vec[] = {
900026b8:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
900026ba:	f000 fab3 	bl	90002c24 <psa_connect>
900026be:	1e05      	subs	r5, r0, #0
900026c0:	dd0e      	ble.n	900026e0 <psa_cipher_encrypt_setup+0x5c>

    status = API_DISPATCH(tfm_crypto_cipher_encrypt_setup,
900026c2:	2301      	movs	r3, #1
900026c4:	aa05      	add	r2, sp, #20
900026c6:	9200      	str	r2, [sp, #0]
900026c8:	9301      	str	r3, [sp, #4]
900026ca:	aa03      	add	r2, sp, #12
900026cc:	2100      	movs	r1, #0
900026ce:	f000 fab7 	bl	90002c40 <psa_call>
900026d2:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_ENCRYPT_SETUP);

    PSA_CLOSE();
900026d4:	4628      	mov	r0, r5
900026d6:	f000 fac7 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
900026da:	4620      	mov	r0, r4
900026dc:	b014      	add	sp, #80	; 0x50
900026de:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
900026e0:	f06f 0483 	mvn.w	r4, #131	; 0x83
900026e4:	e7f9      	b.n	900026da <psa_cipher_encrypt_setup+0x56>

900026e6 <psa_cipher_decrypt_setup>:

psa_status_t psa_cipher_decrypt_setup(psa_cipher_operation_t *operation,
                                      psa_key_handle_t handle,
                                      psa_algorithm_t alg)
{
900026e6:	b570      	push	{r4, r5, r6, lr}
900026e8:	b094      	sub	sp, #80	; 0x50
900026ea:	4604      	mov	r4, r0
900026ec:	4615      	mov	r5, r2
900026ee:	460e      	mov	r6, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
900026f0:	222e      	movs	r2, #46	; 0x2e
900026f2:	2100      	movs	r1, #0
900026f4:	f10d 0022 	add.w	r0, sp, #34	; 0x22
900026f8:	f000 ff70 	bl	900035dc <memset>
900026fc:	230d      	movs	r3, #13
900026fe:	9307      	str	r3, [sp, #28]
90002700:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
90002702:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
90002704:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
90002706:	ab07      	add	r3, sp, #28
90002708:	9303      	str	r3, [sp, #12]
9000270a:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
9000270c:	e9cd 3404 	strd	r3, r4, [sp, #16]
90002710:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
90002712:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
90002714:	950b      	str	r5, [sp, #44]	; 0x2c
90002716:	f8ad 6020 	strh.w	r6, [sp, #32]
    psa_outvec out_vec[] = {
9000271a:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
9000271c:	f000 fa82 	bl	90002c24 <psa_connect>
90002720:	1e05      	subs	r5, r0, #0
90002722:	dd0e      	ble.n	90002742 <psa_cipher_decrypt_setup+0x5c>

    status = API_DISPATCH(tfm_crypto_cipher_decrypt_setup,
90002724:	2301      	movs	r3, #1
90002726:	aa05      	add	r2, sp, #20
90002728:	9200      	str	r2, [sp, #0]
9000272a:	9301      	str	r3, [sp, #4]
9000272c:	aa03      	add	r2, sp, #12
9000272e:	2100      	movs	r1, #0
90002730:	f000 fa86 	bl	90002c40 <psa_call>
90002734:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_DECRYPT_SETUP);

    PSA_CLOSE();
90002736:	4628      	mov	r0, r5
90002738:	f000 fa96 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
9000273c:	4620      	mov	r0, r4
9000273e:	b014      	add	sp, #80	; 0x50
90002740:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
90002742:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002746:	e7f9      	b.n	9000273c <psa_cipher_decrypt_setup+0x56>

90002748 <psa_cipher_update>:
                               const uint8_t *input,
                               size_t input_length,
                               unsigned char *output,
                               size_t output_size,
                               size_t *output_length)
{
90002748:	b5f0      	push	{r4, r5, r6, r7, lr}
9000274a:	4616      	mov	r6, r2
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000274c:	2230      	movs	r2, #48	; 0x30
{
9000274e:	b099      	sub	sp, #100	; 0x64
90002750:	4604      	mov	r4, r0
90002752:	460f      	mov	r7, r1
    struct tfm_crypto_pack_iovec iov = {
90002754:	eb0d 0002 	add.w	r0, sp, r2
90002758:	2100      	movs	r1, #0
{
9000275a:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
9000275c:	f000 ff3e 	bl	900035dc <memset>
90002760:	230e      	movs	r3, #14
90002762:	930b      	str	r3, [sp, #44]	; 0x2c
90002764:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = output, .len = output_size}
    };

    PSA_CONNECT(TFM_CRYPTO);
90002766:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
90002768:	9311      	str	r3, [sp, #68]	; 0x44
    psa_invec in_vec[] = {
9000276a:	ab0b      	add	r3, sp, #44	; 0x2c
9000276c:	9303      	str	r3, [sp, #12]
9000276e:	2334      	movs	r3, #52	; 0x34
90002770:	e9cd 3704 	strd	r3, r7, [sp, #16]
    psa_outvec out_vec[] = {
90002774:	2304      	movs	r3, #4
90002776:	e9cd 3508 	strd	r3, r5, [sp, #32]
9000277a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    PSA_CONNECT(TFM_CRYPTO);
9000277c:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
9000277e:	e9cd 6406 	strd	r6, r4, [sp, #24]
90002782:	930a      	str	r3, [sp, #40]	; 0x28
    PSA_CONNECT(TFM_CRYPTO);
90002784:	f000 fa4e 	bl	90002c24 <psa_connect>
90002788:	1e05      	subs	r5, r0, #0
9000278a:	dd11      	ble.n	900027b0 <psa_cipher_update+0x68>

    status = API_DISPATCH(tfm_crypto_cipher_update,
9000278c:	2302      	movs	r3, #2
9000278e:	aa07      	add	r2, sp, #28
90002790:	9301      	str	r3, [sp, #4]
90002792:	9200      	str	r2, [sp, #0]
90002794:	2100      	movs	r1, #0
90002796:	aa03      	add	r2, sp, #12
90002798:	f000 fa52 	bl	90002c40 <psa_call>
                          TFM_CRYPTO_CIPHER_UPDATE);

    *output_length = out_vec[1].len;
9000279c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
9000279e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    status = API_DISPATCH(tfm_crypto_cipher_update,
900027a0:	4604      	mov	r4, r0
    *output_length = out_vec[1].len;
900027a2:	601a      	str	r2, [r3, #0]

    PSA_CLOSE();
900027a4:	4628      	mov	r0, r5
900027a6:	f000 fa5f 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
900027aa:	4620      	mov	r0, r4
900027ac:	b019      	add	sp, #100	; 0x64
900027ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
900027b0:	f06f 0483 	mvn.w	r4, #131	; 0x83
900027b4:	e7f9      	b.n	900027aa <psa_cipher_update+0x62>

900027b6 <psa_cipher_abort>:

psa_status_t psa_cipher_abort(psa_cipher_operation_t *operation)
{
900027b6:	b530      	push	{r4, r5, lr}
900027b8:	b095      	sub	sp, #84	; 0x54
900027ba:	4604      	mov	r4, r0
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
900027bc:	2230      	movs	r2, #48	; 0x30
900027be:	2100      	movs	r1, #0
900027c0:	a808      	add	r0, sp, #32
900027c2:	f000 ff0b 	bl	900035dc <memset>
900027c6:	230f      	movs	r3, #15
900027c8:	9307      	str	r3, [sp, #28]
900027ca:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
900027cc:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
900027ce:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
900027d0:	ab07      	add	r3, sp, #28
900027d2:	9303      	str	r3, [sp, #12]
900027d4:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
900027d6:	e9cd 3404 	strd	r3, r4, [sp, #16]
900027da:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
900027dc:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
900027de:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
900027e0:	f000 fa20 	bl	90002c24 <psa_connect>
900027e4:	1e05      	subs	r5, r0, #0
900027e6:	dd0e      	ble.n	90002806 <psa_cipher_abort+0x50>

    status = API_DISPATCH(tfm_crypto_cipher_abort,
900027e8:	2301      	movs	r3, #1
900027ea:	aa05      	add	r2, sp, #20
900027ec:	9200      	str	r2, [sp, #0]
900027ee:	9301      	str	r3, [sp, #4]
900027f0:	aa03      	add	r2, sp, #12
900027f2:	2100      	movs	r1, #0
900027f4:	f000 fa24 	bl	90002c40 <psa_call>
900027f8:	4604      	mov	r4, r0
                          TFM_CRYPTO_CIPHER_ABORT);

    PSA_CLOSE();
900027fa:	4628      	mov	r0, r5
900027fc:	f000 fa34 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
90002800:	4620      	mov	r0, r4
90002802:	b015      	add	sp, #84	; 0x54
90002804:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
90002806:	f06f 0483 	mvn.w	r4, #131	; 0x83
9000280a:	e7f9      	b.n	90002800 <psa_cipher_abort+0x4a>

9000280c <psa_cipher_finish>:

psa_status_t psa_cipher_finish(psa_cipher_operation_t *operation,
                               uint8_t *output,
                               size_t output_size,
                               size_t *output_length)
{
9000280c:	b5f0      	push	{r4, r5, r6, r7, lr}
9000280e:	b097      	sub	sp, #92	; 0x5c
90002810:	4604      	mov	r4, r0
90002812:	4615      	mov	r5, r2
90002814:	460f      	mov	r7, r1
#if (TFM_CRYPTO_CIPHER_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
90002816:	2230      	movs	r2, #48	; 0x30
90002818:	2100      	movs	r1, #0
9000281a:	a80a      	add	r0, sp, #40	; 0x28
{
9000281c:	461e      	mov	r6, r3
    struct tfm_crypto_pack_iovec iov = {
9000281e:	f000 fedd 	bl	900035dc <memset>
90002822:	2310      	movs	r3, #16
90002824:	9309      	str	r3, [sp, #36]	; 0x24
90002826:	6823      	ldr	r3, [r4, #0]
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
        {.base = output, .len = output_size},
    };

    PSA_CONNECT(TFM_CRYPTO);
90002828:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
9000282a:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
9000282c:	ab09      	add	r3, sp, #36	; 0x24
9000282e:	9303      	str	r3, [sp, #12]
90002830:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
90002832:	e9cd 3404 	strd	r3, r4, [sp, #16]
90002836:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
90002838:	2080      	movs	r0, #128	; 0x80
    psa_outvec out_vec[] = {
9000283a:	9508      	str	r5, [sp, #32]
9000283c:	e9cd 3706 	strd	r3, r7, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
90002840:	f000 f9f0 	bl	90002c24 <psa_connect>
90002844:	1e05      	subs	r5, r0, #0
90002846:	dd11      	ble.n	9000286c <psa_cipher_finish+0x60>

    status = API_DISPATCH(tfm_crypto_cipher_finish,
90002848:	2302      	movs	r3, #2
9000284a:	9301      	str	r3, [sp, #4]
9000284c:	ab05      	add	r3, sp, #20
9000284e:	9300      	str	r3, [sp, #0]
90002850:	aa03      	add	r2, sp, #12
90002852:	2301      	movs	r3, #1
90002854:	2100      	movs	r1, #0
90002856:	f000 f9f3 	bl	90002c40 <psa_call>
                          TFM_CRYPTO_CIPHER_FINISH);

    *output_length = out_vec[1].len;
9000285a:	9b08      	ldr	r3, [sp, #32]
    status = API_DISPATCH(tfm_crypto_cipher_finish,
9000285c:	4604      	mov	r4, r0
    *output_length = out_vec[1].len;
9000285e:	6033      	str	r3, [r6, #0]

    PSA_CLOSE();
90002860:	4628      	mov	r0, r5
90002862:	f000 fa01 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_CIPHER_MODULE_DISABLED */
}
90002866:	4620      	mov	r0, r4
90002868:	b017      	add	sp, #92	; 0x5c
9000286a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PSA_CONNECT(TFM_CRYPTO);
9000286c:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002870:	e7f9      	b.n	90002866 <psa_cipher_finish+0x5a>

90002872 <psa_hash_setup>:

psa_status_t psa_hash_setup(psa_hash_operation_t *operation,
                            psa_algorithm_t alg)
{
90002872:	b530      	push	{r4, r5, lr}
90002874:	b095      	sub	sp, #84	; 0x54
90002876:	4604      	mov	r4, r0
90002878:	460d      	mov	r5, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000287a:	2230      	movs	r2, #48	; 0x30
9000287c:	2100      	movs	r1, #0
9000287e:	a808      	add	r0, sp, #32
90002880:	f000 feac 	bl	900035dc <memset>
90002884:	2311      	movs	r3, #17
90002886:	9307      	str	r3, [sp, #28]
90002888:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
9000288a:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
9000288c:	930d      	str	r3, [sp, #52]	; 0x34
    psa_invec in_vec[] = {
9000288e:	ab07      	add	r3, sp, #28
90002890:	9303      	str	r3, [sp, #12]
90002892:	2334      	movs	r3, #52	; 0x34
    psa_outvec out_vec[] = {
90002894:	e9cd 3404 	strd	r3, r4, [sp, #16]
90002898:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
9000289a:	2080      	movs	r0, #128	; 0x80
    struct tfm_crypto_pack_iovec iov = {
9000289c:	950b      	str	r5, [sp, #44]	; 0x2c
    psa_outvec out_vec[] = {
9000289e:	9306      	str	r3, [sp, #24]
    PSA_CONNECT(TFM_CRYPTO);
900028a0:	f000 f9c0 	bl	90002c24 <psa_connect>
900028a4:	1e05      	subs	r5, r0, #0
900028a6:	dd0e      	ble.n	900028c6 <psa_hash_setup+0x54>

    status = API_DISPATCH(tfm_crypto_hash_setup,
900028a8:	2301      	movs	r3, #1
900028aa:	aa05      	add	r2, sp, #20
900028ac:	9200      	str	r2, [sp, #0]
900028ae:	9301      	str	r3, [sp, #4]
900028b0:	aa03      	add	r2, sp, #12
900028b2:	2100      	movs	r1, #0
900028b4:	f000 f9c4 	bl	90002c40 <psa_call>
900028b8:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_SETUP);

    PSA_CLOSE();
900028ba:	4628      	mov	r0, r5
900028bc:	f000 f9d4 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
900028c0:	4620      	mov	r0, r4
900028c2:	b015      	add	sp, #84	; 0x54
900028c4:	bd30      	pop	{r4, r5, pc}
    PSA_CONNECT(TFM_CRYPTO);
900028c6:	f06f 0483 	mvn.w	r4, #131	; 0x83
900028ca:	e7f9      	b.n	900028c0 <psa_hash_setup+0x4e>

900028cc <psa_hash_update>:

psa_status_t psa_hash_update(psa_hash_operation_t *operation,
                             const uint8_t *input,
                             size_t input_length)
{
900028cc:	b570      	push	{r4, r5, r6, lr}
900028ce:	b096      	sub	sp, #88	; 0x58
900028d0:	4604      	mov	r4, r0
900028d2:	4615      	mov	r5, r2
900028d4:	460e      	mov	r6, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
900028d6:	2230      	movs	r2, #48	; 0x30
900028d8:	2100      	movs	r1, #0
900028da:	a80a      	add	r0, sp, #40	; 0x28
900028dc:	f000 fe7e 	bl	900035dc <memset>
900028e0:	2312      	movs	r3, #18
900028e2:	9309      	str	r3, [sp, #36]	; 0x24
900028e4:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
900028e6:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
900028e8:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
900028ea:	ab09      	add	r3, sp, #36	; 0x24
900028ec:	9305      	str	r3, [sp, #20]
900028ee:	2334      	movs	r3, #52	; 0x34
900028f0:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
900028f4:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
900028f6:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
900028f8:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
900028fa:	9403      	str	r4, [sp, #12]
900028fc:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
900028fe:	f000 f991 	bl	90002c24 <psa_connect>
90002902:	1e05      	subs	r5, r0, #0
90002904:	dd0f      	ble.n	90002926 <psa_hash_update+0x5a>

    status = API_DISPATCH(tfm_crypto_hash_update,
90002906:	2301      	movs	r3, #1
90002908:	9301      	str	r3, [sp, #4]
9000290a:	ab03      	add	r3, sp, #12
9000290c:	9300      	str	r3, [sp, #0]
9000290e:	aa05      	add	r2, sp, #20
90002910:	2302      	movs	r3, #2
90002912:	2100      	movs	r1, #0
90002914:	f000 f994 	bl	90002c40 <psa_call>
90002918:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_UPDATE);

    PSA_CLOSE();
9000291a:	4628      	mov	r0, r5
9000291c:	f000 f9a4 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
90002920:	4620      	mov	r0, r4
90002922:	b016      	add	sp, #88	; 0x58
90002924:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
90002926:	f06f 0483 	mvn.w	r4, #131	; 0x83
9000292a:	e7f9      	b.n	90002920 <psa_hash_update+0x54>

9000292c <psa_hash_verify>:
}

psa_status_t psa_hash_verify(psa_hash_operation_t *operation,
                             const uint8_t *hash,
                             size_t hash_length)
{
9000292c:	b570      	push	{r4, r5, r6, lr}
9000292e:	b096      	sub	sp, #88	; 0x58
90002930:	4604      	mov	r4, r0
90002932:	4615      	mov	r5, r2
90002934:	460e      	mov	r6, r1
#if (TFM_CRYPTO_HASH_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
90002936:	2230      	movs	r2, #48	; 0x30
90002938:	2100      	movs	r1, #0
9000293a:	a80a      	add	r0, sp, #40	; 0x28
9000293c:	f000 fe4e 	bl	900035dc <memset>
90002940:	2314      	movs	r3, #20
90002942:	9309      	str	r3, [sp, #36]	; 0x24
90002944:	6823      	ldr	r3, [r4, #0]
    };
    psa_outvec out_vec[] = {
        {.base = &(operation->handle), .len = sizeof(uint32_t)},
    };

    PSA_CONNECT(TFM_CRYPTO);
90002946:	2101      	movs	r1, #1
    struct tfm_crypto_pack_iovec iov = {
90002948:	930f      	str	r3, [sp, #60]	; 0x3c
    psa_invec in_vec[] = {
9000294a:	ab09      	add	r3, sp, #36	; 0x24
9000294c:	9305      	str	r3, [sp, #20]
9000294e:	2334      	movs	r3, #52	; 0x34
90002950:	e9cd 3606 	strd	r3, r6, [sp, #24]
    psa_outvec out_vec[] = {
90002954:	2304      	movs	r3, #4
    PSA_CONNECT(TFM_CRYPTO);
90002956:	2080      	movs	r0, #128	; 0x80
    psa_invec in_vec[] = {
90002958:	9508      	str	r5, [sp, #32]
    psa_outvec out_vec[] = {
9000295a:	9403      	str	r4, [sp, #12]
9000295c:	9304      	str	r3, [sp, #16]
    PSA_CONNECT(TFM_CRYPTO);
9000295e:	f000 f961 	bl	90002c24 <psa_connect>
90002962:	1e05      	subs	r5, r0, #0
90002964:	dd0f      	ble.n	90002986 <psa_hash_verify+0x5a>

    status = API_DISPATCH(tfm_crypto_hash_verify,
90002966:	2301      	movs	r3, #1
90002968:	9301      	str	r3, [sp, #4]
9000296a:	ab03      	add	r3, sp, #12
9000296c:	9300      	str	r3, [sp, #0]
9000296e:	aa05      	add	r2, sp, #20
90002970:	2302      	movs	r3, #2
90002972:	2100      	movs	r1, #0
90002974:	f000 f964 	bl	90002c40 <psa_call>
90002978:	4604      	mov	r4, r0
                          TFM_CRYPTO_HASH_VERIFY);

    PSA_CLOSE();
9000297a:	4628      	mov	r0, r5
9000297c:	f000 f974 	bl	90002c68 <psa_close>

    return status;
#endif /* TFM_CRYPTO_HASH_MODULE_DISABLED */
}
90002980:	4620      	mov	r0, r4
90002982:	b016      	add	sp, #88	; 0x58
90002984:	bd70      	pop	{r4, r5, r6, pc}
    PSA_CONNECT(TFM_CRYPTO);
90002986:	f06f 0483 	mvn.w	r4, #131	; 0x83
9000298a:	e7f9      	b.n	90002980 <psa_hash_verify+0x54>

9000298c <psa_aead_encrypt>:
                              const uint8_t *plaintext,
                              size_t plaintext_length,
                              uint8_t *ciphertext,
                              size_t ciphertext_size,
                              size_t *ciphertext_length)
{
9000298c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
90002990:	b099      	sub	sp, #100	; 0x64
90002992:	4681      	mov	r9, r0
90002994:	e9dd 4720 	ldrd	r4, r7, [sp, #128]	; 0x80
90002998:	4688      	mov	r8, r1
9000299a:	4616      	mov	r6, r2
#if (TFM_CRYPTO_AEAD_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
9000299c:	2100      	movs	r1, #0
9000299e:	222a      	movs	r2, #42	; 0x2a
900029a0:	f10d 0032 	add.w	r0, sp, #50	; 0x32
{
900029a4:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
900029a6:	f000 fe19 	bl	900035dc <memset>
900029aa:	231d      	movs	r3, #29
900029ac:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
900029b0:	930b      	str	r3, [sp, #44]	; 0x2c
900029b2:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
900029b6:	9517      	str	r5, [sp, #92]	; 0x5c
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
900029b8:	b934      	cbnz	r4, 900029c8 <psa_aead_encrypt+0x3c>
900029ba:	b12f      	cbz	r7, 900029c8 <psa_aead_encrypt+0x3c>
        return PSA_ERROR_INVALID_ARGUMENT;
900029bc:	f06f 0486 	mvn.w	r4, #134	; 0x86

    PSA_CLOSE();

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
900029c0:	4620      	mov	r0, r4
900029c2:	b019      	add	sp, #100	; 0x64
900029c4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
900029c8:	2234      	movs	r2, #52	; 0x34
900029ca:	9206      	str	r2, [sp, #24]
900029cc:	9a22      	ldr	r2, [sp, #136]	; 0x88
900029ce:	ab0b      	add	r3, sp, #44	; 0x2c
900029d0:	9207      	str	r2, [sp, #28]
900029d2:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
900029d4:	2d10      	cmp	r5, #16
    psa_invec in_vec[] = {
900029d6:	e9cd 2408 	strd	r2, r4, [sp, #32]
    psa_outvec out_vec[] = {
900029da:	9a24      	ldr	r2, [sp, #144]	; 0x90
    psa_invec in_vec[] = {
900029dc:	9305      	str	r3, [sp, #20]
    psa_outvec out_vec[] = {
900029de:	9203      	str	r2, [sp, #12]
900029e0:	9a25      	ldr	r2, [sp, #148]	; 0x94
    psa_invec in_vec[] = {
900029e2:	970a      	str	r7, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
900029e4:	9204      	str	r2, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
900029e6:	d8e9      	bhi.n	900029bc <psa_aead_encrypt+0x30>
    if (nonce != NULL) {
900029e8:	b986      	cbnz	r6, 90002a0c <psa_aead_encrypt+0x80>
    PSA_CONNECT(TFM_CRYPTO);
900029ea:	2101      	movs	r1, #1
900029ec:	2080      	movs	r0, #128	; 0x80
900029ee:	f000 f919 	bl	90002c24 <psa_connect>
900029f2:	1e05      	subs	r5, r0, #0
900029f4:	dc0c      	bgt.n	90002a10 <psa_aead_encrypt+0x84>
900029f6:	f06f 0483 	mvn.w	r4, #131	; 0x83
900029fa:	e7e1      	b.n	900029c0 <psa_aead_encrypt+0x34>
            iov.aead_in.nonce[idx] = nonce[idx];
900029fc:	5cb0      	ldrb	r0, [r6, r2]
900029fe:	1899      	adds	r1, r3, r2
90002a00:	f881 0020 	strb.w	r0, [r1, #32]
        for (idx = 0; idx < nonce_length; idx++) {
90002a04:	3201      	adds	r2, #1
90002a06:	42aa      	cmp	r2, r5
90002a08:	d1f8      	bne.n	900029fc <psa_aead_encrypt+0x70>
90002a0a:	e7ee      	b.n	900029ea <psa_aead_encrypt+0x5e>
90002a0c:	2200      	movs	r2, #0
90002a0e:	e7fa      	b.n	90002a06 <psa_aead_encrypt+0x7a>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
90002a10:	2301      	movs	r3, #1
        in_len--;
90002a12:	2c00      	cmp	r4, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
90002a14:	9301      	str	r3, [sp, #4]
90002a16:	ab03      	add	r3, sp, #12
90002a18:	9300      	str	r3, [sp, #0]
90002a1a:	aa05      	add	r2, sp, #20
90002a1c:	bf14      	ite	ne
90002a1e:	2303      	movne	r3, #3
90002a20:	2302      	moveq	r3, #2
90002a22:	2100      	movs	r1, #0
90002a24:	f000 f90c 	bl	90002c40 <psa_call>
    *ciphertext_length = out_vec[0].len;
90002a28:	9b26      	ldr	r3, [sp, #152]	; 0x98
90002a2a:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
90002a2c:	4604      	mov	r4, r0
    *ciphertext_length = out_vec[0].len;
90002a2e:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
90002a30:	4628      	mov	r0, r5
90002a32:	f000 f919 	bl	90002c68 <psa_close>
    return status;
90002a36:	e7c3      	b.n	900029c0 <psa_aead_encrypt+0x34>

90002a38 <psa_aead_decrypt>:
                              const uint8_t *ciphertext,
                              size_t ciphertext_length,
                              uint8_t *plaintext,
                              size_t plaintext_size,
                              size_t *plaintext_length)
{
90002a38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
90002a3c:	b099      	sub	sp, #100	; 0x64
90002a3e:	4681      	mov	r9, r0
90002a40:	e9dd 4720 	ldrd	r4, r7, [sp, #128]	; 0x80
90002a44:	4688      	mov	r8, r1
90002a46:	4616      	mov	r6, r2
#if (TFM_CRYPTO_AEAD_MODULE_DISABLED != 0)
    return PSA_ERROR_NOT_SUPPORTED;
#else
    psa_status_t status;
    struct tfm_crypto_pack_iovec iov = {
90002a48:	2100      	movs	r1, #0
90002a4a:	222a      	movs	r2, #42	; 0x2a
90002a4c:	f10d 0032 	add.w	r0, sp, #50	; 0x32
{
90002a50:	461d      	mov	r5, r3
    struct tfm_crypto_pack_iovec iov = {
90002a52:	f000 fdc3 	bl	900035dc <memset>
90002a56:	231e      	movs	r3, #30
90002a58:	f8ad 9030 	strh.w	r9, [sp, #48]	; 0x30
90002a5c:	930b      	str	r3, [sp, #44]	; 0x2c
90002a5e:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
90002a62:	9517      	str	r5, [sp, #92]	; 0x5c
        .alg = alg,
        .aead_in = {.nonce = {0}, .nonce_length = nonce_length}
    };

    /* Sanitize the optional input */
    if ((additional_data == NULL) && (additional_data_length != 0)) {
90002a64:	b934      	cbnz	r4, 90002a74 <psa_aead_decrypt+0x3c>
90002a66:	b12f      	cbz	r7, 90002a74 <psa_aead_decrypt+0x3c>
        return PSA_ERROR_INVALID_ARGUMENT;
90002a68:	f06f 0486 	mvn.w	r4, #134	; 0x86

    PSA_CLOSE();

    return status;
#endif /* TFM_CRYPTO_AEAD_MODULE_DISABLED */
}
90002a6c:	4620      	mov	r0, r4
90002a6e:	b019      	add	sp, #100	; 0x64
90002a70:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    psa_invec in_vec[] = {
90002a74:	2234      	movs	r2, #52	; 0x34
90002a76:	9206      	str	r2, [sp, #24]
90002a78:	9a22      	ldr	r2, [sp, #136]	; 0x88
90002a7a:	ab0b      	add	r3, sp, #44	; 0x2c
90002a7c:	9207      	str	r2, [sp, #28]
90002a7e:	9a23      	ldr	r2, [sp, #140]	; 0x8c
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
90002a80:	2d10      	cmp	r5, #16
    psa_invec in_vec[] = {
90002a82:	e9cd 2408 	strd	r2, r4, [sp, #32]
    psa_outvec out_vec[] = {
90002a86:	9a24      	ldr	r2, [sp, #144]	; 0x90
    psa_invec in_vec[] = {
90002a88:	9305      	str	r3, [sp, #20]
    psa_outvec out_vec[] = {
90002a8a:	9203      	str	r2, [sp, #12]
90002a8c:	9a25      	ldr	r2, [sp, #148]	; 0x94
    psa_invec in_vec[] = {
90002a8e:	970a      	str	r7, [sp, #40]	; 0x28
    psa_outvec out_vec[] = {
90002a90:	9204      	str	r2, [sp, #16]
    if (nonce_length > TFM_CRYPTO_MAX_NONCE_LENGTH) {
90002a92:	d8e9      	bhi.n	90002a68 <psa_aead_decrypt+0x30>
    if (nonce != NULL) {
90002a94:	b986      	cbnz	r6, 90002ab8 <psa_aead_decrypt+0x80>
    PSA_CONNECT(TFM_CRYPTO);
90002a96:	2101      	movs	r1, #1
90002a98:	2080      	movs	r0, #128	; 0x80
90002a9a:	f000 f8c3 	bl	90002c24 <psa_connect>
90002a9e:	1e05      	subs	r5, r0, #0
90002aa0:	dc0c      	bgt.n	90002abc <psa_aead_decrypt+0x84>
90002aa2:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002aa6:	e7e1      	b.n	90002a6c <psa_aead_decrypt+0x34>
            iov.aead_in.nonce[idx] = nonce[idx];
90002aa8:	5cb0      	ldrb	r0, [r6, r2]
90002aaa:	1899      	adds	r1, r3, r2
90002aac:	f881 0020 	strb.w	r0, [r1, #32]
        for (idx = 0; idx < nonce_length; idx++) {
90002ab0:	3201      	adds	r2, #1
90002ab2:	42aa      	cmp	r2, r5
90002ab4:	d1f8      	bne.n	90002aa8 <psa_aead_decrypt+0x70>
90002ab6:	e7ee      	b.n	90002a96 <psa_aead_decrypt+0x5e>
90002ab8:	2200      	movs	r2, #0
90002aba:	e7fa      	b.n	90002ab2 <psa_aead_decrypt+0x7a>
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
90002abc:	2301      	movs	r3, #1
        in_len--;
90002abe:	2c00      	cmp	r4, #0
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
90002ac0:	9301      	str	r3, [sp, #4]
90002ac2:	ab03      	add	r3, sp, #12
90002ac4:	9300      	str	r3, [sp, #0]
90002ac6:	aa05      	add	r2, sp, #20
90002ac8:	bf14      	ite	ne
90002aca:	2303      	movne	r3, #3
90002acc:	2302      	moveq	r3, #2
90002ace:	2100      	movs	r1, #0
90002ad0:	f000 f8b6 	bl	90002c40 <psa_call>
    *plaintext_length = out_vec[0].len;
90002ad4:	9b26      	ldr	r3, [sp, #152]	; 0x98
90002ad6:	9a04      	ldr	r2, [sp, #16]
    status = psa_call(ipc_handle, PSA_IPC_CALL, in_vec, in_len,
90002ad8:	4604      	mov	r4, r0
    *plaintext_length = out_vec[0].len;
90002ada:	601a      	str	r2, [r3, #0]
    PSA_CLOSE();
90002adc:	4628      	mov	r0, r5
90002ade:	f000 f8c3 	bl	90002c68 <psa_close>
    return status;
90002ae2:	e7c3      	b.n	90002a6c <psa_aead_decrypt+0x34>

90002ae4 <psa_initial_attest_get_token>:
enum psa_attest_err_t
psa_initial_attest_get_token(const uint8_t *challenge_obj,
                             uint32_t       challenge_size,
                             uint8_t       *token,
                             uint32_t      *token_size)
{
90002ae4:	b570      	push	{r4, r5, r6, lr}
90002ae6:	461d      	mov	r5, r3
90002ae8:	b086      	sub	sp, #24
    psa_status_t status;

    psa_invec in_vec[] = {
        {challenge_obj, challenge_size}
    };
    psa_outvec out_vec[] = {
90002aea:	681b      	ldr	r3, [r3, #0]
    psa_invec in_vec[] = {
90002aec:	e9cd 0102 	strd	r0, r1, [sp, #8]
        {token, *token_size}
    };

    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
90002af0:	2101      	movs	r1, #1
90002af2:	2020      	movs	r0, #32
    psa_outvec out_vec[] = {
90002af4:	9204      	str	r2, [sp, #16]
90002af6:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ATTEST_GET_TOKEN_SID,
90002af8:	f000 f894 	bl	90002c24 <psa_connect>
                         TFM_ATTEST_GET_TOKEN_VERSION);
    if (handle <= 0) {
90002afc:	1e06      	subs	r6, r0, #0
90002afe:	dc02      	bgt.n	90002b06 <psa_initial_attest_get_token+0x22>
        return PSA_ATTEST_ERR_GENERAL;
90002b00:	2005      	movs	r0, #5
    if (status == PSA_SUCCESS) {
        *token_size = out_vec[0].len;
    }

    return (enum psa_attest_err_t)status;
}
90002b02:	b006      	add	sp, #24
90002b04:	bd70      	pop	{r4, r5, r6, pc}
    status = psa_call(handle, PSA_IPC_CALL,
90002b06:	2301      	movs	r3, #1
90002b08:	aa04      	add	r2, sp, #16
90002b0a:	9301      	str	r3, [sp, #4]
90002b0c:	9200      	str	r2, [sp, #0]
90002b0e:	2100      	movs	r1, #0
90002b10:	aa02      	add	r2, sp, #8
90002b12:	f000 f895 	bl	90002c40 <psa_call>
90002b16:	4604      	mov	r4, r0
    psa_close(handle);
90002b18:	4630      	mov	r0, r6
90002b1a:	f000 f8a5 	bl	90002c68 <psa_close>
    if (status < PSA_SUCCESS) {
90002b1e:	2c00      	cmp	r4, #0
90002b20:	dbee      	blt.n	90002b00 <psa_initial_attest_get_token+0x1c>
        *token_size = out_vec[0].len;
90002b22:	bf08      	it	eq
90002b24:	9b05      	ldreq	r3, [sp, #20]
    return (enum psa_attest_err_t)status;
90002b26:	4620      	mov	r0, r4
        *token_size = out_vec[0].len;
90002b28:	bf08      	it	eq
90002b2a:	602b      	streq	r3, [r5, #0]
    return (enum psa_attest_err_t)status;
90002b2c:	e7e9      	b.n	90002b02 <psa_initial_attest_get_token+0x1e>

90002b2e <psa_its_set>:

psa_status_t psa_its_set(psa_storage_uid_t uid,
                         size_t data_length,
                         const void *p_data,
                         psa_storage_create_flags_t create_flags)
{
90002b2e:	b530      	push	{r4, r5, lr}
90002b30:	b08b      	sub	sp, #44	; 0x2c
90002b32:	ac0a      	add	r4, sp, #40	; 0x28
90002b34:	e964 0108 	strd	r0, r1, [r4, #-32]!
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
90002b38:	2108      	movs	r1, #8
90002b3a:	e9cd 1305 	strd	r1, r3, [sp, #20]
90002b3e:	ab0e      	add	r3, sp, #56	; 0x38
90002b40:	9308      	str	r3, [sp, #32]
90002b42:	2304      	movs	r3, #4
        { .base = &uid, .len = sizeof(uid) },
        { .base = p_data, .len = data_length },
        { .base = &create_flags, .len = sizeof(create_flags) }
    };

    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
90002b44:	2101      	movs	r1, #1
90002b46:	2070      	movs	r0, #112	; 0x70
    psa_invec in_vec[] = {
90002b48:	9404      	str	r4, [sp, #16]
90002b4a:	9207      	str	r2, [sp, #28]
90002b4c:	9309      	str	r3, [sp, #36]	; 0x24
    handle = psa_connect(TFM_ITS_SET_SID, TFM_ITS_SET_VERSION);
90002b4e:	f000 f869 	bl	90002c24 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
90002b52:	1e05      	subs	r5, r0, #0
90002b54:	dd11      	ble.n	90002b7a <psa_its_set+0x4c>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
90002b56:	2100      	movs	r1, #0
90002b58:	2303      	movs	r3, #3
90002b5a:	e9cd 1100 	strd	r1, r1, [sp]
90002b5e:	aa04      	add	r2, sp, #16
90002b60:	f000 f86e 	bl	90002c40 <psa_call>
90002b64:	4604      	mov	r4, r0

    psa_close(handle);
90002b66:	4628      	mov	r0, r5
90002b68:	f000 f87e 	bl	90002c68 <psa_close>

    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
        return PSA_ERROR_INVALID_ARGUMENT;
90002b6c:	2c03      	cmp	r4, #3
90002b6e:	bf08      	it	eq
90002b70:	f06f 0486 	mvneq.w	r4, #134	; 0x86
    }

    return status;
}
90002b74:	4620      	mov	r0, r4
90002b76:	b00b      	add	sp, #44	; 0x2c
90002b78:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
90002b7a:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002b7e:	e7f9      	b.n	90002b74 <psa_its_set+0x46>

90002b80 <psa_its_get>:
psa_status_t psa_its_get(psa_storage_uid_t uid,
                         size_t data_offset,
                         size_t data_size,
                         void *p_data,
                         size_t *p_data_length)
{
90002b80:	b570      	push	{r4, r5, r6, lr}
90002b82:	b08c      	sub	sp, #48	; 0x30
90002b84:	9203      	str	r2, [sp, #12]
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
90002b86:	aa04      	add	r2, sp, #16
90002b88:	9208      	str	r2, [sp, #32]
90002b8a:	2208      	movs	r2, #8
90002b8c:	9209      	str	r2, [sp, #36]	; 0x24
90002b8e:	aa03      	add	r2, sp, #12
90002b90:	920a      	str	r2, [sp, #40]	; 0x28
90002b92:	2204      	movs	r2, #4
{
90002b94:	9d11      	ldr	r5, [sp, #68]	; 0x44
    psa_invec in_vec[] = {
90002b96:	920b      	str	r2, [sp, #44]	; 0x2c
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
90002b98:	9a10      	ldr	r2, [sp, #64]	; 0x40
{
90002b9a:	e9cd 0104 	strd	r0, r1, [sp, #16]
    psa_outvec out_vec[] = {
90002b9e:	e9cd 2306 	strd	r2, r3, [sp, #24]
        { .base = p_data, .len = data_size }
    };

    if (p_data_length == NULL) {
90002ba2:	b925      	cbnz	r5, 90002bae <psa_its_get+0x2e>
        return PSA_ERROR_INVALID_ARGUMENT;
90002ba4:	f06f 0486 	mvn.w	r4, #134	; 0x86
    }

    *p_data_length = out_vec[0].len;

    return status;
}
90002ba8:	4620      	mov	r0, r4
90002baa:	b00c      	add	sp, #48	; 0x30
90002bac:	bd70      	pop	{r4, r5, r6, pc}
    handle = psa_connect(TFM_ITS_GET_SID, TFM_ITS_GET_VERSION);
90002bae:	2101      	movs	r1, #1
90002bb0:	2071      	movs	r0, #113	; 0x71
90002bb2:	f000 f837 	bl	90002c24 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
90002bb6:	1e06      	subs	r6, r0, #0
90002bb8:	dd11      	ble.n	90002bde <psa_its_get+0x5e>
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
90002bba:	2301      	movs	r3, #1
90002bbc:	9301      	str	r3, [sp, #4]
90002bbe:	ab06      	add	r3, sp, #24
90002bc0:	9300      	str	r3, [sp, #0]
90002bc2:	aa08      	add	r2, sp, #32
90002bc4:	2302      	movs	r3, #2
90002bc6:	2100      	movs	r1, #0
90002bc8:	f000 f83a 	bl	90002c40 <psa_call>
90002bcc:	4604      	mov	r4, r0
    psa_close(handle);
90002bce:	4630      	mov	r0, r6
90002bd0:	f000 f84a 	bl	90002c68 <psa_close>
    if (status == (psa_status_t)TFM_ERROR_INVALID_PARAMETER) {
90002bd4:	2c03      	cmp	r4, #3
90002bd6:	d0e5      	beq.n	90002ba4 <psa_its_get+0x24>
    *p_data_length = out_vec[0].len;
90002bd8:	9b07      	ldr	r3, [sp, #28]
90002bda:	602b      	str	r3, [r5, #0]
    return status;
90002bdc:	e7e4      	b.n	90002ba8 <psa_its_get+0x28>
        return PSA_ERROR_GENERIC_ERROR;
90002bde:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002be2:	e7e1      	b.n	90002ba8 <psa_its_get+0x28>

90002be4 <psa_its_remove>:

    return status;
}

psa_status_t psa_its_remove(psa_storage_uid_t uid)
{
90002be4:	b530      	push	{r4, r5, lr}
90002be6:	b087      	sub	sp, #28
90002be8:	ab06      	add	r3, sp, #24
90002bea:	e963 0104 	strd	r0, r1, [r3, #-16]!
    psa_status_t status;
    psa_handle_t handle;

    psa_invec in_vec[] = {
90002bee:	9304      	str	r3, [sp, #16]
90002bf0:	2308      	movs	r3, #8
        { .base = &uid, .len = sizeof(uid) }
    };

    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
90002bf2:	2101      	movs	r1, #1
90002bf4:	2073      	movs	r0, #115	; 0x73
    psa_invec in_vec[] = {
90002bf6:	9305      	str	r3, [sp, #20]
    handle = psa_connect(TFM_ITS_REMOVE_SID, TFM_ITS_REMOVE_VERSION);
90002bf8:	f000 f814 	bl	90002c24 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
90002bfc:	1e05      	subs	r5, r0, #0
90002bfe:	dd0d      	ble.n	90002c1c <psa_its_remove+0x38>
        return PSA_ERROR_GENERIC_ERROR;
    }

    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), NULL, 0);
90002c00:	2100      	movs	r1, #0
90002c02:	2301      	movs	r3, #1
90002c04:	e9cd 1100 	strd	r1, r1, [sp]
90002c08:	aa04      	add	r2, sp, #16
90002c0a:	f000 f819 	bl	90002c40 <psa_call>
90002c0e:	4604      	mov	r4, r0

    psa_close(handle);
90002c10:	4628      	mov	r0, r5
90002c12:	f000 f829 	bl	90002c68 <psa_close>

    return status;
}
90002c16:	4620      	mov	r0, r4
90002c18:	b007      	add	sp, #28
90002c1a:	bd30      	pop	{r4, r5, pc}
        return PSA_ERROR_GENERIC_ERROR;
90002c1c:	f06f 0483 	mvn.w	r4, #131	; 0x83
90002c20:	e7f9      	b.n	90002c16 <psa_its_remove+0x32>
	...

90002c24 <psa_connect>:
                                0);
}

psa_handle_t psa_connect(uint32_t sid, uint32_t version)
{
    return tfm_ns_interface_dispatch(
90002c24:	2300      	movs	r3, #0
{
90002c26:	b507      	push	{r0, r1, r2, lr}
    return tfm_ns_interface_dispatch(
90002c28:	460a      	mov	r2, r1
90002c2a:	9300      	str	r3, [sp, #0]
90002c2c:	4601      	mov	r1, r0
90002c2e:	4803      	ldr	r0, [pc, #12]	; (90002c3c <psa_connect+0x18>)
90002c30:	f7fe fd0e 	bl	90001650 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_psa_connect_veneer,
                                sid,
                                version,
                                0,
                                0);
}
90002c34:	b003      	add	sp, #12
90002c36:	f85d fb04 	ldr.w	pc, [sp], #4
90002c3a:	bf00      	nop
90002c3c:	0c038cb1 	.word	0x0c038cb1

90002c40 <psa_call>:
psa_status_t psa_call(psa_handle_t handle, int32_t type,
                      const psa_invec *in_vec,
                      size_t in_len,
                      psa_outvec *out_vec,
                      size_t out_len)
{
90002c40:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
     * serialization in order for NS to pass arguments to S
     */
    psa_invec in_vecs, out_vecs;

    in_vecs.base = in_vec;
    in_vecs.len = in_len;
90002c42:	e9cd 2302 	strd	r2, r3, [sp, #8]
    out_vecs.base = out_vec;
90002c46:	9b08      	ldr	r3, [sp, #32]
    out_vecs.len = out_len;
    return tfm_ns_interface_dispatch(
90002c48:	460a      	mov	r2, r1
    out_vecs.base = out_vec;
90002c4a:	9304      	str	r3, [sp, #16]
    out_vecs.len = out_len;
90002c4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    return tfm_ns_interface_dispatch(
90002c4e:	4601      	mov	r1, r0
    out_vecs.len = out_len;
90002c50:	9305      	str	r3, [sp, #20]
    return tfm_ns_interface_dispatch(
90002c52:	ab04      	add	r3, sp, #16
90002c54:	9300      	str	r3, [sp, #0]
90002c56:	4803      	ldr	r0, [pc, #12]	; (90002c64 <psa_call+0x24>)
90002c58:	ab02      	add	r3, sp, #8
90002c5a:	f7fe fcf9 	bl	90001650 <tfm_ns_interface_dispatch>
                                (veneer_fn)tfm_psa_call_veneer,
                                (uint32_t)handle,
                                (uint32_t)type,
                                (uint32_t)&in_vecs,
                                (uint32_t)&out_vecs);
}
90002c5e:	b007      	add	sp, #28
90002c60:	f85d fb04 	ldr.w	pc, [sp], #4
90002c64:	0c038cc9 	.word	0x0c038cc9

90002c68 <psa_close>:

void psa_close(psa_handle_t handle)
{
    (void)tfm_ns_interface_dispatch(
90002c68:	2300      	movs	r3, #0
{
90002c6a:	b507      	push	{r0, r1, r2, lr}
    (void)tfm_ns_interface_dispatch(
90002c6c:	4601      	mov	r1, r0
90002c6e:	9300      	str	r3, [sp, #0]
90002c70:	461a      	mov	r2, r3
90002c72:	4803      	ldr	r0, [pc, #12]	; (90002c80 <psa_close+0x18>)
90002c74:	f7fe fcec 	bl	90001650 <tfm_ns_interface_dispatch>
                         (veneer_fn)tfm_psa_close_veneer,
                         (uint32_t)handle,
                         0,
                         0,
                         0);
}
90002c78:	b003      	add	sp, #12
90002c7a:	f85d fb04 	ldr.w	pc, [sp], #4
90002c7e:	bf00      	nop
90002c80:	0c038ca1 	.word	0x0c038ca1

90002c84 <psa_ps_set>:

psa_ps_status_t psa_ps_set(psa_ps_uid_t uid,
                           uint32_t data_length,
                           const void *p_data,
                           psa_ps_create_flags_t create_flags)
{
90002c84:	b530      	push	{r4, r5, lr}
90002c86:	b08f      	sub	sp, #60	; 0x3c
90002c88:	ac0e      	add	r4, sp, #56	; 0x38
90002c8a:	e964 010c 	strd	r0, r1, [r4, #-48]!	; 0x30
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
90002c8e:	2108      	movs	r1, #8
90002c90:	e9cd 1309 	strd	r1, r3, [sp, #36]	; 0x24
90002c94:	ab12      	add	r3, sp, #72	; 0x48
90002c96:	930c      	str	r3, [sp, #48]	; 0x30
90002c98:	2304      	movs	r3, #4
90002c9a:	920b      	str	r2, [sp, #44]	; 0x2c

    psa_outvec out_vec[] = {
        { .base = &err , .len = sizeof(err) }
    };

    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
90002c9c:	2101      	movs	r1, #1
    psa_outvec out_vec[] = {
90002c9e:	aa05      	add	r2, sp, #20
    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
90002ca0:	2060      	movs	r0, #96	; 0x60
    psa_invec in_vec[] = {
90002ca2:	9408      	str	r4, [sp, #32]
90002ca4:	930d      	str	r3, [sp, #52]	; 0x34
    psa_outvec out_vec[] = {
90002ca6:	e9cd 2306 	strd	r2, r3, [sp, #24]
    handle = psa_connect(TFM_SST_SET_SID, TFM_SST_SET_VERSION);
90002caa:	f7ff ffbb 	bl	90002c24 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
90002cae:	1e05      	subs	r5, r0, #0
90002cb0:	dc02      	bgt.n	90002cb8 <psa_ps_set+0x34>
        return PSA_PS_ERROR_OPERATION_FAILED;
90002cb2:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
90002cb4:	b00f      	add	sp, #60	; 0x3c
90002cb6:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
90002cb8:	2301      	movs	r3, #1
90002cba:	9301      	str	r3, [sp, #4]
90002cbc:	ab06      	add	r3, sp, #24
90002cbe:	9300      	str	r3, [sp, #0]
90002cc0:	aa08      	add	r2, sp, #32
90002cc2:	2303      	movs	r3, #3
90002cc4:	2100      	movs	r1, #0
90002cc6:	f7ff ffbb 	bl	90002c40 <psa_call>
90002cca:	4604      	mov	r4, r0
    psa_close(handle);
90002ccc:	4628      	mov	r0, r5
90002cce:	f7ff ffcb 	bl	90002c68 <psa_close>
    if (status != PSA_SUCCESS) {
90002cd2:	2c00      	cmp	r4, #0
90002cd4:	d1ed      	bne.n	90002cb2 <psa_ps_set+0x2e>
    return err;
90002cd6:	9805      	ldr	r0, [sp, #20]
90002cd8:	e7ec      	b.n	90002cb4 <psa_ps_set+0x30>

90002cda <psa_ps_get>:

psa_ps_status_t psa_ps_get(psa_ps_uid_t uid,
                           uint32_t data_offset,
                           uint32_t data_length,
                           void *p_data)
{
90002cda:	b530      	push	{r4, r5, lr}
90002cdc:	b091      	sub	sp, #68	; 0x44
90002cde:	9203      	str	r2, [sp, #12]
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
90002ce0:	aa04      	add	r2, sp, #16
90002ce2:	9208      	str	r2, [sp, #32]
90002ce4:	2208      	movs	r2, #8
90002ce6:	9209      	str	r2, [sp, #36]	; 0x24
90002ce8:	aa03      	add	r2, sp, #12
90002cea:	920a      	str	r2, [sp, #40]	; 0x28
90002cec:	2204      	movs	r2, #4
{
90002cee:	e9cd 0104 	strd	r0, r1, [sp, #16]
        { .base = &uid, .len = sizeof(uid) },
        { .base = &data_offset, .len = sizeof(data_offset) }
    };

    psa_outvec out_vec[] = {
90002cf2:	a907      	add	r1, sp, #28
90002cf4:	e9cd 120c 	strd	r1, r2, [sp, #48]	; 0x30
    psa_invec in_vec[] = {
90002cf8:	920b      	str	r2, [sp, #44]	; 0x2c
    psa_outvec out_vec[] = {
90002cfa:	9a14      	ldr	r2, [sp, #80]	; 0x50
        { .base = &err,   .len = sizeof(err) },
        { .base = p_data, .len = data_length }
    };

    handle = psa_connect(TFM_SST_GET_SID, TFM_SST_GET_VERSION);
90002cfc:	2101      	movs	r1, #1
90002cfe:	2061      	movs	r0, #97	; 0x61
    psa_outvec out_vec[] = {
90002d00:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
    handle = psa_connect(TFM_SST_GET_SID, TFM_SST_GET_VERSION);
90002d04:	f7ff ff8e 	bl	90002c24 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
90002d08:	1e05      	subs	r5, r0, #0
90002d0a:	dc02      	bgt.n	90002d12 <psa_ps_get+0x38>
        return PSA_PS_ERROR_OPERATION_FAILED;
90002d0c:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
90002d0e:	b011      	add	sp, #68	; 0x44
90002d10:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
90002d12:	2302      	movs	r3, #2
90002d14:	aa0c      	add	r2, sp, #48	; 0x30
90002d16:	9200      	str	r2, [sp, #0]
90002d18:	9301      	str	r3, [sp, #4]
90002d1a:	aa08      	add	r2, sp, #32
90002d1c:	2100      	movs	r1, #0
90002d1e:	f7ff ff8f 	bl	90002c40 <psa_call>
90002d22:	4604      	mov	r4, r0
    psa_close(handle);
90002d24:	4628      	mov	r0, r5
90002d26:	f7ff ff9f 	bl	90002c68 <psa_close>
    if (status != PSA_SUCCESS) {
90002d2a:	2c00      	cmp	r4, #0
90002d2c:	d1ee      	bne.n	90002d0c <psa_ps_get+0x32>
    return err;
90002d2e:	9807      	ldr	r0, [sp, #28]
90002d30:	e7ed      	b.n	90002d0e <psa_ps_get+0x34>

90002d32 <psa_ps_remove>:

    return err;
}

psa_ps_status_t psa_ps_remove(psa_ps_uid_t uid)
{
90002d32:	b530      	push	{r4, r5, lr}
90002d34:	b08b      	sub	sp, #44	; 0x2c
90002d36:	ab0a      	add	r3, sp, #40	; 0x28
90002d38:	e963 0108 	strd	r0, r1, [r3, #-32]!
    psa_status_t status;
    psa_ps_status_t err;
    psa_handle_t handle;

    psa_invec in_vec[] = {
90002d3c:	9306      	str	r3, [sp, #24]
90002d3e:	2308      	movs	r3, #8
90002d40:	9307      	str	r3, [sp, #28]
        { .base = &uid, .len = sizeof(uid) }
    };

    psa_outvec out_vec[] = {
90002d42:	ab05      	add	r3, sp, #20
90002d44:	9308      	str	r3, [sp, #32]
90002d46:	2304      	movs	r3, #4
        { .base = &err, .len = sizeof(err) }
    };

    handle = psa_connect(TFM_SST_REMOVE_SID, TFM_SST_REMOVE_VERSION);
90002d48:	2101      	movs	r1, #1
90002d4a:	2063      	movs	r0, #99	; 0x63
    psa_outvec out_vec[] = {
90002d4c:	9309      	str	r3, [sp, #36]	; 0x24
    handle = psa_connect(TFM_SST_REMOVE_SID, TFM_SST_REMOVE_VERSION);
90002d4e:	f7ff ff69 	bl	90002c24 <psa_connect>
    if (!PSA_HANDLE_IS_VALID(handle)) {
90002d52:	1e05      	subs	r5, r0, #0
90002d54:	dc02      	bgt.n	90002d5c <psa_ps_remove+0x2a>
        return PSA_PS_ERROR_OPERATION_FAILED;
90002d56:	200b      	movs	r0, #11
    if (status != PSA_SUCCESS) {
        return PSA_PS_ERROR_OPERATION_FAILED;
    }

    return err;
}
90002d58:	b00b      	add	sp, #44	; 0x2c
90002d5a:	bd30      	pop	{r4, r5, pc}
    status = psa_call(handle, PSA_IPC_CALL, in_vec, IOVEC_LEN(in_vec), out_vec,
90002d5c:	2301      	movs	r3, #1
90002d5e:	aa08      	add	r2, sp, #32
90002d60:	9200      	str	r2, [sp, #0]
90002d62:	9301      	str	r3, [sp, #4]
90002d64:	aa06      	add	r2, sp, #24
90002d66:	2100      	movs	r1, #0
90002d68:	f7ff ff6a 	bl	90002c40 <psa_call>
90002d6c:	4604      	mov	r4, r0
    psa_close(handle);
90002d6e:	4628      	mov	r0, r5
90002d70:	f7ff ff7a 	bl	90002c68 <psa_close>
    if (status != PSA_SUCCESS) {
90002d74:	2c00      	cmp	r4, #0
90002d76:	d1ee      	bne.n	90002d56 <psa_ps_remove+0x24>
    return err;
90002d78:	9805      	ldr	r0, [sp, #20]
90002d7a:	e7ed      	b.n	90002d58 <psa_ps_remove+0x26>

90002d7c <psa_cipher_test>:
}

void psa_cipher_test(const psa_key_type_t key_type,
                     const psa_algorithm_t alg,
                     struct test_result_t *ret)
{
90002d7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    psa_cipher_operation_t handle = psa_cipher_operation_init();
90002d80:	2300      	movs	r3, #0
{
90002d82:	b0ab      	sub	sp, #172	; 0xac
90002d84:	4614      	mov	r4, r2
    psa_cipher_operation_t handle_dec = psa_cipher_operation_init();
    psa_status_t status = PSA_SUCCESS;
    psa_key_handle_t key_handle;
    const uint8_t data[] = "THIS IS MY KEY1";
90002d86:	aa0e      	add	r2, sp, #56	; 0x38
{
90002d88:	4606      	mov	r6, r0
90002d8a:	460f      	mov	r7, r1
90002d8c:	4693      	mov	fp, r2
    psa_cipher_operation_t handle_dec = psa_cipher_operation_init();
90002d8e:	e9cd 3306 	strd	r3, r3, [sp, #24]
    const uint8_t data[] = "THIS IS MY KEY1";
90002d92:	4b91      	ldr	r3, [pc, #580]	; (90002fd8 <psa_cipher_test+0x25c>)
90002d94:	f103 0c10 	add.w	ip, r3, #16
90002d98:	4615      	mov	r5, r2
90002d9a:	6818      	ldr	r0, [r3, #0]
90002d9c:	6859      	ldr	r1, [r3, #4]
90002d9e:	3308      	adds	r3, #8
90002da0:	c503      	stmia	r5!, {r0, r1}
90002da2:	4563      	cmp	r3, ip
90002da4:	462a      	mov	r2, r5
90002da6:	d1f7      	bne.n	90002d98 <psa_cipher_test+0x1c>
    psa_key_type_t type = PSA_KEY_TYPE_NONE;
90002da8:	2300      	movs	r3, #0
    size_t bits = 0;
90002daa:	e9cd 3308 	strd	r3, r3, [sp, #32]
    const size_t iv_length = PSA_BLOCK_CIPHER_BLOCK_SIZE(key_type);
90002dae:	4b8b      	ldr	r3, [pc, #556]	; (90002fdc <psa_cipher_test+0x260>)
90002db0:	429e      	cmp	r6, r3
90002db2:	d049      	beq.n	90002e48 <psa_cipher_test+0xcc>
90002db4:	3301      	adds	r3, #1
90002db6:	429e      	cmp	r6, r3
90002db8:	d044      	beq.n	90002e44 <psa_cipher_test+0xc8>
90002dba:	3301      	adds	r3, #1
90002dbc:	429e      	cmp	r6, r3
90002dbe:	d043      	beq.n	90002e48 <psa_cipher_test+0xcc>
90002dc0:	4d87      	ldr	r5, [pc, #540]	; (90002fe0 <psa_cipher_test+0x264>)
90002dc2:	1b73      	subs	r3, r6, r5
90002dc4:	425d      	negs	r5, r3
90002dc6:	415d      	adcs	r5, r3
    const uint8_t iv[] = "012345678901234";
90002dc8:	aa12      	add	r2, sp, #72	; 0x48
90002dca:	4692      	mov	sl, r2
90002dcc:	4b85      	ldr	r3, [pc, #532]	; (90002fe4 <psa_cipher_test+0x268>)
90002dce:	f103 0e10 	add.w	lr, r3, #16
90002dd2:	4694      	mov	ip, r2
90002dd4:	6818      	ldr	r0, [r3, #0]
90002dd6:	6859      	ldr	r1, [r3, #4]
90002dd8:	3308      	adds	r3, #8
90002dda:	e8ac 0003 	stmia.w	ip!, {r0, r1}
90002dde:	4573      	cmp	r3, lr
90002de0:	4662      	mov	r2, ip
90002de2:	d1f6      	bne.n	90002dd2 <psa_cipher_test+0x56>
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
90002de4:	aa16      	add	r2, sp, #88	; 0x58
90002de6:	4691      	mov	r9, r2
90002de8:	4b7f      	ldr	r3, [pc, #508]	; (90002fe8 <psa_cipher_test+0x26c>)
90002dea:	f103 0e10 	add.w	lr, r3, #16
90002dee:	4694      	mov	ip, r2
90002df0:	6818      	ldr	r0, [r3, #0]
90002df2:	6859      	ldr	r1, [r3, #4]
90002df4:	3308      	adds	r3, #8
90002df6:	e8ac 0003 	stmia.w	ip!, {r0, r1}
90002dfa:	4573      	cmp	r3, lr
90002dfc:	4662      	mov	r2, ip
90002dfe:	d1f6      	bne.n	90002dee <psa_cipher_test+0x72>
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
90002e00:	f04f 0820 	mov.w	r8, #32
90002e04:	2100      	movs	r1, #0
90002e06:	4642      	mov	r2, r8
90002e08:	a81a      	add	r0, sp, #104	; 0x68
90002e0a:	f000 fbe7 	bl	900035dc <memset>
    size_t output_length = 0, total_output_length = 0;
90002e0e:	2300      	movs	r3, #0
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
90002e10:	4642      	mov	r2, r8
90002e12:	4619      	mov	r1, r3
90002e14:	a822      	add	r0, sp, #136	; 0x88
    size_t output_length = 0, total_output_length = 0;
90002e16:	930a      	str	r3, [sp, #40]	; 0x28
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
90002e18:	9303      	str	r3, [sp, #12]
90002e1a:	f000 fbdf 	bl	900035dc <memset>

#define PSA_KEY_POLICY_INIT {0, 0, 0}
static inline struct psa_key_policy_s psa_key_policy_init( void )
{
    const struct psa_key_policy_s v = PSA_KEY_POLICY_INIT;
    return( v );
90002e1e:	9b03      	ldr	r3, [sp, #12]
    uint32_t i;

    ret->val = TEST_PASSED;

    /* Allocate a transient key */
    status = psa_allocate_key(&key_handle);
90002e20:	f10d 0016 	add.w	r0, sp, #22
    ret->val = TEST_PASSED;
90002e24:	7023      	strb	r3, [r4, #0]
90002e26:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
90002e2a:	930d      	str	r3, [sp, #52]	; 0x34
    status = psa_allocate_key(&key_handle);
90002e2c:	f7ff fb1e 	bl	9000246c <psa_allocate_key>
    if (status != PSA_SUCCESS) {
90002e30:	b160      	cbz	r0, 90002e4c <psa_cipher_test+0xd0>
        TEST_FAIL("Failed to allocate key");
90002e32:	4623      	mov	r3, r4
90002e34:	2288      	movs	r2, #136	; 0x88
90002e36:	496d      	ldr	r1, [pc, #436]	; (90002fec <psa_cipher_test+0x270>)
90002e38:	486d      	ldr	r0, [pc, #436]	; (90002ff0 <psa_cipher_test+0x274>)

destroy_key:
    /* Destroy the key */
    status = psa_destroy_key(key_handle);
    if (status != PSA_SUCCESS) {
        TEST_FAIL("Error destroying a key");
90002e3a:	f000 fb65 	bl	90003508 <set_test_failed>
    }

}
90002e3e:	b02b      	add	sp, #172	; 0xac
90002e40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    const size_t iv_length = PSA_BLOCK_CIPHER_BLOCK_SIZE(key_type);
90002e44:	2508      	movs	r5, #8
90002e46:	e7bf      	b.n	90002dc8 <psa_cipher_test+0x4c>
90002e48:	2510      	movs	r5, #16
90002e4a:	e7bd      	b.n	90002dc8 <psa_cipher_test+0x4c>
    psa_key_policy_set_usage(&policy, usage, alg);
90002e4c:	f44f 7140 	mov.w	r1, #768	; 0x300
90002e50:	a80b      	add	r0, sp, #44	; 0x2c
90002e52:	463a      	mov	r2, r7
90002e54:	f7ff fbb7 	bl	900025c6 <psa_key_policy_set_usage>
    status = psa_set_key_policy(key_handle, &policy);
90002e58:	a90b      	add	r1, sp, #44	; 0x2c
90002e5a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90002e5e:	f7ff fbb5 	bl	900025cc <psa_set_key_policy>
    if (status != PSA_SUCCESS) {
90002e62:	b188      	cbz	r0, 90002e88 <psa_cipher_test+0x10c>
        TEST_FAIL("Failed to set key policy");
90002e64:	4623      	mov	r3, r4
90002e66:	2290      	movs	r2, #144	; 0x90
90002e68:	4960      	ldr	r1, [pc, #384]	; (90002fec <psa_cipher_test+0x270>)
90002e6a:	4862      	ldr	r0, [pc, #392]	; (90002ff4 <psa_cipher_test+0x278>)
        TEST_FAIL("After finalising, unexpected decrypted length");
90002e6c:	f000 fb4c 	bl	90003508 <set_test_failed>
    status = psa_destroy_key(key_handle);
90002e70:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90002e74:	f7ff fb4e 	bl	90002514 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
90002e78:	2800      	cmp	r0, #0
90002e7a:	d0e0      	beq.n	90002e3e <psa_cipher_test+0xc2>
        TEST_FAIL("Error destroying a key");
90002e7c:	4623      	mov	r3, r4
90002e7e:	f240 123f 	movw	r2, #319	; 0x13f
90002e82:	495a      	ldr	r1, [pc, #360]	; (90002fec <psa_cipher_test+0x270>)
90002e84:	485c      	ldr	r0, [pc, #368]	; (90002ff8 <psa_cipher_test+0x27c>)
90002e86:	e7d8      	b.n	90002e3a <psa_cipher_test+0xbe>
    status = psa_import_key(key_handle, key_type, data, sizeof(data));
90002e88:	2310      	movs	r3, #16
90002e8a:	465a      	mov	r2, fp
90002e8c:	4631      	mov	r1, r6
90002e8e:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90002e92:	f7ff fb12 	bl	900024ba <psa_import_key>
    if (status != PSA_SUCCESS) {
90002e96:	b120      	cbz	r0, 90002ea2 <psa_cipher_test+0x126>
        TEST_FAIL("Error importing a key");
90002e98:	4623      	mov	r3, r4
90002e9a:	2297      	movs	r2, #151	; 0x97
90002e9c:	4953      	ldr	r1, [pc, #332]	; (90002fec <psa_cipher_test+0x270>)
90002e9e:	4857      	ldr	r0, [pc, #348]	; (90002ffc <psa_cipher_test+0x280>)
90002ea0:	e7e4      	b.n	90002e6c <psa_cipher_test+0xf0>
    status = psa_get_key_information(key_handle, &type, &bits);
90002ea2:	aa09      	add	r2, sp, #36	; 0x24
90002ea4:	a908      	add	r1, sp, #32
90002ea6:	f8bd 0016 	ldrh.w	r0, [sp, #22]
90002eaa:	f7ff fb5b 	bl	90002564 <psa_get_key_information>
    if (status != PSA_SUCCESS) {
90002eae:	b120      	cbz	r0, 90002eba <psa_cipher_test+0x13e>
        TEST_FAIL("Error getting key metadata");
90002eb0:	4623      	mov	r3, r4
90002eb2:	229d      	movs	r2, #157	; 0x9d
90002eb4:	494d      	ldr	r1, [pc, #308]	; (90002fec <psa_cipher_test+0x270>)
90002eb6:	4852      	ldr	r0, [pc, #328]	; (90003000 <psa_cipher_test+0x284>)
90002eb8:	e7d8      	b.n	90002e6c <psa_cipher_test+0xf0>
    if (bits != BIT_SIZE_TEST_KEY) {
90002eba:	9b09      	ldr	r3, [sp, #36]	; 0x24
90002ebc:	2b80      	cmp	r3, #128	; 0x80
90002ebe:	d004      	beq.n	90002eca <psa_cipher_test+0x14e>
        TEST_FAIL("The number of key bits is different from expected");
90002ec0:	4623      	mov	r3, r4
90002ec2:	22a2      	movs	r2, #162	; 0xa2
90002ec4:	4949      	ldr	r1, [pc, #292]	; (90002fec <psa_cipher_test+0x270>)
90002ec6:	484f      	ldr	r0, [pc, #316]	; (90003004 <psa_cipher_test+0x288>)
90002ec8:	e7d0      	b.n	90002e6c <psa_cipher_test+0xf0>
    if (type != key_type) {
90002eca:	9b08      	ldr	r3, [sp, #32]
90002ecc:	42b3      	cmp	r3, r6
90002ece:	d004      	beq.n	90002eda <psa_cipher_test+0x15e>
        TEST_FAIL("The type of the key is different from expected");
90002ed0:	4623      	mov	r3, r4
90002ed2:	22a7      	movs	r2, #167	; 0xa7
90002ed4:	4945      	ldr	r1, [pc, #276]	; (90002fec <psa_cipher_test+0x270>)
90002ed6:	484c      	ldr	r0, [pc, #304]	; (90003008 <psa_cipher_test+0x28c>)
90002ed8:	e7c8      	b.n	90002e6c <psa_cipher_test+0xf0>
    status = psa_cipher_encrypt_setup(&handle, key_handle, alg);
90002eda:	463a      	mov	r2, r7
90002edc:	f8bd 1016 	ldrh.w	r1, [sp, #22]
90002ee0:	a806      	add	r0, sp, #24
90002ee2:	f7ff fbcf 	bl	90002684 <psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
90002ee6:	b150      	cbz	r0, 90002efe <psa_cipher_test+0x182>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
90002ee8:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90002eea:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
90002eec:	d103      	bne.n	90002ef6 <psa_cipher_test+0x17a>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90002eee:	22af      	movs	r2, #175	; 0xaf
90002ef0:	493e      	ldr	r1, [pc, #248]	; (90002fec <psa_cipher_test+0x270>)
90002ef2:	4846      	ldr	r0, [pc, #280]	; (9000300c <psa_cipher_test+0x290>)
90002ef4:	e7ba      	b.n	90002e6c <psa_cipher_test+0xf0>
            TEST_FAIL("Error setting up cipher operation object");
90002ef6:	22b1      	movs	r2, #177	; 0xb1
        TEST_FAIL("Error setting up cipher operation object");
90002ef8:	493c      	ldr	r1, [pc, #240]	; (90002fec <psa_cipher_test+0x270>)
90002efa:	4845      	ldr	r0, [pc, #276]	; (90003010 <psa_cipher_test+0x294>)
90002efc:	e7b6      	b.n	90002e6c <psa_cipher_test+0xf0>
    status = psa_cipher_set_iv(&handle, iv, iv_length);
90002efe:	462a      	mov	r2, r5
90002f00:	4651      	mov	r1, sl
90002f02:	a806      	add	r0, sp, #24
90002f04:	f7ff fb8e 	bl	90002624 <psa_cipher_set_iv>
    if (status != PSA_SUCCESS) {
90002f08:	b178      	cbz	r0, 90002f2a <psa_cipher_test+0x1ae>
        TEST_FAIL("Error setting the IV on the cypher operation object");
90002f0a:	4842      	ldr	r0, [pc, #264]	; (90003014 <psa_cipher_test+0x298>)
90002f0c:	4623      	mov	r3, r4
90002f0e:	22b9      	movs	r2, #185	; 0xb9
90002f10:	4936      	ldr	r1, [pc, #216]	; (90002fec <psa_cipher_test+0x270>)
90002f12:	f000 faf9 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle);
90002f16:	a806      	add	r0, sp, #24
90002f18:	f7ff fc4d 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
90002f1c:	2800      	cmp	r0, #0
90002f1e:	d0a7      	beq.n	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
90002f20:	4623      	mov	r3, r4
90002f22:	22bc      	movs	r2, #188	; 0xbc
            TEST_FAIL("Error aborting the operation");
90002f24:	4931      	ldr	r1, [pc, #196]	; (90002fec <psa_cipher_test+0x270>)
90002f26:	483c      	ldr	r0, [pc, #240]	; (90003018 <psa_cipher_test+0x29c>)
90002f28:	e7a0      	b.n	90002e6c <psa_cipher_test+0xf0>
    status = psa_cipher_update(&handle, plain_text, BYTE_SIZE_CHUNK,
90002f2a:	ae0a      	add	r6, sp, #40	; 0x28
90002f2c:	e9cd 8600 	strd	r8, r6, [sp]
90002f30:	ab22      	add	r3, sp, #136	; 0x88
90002f32:	2210      	movs	r2, #16
90002f34:	4649      	mov	r1, r9
90002f36:	a806      	add	r0, sp, #24
90002f38:	f7ff fc06 	bl	90002748 <psa_cipher_update>
    if (status != PSA_SUCCESS) {
90002f3c:	b168      	cbz	r0, 90002f5a <psa_cipher_test+0x1de>
        TEST_FAIL("Error encrypting one chunk of information");
90002f3e:	4837      	ldr	r0, [pc, #220]	; (9000301c <psa_cipher_test+0x2a0>)
90002f40:	4623      	mov	r3, r4
90002f42:	22c7      	movs	r2, #199	; 0xc7
90002f44:	4929      	ldr	r1, [pc, #164]	; (90002fec <psa_cipher_test+0x270>)
90002f46:	f000 fadf 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle);
90002f4a:	a806      	add	r0, sp, #24
90002f4c:	f7ff fc33 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
90002f50:	2800      	cmp	r0, #0
90002f52:	d08d      	beq.n	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
90002f54:	4623      	mov	r3, r4
90002f56:	22ca      	movs	r2, #202	; 0xca
90002f58:	e7e4      	b.n	90002f24 <psa_cipher_test+0x1a8>
    if (output_length != BYTE_SIZE_CHUNK) {
90002f5a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
90002f5c:	2a10      	cmp	r2, #16
90002f5e:	d00e      	beq.n	90002f7e <psa_cipher_test+0x202>
        TEST_FAIL("Expected encrypted data length is different from expected");
90002f60:	482f      	ldr	r0, [pc, #188]	; (90003020 <psa_cipher_test+0x2a4>)
90002f62:	4623      	mov	r3, r4
90002f64:	22d0      	movs	r2, #208	; 0xd0
90002f66:	4921      	ldr	r1, [pc, #132]	; (90002fec <psa_cipher_test+0x270>)
90002f68:	f000 face 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle);
90002f6c:	a806      	add	r0, sp, #24
90002f6e:	f7ff fc22 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
90002f72:	2800      	cmp	r0, #0
90002f74:	f43f af7c 	beq.w	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
90002f78:	4623      	mov	r3, r4
90002f7a:	22d3      	movs	r2, #211	; 0xd3
90002f7c:	e7d2      	b.n	90002f24 <psa_cipher_test+0x1a8>
    status = psa_cipher_finish(&handle, &encrypted_data[output_length],
90002f7e:	4633      	mov	r3, r6
90002f80:	a926      	add	r1, sp, #152	; 0x98
90002f82:	a806      	add	r0, sp, #24
90002f84:	f7ff fc42 	bl	9000280c <psa_cipher_finish>
    if (status != PSA_SUCCESS) {
90002f88:	b170      	cbz	r0, 90002fa8 <psa_cipher_test+0x22c>
        TEST_FAIL("Error finalising the cipher operation");
90002f8a:	4826      	ldr	r0, [pc, #152]	; (90003024 <psa_cipher_test+0x2a8>)
90002f8c:	4623      	mov	r3, r4
90002f8e:	22de      	movs	r2, #222	; 0xde
90002f90:	4916      	ldr	r1, [pc, #88]	; (90002fec <psa_cipher_test+0x270>)
90002f92:	f000 fab9 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle);
90002f96:	a806      	add	r0, sp, #24
90002f98:	f7ff fc0d 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
90002f9c:	2800      	cmp	r0, #0
90002f9e:	f43f af67 	beq.w	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
90002fa2:	4623      	mov	r3, r4
90002fa4:	22e1      	movs	r2, #225	; 0xe1
90002fa6:	e7bd      	b.n	90002f24 <psa_cipher_test+0x1a8>
    if (output_length != 0) {
90002fa8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
90002faa:	b123      	cbz	r3, 90002fb6 <psa_cipher_test+0x23a>
        TEST_FAIL("Unexpected output length after finalisation");
90002fac:	4623      	mov	r3, r4
90002fae:	22e7      	movs	r2, #231	; 0xe7
90002fb0:	490e      	ldr	r1, [pc, #56]	; (90002fec <psa_cipher_test+0x270>)
90002fb2:	481d      	ldr	r0, [pc, #116]	; (90003028 <psa_cipher_test+0x2ac>)
90002fb4:	e75a      	b.n	90002e6c <psa_cipher_test+0xf0>
    if (alg == PSA_ALG_CFB) {
90002fb6:	4b1d      	ldr	r3, [pc, #116]	; (9000302c <psa_cipher_test+0x2b0>)
90002fb8:	f8bd 1016 	ldrh.w	r1, [sp, #22]
90002fbc:	429f      	cmp	r7, r3
        status = psa_cipher_encrypt_setup(&handle_dec, key_handle, alg);
90002fbe:	463a      	mov	r2, r7
90002fc0:	a807      	add	r0, sp, #28
    if (alg == PSA_ALG_CFB) {
90002fc2:	d105      	bne.n	90002fd0 <psa_cipher_test+0x254>
        status = psa_cipher_encrypt_setup(&handle_dec, key_handle, alg);
90002fc4:	f7ff fb5e 	bl	90002684 <psa_cipher_encrypt_setup>
    if (status != PSA_SUCCESS) {
90002fc8:	b390      	cbz	r0, 90003030 <psa_cipher_test+0x2b4>
        TEST_FAIL("Error setting up cipher operation object");
90002fca:	4623      	mov	r3, r4
90002fcc:	22f4      	movs	r2, #244	; 0xf4
90002fce:	e793      	b.n	90002ef8 <psa_cipher_test+0x17c>
        status = psa_cipher_decrypt_setup(&handle_dec, key_handle, alg);
90002fd0:	f7ff fb89 	bl	900026e6 <psa_cipher_decrypt_setup>
90002fd4:	e7f8      	b.n	90002fc8 <psa_cipher_test+0x24c>
90002fd6:	bf00      	nop
90002fd8:	90005d4d 	.word	0x90005d4d
90002fdc:	40000001 	.word	0x40000001
90002fe0:	40000004 	.word	0x40000004
90002fe4:	90005b10 	.word	0x90005b10
90002fe8:	90005b20 	.word	0x90005b20
90002fec:	900056ce 	.word	0x900056ce
90002ff0:	90005baa 	.word	0x90005baa
90002ff4:	90005bc1 	.word	0x90005bc1
90002ff8:	90005af9 	.word	0x90005af9
90002ffc:	90005c07 	.word	0x90005c07
90003000:	90005c1d 	.word	0x90005c1d
90003004:	90005c38 	.word	0x90005c38
90003008:	90005c6a 	.word	0x90005c6a
9000300c:	90005904 	.word	0x90005904
90003010:	90005932 	.word	0x90005932
90003014:	9000595b 	.word	0x9000595b
90003018:	9000598f 	.word	0x9000598f
9000301c:	900059ac 	.word	0x900059ac
90003020:	900059d6 	.word	0x900059d6
90003024:	90005a10 	.word	0x90005a10
90003028:	90005a36 	.word	0x90005a36
9000302c:	04c00002 	.word	0x04c00002
    status = psa_cipher_set_iv(&handle_dec, iv, iv_length);
90003030:	462a      	mov	r2, r5
90003032:	4651      	mov	r1, sl
90003034:	a807      	add	r0, sp, #28
90003036:	f7ff faf5 	bl	90002624 <psa_cipher_set_iv>
    if (status != PSA_SUCCESS) {
9000303a:	2800      	cmp	r0, #0
9000303c:	d138      	bne.n	900030b0 <psa_cipher_test+0x334>
        status = psa_cipher_update(&handle_dec,
9000303e:	2320      	movs	r3, #32
90003040:	9601      	str	r6, [sp, #4]
90003042:	9300      	str	r3, [sp, #0]
90003044:	2210      	movs	r2, #16
90003046:	ab1a      	add	r3, sp, #104	; 0x68
90003048:	a922      	add	r1, sp, #136	; 0x88
9000304a:	a807      	add	r0, sp, #28
9000304c:	f7ff fb7c 	bl	90002748 <psa_cipher_update>
        if (status != PSA_SUCCESS) {
90003050:	2800      	cmp	r0, #0
90003052:	d13c      	bne.n	900030ce <psa_cipher_test+0x352>
        total_output_length += output_length;
90003054:	9d0a      	ldr	r5, [sp, #40]	; 0x28
        status = psa_cipher_update(&handle_dec,
90003056:	9601      	str	r6, [sp, #4]
90003058:	f1c5 0320 	rsb	r3, r5, #32
9000305c:	9300      	str	r3, [sp, #0]
9000305e:	ab1a      	add	r3, sp, #104	; 0x68
90003060:	442b      	add	r3, r5
90003062:	2210      	movs	r2, #16
90003064:	a926      	add	r1, sp, #152	; 0x98
90003066:	a807      	add	r0, sp, #28
90003068:	f7ff fb6e 	bl	90002748 <psa_cipher_update>
        if (status != PSA_SUCCESS) {
9000306c:	bb78      	cbnz	r0, 900030ce <psa_cipher_test+0x352>
}

__attribute__ ((always_inline)) __STATIC_INLINE
int tfm_memcmp(const void *ptr1, const void *ptr2, size_t num)
{
    return (memcmp(ptr1, ptr2, num));
9000306e:	2210      	movs	r2, #16
90003070:	a91a      	add	r1, sp, #104	; 0x68
90003072:	4648      	mov	r0, r9
90003074:	f000 fa98 	bl	900035a8 <memcmp>
    if (comp_result != 0) {
90003078:	2800      	cmp	r0, #0
9000307a:	d139      	bne.n	900030f0 <psa_cipher_test+0x374>
    status = psa_cipher_finish(&handle_dec, decrypted_data, BYTE_SIZE_CHUNK,
9000307c:	4633      	mov	r3, r6
9000307e:	2210      	movs	r2, #16
90003080:	a91a      	add	r1, sp, #104	; 0x68
90003082:	a807      	add	r0, sp, #28
        total_output_length += output_length;
90003084:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    status = psa_cipher_finish(&handle_dec, decrypted_data, BYTE_SIZE_CHUNK,
90003086:	f7ff fbc1 	bl	9000280c <psa_cipher_finish>
    if (status != PSA_SUCCESS) {
9000308a:	2800      	cmp	r0, #0
9000308c:	d041      	beq.n	90003112 <psa_cipher_test+0x396>
        TEST_FAIL("Error finalising the cipher operation");
9000308e:	4827      	ldr	r0, [pc, #156]	; (9000312c <psa_cipher_test+0x3b0>)
90003090:	4623      	mov	r3, r4
90003092:	f240 122b 	movw	r2, #299	; 0x12b
90003096:	4926      	ldr	r1, [pc, #152]	; (90003130 <psa_cipher_test+0x3b4>)
90003098:	f000 fa36 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
9000309c:	a807      	add	r0, sp, #28
9000309e:	f7ff fb8a 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
900030a2:	2800      	cmp	r0, #0
900030a4:	f43f aee4 	beq.w	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
900030a8:	4623      	mov	r3, r4
900030aa:	f44f 7297 	mov.w	r2, #302	; 0x12e
900030ae:	e739      	b.n	90002f24 <psa_cipher_test+0x1a8>
        TEST_FAIL("Error setting the IV for decryption");
900030b0:	4820      	ldr	r0, [pc, #128]	; (90003134 <psa_cipher_test+0x3b8>)
900030b2:	4623      	mov	r3, r4
900030b4:	22fb      	movs	r2, #251	; 0xfb
900030b6:	491e      	ldr	r1, [pc, #120]	; (90003130 <psa_cipher_test+0x3b4>)
900030b8:	f000 fa26 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
900030bc:	a807      	add	r0, sp, #28
900030be:	f7ff fb7a 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
900030c2:	2800      	cmp	r0, #0
900030c4:	f43f aed4 	beq.w	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
900030c8:	4623      	mov	r3, r4
900030ca:	22fe      	movs	r2, #254	; 0xfe
900030cc:	e72a      	b.n	90002f24 <psa_cipher_test+0x1a8>
            TEST_FAIL("Error during decryption");
900030ce:	481a      	ldr	r0, [pc, #104]	; (90003138 <psa_cipher_test+0x3bc>)
900030d0:	4623      	mov	r3, r4
900030d2:	f44f 7286 	mov.w	r2, #268	; 0x10c
900030d6:	4916      	ldr	r1, [pc, #88]	; (90003130 <psa_cipher_test+0x3b4>)
900030d8:	f000 fa16 	bl	90003508 <set_test_failed>
            status = psa_cipher_abort(&handle_dec);
900030dc:	a807      	add	r0, sp, #28
900030de:	f7ff fb6a 	bl	900027b6 <psa_cipher_abort>
            if (status != PSA_SUCCESS) {
900030e2:	2800      	cmp	r0, #0
900030e4:	f43f aec4 	beq.w	90002e70 <psa_cipher_test+0xf4>
                TEST_FAIL("Error aborting the operation");
900030e8:	4623      	mov	r3, r4
900030ea:	f240 120f 	movw	r2, #271	; 0x10f
900030ee:	e719      	b.n	90002f24 <psa_cipher_test+0x1a8>
        TEST_FAIL("Decrypted data doesn't match with plain text");
900030f0:	4812      	ldr	r0, [pc, #72]	; (9000313c <psa_cipher_test+0x3c0>)
900030f2:	4623      	mov	r3, r4
900030f4:	f44f 728f 	mov.w	r2, #286	; 0x11e
900030f8:	490d      	ldr	r1, [pc, #52]	; (90003130 <psa_cipher_test+0x3b4>)
900030fa:	f000 fa05 	bl	90003508 <set_test_failed>
        status = psa_cipher_abort(&handle_dec);
900030fe:	a807      	add	r0, sp, #28
90003100:	f7ff fb59 	bl	900027b6 <psa_cipher_abort>
        if (status != PSA_SUCCESS) {
90003104:	2800      	cmp	r0, #0
90003106:	f43f aeb3 	beq.w	90002e70 <psa_cipher_test+0xf4>
            TEST_FAIL("Error aborting the operation");
9000310a:	4623      	mov	r3, r4
9000310c:	f240 1221 	movw	r2, #289	; 0x121
90003110:	e708      	b.n	90002f24 <psa_cipher_test+0x1a8>
    total_output_length += output_length;
90003112:	9b0a      	ldr	r3, [sp, #40]	; 0x28
        total_output_length += output_length;
90003114:	443d      	add	r5, r7
    total_output_length += output_length;
90003116:	441d      	add	r5, r3
    if (total_output_length != ENC_DEC_BUFFER_SIZE) {
90003118:	2d20      	cmp	r5, #32
9000311a:	f43f aea9 	beq.w	90002e70 <psa_cipher_test+0xf4>
        TEST_FAIL("After finalising, unexpected decrypted length");
9000311e:	4623      	mov	r3, r4
90003120:	f240 1237 	movw	r2, #311	; 0x137
90003124:	4902      	ldr	r1, [pc, #8]	; (90003130 <psa_cipher_test+0x3b4>)
90003126:	4806      	ldr	r0, [pc, #24]	; (90003140 <psa_cipher_test+0x3c4>)
90003128:	e6a0      	b.n	90002e6c <psa_cipher_test+0xf0>
9000312a:	bf00      	nop
9000312c:	90005a10 	.word	0x90005a10
90003130:	900056ce 	.word	0x900056ce
90003134:	90005a62 	.word	0x90005a62
90003138:	90005a86 	.word	0x90005a86
9000313c:	90005a9e 	.word	0x90005a9e
90003140:	90005acb 	.word	0x90005acb

90003144 <psa_hash_test>:
    const size_t msg_size[] = {25, 32}; /* Length in bytes of msg[0], msg[1] */
    const uint32_t msg_num = sizeof(msg)/sizeof(msg[0]);
    uint32_t idx;

    psa_status_t status;
    psa_hash_operation_t handle = psa_hash_operation_init();
90003144:	2300      	movs	r3, #0
{
90003146:	b573      	push	{r0, r1, r4, r5, r6, lr}
    psa_hash_operation_t handle = psa_hash_operation_init();
90003148:	ae02      	add	r6, sp, #8
9000314a:	f846 3d04 	str.w	r3, [r6, #-4]!
{
9000314e:	4604      	mov	r4, r0
90003150:	460d      	mov	r5, r1

    /* Setup the hash object for the desired hash*/
    status = psa_hash_setup(&handle, alg);
90003152:	4601      	mov	r1, r0
90003154:	4630      	mov	r0, r6
90003156:	f7ff fb8c 	bl	90002872 <psa_hash_setup>

    if (status != PSA_SUCCESS) {
9000315a:	2800      	cmp	r0, #0
9000315c:	d14b      	bne.n	900031f6 <psa_hash_test+0xb2>
        return;
    }

    /* Update object with all the chunks of message */
    for (idx=0; idx<msg_num; idx++) {
        status = psa_hash_update(&handle,
9000315e:	2219      	movs	r2, #25
90003160:	493f      	ldr	r1, [pc, #252]	; (90003260 <psa_hash_test+0x11c>)
90003162:	4630      	mov	r0, r6
90003164:	f7ff fbb2 	bl	900028cc <psa_hash_update>
                                 (const uint8_t *)msg[idx],msg_size[idx]);
        if (status != PSA_SUCCESS) {
90003168:	2800      	cmp	r0, #0
9000316a:	d154      	bne.n	90003216 <psa_hash_test+0xd2>
        status = psa_hash_update(&handle,
9000316c:	2220      	movs	r2, #32
9000316e:	493d      	ldr	r1, [pc, #244]	; (90003264 <psa_hash_test+0x120>)
90003170:	4630      	mov	r0, r6
90003172:	f7ff fbab 	bl	900028cc <psa_hash_update>
        if (status != PSA_SUCCESS) {
90003176:	2800      	cmp	r0, #0
90003178:	d14d      	bne.n	90003216 <psa_hash_test+0xd2>
            return;
        }
    }

    /* Cycle until idx points to the correct index in the algorithm table */
    for (idx=0; hash_alg[idx] != alg; idx++);
9000317a:	4b3b      	ldr	r3, [pc, #236]	; (90003268 <psa_hash_test+0x124>)
9000317c:	429c      	cmp	r4, r3
9000317e:	d150      	bne.n	90003222 <psa_hash_test+0xde>

    /* Finalise and verify that the hash is as expected */
    status = psa_hash_verify(&handle, &(hash_val[idx][0]), PSA_HASH_SIZE(alg));
90003180:	b2e2      	uxtb	r2, r4
90003182:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
90003186:	f102 437f 	add.w	r3, r2, #4278190080	; 0xff000000
9000318a:	4938      	ldr	r1, [pc, #224]	; (9000326c <psa_hash_test+0x128>)
9000318c:	3b01      	subs	r3, #1
9000318e:	2b02      	cmp	r3, #2
90003190:	eb01 1180 	add.w	r1, r1, r0, lsl #6
90003194:	d955      	bls.n	90003242 <psa_hash_test+0xfe>
90003196:	f102 437f 	add.w	r3, r2, #4278190080	; 0xff000000
9000319a:	3b04      	subs	r3, #4
9000319c:	2b01      	cmp	r3, #1
9000319e:	d952      	bls.n	90003246 <psa_hash_test+0x102>
900031a0:	4b33      	ldr	r3, [pc, #204]	; (90003270 <psa_hash_test+0x12c>)
900031a2:	429a      	cmp	r2, r3
900031a4:	d053      	beq.n	9000324e <psa_hash_test+0x10a>
900031a6:	3301      	adds	r3, #1
900031a8:	429a      	cmp	r2, r3
900031aa:	d052      	beq.n	90003252 <psa_hash_test+0x10e>
900031ac:	3301      	adds	r3, #1
900031ae:	429a      	cmp	r2, r3
900031b0:	d051      	beq.n	90003256 <psa_hash_test+0x112>
900031b2:	3301      	adds	r3, #1
900031b4:	429a      	cmp	r2, r3
900031b6:	d048      	beq.n	9000324a <psa_hash_test+0x106>
900031b8:	3301      	adds	r3, #1
900031ba:	429a      	cmp	r2, r3
900031bc:	d047      	beq.n	9000324e <psa_hash_test+0x10a>
900031be:	3301      	adds	r3, #1
900031c0:	429a      	cmp	r2, r3
900031c2:	d046      	beq.n	90003252 <psa_hash_test+0x10e>
900031c4:	3303      	adds	r3, #3
900031c6:	429a      	cmp	r2, r3
900031c8:	d041      	beq.n	9000324e <psa_hash_test+0x10a>
900031ca:	3301      	adds	r3, #1
900031cc:	429a      	cmp	r2, r3
900031ce:	d040      	beq.n	90003252 <psa_hash_test+0x10e>
900031d0:	3301      	adds	r3, #1
900031d2:	429a      	cmp	r2, r3
900031d4:	d03f      	beq.n	90003256 <psa_hash_test+0x112>
900031d6:	3301      	adds	r3, #1
900031d8:	429a      	cmp	r2, r3
900031da:	bf0c      	ite	eq
900031dc:	2240      	moveq	r2, #64	; 0x40
900031de:	2200      	movne	r2, #0
900031e0:	4630      	mov	r0, r6
900031e2:	f7ff fba3 	bl	9000292c <psa_hash_verify>
    if (status != PSA_SUCCESS) {
900031e6:	2800      	cmp	r0, #0
900031e8:	d037      	beq.n	9000325a <psa_hash_test+0x116>
        TEST_FAIL("Error verifying the hash operation object");
900031ea:	462b      	mov	r3, r5
900031ec:	f240 12d3 	movw	r2, #467	; 0x1d3
900031f0:	4920      	ldr	r1, [pc, #128]	; (90003274 <psa_hash_test+0x130>)
900031f2:	4821      	ldr	r0, [pc, #132]	; (90003278 <psa_hash_test+0x134>)
900031f4:	e00b      	b.n	9000320e <psa_hash_test+0xca>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
900031f6:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
900031f8:	462b      	mov	r3, r5
900031fa:	bf09      	itett	eq
900031fc:	f240 12bb 	movweq	r2, #443	; 0x1bb
        TEST_FAIL("Error setting up hash operation object");
90003200:	f240 12bf 	movwne	r2, #447	; 0x1bf
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90003204:	491b      	ldreq	r1, [pc, #108]	; (90003274 <psa_hash_test+0x130>)
90003206:	481d      	ldreq	r0, [pc, #116]	; (9000327c <psa_hash_test+0x138>)
        TEST_FAIL("Error setting up hash operation object");
90003208:	bf1c      	itt	ne
9000320a:	491a      	ldrne	r1, [pc, #104]	; (90003274 <psa_hash_test+0x130>)
9000320c:	481c      	ldrne	r0, [pc, #112]	; (90003280 <psa_hash_test+0x13c>)
        TEST_FAIL("Error verifying the hash operation object");
9000320e:	f000 f97b 	bl	90003508 <set_test_failed>
        return;
    }

    ret->val = TEST_PASSED;
}
90003212:	b002      	add	sp, #8
90003214:	bd70      	pop	{r4, r5, r6, pc}
            TEST_FAIL("Error updating the hash operation object");
90003216:	462b      	mov	r3, r5
90003218:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
9000321c:	4915      	ldr	r1, [pc, #84]	; (90003274 <psa_hash_test+0x130>)
9000321e:	4819      	ldr	r0, [pc, #100]	; (90003284 <psa_hash_test+0x140>)
90003220:	e7f5      	b.n	9000320e <psa_hash_test+0xca>
    for (idx=0; hash_alg[idx] != alg; idx++);
90003222:	4b13      	ldr	r3, [pc, #76]	; (90003270 <psa_hash_test+0x12c>)
90003224:	429c      	cmp	r4, r3
90003226:	d008      	beq.n	9000323a <psa_hash_test+0xf6>
90003228:	3301      	adds	r3, #1
9000322a:	429c      	cmp	r4, r3
9000322c:	d007      	beq.n	9000323e <psa_hash_test+0xfa>
9000322e:	4816      	ldr	r0, [pc, #88]	; (90003288 <psa_hash_test+0x144>)
90003230:	4284      	cmp	r4, r0
90003232:	bf0c      	ite	eq
90003234:	2003      	moveq	r0, #3
90003236:	2004      	movne	r0, #4
90003238:	e7a2      	b.n	90003180 <psa_hash_test+0x3c>
9000323a:	2001      	movs	r0, #1
9000323c:	e7a0      	b.n	90003180 <psa_hash_test+0x3c>
9000323e:	2002      	movs	r0, #2
90003240:	e79e      	b.n	90003180 <psa_hash_test+0x3c>
    status = psa_hash_verify(&handle, &(hash_val[idx][0]), PSA_HASH_SIZE(alg));
90003242:	2210      	movs	r2, #16
90003244:	e7cc      	b.n	900031e0 <psa_hash_test+0x9c>
90003246:	2214      	movs	r2, #20
90003248:	e7ca      	b.n	900031e0 <psa_hash_test+0x9c>
9000324a:	2240      	movs	r2, #64	; 0x40
9000324c:	e7c8      	b.n	900031e0 <psa_hash_test+0x9c>
9000324e:	221c      	movs	r2, #28
90003250:	e7c6      	b.n	900031e0 <psa_hash_test+0x9c>
90003252:	2220      	movs	r2, #32
90003254:	e7c4      	b.n	900031e0 <psa_hash_test+0x9c>
90003256:	2230      	movs	r2, #48	; 0x30
90003258:	e7c2      	b.n	900031e0 <psa_hash_test+0x9c>
    ret->val = TEST_PASSED;
9000325a:	7028      	strb	r0, [r5, #0]
9000325c:	e7d9      	b.n	90003212 <psa_hash_test+0xce>
9000325e:	bf00      	nop
90003260:	90005d5d 	.word	0x90005d5d
90003264:	90005d77 	.word	0x90005d77
90003268:	01000005 	.word	0x01000005
9000326c:	900056fa 	.word	0x900056fa
90003270:	01000008 	.word	0x01000008
90003274:	900056de 	.word	0x900056de
90003278:	90005b80 	.word	0x90005b80
9000327c:	90005904 	.word	0x90005904
90003280:	90005b30 	.word	0x90005b30
90003284:	90005b57 	.word	0x90005b57
90003288:	0100000a 	.word	0x0100000a

9000328c <psa_aead_test>:
}

void psa_aead_test(const psa_key_type_t key_type,
                   const psa_algorithm_t alg,
                   struct test_result_t *ret)
{
9000328c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90003290:	4614      	mov	r4, r2
    psa_key_handle_t key_handle;
    const size_t nonce_length = 12;
    const uint8_t nonce[] = "01234567890";
90003292:	4a84      	ldr	r2, [pc, #528]	; (900034a4 <psa_aead_test+0x218>)
{
90003294:	b0b3      	sub	sp, #204	; 0xcc
90003296:	4682      	mov	sl, r0
90003298:	460e      	mov	r6, r1
    const uint8_t nonce[] = "01234567890";
9000329a:	6810      	ldr	r0, [r2, #0]
9000329c:	6851      	ldr	r1, [r2, #4]
9000329e:	ab0e      	add	r3, sp, #56	; 0x38
900032a0:	c303      	stmia	r3!, {r0, r1}
900032a2:	6890      	ldr	r0, [r2, #8]
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
900032a4:	aa14      	add	r2, sp, #80	; 0x50
900032a6:	4690      	mov	r8, r2
    const uint8_t nonce[] = "01234567890";
900032a8:	6018      	str	r0, [r3, #0]
    const uint8_t plain_text[BYTE_SIZE_CHUNK] = "Sixteen bytes!!";
900032aa:	4b7f      	ldr	r3, [pc, #508]	; (900034a8 <psa_aead_test+0x21c>)
900032ac:	f103 0710 	add.w	r7, r3, #16
900032b0:	4615      	mov	r5, r2
900032b2:	6818      	ldr	r0, [r3, #0]
900032b4:	6859      	ldr	r1, [r3, #4]
900032b6:	3308      	adds	r3, #8
900032b8:	c503      	stmia	r5!, {r0, r1}
900032ba:	42bb      	cmp	r3, r7
900032bc:	462a      	mov	r2, r5
900032be:	d1f7      	bne.n	900032b0 <psa_aead_test+0x24>
    const uint8_t associated_data[ASSOCIATED_DATA_SIZE] =
900032c0:	aa1c      	add	r2, sp, #112	; 0x70
900032c2:	4691      	mov	r9, r2
900032c4:	4b79      	ldr	r3, [pc, #484]	; (900034ac <psa_aead_test+0x220>)
900032c6:	f103 0718 	add.w	r7, r3, #24
900032ca:	4615      	mov	r5, r2
900032cc:	6818      	ldr	r0, [r3, #0]
900032ce:	6859      	ldr	r1, [r3, #4]
900032d0:	3308      	adds	r3, #8
900032d2:	c503      	stmia	r5!, {r0, r1}
900032d4:	42bb      	cmp	r3, r7
900032d6:	462a      	mov	r2, r5
900032d8:	d1f7      	bne.n	900032ca <psa_aead_test+0x3e>
                                                      "This is associated data";
    uint8_t encrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
900032da:	ad22      	add	r5, sp, #136	; 0x88
900032dc:	2220      	movs	r2, #32
900032de:	2100      	movs	r1, #0
900032e0:	4628      	mov	r0, r5
900032e2:	f000 f97b 	bl	900035dc <memset>
    size_t encrypted_data_length = 0, decrypted_data_length = 0;
900032e6:	2100      	movs	r1, #0
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
900032e8:	af2a      	add	r7, sp, #168	; 0xa8
900032ea:	2220      	movs	r2, #32
900032ec:	4638      	mov	r0, r7
    size_t encrypted_data_length = 0, decrypted_data_length = 0;
900032ee:	e9cd 110a 	strd	r1, r1, [sp, #40]	; 0x28
    uint8_t decrypted_data[ENC_DEC_BUFFER_SIZE] = {0};
900032f2:	f000 f973 	bl	900035dc <memset>
    psa_status_t status;
    const uint8_t data[] = "THIS IS MY KEY1";
900032f6:	aa18      	add	r2, sp, #96	; 0x60
900032f8:	4693      	mov	fp, r2
900032fa:	4b6d      	ldr	r3, [pc, #436]	; (900034b0 <psa_aead_test+0x224>)
900032fc:	f103 0e10 	add.w	lr, r3, #16
90003300:	4694      	mov	ip, r2
90003302:	6818      	ldr	r0, [r3, #0]
90003304:	6859      	ldr	r1, [r3, #4]
90003306:	3308      	adds	r3, #8
90003308:	e8ac 0003 	stmia.w	ip!, {r0, r1}
9000330c:	4573      	cmp	r3, lr
9000330e:	4662      	mov	r2, ip
90003310:	d1f6      	bne.n	90003300 <psa_aead_test+0x74>
    psa_key_type_t type = PSA_KEY_TYPE_NONE;
90003312:	2300      	movs	r3, #0
    psa_key_usage_t usage = (PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT);

    ret->val = TEST_PASSED;

    /* Allocate a transient key */
    status = psa_allocate_key(&key_handle);
90003314:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    ret->val = TEST_PASSED;
90003318:	7023      	strb	r3, [r4, #0]
    size_t bits = 0;
9000331a:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
9000331e:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
90003322:	9313      	str	r3, [sp, #76]	; 0x4c
    status = psa_allocate_key(&key_handle);
90003324:	f7ff f8a2 	bl	9000246c <psa_allocate_key>
    if (status != PSA_SUCCESS) {
90003328:	b148      	cbz	r0, 9000333e <psa_aead_test+0xb2>
        TEST_FAIL("Failed to allocate key");
9000332a:	4623      	mov	r3, r4
9000332c:	f240 2292 	movw	r2, #658	; 0x292
90003330:	4960      	ldr	r1, [pc, #384]	; (900034b4 <psa_aead_test+0x228>)
90003332:	4861      	ldr	r0, [pc, #388]	; (900034b8 <psa_aead_test+0x22c>)

destroy_key_aead:
    /* Destroy the key */
    status = psa_destroy_key(key_handle);
    if (status != PSA_SUCCESS) {
        TEST_FAIL("Error destroying a key");
90003334:	f000 f8e8 	bl	90003508 <set_test_failed>
    }
}
90003338:	b033      	add	sp, #204	; 0xcc
9000333a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    psa_key_policy_set_usage(&policy, usage, alg);
9000333e:	f44f 7140 	mov.w	r1, #768	; 0x300
90003342:	a811      	add	r0, sp, #68	; 0x44
90003344:	4632      	mov	r2, r6
90003346:	f7ff f93e 	bl	900025c6 <psa_key_policy_set_usage>
    status = psa_set_key_policy(key_handle, &policy);
9000334a:	a911      	add	r1, sp, #68	; 0x44
9000334c:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
90003350:	f7ff f93c 	bl	900025cc <psa_set_key_policy>
    if (status != PSA_SUCCESS) {
90003354:	b190      	cbz	r0, 9000337c <psa_aead_test+0xf0>
        TEST_FAIL("Failed to set key policy");
90003356:	4623      	mov	r3, r4
90003358:	f240 229a 	movw	r2, #666	; 0x29a
9000335c:	4955      	ldr	r1, [pc, #340]	; (900034b4 <psa_aead_test+0x228>)
9000335e:	4857      	ldr	r0, [pc, #348]	; (900034bc <psa_aead_test+0x230>)
        TEST_FAIL("Decrypted data doesn't match with plain text");
90003360:	f000 f8d2 	bl	90003508 <set_test_failed>
    status = psa_destroy_key(key_handle);
90003364:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
90003368:	f7ff f8d4 	bl	90002514 <psa_destroy_key>
    if (status != PSA_SUCCESS) {
9000336c:	2800      	cmp	r0, #0
9000336e:	d0e3      	beq.n	90003338 <psa_aead_test+0xac>
        TEST_FAIL("Error destroying a key");
90003370:	4623      	mov	r3, r4
90003372:	f240 22f7 	movw	r2, #759	; 0x2f7
90003376:	494f      	ldr	r1, [pc, #316]	; (900034b4 <psa_aead_test+0x228>)
90003378:	4851      	ldr	r0, [pc, #324]	; (900034c0 <psa_aead_test+0x234>)
9000337a:	e7db      	b.n	90003334 <psa_aead_test+0xa8>
    status = psa_import_key(key_handle, key_type, data, sizeof(data));
9000337c:	2310      	movs	r3, #16
9000337e:	465a      	mov	r2, fp
90003380:	4651      	mov	r1, sl
90003382:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
90003386:	f7ff f898 	bl	900024ba <psa_import_key>
    if (status != PSA_SUCCESS) {
9000338a:	b128      	cbz	r0, 90003398 <psa_aead_test+0x10c>
        TEST_FAIL("Error importing a key");
9000338c:	4623      	mov	r3, r4
9000338e:	f240 22a1 	movw	r2, #673	; 0x2a1
90003392:	4948      	ldr	r1, [pc, #288]	; (900034b4 <psa_aead_test+0x228>)
90003394:	484b      	ldr	r0, [pc, #300]	; (900034c4 <psa_aead_test+0x238>)
90003396:	e7e3      	b.n	90003360 <psa_aead_test+0xd4>
    status = psa_get_key_information(key_handle, &type, &bits);
90003398:	aa0d      	add	r2, sp, #52	; 0x34
9000339a:	a90c      	add	r1, sp, #48	; 0x30
9000339c:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
900033a0:	f7ff f8e0 	bl	90002564 <psa_get_key_information>
    if (status != PSA_SUCCESS) {
900033a4:	b128      	cbz	r0, 900033b2 <psa_aead_test+0x126>
        TEST_FAIL("Error getting key metadata");
900033a6:	4623      	mov	r3, r4
900033a8:	f240 22a7 	movw	r2, #679	; 0x2a7
900033ac:	4941      	ldr	r1, [pc, #260]	; (900034b4 <psa_aead_test+0x228>)
900033ae:	4846      	ldr	r0, [pc, #280]	; (900034c8 <psa_aead_test+0x23c>)
900033b0:	e7d6      	b.n	90003360 <psa_aead_test+0xd4>
    if (bits != BIT_SIZE_TEST_KEY) {
900033b2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
900033b4:	2b80      	cmp	r3, #128	; 0x80
900033b6:	d005      	beq.n	900033c4 <psa_aead_test+0x138>
        TEST_FAIL("The number of key bits is different from expected");
900033b8:	4623      	mov	r3, r4
900033ba:	f44f 722b 	mov.w	r2, #684	; 0x2ac
900033be:	493d      	ldr	r1, [pc, #244]	; (900034b4 <psa_aead_test+0x228>)
900033c0:	4842      	ldr	r0, [pc, #264]	; (900034cc <psa_aead_test+0x240>)
900033c2:	e7cd      	b.n	90003360 <psa_aead_test+0xd4>
    if (type != key_type) {
900033c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
900033c6:	4553      	cmp	r3, sl
900033c8:	d005      	beq.n	900033d6 <psa_aead_test+0x14a>
        TEST_FAIL("The type of the key is different from expected");
900033ca:	4623      	mov	r3, r4
900033cc:	f240 22b1 	movw	r2, #689	; 0x2b1
900033d0:	4938      	ldr	r1, [pc, #224]	; (900034b4 <psa_aead_test+0x228>)
900033d2:	483f      	ldr	r0, [pc, #252]	; (900034d0 <psa_aead_test+0x244>)
900033d4:	e7c4      	b.n	90003360 <psa_aead_test+0xd4>
    status = psa_aead_encrypt(key_handle, alg, nonce, nonce_length,
900033d6:	ab0a      	add	r3, sp, #40	; 0x28
900033d8:	9306      	str	r3, [sp, #24]
900033da:	2320      	movs	r3, #32
900033dc:	e9cd 5304 	strd	r5, r3, [sp, #16]
900033e0:	2310      	movs	r3, #16
900033e2:	e9cd 8302 	strd	r8, r3, [sp, #8]
900033e6:	2318      	movs	r3, #24
900033e8:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
900033ec:	e9cd 9300 	strd	r9, r3, [sp]
900033f0:	aa0e      	add	r2, sp, #56	; 0x38
900033f2:	230c      	movs	r3, #12
900033f4:	4631      	mov	r1, r6
900033f6:	f7ff fac9 	bl	9000298c <psa_aead_encrypt>
    if (status != PSA_SUCCESS) {
900033fa:	b160      	cbz	r0, 90003416 <psa_aead_test+0x18a>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
900033fc:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
900033fe:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
90003400:	d104      	bne.n	9000340c <psa_aead_test+0x180>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90003402:	f240 22c1 	movw	r2, #705	; 0x2c1
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90003406:	492b      	ldr	r1, [pc, #172]	; (900034b4 <psa_aead_test+0x228>)
90003408:	4832      	ldr	r0, [pc, #200]	; (900034d4 <psa_aead_test+0x248>)
9000340a:	e7a9      	b.n	90003360 <psa_aead_test+0xd4>
        TEST_FAIL("Error performing AEAD encryption");
9000340c:	f240 22c5 	movw	r2, #709	; 0x2c5
90003410:	4928      	ldr	r1, [pc, #160]	; (900034b4 <psa_aead_test+0x228>)
90003412:	4831      	ldr	r0, [pc, #196]	; (900034d8 <psa_aead_test+0x24c>)
90003414:	e7a4      	b.n	90003360 <psa_aead_test+0xd4>
        != PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, sizeof(plain_text))) {
90003416:	f006 43fe 	and.w	r3, r6, #2130706432	; 0x7f000000
9000341a:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
9000341e:	d10c      	bne.n	9000343a <psa_aead_test+0x1ae>
90003420:	f3c6 2305 	ubfx	r3, r6, #8, #6
90003424:	b103      	cbz	r3, 90003428 <psa_aead_test+0x19c>
90003426:	3310      	adds	r3, #16
90003428:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    if (encrypted_data_length
9000342a:	429a      	cmp	r2, r3
9000342c:	d007      	beq.n	9000343e <psa_aead_test+0x1b2>
        TEST_FAIL("Encrypted data length is different than expected");
9000342e:	4623      	mov	r3, r4
90003430:	f240 22cb 	movw	r2, #715	; 0x2cb
90003434:	491f      	ldr	r1, [pc, #124]	; (900034b4 <psa_aead_test+0x228>)
90003436:	4829      	ldr	r0, [pc, #164]	; (900034dc <psa_aead_test+0x250>)
90003438:	e792      	b.n	90003360 <psa_aead_test+0xd4>
        != PSA_AEAD_ENCRYPT_OUTPUT_SIZE(alg, sizeof(plain_text))) {
9000343a:	4603      	mov	r3, r0
9000343c:	e7f4      	b.n	90003428 <psa_aead_test+0x19c>
    status = psa_aead_decrypt(key_handle, alg, nonce, nonce_length,
9000343e:	aa0b      	add	r2, sp, #44	; 0x2c
90003440:	9206      	str	r2, [sp, #24]
90003442:	e9cd 5302 	strd	r5, r3, [sp, #8]
90003446:	2220      	movs	r2, #32
90003448:	2318      	movs	r3, #24
9000344a:	e9cd 7204 	strd	r7, r2, [sp, #16]
9000344e:	e9cd 9300 	strd	r9, r3, [sp]
90003452:	f8bd 0026 	ldrh.w	r0, [sp, #38]	; 0x26
90003456:	230c      	movs	r3, #12
90003458:	aa0e      	add	r2, sp, #56	; 0x38
9000345a:	4631      	mov	r1, r6
9000345c:	f7ff faec 	bl	90002a38 <psa_aead_decrypt>
    if (status != PSA_SUCCESS) {
90003460:	b150      	cbz	r0, 90003478 <psa_aead_test+0x1ec>
        if (status == PSA_ERROR_NOT_SUPPORTED) {
90003462:	3086      	adds	r0, #134	; 0x86
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90003464:	4623      	mov	r3, r4
        if (status == PSA_ERROR_NOT_SUPPORTED) {
90003466:	d102      	bne.n	9000346e <psa_aead_test+0x1e2>
            TEST_FAIL("Algorithm NOT SUPPORTED by the implementation");
90003468:	f240 22db 	movw	r2, #731	; 0x2db
9000346c:	e7cb      	b.n	90003406 <psa_aead_test+0x17a>
            TEST_FAIL("Error performing AEAD decryption");
9000346e:	f240 22dd 	movw	r2, #733	; 0x2dd
90003472:	4910      	ldr	r1, [pc, #64]	; (900034b4 <psa_aead_test+0x228>)
90003474:	481a      	ldr	r0, [pc, #104]	; (900034e0 <psa_aead_test+0x254>)
90003476:	e773      	b.n	90003360 <psa_aead_test+0xd4>
    if (sizeof(plain_text) != decrypted_data_length) {
90003478:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
9000347a:	2a10      	cmp	r2, #16
9000347c:	d005      	beq.n	9000348a <psa_aead_test+0x1fe>
        TEST_FAIL("Decrypted data length is different from plain text");
9000347e:	4623      	mov	r3, r4
90003480:	f44f 7239 	mov.w	r2, #740	; 0x2e4
90003484:	490b      	ldr	r1, [pc, #44]	; (900034b4 <psa_aead_test+0x228>)
90003486:	4817      	ldr	r0, [pc, #92]	; (900034e4 <psa_aead_test+0x258>)
90003488:	e76a      	b.n	90003360 <psa_aead_test+0xd4>
9000348a:	4639      	mov	r1, r7
9000348c:	4640      	mov	r0, r8
9000348e:	f000 f88b 	bl	900035a8 <memcmp>
    if (comp_result != 0) {
90003492:	2800      	cmp	r0, #0
90003494:	f43f af66 	beq.w	90003364 <psa_aead_test+0xd8>
        TEST_FAIL("Decrypted data doesn't match with plain text");
90003498:	4623      	mov	r3, r4
9000349a:	f240 22ef 	movw	r2, #751	; 0x2ef
9000349e:	4905      	ldr	r1, [pc, #20]	; (900034b4 <psa_aead_test+0x228>)
900034a0:	4811      	ldr	r0, [pc, #68]	; (900034e8 <psa_aead_test+0x25c>)
900034a2:	e75d      	b.n	90003360 <psa_aead_test+0xd4>
900034a4:	900058e0 	.word	0x900058e0
900034a8:	90005b20 	.word	0x90005b20
900034ac:	900058ec 	.word	0x900058ec
900034b0:	90005d4d 	.word	0x90005d4d
900034b4:	900056ec 	.word	0x900056ec
900034b8:	90005baa 	.word	0x90005baa
900034bc:	90005bc1 	.word	0x90005bc1
900034c0:	90005af9 	.word	0x90005af9
900034c4:	90005c07 	.word	0x90005c07
900034c8:	90005c1d 	.word	0x90005c1d
900034cc:	90005c38 	.word	0x90005c38
900034d0:	90005c6a 	.word	0x90005c6a
900034d4:	90005904 	.word	0x90005904
900034d8:	9000583a 	.word	0x9000583a
900034dc:	9000585b 	.word	0x9000585b
900034e0:	9000588c 	.word	0x9000588c
900034e4:	900058ad 	.word	0x900058ad
900034e8:	90005a9e 	.word	0x90005a9e

900034ec <print_error>:

    printf("  TEST FAILED!\r\n");
}

static void print_error(const char *err_msg)
{
900034ec:	b510      	push	{r4, lr}
900034ee:	4604      	mov	r4, r0
    printf_set_color(RED);
900034f0:	2001      	movs	r0, #1
900034f2:	f000 f81b 	bl	9000352c <printf_set_color>
    printf("Error ( %s )\r\n", err_msg);
900034f6:	4621      	mov	r1, r4
}
900034f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    printf("Error ( %s )\r\n", err_msg);
900034fc:	4801      	ldr	r0, [pc, #4]	; (90003504 <print_error+0x18>)
900034fe:	f000 b875 	b.w	900035ec <iprintf>
90003502:	bf00      	nop
90003504:	90005db9 	.word	0x90005db9

90003508 <set_test_failed>:
    return TEST_SUITE_ERR_NO_ERROR;
}

void set_test_failed(const char *info_msg, const char *filename, uint32_t line,
                     struct test_result_t *ret)
{
90003508:	b410      	push	{r4}
    if (ret == 0) {
9000350a:	b923      	cbnz	r3, 90003516 <set_test_failed+0xe>
        print_error("TEST_SUITE_ERR_INVALID_TEST_DATA!");
9000350c:	4806      	ldr	r0, [pc, #24]	; (90003528 <set_test_failed+0x20>)

    ret->val = TEST_FAILED;
    ret->info_msg = info_msg;
    ret->filename = filename;
    ret->line = line;
}
9000350e:	f85d 4b04 	ldr.w	r4, [sp], #4
        print_error("TEST_SUITE_ERR_INVALID_TEST_DATA!");
90003512:	f7ff bfeb 	b.w	900034ec <print_error>
    ret->val = TEST_FAILED;
90003516:	2401      	movs	r4, #1
    ret->filename = filename;
90003518:	e9c3 0101 	strd	r0, r1, [r3, #4]
    ret->val = TEST_FAILED;
9000351c:	701c      	strb	r4, [r3, #0]
    ret->line = line;
9000351e:	60da      	str	r2, [r3, #12]
}
90003520:	f85d 4b04 	ldr.w	r4, [sp], #4
90003524:	4770      	bx	lr
90003526:	bf00      	nop
90003528:	90005dc8 	.word	0x90005dc8

9000352c <printf_set_color>:
    }
}

void printf_set_color(enum serial_color_t color_id)
{
    printf("\33[3%dm", color_id);
9000352c:	4601      	mov	r1, r0
9000352e:	4801      	ldr	r0, [pc, #4]	; (90003534 <printf_set_color+0x8>)
90003530:	f000 b85c 	b.w	900035ec <iprintf>
90003534:	90005dea 	.word	0x90005dea

90003538 <exit>:
90003538:	b508      	push	{r3, lr}
9000353a:	4b07      	ldr	r3, [pc, #28]	; (90003558 <exit+0x20>)
9000353c:	4604      	mov	r4, r0
9000353e:	b113      	cbz	r3, 90003546 <exit+0xe>
90003540:	2100      	movs	r1, #0
90003542:	e000      	b.n	90003546 <exit+0xe>
90003544:	bf00      	nop
90003546:	4b05      	ldr	r3, [pc, #20]	; (9000355c <exit+0x24>)
90003548:	6818      	ldr	r0, [r3, #0]
9000354a:	6a83      	ldr	r3, [r0, #40]	; 0x28
9000354c:	b103      	cbz	r3, 90003550 <exit+0x18>
9000354e:	4798      	blx	r3
90003550:	4620      	mov	r0, r4
90003552:	f001 fa27 	bl	900049a4 <_exit>
90003556:	bf00      	nop
90003558:	00000000 	.word	0x00000000
9000355c:	90005df4 	.word	0x90005df4

90003560 <__libc_init_array>:
90003560:	b570      	push	{r4, r5, r6, lr}
90003562:	4e0d      	ldr	r6, [pc, #52]	; (90003598 <__libc_init_array+0x38>)
90003564:	2500      	movs	r5, #0
90003566:	4c0d      	ldr	r4, [pc, #52]	; (9000359c <__libc_init_array+0x3c>)
90003568:	1ba4      	subs	r4, r4, r6
9000356a:	10a4      	asrs	r4, r4, #2
9000356c:	42a5      	cmp	r5, r4
9000356e:	d109      	bne.n	90003584 <__libc_init_array+0x24>
90003570:	4e0b      	ldr	r6, [pc, #44]	; (900035a0 <__libc_init_array+0x40>)
90003572:	2500      	movs	r5, #0
90003574:	4c0b      	ldr	r4, [pc, #44]	; (900035a4 <__libc_init_array+0x44>)
90003576:	f001 fa17 	bl	900049a8 <_init>
9000357a:	1ba4      	subs	r4, r4, r6
9000357c:	10a4      	asrs	r4, r4, #2
9000357e:	42a5      	cmp	r5, r4
90003580:	d105      	bne.n	9000358e <__libc_init_array+0x2e>
90003582:	bd70      	pop	{r4, r5, r6, pc}
90003584:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
90003588:	3501      	adds	r5, #1
9000358a:	4798      	blx	r3
9000358c:	e7ee      	b.n	9000356c <__libc_init_array+0xc>
9000358e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
90003592:	3501      	adds	r5, #1
90003594:	4798      	blx	r3
90003596:	e7f2      	b.n	9000357e <__libc_init_array+0x1e>
90003598:	2000018c 	.word	0x2000018c
9000359c:	2000018c 	.word	0x2000018c
900035a0:	2000018c 	.word	0x2000018c
900035a4:	20000190 	.word	0x20000190

900035a8 <memcmp>:
900035a8:	b530      	push	{r4, r5, lr}
900035aa:	2400      	movs	r4, #0
900035ac:	42a2      	cmp	r2, r4
900035ae:	d101      	bne.n	900035b4 <memcmp+0xc>
900035b0:	2000      	movs	r0, #0
900035b2:	e007      	b.n	900035c4 <memcmp+0x1c>
900035b4:	5d03      	ldrb	r3, [r0, r4]
900035b6:	3401      	adds	r4, #1
900035b8:	190d      	adds	r5, r1, r4
900035ba:	f815 5c01 	ldrb.w	r5, [r5, #-1]
900035be:	42ab      	cmp	r3, r5
900035c0:	d0f4      	beq.n	900035ac <memcmp+0x4>
900035c2:	1b58      	subs	r0, r3, r5
900035c4:	bd30      	pop	{r4, r5, pc}

900035c6 <memcpy>:
900035c6:	1e43      	subs	r3, r0, #1
900035c8:	440a      	add	r2, r1
900035ca:	b510      	push	{r4, lr}
900035cc:	4291      	cmp	r1, r2
900035ce:	d100      	bne.n	900035d2 <memcpy+0xc>
900035d0:	bd10      	pop	{r4, pc}
900035d2:	f811 4b01 	ldrb.w	r4, [r1], #1
900035d6:	f803 4f01 	strb.w	r4, [r3, #1]!
900035da:	e7f7      	b.n	900035cc <memcpy+0x6>

900035dc <memset>:
900035dc:	4402      	add	r2, r0
900035de:	4603      	mov	r3, r0
900035e0:	4293      	cmp	r3, r2
900035e2:	d100      	bne.n	900035e6 <memset+0xa>
900035e4:	4770      	bx	lr
900035e6:	f803 1b01 	strb.w	r1, [r3], #1
900035ea:	e7f9      	b.n	900035e0 <memset+0x4>

900035ec <iprintf>:
900035ec:	b40f      	push	{r0, r1, r2, r3}
900035ee:	4b0a      	ldr	r3, [pc, #40]	; (90003618 <iprintf+0x2c>)
900035f0:	b513      	push	{r0, r1, r4, lr}
900035f2:	681c      	ldr	r4, [r3, #0]
900035f4:	b124      	cbz	r4, 90003600 <iprintf+0x14>
900035f6:	69a3      	ldr	r3, [r4, #24]
900035f8:	b913      	cbnz	r3, 90003600 <iprintf+0x14>
900035fa:	4620      	mov	r0, r4
900035fc:	f000 fade 	bl	90003bbc <__sinit>
90003600:	ab05      	add	r3, sp, #20
90003602:	9a04      	ldr	r2, [sp, #16]
90003604:	68a1      	ldr	r1, [r4, #8]
90003606:	4620      	mov	r0, r4
90003608:	9301      	str	r3, [sp, #4]
9000360a:	f000 fc9f 	bl	90003f4c <_vfiprintf_r>
9000360e:	b002      	add	sp, #8
90003610:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
90003614:	b004      	add	sp, #16
90003616:	4770      	bx	lr
90003618:	20000128 	.word	0x20000128

9000361c <_puts_r>:
9000361c:	b570      	push	{r4, r5, r6, lr}
9000361e:	460e      	mov	r6, r1
90003620:	4605      	mov	r5, r0
90003622:	b118      	cbz	r0, 9000362c <_puts_r+0x10>
90003624:	6983      	ldr	r3, [r0, #24]
90003626:	b90b      	cbnz	r3, 9000362c <_puts_r+0x10>
90003628:	f000 fac8 	bl	90003bbc <__sinit>
9000362c:	69ab      	ldr	r3, [r5, #24]
9000362e:	68ac      	ldr	r4, [r5, #8]
90003630:	b913      	cbnz	r3, 90003638 <_puts_r+0x1c>
90003632:	4628      	mov	r0, r5
90003634:	f000 fac2 	bl	90003bbc <__sinit>
90003638:	4b23      	ldr	r3, [pc, #140]	; (900036c8 <_puts_r+0xac>)
9000363a:	429c      	cmp	r4, r3
9000363c:	d117      	bne.n	9000366e <_puts_r+0x52>
9000363e:	686c      	ldr	r4, [r5, #4]
90003640:	89a3      	ldrh	r3, [r4, #12]
90003642:	071b      	lsls	r3, r3, #28
90003644:	d51d      	bpl.n	90003682 <_puts_r+0x66>
90003646:	6923      	ldr	r3, [r4, #16]
90003648:	b1db      	cbz	r3, 90003682 <_puts_r+0x66>
9000364a:	3e01      	subs	r6, #1
9000364c:	68a3      	ldr	r3, [r4, #8]
9000364e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
90003652:	3b01      	subs	r3, #1
90003654:	60a3      	str	r3, [r4, #8]
90003656:	b9e9      	cbnz	r1, 90003694 <_puts_r+0x78>
90003658:	2b00      	cmp	r3, #0
9000365a:	da2e      	bge.n	900036ba <_puts_r+0x9e>
9000365c:	4622      	mov	r2, r4
9000365e:	210a      	movs	r1, #10
90003660:	4628      	mov	r0, r5
90003662:	f000 f8fd 	bl	90003860 <__swbuf_r>
90003666:	3001      	adds	r0, #1
90003668:	d011      	beq.n	9000368e <_puts_r+0x72>
9000366a:	200a      	movs	r0, #10
9000366c:	e011      	b.n	90003692 <_puts_r+0x76>
9000366e:	4b17      	ldr	r3, [pc, #92]	; (900036cc <_puts_r+0xb0>)
90003670:	429c      	cmp	r4, r3
90003672:	d101      	bne.n	90003678 <_puts_r+0x5c>
90003674:	68ac      	ldr	r4, [r5, #8]
90003676:	e7e3      	b.n	90003640 <_puts_r+0x24>
90003678:	4b15      	ldr	r3, [pc, #84]	; (900036d0 <_puts_r+0xb4>)
9000367a:	429c      	cmp	r4, r3
9000367c:	bf08      	it	eq
9000367e:	68ec      	ldreq	r4, [r5, #12]
90003680:	e7de      	b.n	90003640 <_puts_r+0x24>
90003682:	4621      	mov	r1, r4
90003684:	4628      	mov	r0, r5
90003686:	f000 f93d 	bl	90003904 <__swsetup_r>
9000368a:	2800      	cmp	r0, #0
9000368c:	d0dd      	beq.n	9000364a <_puts_r+0x2e>
9000368e:	f04f 30ff 	mov.w	r0, #4294967295
90003692:	bd70      	pop	{r4, r5, r6, pc}
90003694:	2b00      	cmp	r3, #0
90003696:	da04      	bge.n	900036a2 <_puts_r+0x86>
90003698:	69a2      	ldr	r2, [r4, #24]
9000369a:	429a      	cmp	r2, r3
9000369c:	dc06      	bgt.n	900036ac <_puts_r+0x90>
9000369e:	290a      	cmp	r1, #10
900036a0:	d004      	beq.n	900036ac <_puts_r+0x90>
900036a2:	6823      	ldr	r3, [r4, #0]
900036a4:	1c5a      	adds	r2, r3, #1
900036a6:	6022      	str	r2, [r4, #0]
900036a8:	7019      	strb	r1, [r3, #0]
900036aa:	e7cf      	b.n	9000364c <_puts_r+0x30>
900036ac:	4622      	mov	r2, r4
900036ae:	4628      	mov	r0, r5
900036b0:	f000 f8d6 	bl	90003860 <__swbuf_r>
900036b4:	3001      	adds	r0, #1
900036b6:	d1c9      	bne.n	9000364c <_puts_r+0x30>
900036b8:	e7e9      	b.n	9000368e <_puts_r+0x72>
900036ba:	6823      	ldr	r3, [r4, #0]
900036bc:	200a      	movs	r0, #10
900036be:	1c5a      	adds	r2, r3, #1
900036c0:	6022      	str	r2, [r4, #0]
900036c2:	7018      	strb	r0, [r3, #0]
900036c4:	e7e5      	b.n	90003692 <_puts_r+0x76>
900036c6:	bf00      	nop
900036c8:	90005e18 	.word	0x90005e18
900036cc:	90005e38 	.word	0x90005e38
900036d0:	90005df8 	.word	0x90005df8

900036d4 <puts>:
900036d4:	4b02      	ldr	r3, [pc, #8]	; (900036e0 <puts+0xc>)
900036d6:	4601      	mov	r1, r0
900036d8:	6818      	ldr	r0, [r3, #0]
900036da:	f7ff bf9f 	b.w	9000361c <_puts_r>
900036de:	bf00      	nop
900036e0:	20000128 	.word	0x20000128

900036e4 <setvbuf>:
900036e4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
900036e8:	461d      	mov	r5, r3
900036ea:	4b50      	ldr	r3, [pc, #320]	; (9000382c <setvbuf+0x148>)
900036ec:	4604      	mov	r4, r0
900036ee:	460f      	mov	r7, r1
900036f0:	681e      	ldr	r6, [r3, #0]
900036f2:	4690      	mov	r8, r2
900036f4:	b126      	cbz	r6, 90003700 <setvbuf+0x1c>
900036f6:	69b3      	ldr	r3, [r6, #24]
900036f8:	b913      	cbnz	r3, 90003700 <setvbuf+0x1c>
900036fa:	4630      	mov	r0, r6
900036fc:	f000 fa5e 	bl	90003bbc <__sinit>
90003700:	4b4b      	ldr	r3, [pc, #300]	; (90003830 <setvbuf+0x14c>)
90003702:	429c      	cmp	r4, r3
90003704:	d152      	bne.n	900037ac <setvbuf+0xc8>
90003706:	6874      	ldr	r4, [r6, #4]
90003708:	f1b8 0f02 	cmp.w	r8, #2
9000370c:	d006      	beq.n	9000371c <setvbuf+0x38>
9000370e:	f1b8 0f01 	cmp.w	r8, #1
90003712:	f200 8088 	bhi.w	90003826 <setvbuf+0x142>
90003716:	2d00      	cmp	r5, #0
90003718:	f2c0 8085 	blt.w	90003826 <setvbuf+0x142>
9000371c:	4621      	mov	r1, r4
9000371e:	4630      	mov	r0, r6
90003720:	f000 f9e2 	bl	90003ae8 <_fflush_r>
90003724:	6b61      	ldr	r1, [r4, #52]	; 0x34
90003726:	b141      	cbz	r1, 9000373a <setvbuf+0x56>
90003728:	f104 0344 	add.w	r3, r4, #68	; 0x44
9000372c:	4299      	cmp	r1, r3
9000372e:	d002      	beq.n	90003736 <setvbuf+0x52>
90003730:	4630      	mov	r0, r6
90003732:	f000 fb39 	bl	90003da8 <_free_r>
90003736:	2300      	movs	r3, #0
90003738:	6363      	str	r3, [r4, #52]	; 0x34
9000373a:	2300      	movs	r3, #0
9000373c:	61a3      	str	r3, [r4, #24]
9000373e:	6063      	str	r3, [r4, #4]
90003740:	89a3      	ldrh	r3, [r4, #12]
90003742:	061b      	lsls	r3, r3, #24
90003744:	d503      	bpl.n	9000374e <setvbuf+0x6a>
90003746:	6921      	ldr	r1, [r4, #16]
90003748:	4630      	mov	r0, r6
9000374a:	f000 fb2d 	bl	90003da8 <_free_r>
9000374e:	89a3      	ldrh	r3, [r4, #12]
90003750:	f1b8 0f02 	cmp.w	r8, #2
90003754:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
90003758:	f023 0303 	bic.w	r3, r3, #3
9000375c:	81a3      	strh	r3, [r4, #12]
9000375e:	d05c      	beq.n	9000381a <setvbuf+0x136>
90003760:	ab01      	add	r3, sp, #4
90003762:	466a      	mov	r2, sp
90003764:	4621      	mov	r1, r4
90003766:	4630      	mov	r0, r6
90003768:	f000 fab2 	bl	90003cd0 <__swhatbuf_r>
9000376c:	89a3      	ldrh	r3, [r4, #12]
9000376e:	4318      	orrs	r0, r3
90003770:	81a0      	strh	r0, [r4, #12]
90003772:	bb2d      	cbnz	r5, 900037c0 <setvbuf+0xdc>
90003774:	9d00      	ldr	r5, [sp, #0]
90003776:	4628      	mov	r0, r5
90003778:	f000 fb0e 	bl	90003d98 <malloc>
9000377c:	4607      	mov	r7, r0
9000377e:	2800      	cmp	r0, #0
90003780:	d14d      	bne.n	9000381e <setvbuf+0x13a>
90003782:	f8dd 9000 	ldr.w	r9, [sp]
90003786:	45a9      	cmp	r9, r5
90003788:	d13b      	bne.n	90003802 <setvbuf+0x11e>
9000378a:	f04f 30ff 	mov.w	r0, #4294967295
9000378e:	89a3      	ldrh	r3, [r4, #12]
90003790:	f043 0302 	orr.w	r3, r3, #2
90003794:	81a3      	strh	r3, [r4, #12]
90003796:	2300      	movs	r3, #0
90003798:	60a3      	str	r3, [r4, #8]
9000379a:	f104 0347 	add.w	r3, r4, #71	; 0x47
9000379e:	6023      	str	r3, [r4, #0]
900037a0:	6123      	str	r3, [r4, #16]
900037a2:	2301      	movs	r3, #1
900037a4:	6163      	str	r3, [r4, #20]
900037a6:	b003      	add	sp, #12
900037a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
900037ac:	4b21      	ldr	r3, [pc, #132]	; (90003834 <setvbuf+0x150>)
900037ae:	429c      	cmp	r4, r3
900037b0:	d101      	bne.n	900037b6 <setvbuf+0xd2>
900037b2:	68b4      	ldr	r4, [r6, #8]
900037b4:	e7a8      	b.n	90003708 <setvbuf+0x24>
900037b6:	4b20      	ldr	r3, [pc, #128]	; (90003838 <setvbuf+0x154>)
900037b8:	429c      	cmp	r4, r3
900037ba:	bf08      	it	eq
900037bc:	68f4      	ldreq	r4, [r6, #12]
900037be:	e7a3      	b.n	90003708 <setvbuf+0x24>
900037c0:	2f00      	cmp	r7, #0
900037c2:	d0d8      	beq.n	90003776 <setvbuf+0x92>
900037c4:	69b3      	ldr	r3, [r6, #24]
900037c6:	b913      	cbnz	r3, 900037ce <setvbuf+0xea>
900037c8:	4630      	mov	r0, r6
900037ca:	f000 f9f7 	bl	90003bbc <__sinit>
900037ce:	f1b8 0f01 	cmp.w	r8, #1
900037d2:	6027      	str	r7, [r4, #0]
900037d4:	bf02      	ittt	eq
900037d6:	89a3      	ldrheq	r3, [r4, #12]
900037d8:	f043 0301 	orreq.w	r3, r3, #1
900037dc:	81a3      	strheq	r3, [r4, #12]
900037de:	89a3      	ldrh	r3, [r4, #12]
900037e0:	f013 0008 	ands.w	r0, r3, #8
900037e4:	e9c4 7504 	strd	r7, r5, [r4, #16]
900037e8:	d01b      	beq.n	90003822 <setvbuf+0x13e>
900037ea:	f013 0001 	ands.w	r0, r3, #1
900037ee:	f04f 0300 	mov.w	r3, #0
900037f2:	bf1d      	ittte	ne
900037f4:	426d      	negne	r5, r5
900037f6:	60a3      	strne	r3, [r4, #8]
900037f8:	4618      	movne	r0, r3
900037fa:	60a5      	streq	r5, [r4, #8]
900037fc:	bf18      	it	ne
900037fe:	61a5      	strne	r5, [r4, #24]
90003800:	e7d1      	b.n	900037a6 <setvbuf+0xc2>
90003802:	4648      	mov	r0, r9
90003804:	f000 fac8 	bl	90003d98 <malloc>
90003808:	4607      	mov	r7, r0
9000380a:	2800      	cmp	r0, #0
9000380c:	d0bd      	beq.n	9000378a <setvbuf+0xa6>
9000380e:	89a3      	ldrh	r3, [r4, #12]
90003810:	464d      	mov	r5, r9
90003812:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90003816:	81a3      	strh	r3, [r4, #12]
90003818:	e7d4      	b.n	900037c4 <setvbuf+0xe0>
9000381a:	2000      	movs	r0, #0
9000381c:	e7b7      	b.n	9000378e <setvbuf+0xaa>
9000381e:	46a9      	mov	r9, r5
90003820:	e7f5      	b.n	9000380e <setvbuf+0x12a>
90003822:	60a0      	str	r0, [r4, #8]
90003824:	e7bf      	b.n	900037a6 <setvbuf+0xc2>
90003826:	f04f 30ff 	mov.w	r0, #4294967295
9000382a:	e7bc      	b.n	900037a6 <setvbuf+0xc2>
9000382c:	20000128 	.word	0x20000128
90003830:	90005e18 	.word	0x90005e18
90003834:	90005e38 	.word	0x90005e38
90003838:	90005df8 	.word	0x90005df8

9000383c <strncmp>:
9000383c:	b510      	push	{r4, lr}
9000383e:	b16a      	cbz	r2, 9000385c <strncmp+0x20>
90003840:	3901      	subs	r1, #1
90003842:	1884      	adds	r4, r0, r2
90003844:	f810 3b01 	ldrb.w	r3, [r0], #1
90003848:	f811 2f01 	ldrb.w	r2, [r1, #1]!
9000384c:	4293      	cmp	r3, r2
9000384e:	d103      	bne.n	90003858 <strncmp+0x1c>
90003850:	42a0      	cmp	r0, r4
90003852:	d001      	beq.n	90003858 <strncmp+0x1c>
90003854:	2b00      	cmp	r3, #0
90003856:	d1f5      	bne.n	90003844 <strncmp+0x8>
90003858:	1a98      	subs	r0, r3, r2
9000385a:	bd10      	pop	{r4, pc}
9000385c:	4610      	mov	r0, r2
9000385e:	e7fc      	b.n	9000385a <strncmp+0x1e>

90003860 <__swbuf_r>:
90003860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90003862:	460e      	mov	r6, r1
90003864:	4614      	mov	r4, r2
90003866:	4605      	mov	r5, r0
90003868:	b118      	cbz	r0, 90003872 <__swbuf_r+0x12>
9000386a:	6983      	ldr	r3, [r0, #24]
9000386c:	b90b      	cbnz	r3, 90003872 <__swbuf_r+0x12>
9000386e:	f000 f9a5 	bl	90003bbc <__sinit>
90003872:	4b21      	ldr	r3, [pc, #132]	; (900038f8 <__swbuf_r+0x98>)
90003874:	429c      	cmp	r4, r3
90003876:	d12a      	bne.n	900038ce <__swbuf_r+0x6e>
90003878:	686c      	ldr	r4, [r5, #4]
9000387a:	69a3      	ldr	r3, [r4, #24]
9000387c:	60a3      	str	r3, [r4, #8]
9000387e:	89a3      	ldrh	r3, [r4, #12]
90003880:	071a      	lsls	r2, r3, #28
90003882:	d52e      	bpl.n	900038e2 <__swbuf_r+0x82>
90003884:	6923      	ldr	r3, [r4, #16]
90003886:	b363      	cbz	r3, 900038e2 <__swbuf_r+0x82>
90003888:	6923      	ldr	r3, [r4, #16]
9000388a:	b2f6      	uxtb	r6, r6
9000388c:	6820      	ldr	r0, [r4, #0]
9000388e:	4637      	mov	r7, r6
90003890:	1ac0      	subs	r0, r0, r3
90003892:	6963      	ldr	r3, [r4, #20]
90003894:	4283      	cmp	r3, r0
90003896:	dc04      	bgt.n	900038a2 <__swbuf_r+0x42>
90003898:	4621      	mov	r1, r4
9000389a:	4628      	mov	r0, r5
9000389c:	f000 f924 	bl	90003ae8 <_fflush_r>
900038a0:	bb28      	cbnz	r0, 900038ee <__swbuf_r+0x8e>
900038a2:	68a3      	ldr	r3, [r4, #8]
900038a4:	3001      	adds	r0, #1
900038a6:	3b01      	subs	r3, #1
900038a8:	60a3      	str	r3, [r4, #8]
900038aa:	6823      	ldr	r3, [r4, #0]
900038ac:	1c5a      	adds	r2, r3, #1
900038ae:	6022      	str	r2, [r4, #0]
900038b0:	701e      	strb	r6, [r3, #0]
900038b2:	6963      	ldr	r3, [r4, #20]
900038b4:	4283      	cmp	r3, r0
900038b6:	d004      	beq.n	900038c2 <__swbuf_r+0x62>
900038b8:	89a3      	ldrh	r3, [r4, #12]
900038ba:	07db      	lsls	r3, r3, #31
900038bc:	d519      	bpl.n	900038f2 <__swbuf_r+0x92>
900038be:	2e0a      	cmp	r6, #10
900038c0:	d117      	bne.n	900038f2 <__swbuf_r+0x92>
900038c2:	4621      	mov	r1, r4
900038c4:	4628      	mov	r0, r5
900038c6:	f000 f90f 	bl	90003ae8 <_fflush_r>
900038ca:	b190      	cbz	r0, 900038f2 <__swbuf_r+0x92>
900038cc:	e00f      	b.n	900038ee <__swbuf_r+0x8e>
900038ce:	4b0b      	ldr	r3, [pc, #44]	; (900038fc <__swbuf_r+0x9c>)
900038d0:	429c      	cmp	r4, r3
900038d2:	d101      	bne.n	900038d8 <__swbuf_r+0x78>
900038d4:	68ac      	ldr	r4, [r5, #8]
900038d6:	e7d0      	b.n	9000387a <__swbuf_r+0x1a>
900038d8:	4b09      	ldr	r3, [pc, #36]	; (90003900 <__swbuf_r+0xa0>)
900038da:	429c      	cmp	r4, r3
900038dc:	bf08      	it	eq
900038de:	68ec      	ldreq	r4, [r5, #12]
900038e0:	e7cb      	b.n	9000387a <__swbuf_r+0x1a>
900038e2:	4621      	mov	r1, r4
900038e4:	4628      	mov	r0, r5
900038e6:	f000 f80d 	bl	90003904 <__swsetup_r>
900038ea:	2800      	cmp	r0, #0
900038ec:	d0cc      	beq.n	90003888 <__swbuf_r+0x28>
900038ee:	f04f 37ff 	mov.w	r7, #4294967295
900038f2:	4638      	mov	r0, r7
900038f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
900038f6:	bf00      	nop
900038f8:	90005e18 	.word	0x90005e18
900038fc:	90005e38 	.word	0x90005e38
90003900:	90005df8 	.word	0x90005df8

90003904 <__swsetup_r>:
90003904:	4b32      	ldr	r3, [pc, #200]	; (900039d0 <__swsetup_r+0xcc>)
90003906:	b570      	push	{r4, r5, r6, lr}
90003908:	681d      	ldr	r5, [r3, #0]
9000390a:	4606      	mov	r6, r0
9000390c:	460c      	mov	r4, r1
9000390e:	b125      	cbz	r5, 9000391a <__swsetup_r+0x16>
90003910:	69ab      	ldr	r3, [r5, #24]
90003912:	b913      	cbnz	r3, 9000391a <__swsetup_r+0x16>
90003914:	4628      	mov	r0, r5
90003916:	f000 f951 	bl	90003bbc <__sinit>
9000391a:	4b2e      	ldr	r3, [pc, #184]	; (900039d4 <__swsetup_r+0xd0>)
9000391c:	429c      	cmp	r4, r3
9000391e:	d10f      	bne.n	90003940 <__swsetup_r+0x3c>
90003920:	686c      	ldr	r4, [r5, #4]
90003922:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
90003926:	b29a      	uxth	r2, r3
90003928:	0715      	lsls	r5, r2, #28
9000392a:	d42c      	bmi.n	90003986 <__swsetup_r+0x82>
9000392c:	06d0      	lsls	r0, r2, #27
9000392e:	d411      	bmi.n	90003954 <__swsetup_r+0x50>
90003930:	2209      	movs	r2, #9
90003932:	6032      	str	r2, [r6, #0]
90003934:	f043 0340 	orr.w	r3, r3, #64	; 0x40
90003938:	f04f 30ff 	mov.w	r0, #4294967295
9000393c:	81a3      	strh	r3, [r4, #12]
9000393e:	e03e      	b.n	900039be <__swsetup_r+0xba>
90003940:	4b25      	ldr	r3, [pc, #148]	; (900039d8 <__swsetup_r+0xd4>)
90003942:	429c      	cmp	r4, r3
90003944:	d101      	bne.n	9000394a <__swsetup_r+0x46>
90003946:	68ac      	ldr	r4, [r5, #8]
90003948:	e7eb      	b.n	90003922 <__swsetup_r+0x1e>
9000394a:	4b24      	ldr	r3, [pc, #144]	; (900039dc <__swsetup_r+0xd8>)
9000394c:	429c      	cmp	r4, r3
9000394e:	bf08      	it	eq
90003950:	68ec      	ldreq	r4, [r5, #12]
90003952:	e7e6      	b.n	90003922 <__swsetup_r+0x1e>
90003954:	0751      	lsls	r1, r2, #29
90003956:	d512      	bpl.n	9000397e <__swsetup_r+0x7a>
90003958:	6b61      	ldr	r1, [r4, #52]	; 0x34
9000395a:	b141      	cbz	r1, 9000396e <__swsetup_r+0x6a>
9000395c:	f104 0344 	add.w	r3, r4, #68	; 0x44
90003960:	4299      	cmp	r1, r3
90003962:	d002      	beq.n	9000396a <__swsetup_r+0x66>
90003964:	4630      	mov	r0, r6
90003966:	f000 fa1f 	bl	90003da8 <_free_r>
9000396a:	2300      	movs	r3, #0
9000396c:	6363      	str	r3, [r4, #52]	; 0x34
9000396e:	89a3      	ldrh	r3, [r4, #12]
90003970:	f023 0324 	bic.w	r3, r3, #36	; 0x24
90003974:	81a3      	strh	r3, [r4, #12]
90003976:	2300      	movs	r3, #0
90003978:	6063      	str	r3, [r4, #4]
9000397a:	6923      	ldr	r3, [r4, #16]
9000397c:	6023      	str	r3, [r4, #0]
9000397e:	89a3      	ldrh	r3, [r4, #12]
90003980:	f043 0308 	orr.w	r3, r3, #8
90003984:	81a3      	strh	r3, [r4, #12]
90003986:	6923      	ldr	r3, [r4, #16]
90003988:	b94b      	cbnz	r3, 9000399e <__swsetup_r+0x9a>
9000398a:	89a3      	ldrh	r3, [r4, #12]
9000398c:	f403 7320 	and.w	r3, r3, #640	; 0x280
90003990:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
90003994:	d003      	beq.n	9000399e <__swsetup_r+0x9a>
90003996:	4621      	mov	r1, r4
90003998:	4630      	mov	r0, r6
9000399a:	f000 f9bd 	bl	90003d18 <__smakebuf_r>
9000399e:	89a2      	ldrh	r2, [r4, #12]
900039a0:	f012 0301 	ands.w	r3, r2, #1
900039a4:	d00c      	beq.n	900039c0 <__swsetup_r+0xbc>
900039a6:	2300      	movs	r3, #0
900039a8:	60a3      	str	r3, [r4, #8]
900039aa:	6963      	ldr	r3, [r4, #20]
900039ac:	425b      	negs	r3, r3
900039ae:	61a3      	str	r3, [r4, #24]
900039b0:	6923      	ldr	r3, [r4, #16]
900039b2:	b953      	cbnz	r3, 900039ca <__swsetup_r+0xc6>
900039b4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
900039b8:	f013 0080 	ands.w	r0, r3, #128	; 0x80
900039bc:	d1ba      	bne.n	90003934 <__swsetup_r+0x30>
900039be:	bd70      	pop	{r4, r5, r6, pc}
900039c0:	0792      	lsls	r2, r2, #30
900039c2:	bf58      	it	pl
900039c4:	6963      	ldrpl	r3, [r4, #20]
900039c6:	60a3      	str	r3, [r4, #8]
900039c8:	e7f2      	b.n	900039b0 <__swsetup_r+0xac>
900039ca:	2000      	movs	r0, #0
900039cc:	e7f7      	b.n	900039be <__swsetup_r+0xba>
900039ce:	bf00      	nop
900039d0:	20000128 	.word	0x20000128
900039d4:	90005e18 	.word	0x90005e18
900039d8:	90005e38 	.word	0x90005e38
900039dc:	90005df8 	.word	0x90005df8

900039e0 <__sflush_r>:
900039e0:	898a      	ldrh	r2, [r1, #12]
900039e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900039e6:	4605      	mov	r5, r0
900039e8:	0710      	lsls	r0, r2, #28
900039ea:	460c      	mov	r4, r1
900039ec:	d458      	bmi.n	90003aa0 <__sflush_r+0xc0>
900039ee:	684b      	ldr	r3, [r1, #4]
900039f0:	2b00      	cmp	r3, #0
900039f2:	dc05      	bgt.n	90003a00 <__sflush_r+0x20>
900039f4:	6c0b      	ldr	r3, [r1, #64]	; 0x40
900039f6:	2b00      	cmp	r3, #0
900039f8:	dc02      	bgt.n	90003a00 <__sflush_r+0x20>
900039fa:	2000      	movs	r0, #0
900039fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
90003a00:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
90003a02:	2e00      	cmp	r6, #0
90003a04:	d0f9      	beq.n	900039fa <__sflush_r+0x1a>
90003a06:	2300      	movs	r3, #0
90003a08:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
90003a0c:	682f      	ldr	r7, [r5, #0]
90003a0e:	6a21      	ldr	r1, [r4, #32]
90003a10:	602b      	str	r3, [r5, #0]
90003a12:	d032      	beq.n	90003a7a <__sflush_r+0x9a>
90003a14:	6d60      	ldr	r0, [r4, #84]	; 0x54
90003a16:	89a3      	ldrh	r3, [r4, #12]
90003a18:	075a      	lsls	r2, r3, #29
90003a1a:	d505      	bpl.n	90003a28 <__sflush_r+0x48>
90003a1c:	6863      	ldr	r3, [r4, #4]
90003a1e:	1ac0      	subs	r0, r0, r3
90003a20:	6b63      	ldr	r3, [r4, #52]	; 0x34
90003a22:	b10b      	cbz	r3, 90003a28 <__sflush_r+0x48>
90003a24:	6c23      	ldr	r3, [r4, #64]	; 0x40
90003a26:	1ac0      	subs	r0, r0, r3
90003a28:	2300      	movs	r3, #0
90003a2a:	4602      	mov	r2, r0
90003a2c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
90003a2e:	4628      	mov	r0, r5
90003a30:	6a21      	ldr	r1, [r4, #32]
90003a32:	47b0      	blx	r6
90003a34:	1c43      	adds	r3, r0, #1
90003a36:	89a3      	ldrh	r3, [r4, #12]
90003a38:	d106      	bne.n	90003a48 <__sflush_r+0x68>
90003a3a:	6829      	ldr	r1, [r5, #0]
90003a3c:	291d      	cmp	r1, #29
90003a3e:	d847      	bhi.n	90003ad0 <__sflush_r+0xf0>
90003a40:	4a28      	ldr	r2, [pc, #160]	; (90003ae4 <__sflush_r+0x104>)
90003a42:	40ca      	lsrs	r2, r1
90003a44:	07d6      	lsls	r6, r2, #31
90003a46:	d543      	bpl.n	90003ad0 <__sflush_r+0xf0>
90003a48:	2200      	movs	r2, #0
90003a4a:	04d9      	lsls	r1, r3, #19
90003a4c:	6062      	str	r2, [r4, #4]
90003a4e:	6922      	ldr	r2, [r4, #16]
90003a50:	6022      	str	r2, [r4, #0]
90003a52:	d504      	bpl.n	90003a5e <__sflush_r+0x7e>
90003a54:	1c42      	adds	r2, r0, #1
90003a56:	d101      	bne.n	90003a5c <__sflush_r+0x7c>
90003a58:	682b      	ldr	r3, [r5, #0]
90003a5a:	b903      	cbnz	r3, 90003a5e <__sflush_r+0x7e>
90003a5c:	6560      	str	r0, [r4, #84]	; 0x54
90003a5e:	6b61      	ldr	r1, [r4, #52]	; 0x34
90003a60:	602f      	str	r7, [r5, #0]
90003a62:	2900      	cmp	r1, #0
90003a64:	d0c9      	beq.n	900039fa <__sflush_r+0x1a>
90003a66:	f104 0344 	add.w	r3, r4, #68	; 0x44
90003a6a:	4299      	cmp	r1, r3
90003a6c:	d002      	beq.n	90003a74 <__sflush_r+0x94>
90003a6e:	4628      	mov	r0, r5
90003a70:	f000 f99a 	bl	90003da8 <_free_r>
90003a74:	2000      	movs	r0, #0
90003a76:	6360      	str	r0, [r4, #52]	; 0x34
90003a78:	e7c0      	b.n	900039fc <__sflush_r+0x1c>
90003a7a:	2301      	movs	r3, #1
90003a7c:	4628      	mov	r0, r5
90003a7e:	47b0      	blx	r6
90003a80:	1c41      	adds	r1, r0, #1
90003a82:	d1c8      	bne.n	90003a16 <__sflush_r+0x36>
90003a84:	682b      	ldr	r3, [r5, #0]
90003a86:	2b00      	cmp	r3, #0
90003a88:	d0c5      	beq.n	90003a16 <__sflush_r+0x36>
90003a8a:	2b1d      	cmp	r3, #29
90003a8c:	d001      	beq.n	90003a92 <__sflush_r+0xb2>
90003a8e:	2b16      	cmp	r3, #22
90003a90:	d101      	bne.n	90003a96 <__sflush_r+0xb6>
90003a92:	602f      	str	r7, [r5, #0]
90003a94:	e7b1      	b.n	900039fa <__sflush_r+0x1a>
90003a96:	89a3      	ldrh	r3, [r4, #12]
90003a98:	f043 0340 	orr.w	r3, r3, #64	; 0x40
90003a9c:	81a3      	strh	r3, [r4, #12]
90003a9e:	e7ad      	b.n	900039fc <__sflush_r+0x1c>
90003aa0:	690f      	ldr	r7, [r1, #16]
90003aa2:	2f00      	cmp	r7, #0
90003aa4:	d0a9      	beq.n	900039fa <__sflush_r+0x1a>
90003aa6:	0793      	lsls	r3, r2, #30
90003aa8:	680e      	ldr	r6, [r1, #0]
90003aaa:	600f      	str	r7, [r1, #0]
90003aac:	bf0c      	ite	eq
90003aae:	694b      	ldreq	r3, [r1, #20]
90003ab0:	2300      	movne	r3, #0
90003ab2:	eba6 0807 	sub.w	r8, r6, r7
90003ab6:	608b      	str	r3, [r1, #8]
90003ab8:	f1b8 0f00 	cmp.w	r8, #0
90003abc:	dd9d      	ble.n	900039fa <__sflush_r+0x1a>
90003abe:	4643      	mov	r3, r8
90003ac0:	463a      	mov	r2, r7
90003ac2:	6a21      	ldr	r1, [r4, #32]
90003ac4:	4628      	mov	r0, r5
90003ac6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
90003ac8:	47b0      	blx	r6
90003aca:	2800      	cmp	r0, #0
90003acc:	dc06      	bgt.n	90003adc <__sflush_r+0xfc>
90003ace:	89a3      	ldrh	r3, [r4, #12]
90003ad0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
90003ad4:	f04f 30ff 	mov.w	r0, #4294967295
90003ad8:	81a3      	strh	r3, [r4, #12]
90003ada:	e78f      	b.n	900039fc <__sflush_r+0x1c>
90003adc:	4407      	add	r7, r0
90003ade:	eba8 0800 	sub.w	r8, r8, r0
90003ae2:	e7e9      	b.n	90003ab8 <__sflush_r+0xd8>
90003ae4:	20400001 	.word	0x20400001

90003ae8 <_fflush_r>:
90003ae8:	b538      	push	{r3, r4, r5, lr}
90003aea:	690b      	ldr	r3, [r1, #16]
90003aec:	4605      	mov	r5, r0
90003aee:	460c      	mov	r4, r1
90003af0:	b1db      	cbz	r3, 90003b2a <_fflush_r+0x42>
90003af2:	b118      	cbz	r0, 90003afc <_fflush_r+0x14>
90003af4:	6983      	ldr	r3, [r0, #24]
90003af6:	b90b      	cbnz	r3, 90003afc <_fflush_r+0x14>
90003af8:	f000 f860 	bl	90003bbc <__sinit>
90003afc:	4b0c      	ldr	r3, [pc, #48]	; (90003b30 <_fflush_r+0x48>)
90003afe:	429c      	cmp	r4, r3
90003b00:	d109      	bne.n	90003b16 <_fflush_r+0x2e>
90003b02:	686c      	ldr	r4, [r5, #4]
90003b04:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
90003b08:	b17b      	cbz	r3, 90003b2a <_fflush_r+0x42>
90003b0a:	4621      	mov	r1, r4
90003b0c:	4628      	mov	r0, r5
90003b0e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
90003b12:	f7ff bf65 	b.w	900039e0 <__sflush_r>
90003b16:	4b07      	ldr	r3, [pc, #28]	; (90003b34 <_fflush_r+0x4c>)
90003b18:	429c      	cmp	r4, r3
90003b1a:	d101      	bne.n	90003b20 <_fflush_r+0x38>
90003b1c:	68ac      	ldr	r4, [r5, #8]
90003b1e:	e7f1      	b.n	90003b04 <_fflush_r+0x1c>
90003b20:	4b05      	ldr	r3, [pc, #20]	; (90003b38 <_fflush_r+0x50>)
90003b22:	429c      	cmp	r4, r3
90003b24:	bf08      	it	eq
90003b26:	68ec      	ldreq	r4, [r5, #12]
90003b28:	e7ec      	b.n	90003b04 <_fflush_r+0x1c>
90003b2a:	2000      	movs	r0, #0
90003b2c:	bd38      	pop	{r3, r4, r5, pc}
90003b2e:	bf00      	nop
90003b30:	90005e18 	.word	0x90005e18
90003b34:	90005e38 	.word	0x90005e38
90003b38:	90005df8 	.word	0x90005df8

90003b3c <std>:
90003b3c:	2300      	movs	r3, #0
90003b3e:	b510      	push	{r4, lr}
90003b40:	4604      	mov	r4, r0
90003b42:	6083      	str	r3, [r0, #8]
90003b44:	8181      	strh	r1, [r0, #12]
90003b46:	4619      	mov	r1, r3
90003b48:	6643      	str	r3, [r0, #100]	; 0x64
90003b4a:	81c2      	strh	r2, [r0, #14]
90003b4c:	2208      	movs	r2, #8
90003b4e:	6183      	str	r3, [r0, #24]
90003b50:	e9c0 3300 	strd	r3, r3, [r0]
90003b54:	e9c0 3304 	strd	r3, r3, [r0, #16]
90003b58:	305c      	adds	r0, #92	; 0x5c
90003b5a:	f7ff fd3f 	bl	900035dc <memset>
90003b5e:	4b05      	ldr	r3, [pc, #20]	; (90003b74 <std+0x38>)
90003b60:	6224      	str	r4, [r4, #32]
90003b62:	6263      	str	r3, [r4, #36]	; 0x24
90003b64:	4b04      	ldr	r3, [pc, #16]	; (90003b78 <std+0x3c>)
90003b66:	62a3      	str	r3, [r4, #40]	; 0x28
90003b68:	4b04      	ldr	r3, [pc, #16]	; (90003b7c <std+0x40>)
90003b6a:	62e3      	str	r3, [r4, #44]	; 0x2c
90003b6c:	4b04      	ldr	r3, [pc, #16]	; (90003b80 <std+0x44>)
90003b6e:	6323      	str	r3, [r4, #48]	; 0x30
90003b70:	bd10      	pop	{r4, pc}
90003b72:	bf00      	nop
90003b74:	900044ad 	.word	0x900044ad
90003b78:	900044cf 	.word	0x900044cf
90003b7c:	90004507 	.word	0x90004507
90003b80:	9000452b 	.word	0x9000452b

90003b84 <_cleanup_r>:
90003b84:	4901      	ldr	r1, [pc, #4]	; (90003b8c <_cleanup_r+0x8>)
90003b86:	f000 b885 	b.w	90003c94 <_fwalk_reent>
90003b8a:	bf00      	nop
90003b8c:	90003ae9 	.word	0x90003ae9

90003b90 <__sfmoreglue>:
90003b90:	b570      	push	{r4, r5, r6, lr}
90003b92:	1e4a      	subs	r2, r1, #1
90003b94:	2568      	movs	r5, #104	; 0x68
90003b96:	460e      	mov	r6, r1
90003b98:	4355      	muls	r5, r2
90003b9a:	f105 0174 	add.w	r1, r5, #116	; 0x74
90003b9e:	f000 f951 	bl	90003e44 <_malloc_r>
90003ba2:	4604      	mov	r4, r0
90003ba4:	b140      	cbz	r0, 90003bb8 <__sfmoreglue+0x28>
90003ba6:	2100      	movs	r1, #0
90003ba8:	f105 0268 	add.w	r2, r5, #104	; 0x68
90003bac:	e9c0 1600 	strd	r1, r6, [r0]
90003bb0:	300c      	adds	r0, #12
90003bb2:	60a0      	str	r0, [r4, #8]
90003bb4:	f7ff fd12 	bl	900035dc <memset>
90003bb8:	4620      	mov	r0, r4
90003bba:	bd70      	pop	{r4, r5, r6, pc}

90003bbc <__sinit>:
90003bbc:	6983      	ldr	r3, [r0, #24]
90003bbe:	b510      	push	{r4, lr}
90003bc0:	4604      	mov	r4, r0
90003bc2:	bb33      	cbnz	r3, 90003c12 <__sinit+0x56>
90003bc4:	6503      	str	r3, [r0, #80]	; 0x50
90003bc6:	4a13      	ldr	r2, [pc, #76]	; (90003c14 <__sinit+0x58>)
90003bc8:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
90003bcc:	4b12      	ldr	r3, [pc, #72]	; (90003c18 <__sinit+0x5c>)
90003bce:	6282      	str	r2, [r0, #40]	; 0x28
90003bd0:	681b      	ldr	r3, [r3, #0]
90003bd2:	4298      	cmp	r0, r3
90003bd4:	bf04      	itt	eq
90003bd6:	2301      	moveq	r3, #1
90003bd8:	6183      	streq	r3, [r0, #24]
90003bda:	f000 f81f 	bl	90003c1c <__sfp>
90003bde:	6060      	str	r0, [r4, #4]
90003be0:	4620      	mov	r0, r4
90003be2:	f000 f81b 	bl	90003c1c <__sfp>
90003be6:	60a0      	str	r0, [r4, #8]
90003be8:	4620      	mov	r0, r4
90003bea:	f000 f817 	bl	90003c1c <__sfp>
90003bee:	2200      	movs	r2, #0
90003bf0:	60e0      	str	r0, [r4, #12]
90003bf2:	2104      	movs	r1, #4
90003bf4:	6860      	ldr	r0, [r4, #4]
90003bf6:	f7ff ffa1 	bl	90003b3c <std>
90003bfa:	2201      	movs	r2, #1
90003bfc:	2109      	movs	r1, #9
90003bfe:	68a0      	ldr	r0, [r4, #8]
90003c00:	f7ff ff9c 	bl	90003b3c <std>
90003c04:	2202      	movs	r2, #2
90003c06:	2112      	movs	r1, #18
90003c08:	68e0      	ldr	r0, [r4, #12]
90003c0a:	f7ff ff97 	bl	90003b3c <std>
90003c0e:	2301      	movs	r3, #1
90003c10:	61a3      	str	r3, [r4, #24]
90003c12:	bd10      	pop	{r4, pc}
90003c14:	90003b85 	.word	0x90003b85
90003c18:	90005df4 	.word	0x90005df4

90003c1c <__sfp>:
90003c1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90003c1e:	4b1b      	ldr	r3, [pc, #108]	; (90003c8c <__sfp+0x70>)
90003c20:	4607      	mov	r7, r0
90003c22:	681e      	ldr	r6, [r3, #0]
90003c24:	69b3      	ldr	r3, [r6, #24]
90003c26:	b913      	cbnz	r3, 90003c2e <__sfp+0x12>
90003c28:	4630      	mov	r0, r6
90003c2a:	f7ff ffc7 	bl	90003bbc <__sinit>
90003c2e:	3648      	adds	r6, #72	; 0x48
90003c30:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
90003c34:	3b01      	subs	r3, #1
90003c36:	d503      	bpl.n	90003c40 <__sfp+0x24>
90003c38:	6833      	ldr	r3, [r6, #0]
90003c3a:	b133      	cbz	r3, 90003c4a <__sfp+0x2e>
90003c3c:	6836      	ldr	r6, [r6, #0]
90003c3e:	e7f7      	b.n	90003c30 <__sfp+0x14>
90003c40:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
90003c44:	b16d      	cbz	r5, 90003c62 <__sfp+0x46>
90003c46:	3468      	adds	r4, #104	; 0x68
90003c48:	e7f4      	b.n	90003c34 <__sfp+0x18>
90003c4a:	2104      	movs	r1, #4
90003c4c:	4638      	mov	r0, r7
90003c4e:	f7ff ff9f 	bl	90003b90 <__sfmoreglue>
90003c52:	6030      	str	r0, [r6, #0]
90003c54:	2800      	cmp	r0, #0
90003c56:	d1f1      	bne.n	90003c3c <__sfp+0x20>
90003c58:	230c      	movs	r3, #12
90003c5a:	4604      	mov	r4, r0
90003c5c:	603b      	str	r3, [r7, #0]
90003c5e:	4620      	mov	r0, r4
90003c60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
90003c62:	4b0b      	ldr	r3, [pc, #44]	; (90003c90 <__sfp+0x74>)
90003c64:	2208      	movs	r2, #8
90003c66:	6665      	str	r5, [r4, #100]	; 0x64
90003c68:	4629      	mov	r1, r5
90003c6a:	60a5      	str	r5, [r4, #8]
90003c6c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
90003c70:	e9c4 5500 	strd	r5, r5, [r4]
90003c74:	e9c4 3503 	strd	r3, r5, [r4, #12]
90003c78:	e9c4 5505 	strd	r5, r5, [r4, #20]
90003c7c:	f7ff fcae 	bl	900035dc <memset>
90003c80:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
90003c84:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
90003c88:	e7e9      	b.n	90003c5e <__sfp+0x42>
90003c8a:	bf00      	nop
90003c8c:	90005df4 	.word	0x90005df4
90003c90:	ffff0001 	.word	0xffff0001

90003c94 <_fwalk_reent>:
90003c94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
90003c98:	4680      	mov	r8, r0
90003c9a:	4689      	mov	r9, r1
90003c9c:	f100 0448 	add.w	r4, r0, #72	; 0x48
90003ca0:	2600      	movs	r6, #0
90003ca2:	b914      	cbnz	r4, 90003caa <_fwalk_reent+0x16>
90003ca4:	4630      	mov	r0, r6
90003ca6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
90003caa:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
90003cae:	3f01      	subs	r7, #1
90003cb0:	d501      	bpl.n	90003cb6 <_fwalk_reent+0x22>
90003cb2:	6824      	ldr	r4, [r4, #0]
90003cb4:	e7f5      	b.n	90003ca2 <_fwalk_reent+0xe>
90003cb6:	89ab      	ldrh	r3, [r5, #12]
90003cb8:	2b01      	cmp	r3, #1
90003cba:	d907      	bls.n	90003ccc <_fwalk_reent+0x38>
90003cbc:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
90003cc0:	3301      	adds	r3, #1
90003cc2:	d003      	beq.n	90003ccc <_fwalk_reent+0x38>
90003cc4:	4629      	mov	r1, r5
90003cc6:	4640      	mov	r0, r8
90003cc8:	47c8      	blx	r9
90003cca:	4306      	orrs	r6, r0
90003ccc:	3568      	adds	r5, #104	; 0x68
90003cce:	e7ee      	b.n	90003cae <_fwalk_reent+0x1a>

90003cd0 <__swhatbuf_r>:
90003cd0:	b570      	push	{r4, r5, r6, lr}
90003cd2:	460e      	mov	r6, r1
90003cd4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
90003cd8:	b096      	sub	sp, #88	; 0x58
90003cda:	4614      	mov	r4, r2
90003cdc:	2900      	cmp	r1, #0
90003cde:	461d      	mov	r5, r3
90003ce0:	da07      	bge.n	90003cf2 <__swhatbuf_r+0x22>
90003ce2:	2300      	movs	r3, #0
90003ce4:	602b      	str	r3, [r5, #0]
90003ce6:	89b3      	ldrh	r3, [r6, #12]
90003ce8:	061a      	lsls	r2, r3, #24
90003cea:	d410      	bmi.n	90003d0e <__swhatbuf_r+0x3e>
90003cec:	f44f 6380 	mov.w	r3, #1024	; 0x400
90003cf0:	e00e      	b.n	90003d10 <__swhatbuf_r+0x40>
90003cf2:	466a      	mov	r2, sp
90003cf4:	f000 fc40 	bl	90004578 <_fstat_r>
90003cf8:	2800      	cmp	r0, #0
90003cfa:	dbf2      	blt.n	90003ce2 <__swhatbuf_r+0x12>
90003cfc:	9a01      	ldr	r2, [sp, #4]
90003cfe:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
90003d02:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
90003d06:	425a      	negs	r2, r3
90003d08:	415a      	adcs	r2, r3
90003d0a:	602a      	str	r2, [r5, #0]
90003d0c:	e7ee      	b.n	90003cec <__swhatbuf_r+0x1c>
90003d0e:	2340      	movs	r3, #64	; 0x40
90003d10:	2000      	movs	r0, #0
90003d12:	6023      	str	r3, [r4, #0]
90003d14:	b016      	add	sp, #88	; 0x58
90003d16:	bd70      	pop	{r4, r5, r6, pc}

90003d18 <__smakebuf_r>:
90003d18:	898b      	ldrh	r3, [r1, #12]
90003d1a:	b573      	push	{r0, r1, r4, r5, r6, lr}
90003d1c:	079d      	lsls	r5, r3, #30
90003d1e:	4606      	mov	r6, r0
90003d20:	460c      	mov	r4, r1
90003d22:	d507      	bpl.n	90003d34 <__smakebuf_r+0x1c>
90003d24:	f104 0347 	add.w	r3, r4, #71	; 0x47
90003d28:	6023      	str	r3, [r4, #0]
90003d2a:	6123      	str	r3, [r4, #16]
90003d2c:	2301      	movs	r3, #1
90003d2e:	6163      	str	r3, [r4, #20]
90003d30:	b002      	add	sp, #8
90003d32:	bd70      	pop	{r4, r5, r6, pc}
90003d34:	ab01      	add	r3, sp, #4
90003d36:	466a      	mov	r2, sp
90003d38:	f7ff ffca 	bl	90003cd0 <__swhatbuf_r>
90003d3c:	9900      	ldr	r1, [sp, #0]
90003d3e:	4605      	mov	r5, r0
90003d40:	4630      	mov	r0, r6
90003d42:	f000 f87f 	bl	90003e44 <_malloc_r>
90003d46:	b948      	cbnz	r0, 90003d5c <__smakebuf_r+0x44>
90003d48:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
90003d4c:	059a      	lsls	r2, r3, #22
90003d4e:	d4ef      	bmi.n	90003d30 <__smakebuf_r+0x18>
90003d50:	f023 0303 	bic.w	r3, r3, #3
90003d54:	f043 0302 	orr.w	r3, r3, #2
90003d58:	81a3      	strh	r3, [r4, #12]
90003d5a:	e7e3      	b.n	90003d24 <__smakebuf_r+0xc>
90003d5c:	4b0d      	ldr	r3, [pc, #52]	; (90003d94 <__smakebuf_r+0x7c>)
90003d5e:	62b3      	str	r3, [r6, #40]	; 0x28
90003d60:	89a3      	ldrh	r3, [r4, #12]
90003d62:	6020      	str	r0, [r4, #0]
90003d64:	f043 0380 	orr.w	r3, r3, #128	; 0x80
90003d68:	6120      	str	r0, [r4, #16]
90003d6a:	81a3      	strh	r3, [r4, #12]
90003d6c:	9b00      	ldr	r3, [sp, #0]
90003d6e:	6163      	str	r3, [r4, #20]
90003d70:	9b01      	ldr	r3, [sp, #4]
90003d72:	b15b      	cbz	r3, 90003d8c <__smakebuf_r+0x74>
90003d74:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
90003d78:	4630      	mov	r0, r6
90003d7a:	f000 fc0f 	bl	9000459c <_isatty_r>
90003d7e:	b128      	cbz	r0, 90003d8c <__smakebuf_r+0x74>
90003d80:	89a3      	ldrh	r3, [r4, #12]
90003d82:	f023 0303 	bic.w	r3, r3, #3
90003d86:	f043 0301 	orr.w	r3, r3, #1
90003d8a:	81a3      	strh	r3, [r4, #12]
90003d8c:	89a3      	ldrh	r3, [r4, #12]
90003d8e:	431d      	orrs	r5, r3
90003d90:	81a5      	strh	r5, [r4, #12]
90003d92:	e7cd      	b.n	90003d30 <__smakebuf_r+0x18>
90003d94:	90003b85 	.word	0x90003b85

90003d98 <malloc>:
90003d98:	4b02      	ldr	r3, [pc, #8]	; (90003da4 <malloc+0xc>)
90003d9a:	4601      	mov	r1, r0
90003d9c:	6818      	ldr	r0, [r3, #0]
90003d9e:	f000 b851 	b.w	90003e44 <_malloc_r>
90003da2:	bf00      	nop
90003da4:	20000128 	.word	0x20000128

90003da8 <_free_r>:
90003da8:	b538      	push	{r3, r4, r5, lr}
90003daa:	4605      	mov	r5, r0
90003dac:	2900      	cmp	r1, #0
90003dae:	d045      	beq.n	90003e3c <_free_r+0x94>
90003db0:	f851 3c04 	ldr.w	r3, [r1, #-4]
90003db4:	1f0c      	subs	r4, r1, #4
90003db6:	2b00      	cmp	r3, #0
90003db8:	bfb8      	it	lt
90003dba:	18e4      	addlt	r4, r4, r3
90003dbc:	f000 fc1e 	bl	900045fc <__malloc_lock>
90003dc0:	4a1f      	ldr	r2, [pc, #124]	; (90003e40 <_free_r+0x98>)
90003dc2:	6813      	ldr	r3, [r2, #0]
90003dc4:	4610      	mov	r0, r2
90003dc6:	b933      	cbnz	r3, 90003dd6 <_free_r+0x2e>
90003dc8:	6063      	str	r3, [r4, #4]
90003dca:	6014      	str	r4, [r2, #0]
90003dcc:	4628      	mov	r0, r5
90003dce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
90003dd2:	f000 bc14 	b.w	900045fe <__malloc_unlock>
90003dd6:	42a3      	cmp	r3, r4
90003dd8:	d90c      	bls.n	90003df4 <_free_r+0x4c>
90003dda:	6821      	ldr	r1, [r4, #0]
90003ddc:	1862      	adds	r2, r4, r1
90003dde:	4293      	cmp	r3, r2
90003de0:	bf02      	ittt	eq
90003de2:	681a      	ldreq	r2, [r3, #0]
90003de4:	685b      	ldreq	r3, [r3, #4]
90003de6:	1852      	addeq	r2, r2, r1
90003de8:	6063      	str	r3, [r4, #4]
90003dea:	bf08      	it	eq
90003dec:	6022      	streq	r2, [r4, #0]
90003dee:	6004      	str	r4, [r0, #0]
90003df0:	e7ec      	b.n	90003dcc <_free_r+0x24>
90003df2:	4613      	mov	r3, r2
90003df4:	685a      	ldr	r2, [r3, #4]
90003df6:	b10a      	cbz	r2, 90003dfc <_free_r+0x54>
90003df8:	42a2      	cmp	r2, r4
90003dfa:	d9fa      	bls.n	90003df2 <_free_r+0x4a>
90003dfc:	6819      	ldr	r1, [r3, #0]
90003dfe:	1858      	adds	r0, r3, r1
90003e00:	42a0      	cmp	r0, r4
90003e02:	d10b      	bne.n	90003e1c <_free_r+0x74>
90003e04:	6820      	ldr	r0, [r4, #0]
90003e06:	4401      	add	r1, r0
90003e08:	1858      	adds	r0, r3, r1
90003e0a:	6019      	str	r1, [r3, #0]
90003e0c:	4282      	cmp	r2, r0
90003e0e:	d1dd      	bne.n	90003dcc <_free_r+0x24>
90003e10:	6810      	ldr	r0, [r2, #0]
90003e12:	6852      	ldr	r2, [r2, #4]
90003e14:	4401      	add	r1, r0
90003e16:	605a      	str	r2, [r3, #4]
90003e18:	6019      	str	r1, [r3, #0]
90003e1a:	e7d7      	b.n	90003dcc <_free_r+0x24>
90003e1c:	d902      	bls.n	90003e24 <_free_r+0x7c>
90003e1e:	230c      	movs	r3, #12
90003e20:	602b      	str	r3, [r5, #0]
90003e22:	e7d3      	b.n	90003dcc <_free_r+0x24>
90003e24:	6820      	ldr	r0, [r4, #0]
90003e26:	1821      	adds	r1, r4, r0
90003e28:	428a      	cmp	r2, r1
90003e2a:	bf02      	ittt	eq
90003e2c:	6811      	ldreq	r1, [r2, #0]
90003e2e:	6852      	ldreq	r2, [r2, #4]
90003e30:	1809      	addeq	r1, r1, r0
90003e32:	6062      	str	r2, [r4, #4]
90003e34:	bf08      	it	eq
90003e36:	6021      	streq	r1, [r4, #0]
90003e38:	605c      	str	r4, [r3, #4]
90003e3a:	e7c7      	b.n	90003dcc <_free_r+0x24>
90003e3c:	bd38      	pop	{r3, r4, r5, pc}
90003e3e:	bf00      	nop
90003e40:	20000244 	.word	0x20000244

90003e44 <_malloc_r>:
90003e44:	b570      	push	{r4, r5, r6, lr}
90003e46:	1ccd      	adds	r5, r1, #3
90003e48:	4606      	mov	r6, r0
90003e4a:	f025 0503 	bic.w	r5, r5, #3
90003e4e:	3508      	adds	r5, #8
90003e50:	2d0c      	cmp	r5, #12
90003e52:	bf38      	it	cc
90003e54:	250c      	movcc	r5, #12
90003e56:	2d00      	cmp	r5, #0
90003e58:	db01      	blt.n	90003e5e <_malloc_r+0x1a>
90003e5a:	42a9      	cmp	r1, r5
90003e5c:	d903      	bls.n	90003e66 <_malloc_r+0x22>
90003e5e:	230c      	movs	r3, #12
90003e60:	6033      	str	r3, [r6, #0]
90003e62:	2000      	movs	r0, #0
90003e64:	bd70      	pop	{r4, r5, r6, pc}
90003e66:	f000 fbc9 	bl	900045fc <__malloc_lock>
90003e6a:	4a21      	ldr	r2, [pc, #132]	; (90003ef0 <_malloc_r+0xac>)
90003e6c:	6814      	ldr	r4, [r2, #0]
90003e6e:	4621      	mov	r1, r4
90003e70:	b991      	cbnz	r1, 90003e98 <_malloc_r+0x54>
90003e72:	4c20      	ldr	r4, [pc, #128]	; (90003ef4 <_malloc_r+0xb0>)
90003e74:	6823      	ldr	r3, [r4, #0]
90003e76:	b91b      	cbnz	r3, 90003e80 <_malloc_r+0x3c>
90003e78:	4630      	mov	r0, r6
90003e7a:	f000 fb07 	bl	9000448c <_sbrk_r>
90003e7e:	6020      	str	r0, [r4, #0]
90003e80:	4629      	mov	r1, r5
90003e82:	4630      	mov	r0, r6
90003e84:	f000 fb02 	bl	9000448c <_sbrk_r>
90003e88:	1c43      	adds	r3, r0, #1
90003e8a:	d124      	bne.n	90003ed6 <_malloc_r+0x92>
90003e8c:	230c      	movs	r3, #12
90003e8e:	4630      	mov	r0, r6
90003e90:	6033      	str	r3, [r6, #0]
90003e92:	f000 fbb4 	bl	900045fe <__malloc_unlock>
90003e96:	e7e4      	b.n	90003e62 <_malloc_r+0x1e>
90003e98:	680b      	ldr	r3, [r1, #0]
90003e9a:	1b5b      	subs	r3, r3, r5
90003e9c:	d418      	bmi.n	90003ed0 <_malloc_r+0x8c>
90003e9e:	2b0b      	cmp	r3, #11
90003ea0:	d90f      	bls.n	90003ec2 <_malloc_r+0x7e>
90003ea2:	18cc      	adds	r4, r1, r3
90003ea4:	600b      	str	r3, [r1, #0]
90003ea6:	50cd      	str	r5, [r1, r3]
90003ea8:	4630      	mov	r0, r6
90003eaa:	f000 fba8 	bl	900045fe <__malloc_unlock>
90003eae:	f104 000b 	add.w	r0, r4, #11
90003eb2:	1d23      	adds	r3, r4, #4
90003eb4:	f020 0007 	bic.w	r0, r0, #7
90003eb8:	1ac3      	subs	r3, r0, r3
90003eba:	d0d3      	beq.n	90003e64 <_malloc_r+0x20>
90003ebc:	425a      	negs	r2, r3
90003ebe:	50e2      	str	r2, [r4, r3]
90003ec0:	e7d0      	b.n	90003e64 <_malloc_r+0x20>
90003ec2:	428c      	cmp	r4, r1
90003ec4:	684b      	ldr	r3, [r1, #4]
90003ec6:	bf1a      	itte	ne
90003ec8:	6063      	strne	r3, [r4, #4]
90003eca:	460c      	movne	r4, r1
90003ecc:	6013      	streq	r3, [r2, #0]
90003ece:	e7eb      	b.n	90003ea8 <_malloc_r+0x64>
90003ed0:	460c      	mov	r4, r1
90003ed2:	6849      	ldr	r1, [r1, #4]
90003ed4:	e7cc      	b.n	90003e70 <_malloc_r+0x2c>
90003ed6:	1cc4      	adds	r4, r0, #3
90003ed8:	f024 0403 	bic.w	r4, r4, #3
90003edc:	42a0      	cmp	r0, r4
90003ede:	d005      	beq.n	90003eec <_malloc_r+0xa8>
90003ee0:	1a21      	subs	r1, r4, r0
90003ee2:	4630      	mov	r0, r6
90003ee4:	f000 fad2 	bl	9000448c <_sbrk_r>
90003ee8:	3001      	adds	r0, #1
90003eea:	d0cf      	beq.n	90003e8c <_malloc_r+0x48>
90003eec:	6025      	str	r5, [r4, #0]
90003eee:	e7db      	b.n	90003ea8 <_malloc_r+0x64>
90003ef0:	20000244 	.word	0x20000244
90003ef4:	20000248 	.word	0x20000248

90003ef8 <__sfputc_r>:
90003ef8:	6893      	ldr	r3, [r2, #8]
90003efa:	3b01      	subs	r3, #1
90003efc:	2b00      	cmp	r3, #0
90003efe:	6093      	str	r3, [r2, #8]
90003f00:	b410      	push	{r4}
90003f02:	da08      	bge.n	90003f16 <__sfputc_r+0x1e>
90003f04:	6994      	ldr	r4, [r2, #24]
90003f06:	42a3      	cmp	r3, r4
90003f08:	db01      	blt.n	90003f0e <__sfputc_r+0x16>
90003f0a:	290a      	cmp	r1, #10
90003f0c:	d103      	bne.n	90003f16 <__sfputc_r+0x1e>
90003f0e:	f85d 4b04 	ldr.w	r4, [sp], #4
90003f12:	f7ff bca5 	b.w	90003860 <__swbuf_r>
90003f16:	6813      	ldr	r3, [r2, #0]
90003f18:	1c58      	adds	r0, r3, #1
90003f1a:	6010      	str	r0, [r2, #0]
90003f1c:	4608      	mov	r0, r1
90003f1e:	7019      	strb	r1, [r3, #0]
90003f20:	f85d 4b04 	ldr.w	r4, [sp], #4
90003f24:	4770      	bx	lr

90003f26 <__sfputs_r>:
90003f26:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
90003f28:	4606      	mov	r6, r0
90003f2a:	460f      	mov	r7, r1
90003f2c:	4614      	mov	r4, r2
90003f2e:	18d5      	adds	r5, r2, r3
90003f30:	42ac      	cmp	r4, r5
90003f32:	d101      	bne.n	90003f38 <__sfputs_r+0x12>
90003f34:	2000      	movs	r0, #0
90003f36:	e007      	b.n	90003f48 <__sfputs_r+0x22>
90003f38:	463a      	mov	r2, r7
90003f3a:	f814 1b01 	ldrb.w	r1, [r4], #1
90003f3e:	4630      	mov	r0, r6
90003f40:	f7ff ffda 	bl	90003ef8 <__sfputc_r>
90003f44:	1c43      	adds	r3, r0, #1
90003f46:	d1f3      	bne.n	90003f30 <__sfputs_r+0xa>
90003f48:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

90003f4c <_vfiprintf_r>:
90003f4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
90003f50:	460c      	mov	r4, r1
90003f52:	b09d      	sub	sp, #116	; 0x74
90003f54:	4617      	mov	r7, r2
90003f56:	461d      	mov	r5, r3
90003f58:	4606      	mov	r6, r0
90003f5a:	b118      	cbz	r0, 90003f64 <_vfiprintf_r+0x18>
90003f5c:	6983      	ldr	r3, [r0, #24]
90003f5e:	b90b      	cbnz	r3, 90003f64 <_vfiprintf_r+0x18>
90003f60:	f7ff fe2c 	bl	90003bbc <__sinit>
90003f64:	4b7c      	ldr	r3, [pc, #496]	; (90004158 <_vfiprintf_r+0x20c>)
90003f66:	429c      	cmp	r4, r3
90003f68:	d158      	bne.n	9000401c <_vfiprintf_r+0xd0>
90003f6a:	6874      	ldr	r4, [r6, #4]
90003f6c:	89a3      	ldrh	r3, [r4, #12]
90003f6e:	0718      	lsls	r0, r3, #28
90003f70:	d55e      	bpl.n	90004030 <_vfiprintf_r+0xe4>
90003f72:	6923      	ldr	r3, [r4, #16]
90003f74:	2b00      	cmp	r3, #0
90003f76:	d05b      	beq.n	90004030 <_vfiprintf_r+0xe4>
90003f78:	2300      	movs	r3, #0
90003f7a:	f04f 0b01 	mov.w	fp, #1
90003f7e:	9503      	str	r5, [sp, #12]
90003f80:	9309      	str	r3, [sp, #36]	; 0x24
90003f82:	2320      	movs	r3, #32
90003f84:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
90003f88:	2330      	movs	r3, #48	; 0x30
90003f8a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
90003f8e:	46b8      	mov	r8, r7
90003f90:	4645      	mov	r5, r8
90003f92:	f815 3b01 	ldrb.w	r3, [r5], #1
90003f96:	b10b      	cbz	r3, 90003f9c <_vfiprintf_r+0x50>
90003f98:	2b25      	cmp	r3, #37	; 0x25
90003f9a:	d154      	bne.n	90004046 <_vfiprintf_r+0xfa>
90003f9c:	ebb8 0a07 	subs.w	sl, r8, r7
90003fa0:	d00b      	beq.n	90003fba <_vfiprintf_r+0x6e>
90003fa2:	4653      	mov	r3, sl
90003fa4:	463a      	mov	r2, r7
90003fa6:	4621      	mov	r1, r4
90003fa8:	4630      	mov	r0, r6
90003faa:	f7ff ffbc 	bl	90003f26 <__sfputs_r>
90003fae:	3001      	adds	r0, #1
90003fb0:	f000 80c2 	beq.w	90004138 <_vfiprintf_r+0x1ec>
90003fb4:	9b09      	ldr	r3, [sp, #36]	; 0x24
90003fb6:	4453      	add	r3, sl
90003fb8:	9309      	str	r3, [sp, #36]	; 0x24
90003fba:	f898 3000 	ldrb.w	r3, [r8]
90003fbe:	2b00      	cmp	r3, #0
90003fc0:	f000 80ba 	beq.w	90004138 <_vfiprintf_r+0x1ec>
90003fc4:	2300      	movs	r3, #0
90003fc6:	f04f 32ff 	mov.w	r2, #4294967295
90003fca:	9304      	str	r3, [sp, #16]
90003fcc:	9307      	str	r3, [sp, #28]
90003fce:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
90003fd2:	931a      	str	r3, [sp, #104]	; 0x68
90003fd4:	e9cd 2305 	strd	r2, r3, [sp, #20]
90003fd8:	46a8      	mov	r8, r5
90003fda:	2205      	movs	r2, #5
90003fdc:	485f      	ldr	r0, [pc, #380]	; (9000415c <_vfiprintf_r+0x210>)
90003fde:	f818 1b01 	ldrb.w	r1, [r8], #1
90003fe2:	f000 fafd 	bl	900045e0 <memchr>
90003fe6:	9b04      	ldr	r3, [sp, #16]
90003fe8:	bb78      	cbnz	r0, 9000404a <_vfiprintf_r+0xfe>
90003fea:	06d9      	lsls	r1, r3, #27
90003fec:	bf44      	itt	mi
90003fee:	2220      	movmi	r2, #32
90003ff0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
90003ff4:	071a      	lsls	r2, r3, #28
90003ff6:	bf44      	itt	mi
90003ff8:	222b      	movmi	r2, #43	; 0x2b
90003ffa:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
90003ffe:	782a      	ldrb	r2, [r5, #0]
90004000:	2a2a      	cmp	r2, #42	; 0x2a
90004002:	d02a      	beq.n	9000405a <_vfiprintf_r+0x10e>
90004004:	46a8      	mov	r8, r5
90004006:	9a07      	ldr	r2, [sp, #28]
90004008:	2000      	movs	r0, #0
9000400a:	250a      	movs	r5, #10
9000400c:	4641      	mov	r1, r8
9000400e:	f811 3b01 	ldrb.w	r3, [r1], #1
90004012:	3b30      	subs	r3, #48	; 0x30
90004014:	2b09      	cmp	r3, #9
90004016:	d969      	bls.n	900040ec <_vfiprintf_r+0x1a0>
90004018:	b360      	cbz	r0, 90004074 <_vfiprintf_r+0x128>
9000401a:	e024      	b.n	90004066 <_vfiprintf_r+0x11a>
9000401c:	4b50      	ldr	r3, [pc, #320]	; (90004160 <_vfiprintf_r+0x214>)
9000401e:	429c      	cmp	r4, r3
90004020:	d101      	bne.n	90004026 <_vfiprintf_r+0xda>
90004022:	68b4      	ldr	r4, [r6, #8]
90004024:	e7a2      	b.n	90003f6c <_vfiprintf_r+0x20>
90004026:	4b4f      	ldr	r3, [pc, #316]	; (90004164 <_vfiprintf_r+0x218>)
90004028:	429c      	cmp	r4, r3
9000402a:	bf08      	it	eq
9000402c:	68f4      	ldreq	r4, [r6, #12]
9000402e:	e79d      	b.n	90003f6c <_vfiprintf_r+0x20>
90004030:	4621      	mov	r1, r4
90004032:	4630      	mov	r0, r6
90004034:	f7ff fc66 	bl	90003904 <__swsetup_r>
90004038:	2800      	cmp	r0, #0
9000403a:	d09d      	beq.n	90003f78 <_vfiprintf_r+0x2c>
9000403c:	f04f 30ff 	mov.w	r0, #4294967295
90004040:	b01d      	add	sp, #116	; 0x74
90004042:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
90004046:	46a8      	mov	r8, r5
90004048:	e7a2      	b.n	90003f90 <_vfiprintf_r+0x44>
9000404a:	4a44      	ldr	r2, [pc, #272]	; (9000415c <_vfiprintf_r+0x210>)
9000404c:	4645      	mov	r5, r8
9000404e:	1a80      	subs	r0, r0, r2
90004050:	fa0b f000 	lsl.w	r0, fp, r0
90004054:	4318      	orrs	r0, r3
90004056:	9004      	str	r0, [sp, #16]
90004058:	e7be      	b.n	90003fd8 <_vfiprintf_r+0x8c>
9000405a:	9a03      	ldr	r2, [sp, #12]
9000405c:	1d11      	adds	r1, r2, #4
9000405e:	6812      	ldr	r2, [r2, #0]
90004060:	2a00      	cmp	r2, #0
90004062:	9103      	str	r1, [sp, #12]
90004064:	db01      	blt.n	9000406a <_vfiprintf_r+0x11e>
90004066:	9207      	str	r2, [sp, #28]
90004068:	e004      	b.n	90004074 <_vfiprintf_r+0x128>
9000406a:	4252      	negs	r2, r2
9000406c:	f043 0302 	orr.w	r3, r3, #2
90004070:	9207      	str	r2, [sp, #28]
90004072:	9304      	str	r3, [sp, #16]
90004074:	f898 3000 	ldrb.w	r3, [r8]
90004078:	2b2e      	cmp	r3, #46	; 0x2e
9000407a:	d10e      	bne.n	9000409a <_vfiprintf_r+0x14e>
9000407c:	f898 3001 	ldrb.w	r3, [r8, #1]
90004080:	2b2a      	cmp	r3, #42	; 0x2a
90004082:	d138      	bne.n	900040f6 <_vfiprintf_r+0x1aa>
90004084:	9b03      	ldr	r3, [sp, #12]
90004086:	f108 0802 	add.w	r8, r8, #2
9000408a:	1d1a      	adds	r2, r3, #4
9000408c:	681b      	ldr	r3, [r3, #0]
9000408e:	2b00      	cmp	r3, #0
90004090:	9203      	str	r2, [sp, #12]
90004092:	bfb8      	it	lt
90004094:	f04f 33ff 	movlt.w	r3, #4294967295
90004098:	9305      	str	r3, [sp, #20]
9000409a:	4d33      	ldr	r5, [pc, #204]	; (90004168 <_vfiprintf_r+0x21c>)
9000409c:	2203      	movs	r2, #3
9000409e:	f898 1000 	ldrb.w	r1, [r8]
900040a2:	4628      	mov	r0, r5
900040a4:	f000 fa9c 	bl	900045e0 <memchr>
900040a8:	b140      	cbz	r0, 900040bc <_vfiprintf_r+0x170>
900040aa:	2340      	movs	r3, #64	; 0x40
900040ac:	1b40      	subs	r0, r0, r5
900040ae:	f108 0801 	add.w	r8, r8, #1
900040b2:	fa03 f000 	lsl.w	r0, r3, r0
900040b6:	9b04      	ldr	r3, [sp, #16]
900040b8:	4303      	orrs	r3, r0
900040ba:	9304      	str	r3, [sp, #16]
900040bc:	f898 1000 	ldrb.w	r1, [r8]
900040c0:	2206      	movs	r2, #6
900040c2:	482a      	ldr	r0, [pc, #168]	; (9000416c <_vfiprintf_r+0x220>)
900040c4:	f108 0701 	add.w	r7, r8, #1
900040c8:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
900040cc:	f000 fa88 	bl	900045e0 <memchr>
900040d0:	2800      	cmp	r0, #0
900040d2:	d037      	beq.n	90004144 <_vfiprintf_r+0x1f8>
900040d4:	4b26      	ldr	r3, [pc, #152]	; (90004170 <_vfiprintf_r+0x224>)
900040d6:	bb1b      	cbnz	r3, 90004120 <_vfiprintf_r+0x1d4>
900040d8:	9b03      	ldr	r3, [sp, #12]
900040da:	3307      	adds	r3, #7
900040dc:	f023 0307 	bic.w	r3, r3, #7
900040e0:	3308      	adds	r3, #8
900040e2:	9303      	str	r3, [sp, #12]
900040e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
900040e6:	444b      	add	r3, r9
900040e8:	9309      	str	r3, [sp, #36]	; 0x24
900040ea:	e750      	b.n	90003f8e <_vfiprintf_r+0x42>
900040ec:	fb05 3202 	mla	r2, r5, r2, r3
900040f0:	2001      	movs	r0, #1
900040f2:	4688      	mov	r8, r1
900040f4:	e78a      	b.n	9000400c <_vfiprintf_r+0xc0>
900040f6:	2300      	movs	r3, #0
900040f8:	f108 0801 	add.w	r8, r8, #1
900040fc:	250a      	movs	r5, #10
900040fe:	4619      	mov	r1, r3
90004100:	9305      	str	r3, [sp, #20]
90004102:	4640      	mov	r0, r8
90004104:	f810 2b01 	ldrb.w	r2, [r0], #1
90004108:	3a30      	subs	r2, #48	; 0x30
9000410a:	2a09      	cmp	r2, #9
9000410c:	d903      	bls.n	90004116 <_vfiprintf_r+0x1ca>
9000410e:	2b00      	cmp	r3, #0
90004110:	d0c3      	beq.n	9000409a <_vfiprintf_r+0x14e>
90004112:	9105      	str	r1, [sp, #20]
90004114:	e7c1      	b.n	9000409a <_vfiprintf_r+0x14e>
90004116:	fb05 2101 	mla	r1, r5, r1, r2
9000411a:	2301      	movs	r3, #1
9000411c:	4680      	mov	r8, r0
9000411e:	e7f0      	b.n	90004102 <_vfiprintf_r+0x1b6>
90004120:	ab03      	add	r3, sp, #12
90004122:	4622      	mov	r2, r4
90004124:	a904      	add	r1, sp, #16
90004126:	4630      	mov	r0, r6
90004128:	9300      	str	r3, [sp, #0]
9000412a:	4b12      	ldr	r3, [pc, #72]	; (90004174 <_vfiprintf_r+0x228>)
9000412c:	e000      	b.n	90004130 <_vfiprintf_r+0x1e4>
9000412e:	bf00      	nop
90004130:	f1b0 3fff 	cmp.w	r0, #4294967295
90004134:	4681      	mov	r9, r0
90004136:	d1d5      	bne.n	900040e4 <_vfiprintf_r+0x198>
90004138:	89a3      	ldrh	r3, [r4, #12]
9000413a:	065b      	lsls	r3, r3, #25
9000413c:	f53f af7e 	bmi.w	9000403c <_vfiprintf_r+0xf0>
90004140:	9809      	ldr	r0, [sp, #36]	; 0x24
90004142:	e77d      	b.n	90004040 <_vfiprintf_r+0xf4>
90004144:	ab03      	add	r3, sp, #12
90004146:	4622      	mov	r2, r4
90004148:	a904      	add	r1, sp, #16
9000414a:	4630      	mov	r0, r6
9000414c:	9300      	str	r3, [sp, #0]
9000414e:	4b09      	ldr	r3, [pc, #36]	; (90004174 <_vfiprintf_r+0x228>)
90004150:	f000 f88a 	bl	90004268 <_printf_i>
90004154:	e7ec      	b.n	90004130 <_vfiprintf_r+0x1e4>
90004156:	bf00      	nop
90004158:	90005e18 	.word	0x90005e18
9000415c:	90005e58 	.word	0x90005e58
90004160:	90005e38 	.word	0x90005e38
90004164:	90005df8 	.word	0x90005df8
90004168:	90005e5e 	.word	0x90005e5e
9000416c:	90005e62 	.word	0x90005e62
90004170:	00000000 	.word	0x00000000
90004174:	90003f27 	.word	0x90003f27

90004178 <_printf_common>:
90004178:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
9000417c:	4691      	mov	r9, r2
9000417e:	461f      	mov	r7, r3
90004180:	688a      	ldr	r2, [r1, #8]
90004182:	4606      	mov	r6, r0
90004184:	690b      	ldr	r3, [r1, #16]
90004186:	460c      	mov	r4, r1
90004188:	f8dd 8020 	ldr.w	r8, [sp, #32]
9000418c:	4293      	cmp	r3, r2
9000418e:	bfb8      	it	lt
90004190:	4613      	movlt	r3, r2
90004192:	f8c9 3000 	str.w	r3, [r9]
90004196:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
9000419a:	b112      	cbz	r2, 900041a2 <_printf_common+0x2a>
9000419c:	3301      	adds	r3, #1
9000419e:	f8c9 3000 	str.w	r3, [r9]
900041a2:	6823      	ldr	r3, [r4, #0]
900041a4:	0699      	lsls	r1, r3, #26
900041a6:	bf42      	ittt	mi
900041a8:	f8d9 3000 	ldrmi.w	r3, [r9]
900041ac:	3302      	addmi	r3, #2
900041ae:	f8c9 3000 	strmi.w	r3, [r9]
900041b2:	6825      	ldr	r5, [r4, #0]
900041b4:	f015 0506 	ands.w	r5, r5, #6
900041b8:	d107      	bne.n	900041ca <_printf_common+0x52>
900041ba:	f104 0a19 	add.w	sl, r4, #25
900041be:	68e3      	ldr	r3, [r4, #12]
900041c0:	f8d9 2000 	ldr.w	r2, [r9]
900041c4:	1a9b      	subs	r3, r3, r2
900041c6:	42ab      	cmp	r3, r5
900041c8:	dc2b      	bgt.n	90004222 <_printf_common+0xaa>
900041ca:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
900041ce:	6822      	ldr	r2, [r4, #0]
900041d0:	3300      	adds	r3, #0
900041d2:	bf18      	it	ne
900041d4:	2301      	movne	r3, #1
900041d6:	0692      	lsls	r2, r2, #26
900041d8:	d430      	bmi.n	9000423c <_printf_common+0xc4>
900041da:	f104 0243 	add.w	r2, r4, #67	; 0x43
900041de:	4639      	mov	r1, r7
900041e0:	4630      	mov	r0, r6
900041e2:	47c0      	blx	r8
900041e4:	3001      	adds	r0, #1
900041e6:	d023      	beq.n	90004230 <_printf_common+0xb8>
900041e8:	6823      	ldr	r3, [r4, #0]
900041ea:	341a      	adds	r4, #26
900041ec:	f854 5c0e 	ldr.w	r5, [r4, #-14]
900041f0:	f003 0306 	and.w	r3, r3, #6
900041f4:	f8d9 2000 	ldr.w	r2, [r9]
900041f8:	f04f 0900 	mov.w	r9, #0
900041fc:	2b04      	cmp	r3, #4
900041fe:	f854 3c12 	ldr.w	r3, [r4, #-18]
90004202:	bf08      	it	eq
90004204:	1aad      	subeq	r5, r5, r2
90004206:	f854 2c0a 	ldr.w	r2, [r4, #-10]
9000420a:	bf14      	ite	ne
9000420c:	2500      	movne	r5, #0
9000420e:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
90004212:	4293      	cmp	r3, r2
90004214:	bfc4      	itt	gt
90004216:	1a9b      	subgt	r3, r3, r2
90004218:	18ed      	addgt	r5, r5, r3
9000421a:	454d      	cmp	r5, r9
9000421c:	d11a      	bne.n	90004254 <_printf_common+0xdc>
9000421e:	2000      	movs	r0, #0
90004220:	e008      	b.n	90004234 <_printf_common+0xbc>
90004222:	2301      	movs	r3, #1
90004224:	4652      	mov	r2, sl
90004226:	4639      	mov	r1, r7
90004228:	4630      	mov	r0, r6
9000422a:	47c0      	blx	r8
9000422c:	3001      	adds	r0, #1
9000422e:	d103      	bne.n	90004238 <_printf_common+0xc0>
90004230:	f04f 30ff 	mov.w	r0, #4294967295
90004234:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90004238:	3501      	adds	r5, #1
9000423a:	e7c0      	b.n	900041be <_printf_common+0x46>
9000423c:	18e1      	adds	r1, r4, r3
9000423e:	1c5a      	adds	r2, r3, #1
90004240:	2030      	movs	r0, #48	; 0x30
90004242:	3302      	adds	r3, #2
90004244:	4422      	add	r2, r4
90004246:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
9000424a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
9000424e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
90004252:	e7c2      	b.n	900041da <_printf_common+0x62>
90004254:	2301      	movs	r3, #1
90004256:	4622      	mov	r2, r4
90004258:	4639      	mov	r1, r7
9000425a:	4630      	mov	r0, r6
9000425c:	47c0      	blx	r8
9000425e:	3001      	adds	r0, #1
90004260:	d0e6      	beq.n	90004230 <_printf_common+0xb8>
90004262:	f109 0901 	add.w	r9, r9, #1
90004266:	e7d8      	b.n	9000421a <_printf_common+0xa2>

90004268 <_printf_i>:
90004268:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
9000426c:	f101 0c43 	add.w	ip, r1, #67	; 0x43
90004270:	460c      	mov	r4, r1
90004272:	7e09      	ldrb	r1, [r1, #24]
90004274:	b085      	sub	sp, #20
90004276:	4617      	mov	r7, r2
90004278:	4606      	mov	r6, r0
9000427a:	296e      	cmp	r1, #110	; 0x6e
9000427c:	4698      	mov	r8, r3
9000427e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
90004280:	f000 80b3 	beq.w	900043ea <_printf_i+0x182>
90004284:	d822      	bhi.n	900042cc <_printf_i+0x64>
90004286:	2963      	cmp	r1, #99	; 0x63
90004288:	d036      	beq.n	900042f8 <_printf_i+0x90>
9000428a:	d80a      	bhi.n	900042a2 <_printf_i+0x3a>
9000428c:	2900      	cmp	r1, #0
9000428e:	f000 80b9 	beq.w	90004404 <_printf_i+0x19c>
90004292:	2958      	cmp	r1, #88	; 0x58
90004294:	f000 8083 	beq.w	9000439e <_printf_i+0x136>
90004298:	f104 0542 	add.w	r5, r4, #66	; 0x42
9000429c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
900042a0:	e032      	b.n	90004308 <_printf_i+0xa0>
900042a2:	2964      	cmp	r1, #100	; 0x64
900042a4:	d001      	beq.n	900042aa <_printf_i+0x42>
900042a6:	2969      	cmp	r1, #105	; 0x69
900042a8:	d1f6      	bne.n	90004298 <_printf_i+0x30>
900042aa:	6820      	ldr	r0, [r4, #0]
900042ac:	6813      	ldr	r3, [r2, #0]
900042ae:	0605      	lsls	r5, r0, #24
900042b0:	f103 0104 	add.w	r1, r3, #4
900042b4:	d52a      	bpl.n	9000430c <_printf_i+0xa4>
900042b6:	681b      	ldr	r3, [r3, #0]
900042b8:	6011      	str	r1, [r2, #0]
900042ba:	2b00      	cmp	r3, #0
900042bc:	da03      	bge.n	900042c6 <_printf_i+0x5e>
900042be:	222d      	movs	r2, #45	; 0x2d
900042c0:	425b      	negs	r3, r3
900042c2:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
900042c6:	486f      	ldr	r0, [pc, #444]	; (90004484 <_printf_i+0x21c>)
900042c8:	220a      	movs	r2, #10
900042ca:	e039      	b.n	90004340 <_printf_i+0xd8>
900042cc:	2973      	cmp	r1, #115	; 0x73
900042ce:	f000 809d 	beq.w	9000440c <_printf_i+0x1a4>
900042d2:	d808      	bhi.n	900042e6 <_printf_i+0x7e>
900042d4:	296f      	cmp	r1, #111	; 0x6f
900042d6:	d020      	beq.n	9000431a <_printf_i+0xb2>
900042d8:	2970      	cmp	r1, #112	; 0x70
900042da:	d1dd      	bne.n	90004298 <_printf_i+0x30>
900042dc:	6823      	ldr	r3, [r4, #0]
900042de:	f043 0320 	orr.w	r3, r3, #32
900042e2:	6023      	str	r3, [r4, #0]
900042e4:	e003      	b.n	900042ee <_printf_i+0x86>
900042e6:	2975      	cmp	r1, #117	; 0x75
900042e8:	d017      	beq.n	9000431a <_printf_i+0xb2>
900042ea:	2978      	cmp	r1, #120	; 0x78
900042ec:	d1d4      	bne.n	90004298 <_printf_i+0x30>
900042ee:	2378      	movs	r3, #120	; 0x78
900042f0:	4865      	ldr	r0, [pc, #404]	; (90004488 <_printf_i+0x220>)
900042f2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
900042f6:	e055      	b.n	900043a4 <_printf_i+0x13c>
900042f8:	6813      	ldr	r3, [r2, #0]
900042fa:	f104 0542 	add.w	r5, r4, #66	; 0x42
900042fe:	1d19      	adds	r1, r3, #4
90004300:	681b      	ldr	r3, [r3, #0]
90004302:	6011      	str	r1, [r2, #0]
90004304:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
90004308:	2301      	movs	r3, #1
9000430a:	e08c      	b.n	90004426 <_printf_i+0x1be>
9000430c:	681b      	ldr	r3, [r3, #0]
9000430e:	f010 0f40 	tst.w	r0, #64	; 0x40
90004312:	6011      	str	r1, [r2, #0]
90004314:	bf18      	it	ne
90004316:	b21b      	sxthne	r3, r3
90004318:	e7cf      	b.n	900042ba <_printf_i+0x52>
9000431a:	6813      	ldr	r3, [r2, #0]
9000431c:	6825      	ldr	r5, [r4, #0]
9000431e:	1d18      	adds	r0, r3, #4
90004320:	6010      	str	r0, [r2, #0]
90004322:	0628      	lsls	r0, r5, #24
90004324:	d501      	bpl.n	9000432a <_printf_i+0xc2>
90004326:	681b      	ldr	r3, [r3, #0]
90004328:	e002      	b.n	90004330 <_printf_i+0xc8>
9000432a:	0668      	lsls	r0, r5, #25
9000432c:	d5fb      	bpl.n	90004326 <_printf_i+0xbe>
9000432e:	881b      	ldrh	r3, [r3, #0]
90004330:	296f      	cmp	r1, #111	; 0x6f
90004332:	4854      	ldr	r0, [pc, #336]	; (90004484 <_printf_i+0x21c>)
90004334:	bf14      	ite	ne
90004336:	220a      	movne	r2, #10
90004338:	2208      	moveq	r2, #8
9000433a:	2100      	movs	r1, #0
9000433c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
90004340:	6865      	ldr	r5, [r4, #4]
90004342:	2d00      	cmp	r5, #0
90004344:	60a5      	str	r5, [r4, #8]
90004346:	f2c0 8095 	blt.w	90004474 <_printf_i+0x20c>
9000434a:	6821      	ldr	r1, [r4, #0]
9000434c:	f021 0104 	bic.w	r1, r1, #4
90004350:	6021      	str	r1, [r4, #0]
90004352:	2b00      	cmp	r3, #0
90004354:	d13d      	bne.n	900043d2 <_printf_i+0x16a>
90004356:	2d00      	cmp	r5, #0
90004358:	f040 808e 	bne.w	90004478 <_printf_i+0x210>
9000435c:	4665      	mov	r5, ip
9000435e:	2a08      	cmp	r2, #8
90004360:	d10b      	bne.n	9000437a <_printf_i+0x112>
90004362:	6823      	ldr	r3, [r4, #0]
90004364:	07db      	lsls	r3, r3, #31
90004366:	d508      	bpl.n	9000437a <_printf_i+0x112>
90004368:	6923      	ldr	r3, [r4, #16]
9000436a:	6862      	ldr	r2, [r4, #4]
9000436c:	429a      	cmp	r2, r3
9000436e:	bfde      	ittt	le
90004370:	2330      	movle	r3, #48	; 0x30
90004372:	f805 3c01 	strble.w	r3, [r5, #-1]
90004376:	f105 35ff 	addle.w	r5, r5, #4294967295
9000437a:	ebac 0305 	sub.w	r3, ip, r5
9000437e:	6123      	str	r3, [r4, #16]
90004380:	f8cd 8000 	str.w	r8, [sp]
90004384:	463b      	mov	r3, r7
90004386:	aa03      	add	r2, sp, #12
90004388:	4621      	mov	r1, r4
9000438a:	4630      	mov	r0, r6
9000438c:	f7ff fef4 	bl	90004178 <_printf_common>
90004390:	3001      	adds	r0, #1
90004392:	d14d      	bne.n	90004430 <_printf_i+0x1c8>
90004394:	f04f 30ff 	mov.w	r0, #4294967295
90004398:	b005      	add	sp, #20
9000439a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
9000439e:	4839      	ldr	r0, [pc, #228]	; (90004484 <_printf_i+0x21c>)
900043a0:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
900043a4:	6813      	ldr	r3, [r2, #0]
900043a6:	6821      	ldr	r1, [r4, #0]
900043a8:	1d1d      	adds	r5, r3, #4
900043aa:	681b      	ldr	r3, [r3, #0]
900043ac:	6015      	str	r5, [r2, #0]
900043ae:	060a      	lsls	r2, r1, #24
900043b0:	d50b      	bpl.n	900043ca <_printf_i+0x162>
900043b2:	07ca      	lsls	r2, r1, #31
900043b4:	bf44      	itt	mi
900043b6:	f041 0120 	orrmi.w	r1, r1, #32
900043ba:	6021      	strmi	r1, [r4, #0]
900043bc:	b91b      	cbnz	r3, 900043c6 <_printf_i+0x15e>
900043be:	6822      	ldr	r2, [r4, #0]
900043c0:	f022 0220 	bic.w	r2, r2, #32
900043c4:	6022      	str	r2, [r4, #0]
900043c6:	2210      	movs	r2, #16
900043c8:	e7b7      	b.n	9000433a <_printf_i+0xd2>
900043ca:	064d      	lsls	r5, r1, #25
900043cc:	bf48      	it	mi
900043ce:	b29b      	uxthmi	r3, r3
900043d0:	e7ef      	b.n	900043b2 <_printf_i+0x14a>
900043d2:	4665      	mov	r5, ip
900043d4:	fbb3 f1f2 	udiv	r1, r3, r2
900043d8:	fb02 3311 	mls	r3, r2, r1, r3
900043dc:	5cc3      	ldrb	r3, [r0, r3]
900043de:	f805 3d01 	strb.w	r3, [r5, #-1]!
900043e2:	460b      	mov	r3, r1
900043e4:	2900      	cmp	r1, #0
900043e6:	d1f5      	bne.n	900043d4 <_printf_i+0x16c>
900043e8:	e7b9      	b.n	9000435e <_printf_i+0xf6>
900043ea:	6813      	ldr	r3, [r2, #0]
900043ec:	6825      	ldr	r5, [r4, #0]
900043ee:	1d18      	adds	r0, r3, #4
900043f0:	6961      	ldr	r1, [r4, #20]
900043f2:	6010      	str	r0, [r2, #0]
900043f4:	0628      	lsls	r0, r5, #24
900043f6:	681b      	ldr	r3, [r3, #0]
900043f8:	d501      	bpl.n	900043fe <_printf_i+0x196>
900043fa:	6019      	str	r1, [r3, #0]
900043fc:	e002      	b.n	90004404 <_printf_i+0x19c>
900043fe:	066a      	lsls	r2, r5, #25
90004400:	d5fb      	bpl.n	900043fa <_printf_i+0x192>
90004402:	8019      	strh	r1, [r3, #0]
90004404:	2300      	movs	r3, #0
90004406:	4665      	mov	r5, ip
90004408:	6123      	str	r3, [r4, #16]
9000440a:	e7b9      	b.n	90004380 <_printf_i+0x118>
9000440c:	6813      	ldr	r3, [r2, #0]
9000440e:	1d19      	adds	r1, r3, #4
90004410:	6011      	str	r1, [r2, #0]
90004412:	2100      	movs	r1, #0
90004414:	681d      	ldr	r5, [r3, #0]
90004416:	6862      	ldr	r2, [r4, #4]
90004418:	4628      	mov	r0, r5
9000441a:	f000 f8e1 	bl	900045e0 <memchr>
9000441e:	b108      	cbz	r0, 90004424 <_printf_i+0x1bc>
90004420:	1b40      	subs	r0, r0, r5
90004422:	6060      	str	r0, [r4, #4]
90004424:	6863      	ldr	r3, [r4, #4]
90004426:	6123      	str	r3, [r4, #16]
90004428:	2300      	movs	r3, #0
9000442a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
9000442e:	e7a7      	b.n	90004380 <_printf_i+0x118>
90004430:	6923      	ldr	r3, [r4, #16]
90004432:	462a      	mov	r2, r5
90004434:	4639      	mov	r1, r7
90004436:	4630      	mov	r0, r6
90004438:	47c0      	blx	r8
9000443a:	3001      	adds	r0, #1
9000443c:	d0aa      	beq.n	90004394 <_printf_i+0x12c>
9000443e:	6823      	ldr	r3, [r4, #0]
90004440:	079b      	lsls	r3, r3, #30
90004442:	d413      	bmi.n	9000446c <_printf_i+0x204>
90004444:	68e0      	ldr	r0, [r4, #12]
90004446:	9b03      	ldr	r3, [sp, #12]
90004448:	4298      	cmp	r0, r3
9000444a:	bfb8      	it	lt
9000444c:	4618      	movlt	r0, r3
9000444e:	e7a3      	b.n	90004398 <_printf_i+0x130>
90004450:	2301      	movs	r3, #1
90004452:	464a      	mov	r2, r9
90004454:	4639      	mov	r1, r7
90004456:	4630      	mov	r0, r6
90004458:	47c0      	blx	r8
9000445a:	3001      	adds	r0, #1
9000445c:	d09a      	beq.n	90004394 <_printf_i+0x12c>
9000445e:	3501      	adds	r5, #1
90004460:	68e3      	ldr	r3, [r4, #12]
90004462:	9a03      	ldr	r2, [sp, #12]
90004464:	1a9b      	subs	r3, r3, r2
90004466:	42ab      	cmp	r3, r5
90004468:	dcf2      	bgt.n	90004450 <_printf_i+0x1e8>
9000446a:	e7eb      	b.n	90004444 <_printf_i+0x1dc>
9000446c:	2500      	movs	r5, #0
9000446e:	f104 0919 	add.w	r9, r4, #25
90004472:	e7f5      	b.n	90004460 <_printf_i+0x1f8>
90004474:	2b00      	cmp	r3, #0
90004476:	d1ac      	bne.n	900043d2 <_printf_i+0x16a>
90004478:	7803      	ldrb	r3, [r0, #0]
9000447a:	f104 0542 	add.w	r5, r4, #66	; 0x42
9000447e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
90004482:	e76c      	b.n	9000435e <_printf_i+0xf6>
90004484:	90005e69 	.word	0x90005e69
90004488:	90005e7a 	.word	0x90005e7a

9000448c <_sbrk_r>:
9000448c:	b538      	push	{r3, r4, r5, lr}
9000448e:	2300      	movs	r3, #0
90004490:	4c05      	ldr	r4, [pc, #20]	; (900044a8 <_sbrk_r+0x1c>)
90004492:	4605      	mov	r5, r0
90004494:	4608      	mov	r0, r1
90004496:	6023      	str	r3, [r4, #0]
90004498:	f000 fa76 	bl	90004988 <_sbrk>
9000449c:	1c43      	adds	r3, r0, #1
9000449e:	d102      	bne.n	900044a6 <_sbrk_r+0x1a>
900044a0:	6823      	ldr	r3, [r4, #0]
900044a2:	b103      	cbz	r3, 900044a6 <_sbrk_r+0x1a>
900044a4:	602b      	str	r3, [r5, #0]
900044a6:	bd38      	pop	{r3, r4, r5, pc}
900044a8:	20000258 	.word	0x20000258

900044ac <__sread>:
900044ac:	b510      	push	{r4, lr}
900044ae:	460c      	mov	r4, r1
900044b0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
900044b4:	f000 f8a4 	bl	90004600 <_read_r>
900044b8:	2800      	cmp	r0, #0
900044ba:	bfab      	itete	ge
900044bc:	6d63      	ldrge	r3, [r4, #84]	; 0x54
900044be:	89a3      	ldrhlt	r3, [r4, #12]
900044c0:	181b      	addge	r3, r3, r0
900044c2:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
900044c6:	bfac      	ite	ge
900044c8:	6563      	strge	r3, [r4, #84]	; 0x54
900044ca:	81a3      	strhlt	r3, [r4, #12]
900044cc:	bd10      	pop	{r4, pc}

900044ce <__swrite>:
900044ce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
900044d2:	461f      	mov	r7, r3
900044d4:	898b      	ldrh	r3, [r1, #12]
900044d6:	4605      	mov	r5, r0
900044d8:	460c      	mov	r4, r1
900044da:	05db      	lsls	r3, r3, #23
900044dc:	4616      	mov	r6, r2
900044de:	d505      	bpl.n	900044ec <__swrite+0x1e>
900044e0:	2302      	movs	r3, #2
900044e2:	2200      	movs	r2, #0
900044e4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
900044e8:	f000 f868 	bl	900045bc <_lseek_r>
900044ec:	89a3      	ldrh	r3, [r4, #12]
900044ee:	4632      	mov	r2, r6
900044f0:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
900044f4:	4628      	mov	r0, r5
900044f6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
900044fa:	81a3      	strh	r3, [r4, #12]
900044fc:	463b      	mov	r3, r7
900044fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
90004502:	f000 b817 	b.w	90004534 <_write_r>

90004506 <__sseek>:
90004506:	b510      	push	{r4, lr}
90004508:	460c      	mov	r4, r1
9000450a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9000450e:	f000 f855 	bl	900045bc <_lseek_r>
90004512:	1c43      	adds	r3, r0, #1
90004514:	89a3      	ldrh	r3, [r4, #12]
90004516:	bf15      	itete	ne
90004518:	6560      	strne	r0, [r4, #84]	; 0x54
9000451a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
9000451e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
90004522:	81a3      	strheq	r3, [r4, #12]
90004524:	bf18      	it	ne
90004526:	81a3      	strhne	r3, [r4, #12]
90004528:	bd10      	pop	{r4, pc}

9000452a <__sclose>:
9000452a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
9000452e:	f000 b813 	b.w	90004558 <_close_r>
	...

90004534 <_write_r>:
90004534:	b538      	push	{r3, r4, r5, lr}
90004536:	4605      	mov	r5, r0
90004538:	4c06      	ldr	r4, [pc, #24]	; (90004554 <_write_r+0x20>)
9000453a:	4608      	mov	r0, r1
9000453c:	4611      	mov	r1, r2
9000453e:	2200      	movs	r2, #0
90004540:	6022      	str	r2, [r4, #0]
90004542:	461a      	mov	r2, r3
90004544:	f7fc fa46 	bl	900009d4 <_write>
90004548:	1c43      	adds	r3, r0, #1
9000454a:	d102      	bne.n	90004552 <_write_r+0x1e>
9000454c:	6823      	ldr	r3, [r4, #0]
9000454e:	b103      	cbz	r3, 90004552 <_write_r+0x1e>
90004550:	602b      	str	r3, [r5, #0]
90004552:	bd38      	pop	{r3, r4, r5, pc}
90004554:	20000258 	.word	0x20000258

90004558 <_close_r>:
90004558:	b538      	push	{r3, r4, r5, lr}
9000455a:	2300      	movs	r3, #0
9000455c:	4c05      	ldr	r4, [pc, #20]	; (90004574 <_close_r+0x1c>)
9000455e:	4605      	mov	r5, r0
90004560:	4608      	mov	r0, r1
90004562:	6023      	str	r3, [r4, #0]
90004564:	f000 f9e8 	bl	90004938 <_close>
90004568:	1c43      	adds	r3, r0, #1
9000456a:	d102      	bne.n	90004572 <_close_r+0x1a>
9000456c:	6823      	ldr	r3, [r4, #0]
9000456e:	b103      	cbz	r3, 90004572 <_close_r+0x1a>
90004570:	602b      	str	r3, [r5, #0]
90004572:	bd38      	pop	{r3, r4, r5, pc}
90004574:	20000258 	.word	0x20000258

90004578 <_fstat_r>:
90004578:	b538      	push	{r3, r4, r5, lr}
9000457a:	2300      	movs	r3, #0
9000457c:	4c06      	ldr	r4, [pc, #24]	; (90004598 <_fstat_r+0x20>)
9000457e:	4605      	mov	r5, r0
90004580:	4608      	mov	r0, r1
90004582:	4611      	mov	r1, r2
90004584:	6023      	str	r3, [r4, #0]
90004586:	f000 f9df 	bl	90004948 <_fstat>
9000458a:	1c43      	adds	r3, r0, #1
9000458c:	d102      	bne.n	90004594 <_fstat_r+0x1c>
9000458e:	6823      	ldr	r3, [r4, #0]
90004590:	b103      	cbz	r3, 90004594 <_fstat_r+0x1c>
90004592:	602b      	str	r3, [r5, #0]
90004594:	bd38      	pop	{r3, r4, r5, pc}
90004596:	bf00      	nop
90004598:	20000258 	.word	0x20000258

9000459c <_isatty_r>:
9000459c:	b538      	push	{r3, r4, r5, lr}
9000459e:	2300      	movs	r3, #0
900045a0:	4c05      	ldr	r4, [pc, #20]	; (900045b8 <_isatty_r+0x1c>)
900045a2:	4605      	mov	r5, r0
900045a4:	4608      	mov	r0, r1
900045a6:	6023      	str	r3, [r4, #0]
900045a8:	f000 f9d6 	bl	90004958 <_isatty>
900045ac:	1c43      	adds	r3, r0, #1
900045ae:	d102      	bne.n	900045b6 <_isatty_r+0x1a>
900045b0:	6823      	ldr	r3, [r4, #0]
900045b2:	b103      	cbz	r3, 900045b6 <_isatty_r+0x1a>
900045b4:	602b      	str	r3, [r5, #0]
900045b6:	bd38      	pop	{r3, r4, r5, pc}
900045b8:	20000258 	.word	0x20000258

900045bc <_lseek_r>:
900045bc:	b538      	push	{r3, r4, r5, lr}
900045be:	4605      	mov	r5, r0
900045c0:	4c06      	ldr	r4, [pc, #24]	; (900045dc <_lseek_r+0x20>)
900045c2:	4608      	mov	r0, r1
900045c4:	4611      	mov	r1, r2
900045c6:	2200      	movs	r2, #0
900045c8:	6022      	str	r2, [r4, #0]
900045ca:	461a      	mov	r2, r3
900045cc:	f000 f9cc 	bl	90004968 <_lseek>
900045d0:	1c43      	adds	r3, r0, #1
900045d2:	d102      	bne.n	900045da <_lseek_r+0x1e>
900045d4:	6823      	ldr	r3, [r4, #0]
900045d6:	b103      	cbz	r3, 900045da <_lseek_r+0x1e>
900045d8:	602b      	str	r3, [r5, #0]
900045da:	bd38      	pop	{r3, r4, r5, pc}
900045dc:	20000258 	.word	0x20000258

900045e0 <memchr>:
900045e0:	b2c9      	uxtb	r1, r1
900045e2:	4402      	add	r2, r0
900045e4:	b510      	push	{r4, lr}
900045e6:	4290      	cmp	r0, r2
900045e8:	4603      	mov	r3, r0
900045ea:	d101      	bne.n	900045f0 <memchr+0x10>
900045ec:	2300      	movs	r3, #0
900045ee:	e003      	b.n	900045f8 <memchr+0x18>
900045f0:	781c      	ldrb	r4, [r3, #0]
900045f2:	3001      	adds	r0, #1
900045f4:	428c      	cmp	r4, r1
900045f6:	d1f6      	bne.n	900045e6 <memchr+0x6>
900045f8:	4618      	mov	r0, r3
900045fa:	bd10      	pop	{r4, pc}

900045fc <__malloc_lock>:
900045fc:	4770      	bx	lr

900045fe <__malloc_unlock>:
900045fe:	4770      	bx	lr

90004600 <_read_r>:
90004600:	b538      	push	{r3, r4, r5, lr}
90004602:	4605      	mov	r5, r0
90004604:	4c06      	ldr	r4, [pc, #24]	; (90004620 <_read_r+0x20>)
90004606:	4608      	mov	r0, r1
90004608:	4611      	mov	r1, r2
9000460a:	2200      	movs	r2, #0
9000460c:	6022      	str	r2, [r4, #0]
9000460e:	461a      	mov	r2, r3
90004610:	f000 f9b2 	bl	90004978 <_read>
90004614:	1c43      	adds	r3, r0, #1
90004616:	d102      	bne.n	9000461e <_read_r+0x1e>
90004618:	6823      	ldr	r3, [r4, #0]
9000461a:	b103      	cbz	r3, 9000461e <_read_r+0x1e>
9000461c:	602b      	str	r3, [r5, #0]
9000461e:	bd38      	pop	{r3, r4, r5, pc}
90004620:	20000258 	.word	0x20000258

90004624 <__aeabi_uldivmod>:
90004624:	b953      	cbnz	r3, 9000463c <__aeabi_uldivmod+0x18>
90004626:	b94a      	cbnz	r2, 9000463c <__aeabi_uldivmod+0x18>
90004628:	2900      	cmp	r1, #0
9000462a:	bf08      	it	eq
9000462c:	2800      	cmpeq	r0, #0
9000462e:	bf1c      	itt	ne
90004630:	f04f 31ff 	movne.w	r1, #4294967295
90004634:	f04f 30ff 	movne.w	r0, #4294967295
90004638:	f000 b97c 	b.w	90004934 <__aeabi_idiv0>
9000463c:	f1ad 0c08 	sub.w	ip, sp, #8
90004640:	e96d ce04 	strd	ip, lr, [sp, #-16]!
90004644:	f000 f806 	bl	90004654 <__udivmoddi4>
90004648:	f8dd e004 	ldr.w	lr, [sp, #4]
9000464c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
90004650:	b004      	add	sp, #16
90004652:	4770      	bx	lr

90004654 <__udivmoddi4>:
90004654:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
90004658:	468c      	mov	ip, r1
9000465a:	9d08      	ldr	r5, [sp, #32]
9000465c:	4604      	mov	r4, r0
9000465e:	468a      	mov	sl, r1
90004660:	2b00      	cmp	r3, #0
90004662:	d14a      	bne.n	900046fa <__udivmoddi4+0xa6>
90004664:	428a      	cmp	r2, r1
90004666:	4617      	mov	r7, r2
90004668:	d962      	bls.n	90004730 <__udivmoddi4+0xdc>
9000466a:	fab2 f682 	clz	r6, r2
9000466e:	b14e      	cbz	r6, 90004684 <__udivmoddi4+0x30>
90004670:	f1c6 0e20 	rsb	lr, r6, #32
90004674:	fa01 f306 	lsl.w	r3, r1, r6
90004678:	40b7      	lsls	r7, r6
9000467a:	40b4      	lsls	r4, r6
9000467c:	fa20 fe0e 	lsr.w	lr, r0, lr
90004680:	ea4e 0a03 	orr.w	sl, lr, r3
90004684:	ea4f 4817 	mov.w	r8, r7, lsr #16
90004688:	0c23      	lsrs	r3, r4, #16
9000468a:	fa1f f987 	uxth.w	r9, r7
9000468e:	fbba fef8 	udiv	lr, sl, r8
90004692:	fb08 aa1e 	mls	sl, r8, lr, sl
90004696:	fb0e f209 	mul.w	r2, lr, r9
9000469a:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
9000469e:	429a      	cmp	r2, r3
900046a0:	d90b      	bls.n	900046ba <__udivmoddi4+0x66>
900046a2:	18fb      	adds	r3, r7, r3
900046a4:	f10e 31ff 	add.w	r1, lr, #4294967295
900046a8:	bf2c      	ite	cs
900046aa:	2001      	movcs	r0, #1
900046ac:	2000      	movcc	r0, #0
900046ae:	429a      	cmp	r2, r3
900046b0:	d902      	bls.n	900046b8 <__udivmoddi4+0x64>
900046b2:	2800      	cmp	r0, #0
900046b4:	f000 812a 	beq.w	9000490c <__udivmoddi4+0x2b8>
900046b8:	468e      	mov	lr, r1
900046ba:	1a9a      	subs	r2, r3, r2
900046bc:	b2a3      	uxth	r3, r4
900046be:	fbb2 f0f8 	udiv	r0, r2, r8
900046c2:	fb08 2210 	mls	r2, r8, r0, r2
900046c6:	fb00 f909 	mul.w	r9, r0, r9
900046ca:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
900046ce:	45a1      	cmp	r9, r4
900046d0:	d907      	bls.n	900046e2 <__udivmoddi4+0x8e>
900046d2:	193c      	adds	r4, r7, r4
900046d4:	f100 33ff 	add.w	r3, r0, #4294967295
900046d8:	d202      	bcs.n	900046e0 <__udivmoddi4+0x8c>
900046da:	45a1      	cmp	r9, r4
900046dc:	f200 8110 	bhi.w	90004900 <__udivmoddi4+0x2ac>
900046e0:	4618      	mov	r0, r3
900046e2:	eba4 0409 	sub.w	r4, r4, r9
900046e6:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
900046ea:	2100      	movs	r1, #0
900046ec:	b11d      	cbz	r5, 900046f6 <__udivmoddi4+0xa2>
900046ee:	40f4      	lsrs	r4, r6
900046f0:	2300      	movs	r3, #0
900046f2:	e9c5 4300 	strd	r4, r3, [r5]
900046f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
900046fa:	428b      	cmp	r3, r1
900046fc:	d908      	bls.n	90004710 <__udivmoddi4+0xbc>
900046fe:	2d00      	cmp	r5, #0
90004700:	f000 80f2 	beq.w	900048e8 <__udivmoddi4+0x294>
90004704:	2100      	movs	r1, #0
90004706:	e9c5 0c00 	strd	r0, ip, [r5]
9000470a:	4608      	mov	r0, r1
9000470c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
90004710:	fab3 f183 	clz	r1, r3
90004714:	2900      	cmp	r1, #0
90004716:	d14e      	bne.n	900047b6 <__udivmoddi4+0x162>
90004718:	4563      	cmp	r3, ip
9000471a:	f0c0 80e8 	bcc.w	900048ee <__udivmoddi4+0x29a>
9000471e:	4282      	cmp	r2, r0
90004720:	f240 80e5 	bls.w	900048ee <__udivmoddi4+0x29a>
90004724:	4608      	mov	r0, r1
90004726:	2d00      	cmp	r5, #0
90004728:	d0e5      	beq.n	900046f6 <__udivmoddi4+0xa2>
9000472a:	e9c5 4a00 	strd	r4, sl, [r5]
9000472e:	e7e2      	b.n	900046f6 <__udivmoddi4+0xa2>
90004730:	b902      	cbnz	r2, 90004734 <__udivmoddi4+0xe0>
90004732:	deff      	udf	#255	; 0xff
90004734:	fab2 f682 	clz	r6, r2
90004738:	2e00      	cmp	r6, #0
9000473a:	f040 8099 	bne.w	90004870 <__udivmoddi4+0x21c>
9000473e:	1a8b      	subs	r3, r1, r2
90004740:	ea4f 4e12 	mov.w	lr, r2, lsr #16
90004744:	fa1f f882 	uxth.w	r8, r2
90004748:	2101      	movs	r1, #1
9000474a:	ea4f 4c14 	mov.w	ip, r4, lsr #16
9000474e:	fbb3 f2fe 	udiv	r2, r3, lr
90004752:	fb0e 3012 	mls	r0, lr, r2, r3
90004756:	fb08 f902 	mul.w	r9, r8, r2
9000475a:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
9000475e:	45e1      	cmp	r9, ip
90004760:	d908      	bls.n	90004774 <__udivmoddi4+0x120>
90004762:	eb17 0c0c 	adds.w	ip, r7, ip
90004766:	f102 33ff 	add.w	r3, r2, #4294967295
9000476a:	d202      	bcs.n	90004772 <__udivmoddi4+0x11e>
9000476c:	45e1      	cmp	r9, ip
9000476e:	f200 80ca 	bhi.w	90004906 <__udivmoddi4+0x2b2>
90004772:	461a      	mov	r2, r3
90004774:	ebac 0c09 	sub.w	ip, ip, r9
90004778:	b2a3      	uxth	r3, r4
9000477a:	fbbc f0fe 	udiv	r0, ip, lr
9000477e:	fb0e cc10 	mls	ip, lr, r0, ip
90004782:	fb08 f800 	mul.w	r8, r8, r0
90004786:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
9000478a:	45a0      	cmp	r8, r4
9000478c:	d90e      	bls.n	900047ac <__udivmoddi4+0x158>
9000478e:	193c      	adds	r4, r7, r4
90004790:	f100 33ff 	add.w	r3, r0, #4294967295
90004794:	bf2c      	ite	cs
90004796:	f04f 0c01 	movcs.w	ip, #1
9000479a:	f04f 0c00 	movcc.w	ip, #0
9000479e:	45a0      	cmp	r8, r4
900047a0:	d903      	bls.n	900047aa <__udivmoddi4+0x156>
900047a2:	f1bc 0f00 	cmp.w	ip, #0
900047a6:	f000 80a8 	beq.w	900048fa <__udivmoddi4+0x2a6>
900047aa:	4618      	mov	r0, r3
900047ac:	eba4 0408 	sub.w	r4, r4, r8
900047b0:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
900047b4:	e79a      	b.n	900046ec <__udivmoddi4+0x98>
900047b6:	f1c1 0420 	rsb	r4, r1, #32
900047ba:	408b      	lsls	r3, r1
900047bc:	fa02 fe01 	lsl.w	lr, r2, r1
900047c0:	fa0c f601 	lsl.w	r6, ip, r1
900047c4:	40e2      	lsrs	r2, r4
900047c6:	fa20 f704 	lsr.w	r7, r0, r4
900047ca:	fa2c fc04 	lsr.w	ip, ip, r4
900047ce:	fa00 f801 	lsl.w	r8, r0, r1
900047d2:	4313      	orrs	r3, r2
900047d4:	433e      	orrs	r6, r7
900047d6:	0c1f      	lsrs	r7, r3, #16
900047d8:	0c32      	lsrs	r2, r6, #16
900047da:	fa1f f983 	uxth.w	r9, r3
900047de:	fbbc f0f7 	udiv	r0, ip, r7
900047e2:	fb07 cc10 	mls	ip, r7, r0, ip
900047e6:	fb00 fa09 	mul.w	sl, r0, r9
900047ea:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
900047ee:	45e2      	cmp	sl, ip
900047f0:	d908      	bls.n	90004804 <__udivmoddi4+0x1b0>
900047f2:	eb13 0c0c 	adds.w	ip, r3, ip
900047f6:	f100 32ff 	add.w	r2, r0, #4294967295
900047fa:	d202      	bcs.n	90004802 <__udivmoddi4+0x1ae>
900047fc:	45e2      	cmp	sl, ip
900047fe:	f200 8089 	bhi.w	90004914 <__udivmoddi4+0x2c0>
90004802:	4610      	mov	r0, r2
90004804:	ebac 0c0a 	sub.w	ip, ip, sl
90004808:	b2b6      	uxth	r6, r6
9000480a:	fbbc faf7 	udiv	sl, ip, r7
9000480e:	fb07 cc1a 	mls	ip, r7, sl, ip
90004812:	fb0a f909 	mul.w	r9, sl, r9
90004816:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
9000481a:	4591      	cmp	r9, r2
9000481c:	d906      	bls.n	9000482c <__udivmoddi4+0x1d8>
9000481e:	189a      	adds	r2, r3, r2
90004820:	f10a 36ff 	add.w	r6, sl, #4294967295
90004824:	d201      	bcs.n	9000482a <__udivmoddi4+0x1d6>
90004826:	4591      	cmp	r9, r2
90004828:	d87a      	bhi.n	90004920 <__udivmoddi4+0x2cc>
9000482a:	46b2      	mov	sl, r6
9000482c:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
90004830:	eba2 0209 	sub.w	r2, r2, r9
90004834:	fba0 670e 	umull	r6, r7, r0, lr
90004838:	42ba      	cmp	r2, r7
9000483a:	46b4      	mov	ip, r6
9000483c:	46b9      	mov	r9, r7
9000483e:	d302      	bcc.n	90004846 <__udivmoddi4+0x1f2>
90004840:	d107      	bne.n	90004852 <__udivmoddi4+0x1fe>
90004842:	45b0      	cmp	r8, r6
90004844:	d205      	bcs.n	90004852 <__udivmoddi4+0x1fe>
90004846:	ebb6 0c0e 	subs.w	ip, r6, lr
9000484a:	eb67 0303 	sbc.w	r3, r7, r3
9000484e:	3801      	subs	r0, #1
90004850:	4699      	mov	r9, r3
90004852:	2d00      	cmp	r5, #0
90004854:	d06b      	beq.n	9000492e <__udivmoddi4+0x2da>
90004856:	ebb8 030c 	subs.w	r3, r8, ip
9000485a:	eb62 0209 	sbc.w	r2, r2, r9
9000485e:	fa02 f404 	lsl.w	r4, r2, r4
90004862:	40cb      	lsrs	r3, r1
90004864:	40ca      	lsrs	r2, r1
90004866:	2100      	movs	r1, #0
90004868:	431c      	orrs	r4, r3
9000486a:	e9c5 4200 	strd	r4, r2, [r5]
9000486e:	e742      	b.n	900046f6 <__udivmoddi4+0xa2>
90004870:	40b7      	lsls	r7, r6
90004872:	f1c6 0220 	rsb	r2, r6, #32
90004876:	fa01 f306 	lsl.w	r3, r1, r6
9000487a:	40b4      	lsls	r4, r6
9000487c:	fa21 fc02 	lsr.w	ip, r1, r2
90004880:	ea4f 4e17 	mov.w	lr, r7, lsr #16
90004884:	fa20 f202 	lsr.w	r2, r0, r2
90004888:	fa1f f887 	uxth.w	r8, r7
9000488c:	fbbc f1fe 	udiv	r1, ip, lr
90004890:	431a      	orrs	r2, r3
90004892:	fb0e cc11 	mls	ip, lr, r1, ip
90004896:	fb01 f008 	mul.w	r0, r1, r8
9000489a:	0c13      	lsrs	r3, r2, #16
9000489c:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
900048a0:	4560      	cmp	r0, ip
900048a2:	d907      	bls.n	900048b4 <__udivmoddi4+0x260>
900048a4:	eb17 0c0c 	adds.w	ip, r7, ip
900048a8:	f101 33ff 	add.w	r3, r1, #4294967295
900048ac:	d201      	bcs.n	900048b2 <__udivmoddi4+0x25e>
900048ae:	4560      	cmp	r0, ip
900048b0:	d833      	bhi.n	9000491a <__udivmoddi4+0x2c6>
900048b2:	4619      	mov	r1, r3
900048b4:	ebac 0c00 	sub.w	ip, ip, r0
900048b8:	b292      	uxth	r2, r2
900048ba:	fbbc f0fe 	udiv	r0, ip, lr
900048be:	fb0e cc10 	mls	ip, lr, r0, ip
900048c2:	fb00 f308 	mul.w	r3, r0, r8
900048c6:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
900048ca:	4563      	cmp	r3, ip
900048cc:	d907      	bls.n	900048de <__udivmoddi4+0x28a>
900048ce:	eb17 0c0c 	adds.w	ip, r7, ip
900048d2:	f100 32ff 	add.w	r2, r0, #4294967295
900048d6:	d201      	bcs.n	900048dc <__udivmoddi4+0x288>
900048d8:	4563      	cmp	r3, ip
900048da:	d825      	bhi.n	90004928 <__udivmoddi4+0x2d4>
900048dc:	4610      	mov	r0, r2
900048de:	ebac 0303 	sub.w	r3, ip, r3
900048e2:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
900048e6:	e730      	b.n	9000474a <__udivmoddi4+0xf6>
900048e8:	4629      	mov	r1, r5
900048ea:	4628      	mov	r0, r5
900048ec:	e703      	b.n	900046f6 <__udivmoddi4+0xa2>
900048ee:	1a84      	subs	r4, r0, r2
900048f0:	eb6c 0303 	sbc.w	r3, ip, r3
900048f4:	2001      	movs	r0, #1
900048f6:	469a      	mov	sl, r3
900048f8:	e715      	b.n	90004726 <__udivmoddi4+0xd2>
900048fa:	3802      	subs	r0, #2
900048fc:	443c      	add	r4, r7
900048fe:	e755      	b.n	900047ac <__udivmoddi4+0x158>
90004900:	3802      	subs	r0, #2
90004902:	443c      	add	r4, r7
90004904:	e6ed      	b.n	900046e2 <__udivmoddi4+0x8e>
90004906:	3a02      	subs	r2, #2
90004908:	44bc      	add	ip, r7
9000490a:	e733      	b.n	90004774 <__udivmoddi4+0x120>
9000490c:	f1ae 0e02 	sub.w	lr, lr, #2
90004910:	443b      	add	r3, r7
90004912:	e6d2      	b.n	900046ba <__udivmoddi4+0x66>
90004914:	3802      	subs	r0, #2
90004916:	449c      	add	ip, r3
90004918:	e774      	b.n	90004804 <__udivmoddi4+0x1b0>
9000491a:	3902      	subs	r1, #2
9000491c:	44bc      	add	ip, r7
9000491e:	e7c9      	b.n	900048b4 <__udivmoddi4+0x260>
90004920:	f1aa 0a02 	sub.w	sl, sl, #2
90004924:	441a      	add	r2, r3
90004926:	e781      	b.n	9000482c <__udivmoddi4+0x1d8>
90004928:	3802      	subs	r0, #2
9000492a:	44bc      	add	ip, r7
9000492c:	e7d7      	b.n	900048de <__udivmoddi4+0x28a>
9000492e:	4629      	mov	r1, r5
90004930:	e6e1      	b.n	900046f6 <__udivmoddi4+0xa2>
90004932:	bf00      	nop

90004934 <__aeabi_idiv0>:
90004934:	4770      	bx	lr
90004936:	bf00      	nop

90004938 <_close>:
90004938:	4b02      	ldr	r3, [pc, #8]	; (90004944 <_close+0xc>)
9000493a:	2258      	movs	r2, #88	; 0x58
9000493c:	f04f 30ff 	mov.w	r0, #4294967295
90004940:	601a      	str	r2, [r3, #0]
90004942:	4770      	bx	lr
90004944:	20000258 	.word	0x20000258

90004948 <_fstat>:
90004948:	4b02      	ldr	r3, [pc, #8]	; (90004954 <_fstat+0xc>)
9000494a:	2258      	movs	r2, #88	; 0x58
9000494c:	f04f 30ff 	mov.w	r0, #4294967295
90004950:	601a      	str	r2, [r3, #0]
90004952:	4770      	bx	lr
90004954:	20000258 	.word	0x20000258

90004958 <_isatty>:
90004958:	4b02      	ldr	r3, [pc, #8]	; (90004964 <_isatty+0xc>)
9000495a:	2258      	movs	r2, #88	; 0x58
9000495c:	2000      	movs	r0, #0
9000495e:	601a      	str	r2, [r3, #0]
90004960:	4770      	bx	lr
90004962:	bf00      	nop
90004964:	20000258 	.word	0x20000258

90004968 <_lseek>:
90004968:	4b02      	ldr	r3, [pc, #8]	; (90004974 <_lseek+0xc>)
9000496a:	2258      	movs	r2, #88	; 0x58
9000496c:	f04f 30ff 	mov.w	r0, #4294967295
90004970:	601a      	str	r2, [r3, #0]
90004972:	4770      	bx	lr
90004974:	20000258 	.word	0x20000258

90004978 <_read>:
90004978:	4b02      	ldr	r3, [pc, #8]	; (90004984 <_read+0xc>)
9000497a:	2258      	movs	r2, #88	; 0x58
9000497c:	f04f 30ff 	mov.w	r0, #4294967295
90004980:	601a      	str	r2, [r3, #0]
90004982:	4770      	bx	lr
90004984:	20000258 	.word	0x20000258

90004988 <_sbrk>:
90004988:	4b04      	ldr	r3, [pc, #16]	; (9000499c <_sbrk+0x14>)
9000498a:	4602      	mov	r2, r0
9000498c:	6819      	ldr	r1, [r3, #0]
9000498e:	b909      	cbnz	r1, 90004994 <_sbrk+0xc>
90004990:	4903      	ldr	r1, [pc, #12]	; (900049a0 <_sbrk+0x18>)
90004992:	6019      	str	r1, [r3, #0]
90004994:	6818      	ldr	r0, [r3, #0]
90004996:	4402      	add	r2, r0
90004998:	601a      	str	r2, [r3, #0]
9000499a:	4770      	bx	lr
9000499c:	2000024c 	.word	0x2000024c
900049a0:	20001260 	.word	0x20001260

900049a4 <_exit>:
900049a4:	e7fe      	b.n	900049a4 <_exit>
	...

900049a8 <_init>:
900049a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900049aa:	bf00      	nop
900049ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
900049ae:	bc08      	pop	{r3}
900049b0:	469e      	mov	lr, r3
900049b2:	4770      	bx	lr

900049b4 <_fini>:
900049b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
900049b6:	bf00      	nop
900049b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
900049ba:	bc08      	pop	{r3}
900049bc:	469e      	mov	lr, r3
900049be:	4770      	bx	lr
900049c0:	3d3d0a0d 	.word	0x3d3d0a0d
900049c4:	3d3d3d3d 	.word	0x3d3d3d3d
900049c8:	3d3d3d3d 	.word	0x3d3d3d3d
900049cc:	3d3d3d3d 	.word	0x3d3d3d3d
900049d0:	3d3d3d3d 	.word	0x3d3d3d3d
900049d4:	614d203d 	.word	0x614d203d
900049d8:	4d206e69 	.word	0x4d206e69
900049dc:	20756e65 	.word	0x20756e65
900049e0:	3d3d3d3d 	.word	0x3d3d3d3d
900049e4:	3d3d3d3d 	.word	0x3d3d3d3d
900049e8:	3d3d3d3d 	.word	0x3d3d3d3d
900049ec:	3d3d3d3d 	.word	0x3d3d3d3d
900049f0:	3d3d3d3d 	.word	0x3d3d3d3d
900049f4:	3d3d3d3d 	.word	0x3d3d3d3d
900049f8:	3d3d3d3d 	.word	0x3d3d3d3d
900049fc:	20000a0d 	.word	0x20000a0d
90004a00:	73655420 	.word	0x73655420
90004a04:	72502074 	.word	0x72502074
90004a08:	6365746f 	.word	0x6365746f
90004a0c:	6e6f6974 	.word	0x6e6f6974
90004a10:	2d2d2073 	.word	0x2d2d2073
90004a14:	2d2d2d2d 	.word	0x2d2d2d2d
90004a18:	2d2d2d2d 	.word	0x2d2d2d2d
90004a1c:	2d2d2d2d 	.word	0x2d2d2d2d
90004a20:	2d2d2d2d 	.word	0x2d2d2d2d
90004a24:	2d2d2d2d 	.word	0x2d2d2d2d
90004a28:	2d2d2d2d 	.word	0x2d2d2d2d
90004a2c:	2d2d2d2d 	.word	0x2d2d2d2d
90004a30:	2d2d2d2d 	.word	0x2d2d2d2d
90004a34:	2d2d2d2d 	.word	0x2d2d2d2d
90004a38:	0a0d3120 	.word	0x0a0d3120
90004a3c:	54202000 	.word	0x54202000
90004a40:	20747365 	.word	0x20747365
90004a44:	204d4654 	.word	0x204d4654
90004a48:	2d2d2d2d 	.word	0x2d2d2d2d
90004a4c:	2d2d2d2d 	.word	0x2d2d2d2d
90004a50:	2d2d2d2d 	.word	0x2d2d2d2d
90004a54:	2d2d2d2d 	.word	0x2d2d2d2d
90004a58:	2d2d2d2d 	.word	0x2d2d2d2d
90004a5c:	2d2d2d2d 	.word	0x2d2d2d2d
90004a60:	2d2d2d2d 	.word	0x2d2d2d2d
90004a64:	2d2d2d2d 	.word	0x2d2d2d2d
90004a68:	2d2d2d2d 	.word	0x2d2d2d2d
90004a6c:	2d2d2d2d 	.word	0x2d2d2d2d
90004a70:	2d2d2d2d 	.word	0x2d2d2d2d
90004a74:	32202d2d 	.word	0x32202d2d
90004a78:	20000a0d 	.word	0x20000a0d
90004a7c:	6c655320 	.word	0x6c655320
90004a80:	69746365 	.word	0x69746365
90004a84:	3a206e6f 	.word	0x3a206e6f
90004a88:	0a0d      	.short	0x0a0d
90004a8a:	00          	.byte	0x00
90004a8b:	49          	.byte	0x49
90004a8c:	6c61766e 	.word	0x6c61766e
90004a90:	4e206469 	.word	0x4e206469
90004a94:	65626d75 	.word	0x65626d75
90004a98:	0d212072 	.word	0x0d212072
	...

90004a9d <UserAppId>:
90004a9d:	3d0a0d41 3d3d3d3d 3d3d3d3d 3d3d3d3d     A..=============
90004aad:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
90004abd:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
90004acd:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
90004add:	3d3d3d3d 3d3d3d3d 0a0d003d 2020203d     =========...=   
90004aed:	20202020 20202020 28202020 43202943                (C) C
90004afd:	5259504f 54484749 31303220 54532039     OPYRIGHT 2019 ST
90004b0d:	7263694d 656c656f 6f727463 7363696e     Microelectronics
90004b1d:	20202020 20202020 20202020 20202020                     
90004b2d:	0d003d20 20203d0a 20202020 20202020      =...=          
90004b3d:	20202020 20202020 20202020 20202020                     
90004b4d:	20202020 20202020 20202020 20202020                     
90004b5d:	20202020 20202020 20202020 20202020                     
90004b6d:	20202020 20202020 003d2020 203d0a0d               =...= 
90004b7d:	20202020 20202020 20202020 20202020                     
90004b8d:	20202020 20202020 65735520 70412072              User Ap
90004b9d:	25232070 20202063 20202020 20202020     p #%c           
90004bad:	20202020 20202020 20202020 20202020                     
90004bbd:	20202020 0a0d003d                            =.....

90004bc7 <AHBPrescTable>:
	...
90004bcf:	04030201 09080706                       ........

90004bd7 <APBPrescTable>:
90004bd7:	00000000 04030201                        .........

90004be0 <MSIRangeTable>:
90004be0:	000186a0 00030d40 00061a80 000c3500     ....@........5..
90004bf0:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
90004c00:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
90004c20:	3d3d0a0d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ..==============
90004c30:	3d3d3d3d 6554203d 4d207473 20756e65     ===== Test Menu 
90004c40:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
90004c50:	3d3d3d3d 3d3d3d3d 3d3d3d3d 20000a0d     ============... 
90004c60:	73655420 72502074 6365746f 6e6f6974      Test Protection
90004c70:	4e203a20 65536e6f 65727563 79727420      : NonSecure try
90004c80:	206f7420 65636361 74207373 6553206f      to access to Se
90004c90:	65727563 2d2d2d20 0a0d3120 52202000     cure --- 1...  R
90004ca0:	52205044 65726765 6f697373 2d2d206e     DP Regression --
90004cb0:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
90004cc0:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
90004cd0:	2d2d2d2d 32202d2d 20000a0d 65725020     ------ 2...  Pre
90004ce0:	756f6976 654d2073 2d20756e 2d2d2d2d     vious Menu -----
90004cf0:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
90004d00:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
90004d10:	2d2d2d2d 0a0d7820 200a0d00 69766544     ---- x..... Devi
90004d20:	72206563 79646165 726f6620 67657220     ce ready for reg
90004d30:	73736572 206e6f69 000d203a 2d200a0d     ression : .... -
90004d40:	6e6f4320 7463656e 4d545320 75433233      Connect STM32Cu
90004d50:	72506562 6172676f 72656d6d 646f6d20     beProgrammer mod
90004d60:	6f483d65 756c5074 0a0d0067 50202d20     e=HotPlug... - P
90004d70:	6f667265 52206d72 52205044 65726765     erform RDP Regre
90004d80:	6f697373 0d00206e 0d00200a 5b203d0a     ssion ... ...= [
90004d90:	54534554 7325205d 25204020 30252073     TEST] %s @ %s %0
90004da0:	0d007838 616c660a 65206873 726f7272     8x...flash error
90004db0:	646f6320 25203a65 424f0078 00402073      code: %x.OBs @.
90004dc0:	6c6f7349 64657461 61762000 2065756c     Isolated. value 
90004dd0:	6425203a 76200020 65756c61 25203a20     : %d . value : %
90004de0:	0d002078 4554200a 505f5453 45544f52     x ... TEST_PROTE
90004df0:	4f495443 525f534e 535f6e75 73556365     CTIONS_Run_SecUs
90004e00:	654d7265 203a206d 73736150 0d006465     erMem : Passed..
90004e10:	4554200a 505f5453 45544f52 4f495443     . TEST_PROTECTIO
90004e20:	525f534e 535f6e75 73556365 654d7265     NS_Run_SecUserMe
90004e30:	203a206d 6c696146 08006465 08080808     m : Failed......
90004e40:	00080808                                ....

90004e44 <aProtectTests>:
90004e44:	20030000 61746144 63655320 20657275     ... Data Secure 
90004e54:	72617453 00000074 00000000 00000000     Start...........
90004e64:	00000000 00000104 2003fc00 61746144     ........... Data
90004e74:	63655320 20657275 00646e45 00000000      Secure End.....
	...
90004e90:	00000104 0c017400 65646f43 63655320     .....t..Code Sec
90004ea0:	20657275 72617453 00000074 00000000     ure Start.......
	...
90004eb8:	00000101 0c03b3ff 65646f43 63655320     ........Code Sec
90004ec8:	20657275 28444e45 656e6576 00297265     ure END(veneer).
	...
90004ee0:	00000101 420c0804 20474e52 53205049     .......BRNG IP S
90004ef0:	00000052 00000000 00000000 00000000     R...............
	...
90004f08:	00000006 420c0808 20474e52 44205049     .......BRNG IP D
90004f18:	00000052 00000000 00000000 00000000     R...............
	...
90004f30:	00000006 40003500 4b434142 52205055     .....5.@BACKUP R
90004f40:	30204745 00000000 00000000 00000000     EG 0............
	...
90004f58:	00000106 4000351c 4b434142 52205055     .....5.@BACKUP R
90004f68:	37204745 00000000 00000000 00000000     EG 7............
	...
90004f80:	00000106 00000000 63657845 6f697475     ........Executio
90004f90:	7573206e 73656363 6c756673 00000000     n successful....
	...
90004fa8:	00000007                                ....

90004fac <aTestOperation>:
90004fac:	74697277 20382065 65747962 00000073     write 8 bytes...
90004fbc:	00000000 64616572 62203120 00657479     ....read 1 byte.
	...
90004fd4:	73617265 31352065 79622032 00736574     erase 512 bytes.
90004fe4:	00000000 74697277 20342065 65747962     ....write 4 byte
90004ff4:	00000073 00000000 64616572 62203120     s.......read 1 b
90005004:	00657479 00000000 00000000 63657865     yte.........exec
90005014:	00657475 00000000 00000000 00000000     ute.............
90005024:	64616572 62203420 73657479 00000000     read 4 bytes....
90005034:	00000000 00646e65 00000000 00000000     ....end.........
	...
9000504c:	322e3225 55530078 53454343 4c554653     %2.2x.SUCCESSFUL
9000505c:	49414600 0044454c 20534541 204d4347     .FAILED.AES GCM 
9000506c:	74736574 0d732520 4541000a 42432053     test %s...AES CB
9000507c:	65742043 25207473 000a0d73 20534541     C test %s...AES 
9000508c:	204d4343 74736574 0d732520 5353000a     CCM test %s...SS
9000509c:	65732054 49552074 65742044 25207473     T set UID test %
900050ac:	000a0d73 20545353 64616572 63202f20     s...SST read / c
900050bc:	6b636568 44495520 73657420 73252074     heck UID test %s
900050cc:	53000a0d 72205453 766f6d65 49552065     ...SST remove UI
900050dc:	65742044 25207473 000a0d73 20544145     D test %s...EAT 
900050ec:	6d726f6e 63206c61 75637269 73207469     normal circuit s
900050fc:	74206769 20747365 0a0d7325 53544900     ig test %s...ITS
9000510c:	74657320 44495520 73657420 73252074      set UID test %s
9000511c:	49000a0d 72205354 20646165 6863202f     ...ITS read / ch
9000512c:	206b6365 20444955 74736574 0d732520     eck UID test %s.
9000513c:	5449000a 65722053 65766f6d 44495520     ..ITS remove UID
9000514c:	73657420 73252074 53000a0d 32324148      test %s...SHA22
9000515c:	65742034 25207473 000a0d73 32414853     4 test %s...SHA2
9000516c:	74203635 20747365 0a0d7325 4d554300     56 test %s...CUM
9000517c:	54414c55 20455649 55534552 203a544c     ULATIVE RESULT: 
9000518c:	252f6425 75732064 73656363 000a0d73     %d/%d success...
9000519c:	3d3d0a0d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ..==============
900051ac:	3d3d3d3d 3d3d3d3d 4654203d 7845204d     ========= TFM Ex
900051bc:	6c706d61 4d207365 20756e65 3d3d3d3d     amples Menu ====
900051cc:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
900051dc:	3d3d3d3d 0d3d3d3d 2020000a 204d4654     =======...  TFM 
900051ec:	6554202d 41207473 20206c6c 20202020     - Test All      
900051fc:	20202020 20202020 20202020 20202020                     
9000520c:	20202020 20202020 20202020 2d2d2d20                  ---
9000521c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
9000522c:	30202d2d 20000a0d 4d465420 54202d20     -- 0...  TFM - T
9000523c:	20747365 2d534541 204d4347 20202020     est AES-GCM     
9000524c:	20202020 20202020 20202020 20202020                     
9000525c:	20202020 20202020 2d2d2020 2d2d2d2d               ------
9000526c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 202d2d2d     --------------- 
9000527c:	000a0d31 46542020 202d204d 74736554     1...  TFM - Test
9000528c:	53454120 4342432d 20202020 20202020      AES-CBC        
9000529c:	20202020 20202020 20202020 20202020                     
900052ac:	20202020 2d202020 2d2d2d2d 2d2d2d2d            ---------
900052bc:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0a0d3220     ------------ 2..
900052cc:	54202000 2d204d46 73655420 45412074     .  TFM - Test AE
900052dc:	43432d53 2020204d 20202020 20202020     S-CCM           
900052ec:	20202020 20202020 20202020 20202020                     
900052fc:	20202020 2d2d2d2d 2d2d2d2d 2d2d2d2d         ------------
9000530c:	2d2d2d2d 2d2d2d2d 0d33202d 2020000a     --------- 3...  
9000531c:	204d4654 6554202d 53207473 73205453     TFM - Test SST s
9000532c:	55207465 20204449 20202020 20202020     et UID          
9000533c:	20202020 20202020 20202020 20202020                     
9000534c:	2d2d2d20 2d2d2d2d 2d2d2d2d 2d2d2d2d      ---------------
9000535c:	2d2d2d2d 34202d2d 20000a0d 4d465420     ------ 4...  TFM
9000536c:	54202d20 20747365 20545353 64616572      - Test SST read
9000537c:	63202f20 6b636568 44495520 20202020      / check UID    
9000538c:	20202020 20202020 20202020 2d2d2020                   --
9000539c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
900053ac:	202d2d2d 000a0d35 46542020 202d204d     --- 5...  TFM - 
900053bc:	74736554 54535320 6d657220 2065766f     Test SST remove 
900053cc:	20444955 20202020 20202020 20202020     UID             
900053dc:	20202020 20202020 2d202020 2d2d2d2d                -----
900053ec:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
900053fc:	0a0d3620 54202000 2d204d46 73655420      6...  TFM - Tes
9000540c:	41452074 20202054 20202020 20202020     t EAT           
9000541c:	20202020 20202020 20202020 20202020                     
9000542c:	20202020 20202020 2d2d2d2d 2d2d2d2d             --------
9000543c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 0d37202d     ------------- 7.
9000544c:	2020000a 204d4654 6554202d 49207473     ..  TFM - Test I
9000545c:	73205354 55207465 20204449 20202020     TS set UID      
9000546c:	20202020 20202020 20202020 20202020                     
9000547c:	20202020 2d2d2d20 2d2d2d2d 2d2d2d2d          -----------
9000548c:	2d2d2d2d 2d2d2d2d 38202d2d 20000a0d     ---------- 8... 
9000549c:	4d465420 54202d20 20747365 20535449      TFM - Test ITS 
900054ac:	64616572 63202f20 6b636568 44495520     read / check UID
900054bc:	20202020 20202020 20202020 20202020                     
900054cc:	2d2d2020 2d2d2d2d 2d2d2d2d 2d2d2d2d       --------------
900054dc:	2d2d2d2d 202d2d2d 000a0d39 46542020     ------- 9...  TF
900054ec:	202d204d 74736554 53544920 6d657220     M - Test ITS rem
900054fc:	2065766f 20444955 20202020 20202020     ove UID         
9000550c:	20202020 20202020 20202020 2d202020                    -
9000551c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
9000552c:	2d2d2d2d 0a0d6120 54202000 2d204d46     ---- a...  TFM -
9000553c:	73655420 48532074 34323241 20202020      Test SHA224    
9000554c:	20202020 20202020 20202020 20202020                     
9000555c:	20202020 20202020 20202020 2d2d2d2d                 ----
9000556c:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ----------------
9000557c:	0d62202d 2020000a 204d4654 6554202d     - b...  TFM - Te
9000558c:	53207473 35324148 20202036 20202020     st SHA256       
9000559c:	20202020 20202020 20202020 20202020                     
900055ac:	20202020 20202020 2d2d2d20 2d2d2d2d              -------
900055bc:	2d2d2d2d 2d2d2d2d 2d2d2d2d 63202d2d     -------------- c
900055cc:	20000a0d 69784520 46542074 7845204d     ...  Exit TFM Ex
900055dc:	6c706d61 4d207365 20756e65 20202020     amples Menu     
900055ec:	20202020 20202020 20202020 20202020                     
900055fc:	20202020 2d2d2020 2d2d2d2d 2d2d2d2d           ----------
9000560c:	2d2d2d2d 2d2d2d2d 202d2d2d 000a0d78     ----------- x...
9000561c:	656b6f74 6572206e 73657571 61762074     token request va
9000562c:	2065756c 74000d3a 6e656b6f 73657220     lue :..token res
9000563c:	736e6f70 61762065 2065756c 66000d3a     ponse value :..f
9000564c:	656c6961 74732064 73757461 0d642520     ailed status %d.
9000565c:	2323000a 23232323 23232323 23232323     ..##############
9000566c:	23232323 23232323 23232323 23232323     ################
9000567c:	23232323 23232323 23232323 54002323     ##############.T
9000568c:	54535552 49464445 41574d52 465f4552     RUSTEDFIRMWARE_F
9000569c:	535f524f 32334d54                        OR_STM32.

900056a5 <CSWTCH.58>:
900056a5:	08020401                                ....

900056a9 <CSWTCH.59>:
900056a9:	10101000 10101004 10101002               .............

900056b6 <UARTPrescTable>:
900056b6:	00020001 00060004 000a0008 0010000c     ................
900056c6:	00400020 01000080                        .@.....

900056ce <__func__.7682>:
900056ce:	5f617370 68706963 745f7265 00747365     psa_cipher_test.

900056de <__func__.7712>:
900056de:	5f617370 68736168 7365745f               psa_hash_test.

900056ec <__func__.7769>:
900056ec:	5f617370 64616561 7365745f               psa_aead_test.

900056fa <hash_val>:
900056fa:	350e4a56 d0bcc7f1 bcb1cf7d 2efa16c9     VJ.5....}.......
9000570a:	b296bef5 00000000 00000000 00000000     ................
	...
9000573a:	e290d200 7ec14e0e 10f5957a 0474765c     .....N.~z...\vt.
9000574a:	5e56b56e 15bae7e5 f347236c 00000000     n.V^....l#G.....
	...
9000577a:	2a09226b 14f51e37 cf4d39f7 46174dad     k".*7....9M..M.F
9000578a:	a033cb66 4e41d839 4dd32af1 3eb5c369     f.3.9.AN.*.Mi..>
	...
900057ba:	bb117964 59474e47 60bc4d3e 9cbff9a5     dy..GNGY>M.`....
900057ca:	0f55bac0 df72ca93 56501e57 d6014af9     ..U...r.W.PV.J..
900057da:	62f76fa5 fd484f34 4207159d b89472b7     .o.b4OH....B.r..
	...
900057fa:	6ca31cb4 ad1d67a9 1bbe1f34 2a40c483     ...l.g..4.....@*
9000580a:	bb794247 60f0ca21 9b6ed2e4 3f341270     GBy.!..`..n.p.4?
9000581a:	31092c55 21405b0a 583ba801 1a1348e7     U,.1.[@!..;X.H..
9000582a:	d2e1cd7e 34581046 aa4b1449 b1f5a989     ~...F.X4I.K.....
9000583a:	6f727245 65702072 726f6672 676e696d     Error performing
9000584a:	41454120 6e652044 70797263 6e6f6974      AEAD encryption
9000585a:	636e4500 74707972 64206465 20617461     .Encrypted data 
9000586a:	676e656c 69206874 69642073 72656666     length is differ
9000587a:	20746e65 6e616874 70786520 65746365     ent than expecte
9000588a:	72450064 20726f72 66726570 696d726f     d.Error performi
9000589a:	4120676e 20444145 72636564 69747079     ng AEAD decrypti
900058aa:	44006e6f 79726365 64657470 74616420     on.Decrypted dat
900058ba:	656c2061 6874676e 20736920 66666964     a length is diff
900058ca:	6e657265 72662074 70206d6f 6e69616c     erent from plain
900058da:	78657420 31300074 35343332 39383736      text.0123456789
900058ea:	68540030 69207369 73612073 69636f73     0.This is associ
900058fa:	64657461 74616420 6c410061 69726f67     ated data.Algori
9000590a:	206d6874 20544f4e 50505553 4554524f     thm NOT SUPPORTE
9000591a:	79622044 65687420 706d6920 656d656c     D by the impleme
9000592a:	7461746e 006e6f69 6f727245 65732072     ntation.Error se
9000593a:	6e697474 70752067 70696320 20726568     tting up cipher 
9000594a:	7265706f 6f697461 626f206e 7463656a     operation object
9000595a:	72724500 7320726f 69747465 7420676e     .Error setting t
9000596a:	49206568 6e6f2056 65687420 70796320     he IV on the cyp
9000597a:	20726568 7265706f 6f697461 626f206e     her operation ob
9000598a:	7463656a 72724500 6120726f 74726f62     ject.Error abort
9000599a:	20676e69 20656874 7265706f 6f697461     ing the operatio
900059aa:	7245006e 20726f72 72636e65 69747079     n.Error encrypti
900059ba:	6f20676e 6320656e 6b6e7568 20666f20     ng one chunk of 
900059ca:	6f666e69 74616d72 006e6f69 65707845     information.Expe
900059da:	64657463 636e6520 74707972 64206465     cted encrypted d
900059ea:	20617461 676e656c 69206874 69642073     ata length is di
900059fa:	72656666 20746e65 6d6f7266 70786520     fferent from exp
90005a0a:	65746365 72450064 20726f72 616e6966     ected.Error fina
90005a1a:	6973696c 7420676e 63206568 65687069     lising the ciphe
90005a2a:	706f2072 74617265 006e6f69 78656e55     r operation.Unex
90005a3a:	74636570 6f206465 75707475 656c2074     pected output le
90005a4a:	6874676e 74666120 66207265 6c616e69     ngth after final
90005a5a:	74617369 006e6f69 6f727245 65732072     isation.Error se
90005a6a:	6e697474 68742067 56492065 726f6620     tting the IV for
90005a7a:	63656420 74707972 006e6f69 6f727245      decryption.Erro
90005a8a:	75642072 676e6972 63656420 74707972     r during decrypt
90005a9a:	006e6f69 72636544 65747079 61642064     ion.Decrypted da
90005aaa:	64206174 6e73656f 6d207427 68637461     ta doesn't match
90005aba:	74697720 6c702068 206e6961 74786574      with plain text
90005aca:	74664100 66207265 6c616e69 6e697369     .After finalisin
90005ada:	75202c67 7078656e 65746365 65642064     g, unexpected de
90005aea:	70797263 20646574 676e656c 45006874     crypted length.E
90005afa:	726f7272 73656420 796f7274 20676e69     rror destroying 
90005b0a:	656b2061 31300079 35343332 39383736     a key.0123456789
90005b1a:	33323130 69530034 65657478 7962206e     01234.Sixteen by
90005b2a:	21736574 72450021 20726f72 74746573     tes!!.Error sett
90005b3a:	20676e69 68207075 20687361 7265706f     ing up hash oper
90005b4a:	6f697461 626f206e 7463656a 72724500     ation object.Err
90005b5a:	7520726f 74616470 20676e69 20656874     or updating the 
90005b6a:	68736168 65706f20 69746172 6f206e6f     hash operation o
90005b7a:	63656a62 72450074 20726f72 69726576     bject.Error veri
90005b8a:	6e697966 68742067 61682065 6f206873     fying the hash o
90005b9a:	61726570 6e6f6974 6a626f20 00746365     peration object.
90005baa:	6c696146 74206465 6c61206f 61636f6c     Failed to alloca
90005bba:	6b206574 46007965 656c6961 6f742064     te key.Failed to
90005bca:	74657320 79656b20 6c6f7020 00796369      set key policy.
90005bda:	2079654b 646e6168 6420656c 2073656f     Key handle does 
90005bea:	20746f6e 20746579 746e6f63 206e6961     not yet contain 
90005bfa:	2079656b 6574616d 6c616972 72724500     key material.Err
90005c0a:	6920726f 726f706d 676e6974 6b206120     or importing a k
90005c1a:	45007965 726f7272 74656720 676e6974     ey.Error getting
90005c2a:	79656b20 74656d20 74616461 68540061      key metadata.Th
90005c3a:	756e2065 7265626d 20666f20 2079656b     e number of key 
90005c4a:	73746962 20736920 66666964 6e657265     bits is differen
90005c5a:	72662074 65206d6f 63657078 00646574     t from expected.
90005c6a:	20656854 65707974 20666f20 20656874     The type of the 
90005c7a:	2079656b 64207369 65666669 746e6572     key is different
90005c8a:	6f726620 7865206d 74636570 45006465      from expected.E
90005c9a:	726f7272 70786520 6974726f 6120676e     rror exporting a
90005caa:	79656b20 6d754e00 20726562 6220666f      key.Number of b
90005cba:	73657479 20666f20 6f707865 64657472     ytes of exported
90005cca:	79656b20 66696420 65726566 6620746e      key different f
90005cda:	206d6f72 65707865 64657463 70784500     rom expected.Exp
90005cea:	6574726f 656b2064 6f642079 276e7365     orted key doesn'
90005cfa:	616d2074 20686374 20656874 6f706d69     t match the impo
90005d0a:	64657472 79656b20 72724500 6420726f     rted key.Error d
90005d1a:	72747365 6e69796f 68742067 656b2065     estroying the ke
90005d2a:	654b0079 61682079 656c646e 6f687320     y.Key handle sho
90005d3a:	20646c75 69206562 6c61766e 6e206469     uld be invalid n
90005d4a:	5400776f 20534948 4d205349 454b2059     ow.THIS IS MY KE
90005d5a:	54003159 20736968 6d207369 65742079     Y1.This is my te
90005d6a:	6d207473 61737365 202c6567 656c7000     st message, .ple
90005d7a:	20657361 656e6567 65746172 68206120     ase generate a h
90005d8a:	20687361 20726f66 73696874 6c70002e     ash for this..pl
90005d9a:	65736165 6e656720 74617265 20612065     ease generate a 
90005daa:	63616d68 726f6620 69687420 45002e73     hmac for this..E
90005dba:	726f7272 25202820 0d292073 4554000a     rror ( %s )...TE
90005dca:	535f5453 45544955 5252455f 564e495f     ST_SUITE_ERR_INV
90005dda:	44494c41 5345545f 41445f54 00214154     ALID_TEST_DATA!.
90005dea:	25335b1b 00006d64                        .[3%dm....

90005df4 <_global_impure_ptr>:
90005df4:	2000012c                                ,.. 

90005df8 <__sf_fake_stderr>:
	...

90005e18 <__sf_fake_stdin>:
	...

90005e38 <__sf_fake_stdout>:
	...
90005e58:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
90005e68:	32313000 36353433 41393837 45444342     .0123456789ABCDE
90005e78:	31300046 35343332 39383736 64636261     F.0123456789abcd
90005e88:	00006665                                ef..

90005e8c <__EH_FRAME_BEGIN__>:
90005e8c:	00000000                                ....
