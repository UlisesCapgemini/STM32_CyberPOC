
TFM_Loader.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004cf8  0807a000  0807a000  0000a000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  0807ecf8  0807ecf8  0000ecf8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .copy.table   00000018  0807ed00  0807ed00  0000ed00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .zero.table   00000010  0807ed18  0807ed18  0000ed18  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .data         00000098  20000000  0807ed28  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          000005b0  20000098  0807edc0  00010098  2**2
                  ALLOC
  6 .msp_stack    00000400  20000660  0807f3a0  00010660  2**5
                  ALLOC
  7 .psp_stack    00000400  20000a60  0807f7a0  00010660  2**5
                  ALLOC
  8 .heap         00000200  20000e60  0807fba0  00010660  2**3
                  ALLOC
  9 .ARM.attributes 00000036  00000000  00000000  00010098  2**0
                  CONTENTS, READONLY
 10 .comment      0000007b  00000000  00000000  000100ce  2**0
                  CONTENTS, READONLY
 11 .debug_info   000167cd  00000000  00000000  00010149  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000330b  00000000  00000000  00026916  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    000075e1  00000000  00000000  00029c21  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000a78  00000000  00000000  00031202  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000c40  00000000  00000000  00031c7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0002b9da  00000000  00000000  000328ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0000ded5  00000000  00000000  0005e294  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    0010bac3  00000000  00000000  0006c169  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  00002750  00000000  00000000  00177c2c  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stab         00000084  00000000  00000000  0017a37c  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .stabstr      00000117  00000000  00000000  0017a400  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0807a000 <__Vectors>:
 807a000:	20000a60 	.word	0x20000a60
 807a004:	0807a2a9 	.word	0x0807a2a9
 807a008:	0807a2f9 	.word	0x0807a2f9
 807a00c:	0807a2fd 	.word	0x0807a2fd
 807a010:	0807a301 	.word	0x0807a301
 807a014:	0807a305 	.word	0x0807a305
 807a018:	0807a309 	.word	0x0807a309
 807a01c:	0807a30d 	.word	0x0807a30d
	...
 807a02c:	0807a311 	.word	0x0807a311
 807a030:	0807a315 	.word	0x0807a315
 807a034:	00000000 	.word	0x00000000
 807a038:	0807a319 	.word	0x0807a319
 807a03c:	0807a31d 	.word	0x0807a31d
 807a040:	0807a321 	.word	0x0807a321
 807a044:	0807a325 	.word	0x0807a325
 807a048:	0807a329 	.word	0x0807a329
 807a04c:	0807a32d 	.word	0x0807a32d
 807a050:	0807a331 	.word	0x0807a331
 807a054:	0807a335 	.word	0x0807a335
 807a058:	0807a339 	.word	0x0807a339
 807a05c:	0807a33d 	.word	0x0807a33d
 807a060:	0807a341 	.word	0x0807a341
 807a064:	0807a345 	.word	0x0807a345
 807a068:	0807a349 	.word	0x0807a349
 807a06c:	0807a34d 	.word	0x0807a34d
 807a070:	0807a351 	.word	0x0807a351
 807a074:	0807a355 	.word	0x0807a355
 807a078:	0807a359 	.word	0x0807a359
 807a07c:	0807a35d 	.word	0x0807a35d
 807a080:	0807a361 	.word	0x0807a361
 807a084:	0807a365 	.word	0x0807a365
 807a088:	0807a369 	.word	0x0807a369
 807a08c:	0807a36d 	.word	0x0807a36d
 807a090:	0807a371 	.word	0x0807a371
 807a094:	0807a375 	.word	0x0807a375
 807a098:	0807a379 	.word	0x0807a379
 807a09c:	0807a37d 	.word	0x0807a37d
 807a0a0:	0807a381 	.word	0x0807a381
 807a0a4:	0807a385 	.word	0x0807a385
 807a0a8:	0807a389 	.word	0x0807a389
 807a0ac:	0807a38d 	.word	0x0807a38d
 807a0b0:	0807a391 	.word	0x0807a391
 807a0b4:	0807a395 	.word	0x0807a395
 807a0b8:	0807a399 	.word	0x0807a399
 807a0bc:	0807a39d 	.word	0x0807a39d
 807a0c0:	0807a3a1 	.word	0x0807a3a1
 807a0c4:	0807a3a5 	.word	0x0807a3a5
 807a0c8:	0807a3a9 	.word	0x0807a3a9
 807a0cc:	0807a3ad 	.word	0x0807a3ad
 807a0d0:	0807a3b1 	.word	0x0807a3b1
 807a0d4:	0807a3b5 	.word	0x0807a3b5
 807a0d8:	0807a3b9 	.word	0x0807a3b9
 807a0dc:	0807a3bd 	.word	0x0807a3bd
 807a0e0:	0807a3c1 	.word	0x0807a3c1
 807a0e4:	0807a3c5 	.word	0x0807a3c5
 807a0e8:	0807a3c9 	.word	0x0807a3c9
 807a0ec:	0807a3cd 	.word	0x0807a3cd
 807a0f0:	0807a3d1 	.word	0x0807a3d1
 807a0f4:	0807a3d5 	.word	0x0807a3d5
 807a0f8:	0807a3d9 	.word	0x0807a3d9
 807a0fc:	0807a3dd 	.word	0x0807a3dd
 807a100:	0807a3e1 	.word	0x0807a3e1
 807a104:	0807a3e5 	.word	0x0807a3e5
 807a108:	0807a3e9 	.word	0x0807a3e9
 807a10c:	0807a3ed 	.word	0x0807a3ed
 807a110:	0807a3f1 	.word	0x0807a3f1
 807a114:	0807a3f5 	.word	0x0807a3f5
 807a118:	0807a3f9 	.word	0x0807a3f9
 807a11c:	0807a3fd 	.word	0x0807a3fd
 807a120:	0807a401 	.word	0x0807a401
 807a124:	0807a405 	.word	0x0807a405
 807a128:	0807a409 	.word	0x0807a409
 807a12c:	0807a40d 	.word	0x0807a40d
 807a130:	0807a411 	.word	0x0807a411
 807a134:	0807a415 	.word	0x0807a415
 807a138:	0807a419 	.word	0x0807a419
 807a13c:	0807a41d 	.word	0x0807a41d
 807a140:	0807a421 	.word	0x0807a421
 807a144:	0807a425 	.word	0x0807a425
 807a148:	0807a429 	.word	0x0807a429
 807a14c:	0807a42d 	.word	0x0807a42d
 807a150:	0807a431 	.word	0x0807a431
 807a154:	0807a435 	.word	0x0807a435
 807a158:	0807a439 	.word	0x0807a439
 807a15c:	0807a43d 	.word	0x0807a43d
 807a160:	0807a441 	.word	0x0807a441
 807a164:	0807a445 	.word	0x0807a445
 807a168:	0807a449 	.word	0x0807a449
 807a16c:	0807a44d 	.word	0x0807a44d
 807a170:	0807a451 	.word	0x0807a451
 807a174:	00000000 	.word	0x00000000
 807a178:	0807a455 	.word	0x0807a455
 807a17c:	00000000 	.word	0x00000000
 807a180:	0807a459 	.word	0x0807a459
 807a184:	0807a45d 	.word	0x0807a45d
 807a188:	0807a461 	.word	0x0807a461
 807a18c:	0807a465 	.word	0x0807a465
 807a190:	0807a469 	.word	0x0807a469
 807a194:	0807a46d 	.word	0x0807a46d
 807a198:	0807a471 	.word	0x0807a471
 807a19c:	0807a475 	.word	0x0807a475
 807a1a0:	0807a479 	.word	0x0807a479
 807a1a4:	0807a47d 	.word	0x0807a47d
 807a1a8:	0807a481 	.word	0x0807a481
 807a1ac:	0807a485 	.word	0x0807a485
 807a1b0:	0807a489 	.word	0x0807a489
 807a1b4:	00000000 	.word	0x00000000
 807a1b8:	0807a48d 	.word	0x0807a48d
 807a1bc:	0807a491 	.word	0x0807a491
	...
 807a1c8:	0807a495 	.word	0x0807a495
 807a1cc:	0807a499 	.word	0x0807a499
 807a1d0:	0807a49d 	.word	0x0807a49d
 807a1d4:	0807a4a1 	.word	0x0807a4a1
 807a1d8:	0807a4a5 	.word	0x0807a4a5
 807a1dc:	0807a4a9 	.word	0x0807a4a9
 807a1e0:	0807a4ad 	.word	0x0807a4ad
 807a1e4:	0807a4b1 	.word	0x0807a4b1
 807a1e8:	0807a4b5 	.word	0x0807a4b5
 807a1ec:	0807a4b9 	.word	0x0807a4b9
 807a1f0:	0807a4bd 	.word	0x0807a4bd

0807a1f4 <__do_global_dtors_aux>:
 807a1f4:	b510      	push	{r4, lr}
 807a1f6:	4c05      	ldr	r4, [pc, #20]	; (807a20c <__do_global_dtors_aux+0x18>)
 807a1f8:	7823      	ldrb	r3, [r4, #0]
 807a1fa:	b933      	cbnz	r3, 807a20a <__do_global_dtors_aux+0x16>
 807a1fc:	4b04      	ldr	r3, [pc, #16]	; (807a210 <__do_global_dtors_aux+0x1c>)
 807a1fe:	b113      	cbz	r3, 807a206 <__do_global_dtors_aux+0x12>
 807a200:	4804      	ldr	r0, [pc, #16]	; (807a214 <__do_global_dtors_aux+0x20>)
 807a202:	e000      	b.n	807a206 <__do_global_dtors_aux+0x12>
 807a204:	bf00      	nop
 807a206:	2301      	movs	r3, #1
 807a208:	7023      	strb	r3, [r4, #0]
 807a20a:	bd10      	pop	{r4, pc}
 807a20c:	20000098 	.word	0x20000098
 807a210:	00000000 	.word	0x00000000
 807a214:	0807ecf4 	.word	0x0807ecf4

0807a218 <frame_dummy>:
 807a218:	b508      	push	{r3, lr}
 807a21a:	4b03      	ldr	r3, [pc, #12]	; (807a228 <frame_dummy+0x10>)
 807a21c:	b11b      	cbz	r3, 807a226 <frame_dummy+0xe>
 807a21e:	4903      	ldr	r1, [pc, #12]	; (807a22c <frame_dummy+0x14>)
 807a220:	4803      	ldr	r0, [pc, #12]	; (807a230 <frame_dummy+0x18>)
 807a222:	e000      	b.n	807a226 <frame_dummy+0xe>
 807a224:	bf00      	nop
 807a226:	bd08      	pop	{r3, pc}
 807a228:	00000000 	.word	0x00000000
 807a22c:	2000009c 	.word	0x2000009c
 807a230:	0807ecf4 	.word	0x0807ecf4

0807a234 <_mainCRTStartup>:
 807a234:	4b15      	ldr	r3, [pc, #84]	; (807a28c <_mainCRTStartup+0x58>)
 807a236:	2b00      	cmp	r3, #0
 807a238:	bf08      	it	eq
 807a23a:	4b13      	ldreq	r3, [pc, #76]	; (807a288 <_mainCRTStartup+0x54>)
 807a23c:	469d      	mov	sp, r3
 807a23e:	f5a3 3a80 	sub.w	sl, r3, #65536	; 0x10000
 807a242:	2100      	movs	r1, #0
 807a244:	468b      	mov	fp, r1
 807a246:	460f      	mov	r7, r1
 807a248:	4813      	ldr	r0, [pc, #76]	; (807a298 <_mainCRTStartup+0x64>)
 807a24a:	4a14      	ldr	r2, [pc, #80]	; (807a29c <_mainCRTStartup+0x68>)
 807a24c:	1a12      	subs	r2, r2, r0
 807a24e:	f003 f8ad 	bl	807d3ac <memset>
 807a252:	4b0f      	ldr	r3, [pc, #60]	; (807a290 <_mainCRTStartup+0x5c>)
 807a254:	2b00      	cmp	r3, #0
 807a256:	d000      	beq.n	807a25a <_mainCRTStartup+0x26>
 807a258:	4798      	blx	r3
 807a25a:	4b0e      	ldr	r3, [pc, #56]	; (807a294 <_mainCRTStartup+0x60>)
 807a25c:	2b00      	cmp	r3, #0
 807a25e:	d000      	beq.n	807a262 <_mainCRTStartup+0x2e>
 807a260:	4798      	blx	r3
 807a262:	2000      	movs	r0, #0
 807a264:	2100      	movs	r1, #0
 807a266:	0004      	movs	r4, r0
 807a268:	000d      	movs	r5, r1
 807a26a:	480d      	ldr	r0, [pc, #52]	; (807a2a0 <_mainCRTStartup+0x6c>)
 807a26c:	2800      	cmp	r0, #0
 807a26e:	d002      	beq.n	807a276 <_mainCRTStartup+0x42>
 807a270:	480c      	ldr	r0, [pc, #48]	; (807a2a4 <_mainCRTStartup+0x70>)
 807a272:	e000      	b.n	807a276 <_mainCRTStartup+0x42>
 807a274:	bf00      	nop
 807a276:	f003 f875 	bl	807d364 <__libc_init_array>
 807a27a:	0020      	movs	r0, r4
 807a27c:	0029      	movs	r1, r5
 807a27e:	f000 fca9 	bl	807abd4 <main>
 807a282:	f003 f85b 	bl	807d33c <exit>
 807a286:	bf00      	nop
 807a288:	00080000 	.word	0x00080000
 807a28c:	20000e60 	.word	0x20000e60
	...
 807a298:	20000098 	.word	0x20000098
 807a29c:	20000648 	.word	0x20000648
	...

0807a2a8 <Reset_Handler>:
 807a2a8:	4c0f      	ldr	r4, [pc, #60]	; (807a2e8 <Reset_Handler+0x40>)
 807a2aa:	4d10      	ldr	r5, [pc, #64]	; (807a2ec <Reset_Handler+0x44>)
 807a2ac:	42ac      	cmp	r4, r5
 807a2ae:	da09      	bge.n	807a2c4 <Reset_Handler+0x1c>
 807a2b0:	6821      	ldr	r1, [r4, #0]
 807a2b2:	6862      	ldr	r2, [r4, #4]
 807a2b4:	68a3      	ldr	r3, [r4, #8]
 807a2b6:	3b04      	subs	r3, #4
 807a2b8:	bfa2      	ittt	ge
 807a2ba:	58c8      	ldrge	r0, [r1, r3]
 807a2bc:	50d0      	strge	r0, [r2, r3]
 807a2be:	e7fa      	bge.n	807a2b6 <Reset_Handler+0xe>
 807a2c0:	340c      	adds	r4, #12
 807a2c2:	e7f3      	b.n	807a2ac <Reset_Handler+0x4>
 807a2c4:	4b0a      	ldr	r3, [pc, #40]	; (807a2f0 <Reset_Handler+0x48>)
 807a2c6:	4c0b      	ldr	r4, [pc, #44]	; (807a2f4 <Reset_Handler+0x4c>)
 807a2c8:	42a3      	cmp	r3, r4
 807a2ca:	da08      	bge.n	807a2de <Reset_Handler+0x36>
 807a2cc:	6819      	ldr	r1, [r3, #0]
 807a2ce:	685a      	ldr	r2, [r3, #4]
 807a2d0:	2000      	movs	r0, #0
 807a2d2:	3a04      	subs	r2, #4
 807a2d4:	bfa4      	itt	ge
 807a2d6:	5088      	strge	r0, [r1, r2]
 807a2d8:	e7fb      	bge.n	807a2d2 <Reset_Handler+0x2a>
 807a2da:	3308      	adds	r3, #8
 807a2dc:	e7f4      	b.n	807a2c8 <Reset_Handler+0x20>
 807a2de:	f000 fca9 	bl	807ac34 <SystemInit>
 807a2e2:	f7ff ffa7 	bl	807a234 <_mainCRTStartup>
 807a2e6:	0000      	.short	0x0000
 807a2e8:	0807ed00 	.word	0x0807ed00
 807a2ec:	0807ed18 	.word	0x0807ed18
 807a2f0:	0807ed18 	.word	0x0807ed18
 807a2f4:	0807ed28 	.word	0x0807ed28

0807a2f8 <NMI_Handler>:
 807a2f8:	f7ff bffe 	b.w	807a2f8 <NMI_Handler>

0807a2fc <HardFault_Handler>:
 807a2fc:	f7ff bffe 	b.w	807a2fc <HardFault_Handler>

0807a300 <MemManage_Handler>:
 807a300:	f7ff bffe 	b.w	807a300 <MemManage_Handler>

0807a304 <BusFault_Handler>:
 807a304:	f7ff bffe 	b.w	807a304 <BusFault_Handler>

0807a308 <UsageFault_Handler>:
 807a308:	f7ff bffe 	b.w	807a308 <UsageFault_Handler>

0807a30c <SecureFault_Handler>:
 807a30c:	f7ff bffe 	b.w	807a30c <SecureFault_Handler>

0807a310 <SVC_Handler>:
 807a310:	f7ff bffe 	b.w	807a310 <SVC_Handler>

0807a314 <DebugMon_Handler>:
 807a314:	f7ff bffe 	b.w	807a314 <DebugMon_Handler>

0807a318 <PendSV_Handler>:
 807a318:	f7ff bffe 	b.w	807a318 <PendSV_Handler>

0807a31c <SysTick_Handler>:
 807a31c:	f7ff bffe 	b.w	807a31c <SysTick_Handler>

0807a320 <WWDG_IRQHandler>:
 807a320:	f7ff bffe 	b.w	807a320 <WWDG_IRQHandler>

0807a324 <PVD_PVM_IRQHandler>:
 807a324:	f7ff bffe 	b.w	807a324 <PVD_PVM_IRQHandler>

0807a328 <RTC_IRQHandler>:
 807a328:	f7ff bffe 	b.w	807a328 <RTC_IRQHandler>

0807a32c <RTC_IRQHandler_S>:
 807a32c:	f7ff bffe 	b.w	807a32c <RTC_IRQHandler_S>

0807a330 <TAMP_IRQHandler>:
 807a330:	f7ff bffe 	b.w	807a330 <TAMP_IRQHandler>

0807a334 <TAMP_IRQHandler_S>:
 807a334:	f7ff bffe 	b.w	807a334 <TAMP_IRQHandler_S>

0807a338 <FLASH_IRQHandler>:
 807a338:	f7ff bffe 	b.w	807a338 <FLASH_IRQHandler>

0807a33c <FLASH_IRQHandler_S>:
 807a33c:	f7ff bffe 	b.w	807a33c <FLASH_IRQHandler_S>

0807a340 <SERR_IRQHandler>:
 807a340:	f7ff bffe 	b.w	807a340 <SERR_IRQHandler>

0807a344 <RCC_IRQHandler>:
 807a344:	f7ff bffe 	b.w	807a344 <RCC_IRQHandler>

0807a348 <RCC_IRQHandler_S>:
 807a348:	f7ff bffe 	b.w	807a348 <RCC_IRQHandler_S>

0807a34c <EXTI0_IRQHandler>:
 807a34c:	f7ff bffe 	b.w	807a34c <EXTI0_IRQHandler>

0807a350 <EXTI1_IRQHandler>:
 807a350:	f7ff bffe 	b.w	807a350 <EXTI1_IRQHandler>

0807a354 <EXTI2_IRQHandler>:
 807a354:	f7ff bffe 	b.w	807a354 <EXTI2_IRQHandler>

0807a358 <EXTI3_IRQHandler>:
 807a358:	f7ff bffe 	b.w	807a358 <EXTI3_IRQHandler>

0807a35c <EXTI4_IRQHandler>:
 807a35c:	f7ff bffe 	b.w	807a35c <EXTI4_IRQHandler>

0807a360 <EXTI5_IRQHandler>:
 807a360:	f7ff bffe 	b.w	807a360 <EXTI5_IRQHandler>

0807a364 <EXTI6_IRQHandler>:
 807a364:	f7ff bffe 	b.w	807a364 <EXTI6_IRQHandler>

0807a368 <EXTI7_IRQHandler>:
 807a368:	f7ff bffe 	b.w	807a368 <EXTI7_IRQHandler>

0807a36c <EXTI8_IRQHandler>:
 807a36c:	f7ff bffe 	b.w	807a36c <EXTI8_IRQHandler>

0807a370 <EXTI9_IRQHandler>:
 807a370:	f7ff bffe 	b.w	807a370 <EXTI9_IRQHandler>

0807a374 <EXTI10_IRQHandler>:
 807a374:	f7ff bffe 	b.w	807a374 <EXTI10_IRQHandler>

0807a378 <EXTI11_IRQHandler>:
 807a378:	f7ff bffe 	b.w	807a378 <EXTI11_IRQHandler>

0807a37c <EXTI12_IRQHandler>:
 807a37c:	f7ff bffe 	b.w	807a37c <EXTI12_IRQHandler>

0807a380 <EXTI13_IRQHandler>:
 807a380:	f7ff bffe 	b.w	807a380 <EXTI13_IRQHandler>

0807a384 <EXTI14_IRQHandler>:
 807a384:	f7ff bffe 	b.w	807a384 <EXTI14_IRQHandler>

0807a388 <EXTI15_IRQHandler>:
 807a388:	f7ff bffe 	b.w	807a388 <EXTI15_IRQHandler>

0807a38c <DMAMUX1_IRQHandler>:
 807a38c:	f7ff bffe 	b.w	807a38c <DMAMUX1_IRQHandler>

0807a390 <DMAMUX1_IRQHandler_S>:
 807a390:	f7ff bffe 	b.w	807a390 <DMAMUX1_IRQHandler_S>

0807a394 <DMA1_Channel1_IRQHandler>:
 807a394:	f7ff bffe 	b.w	807a394 <DMA1_Channel1_IRQHandler>

0807a398 <DMA1_Channel2_IRQHandler>:
 807a398:	f7ff bffe 	b.w	807a398 <DMA1_Channel2_IRQHandler>

0807a39c <DMA1_Channel3_IRQHandler>:
 807a39c:	f7ff bffe 	b.w	807a39c <DMA1_Channel3_IRQHandler>

0807a3a0 <DMA1_Channel4_IRQHandler>:
 807a3a0:	f7ff bffe 	b.w	807a3a0 <DMA1_Channel4_IRQHandler>

0807a3a4 <DMA1_Channel5_IRQHandler>:
 807a3a4:	f7ff bffe 	b.w	807a3a4 <DMA1_Channel5_IRQHandler>

0807a3a8 <DMA1_Channel6_IRQHandler>:
 807a3a8:	f7ff bffe 	b.w	807a3a8 <DMA1_Channel6_IRQHandler>

0807a3ac <DMA1_Channel7_IRQHandler>:
 807a3ac:	f7ff bffe 	b.w	807a3ac <DMA1_Channel7_IRQHandler>

0807a3b0 <DMA1_Channel8_IRQHandler>:
 807a3b0:	f7ff bffe 	b.w	807a3b0 <DMA1_Channel8_IRQHandler>

0807a3b4 <ADC1_2_IRQHandler>:
 807a3b4:	f7ff bffe 	b.w	807a3b4 <ADC1_2_IRQHandler>

0807a3b8 <DAC_IRQHandler>:
 807a3b8:	f7ff bffe 	b.w	807a3b8 <DAC_IRQHandler>

0807a3bc <FDCAN1_IT0_IRQHandler>:
 807a3bc:	f7ff bffe 	b.w	807a3bc <FDCAN1_IT0_IRQHandler>

0807a3c0 <FDCAN1_IT1_IRQHandler>:
 807a3c0:	f7ff bffe 	b.w	807a3c0 <FDCAN1_IT1_IRQHandler>

0807a3c4 <TIM1_BRK_IRQHandler>:
 807a3c4:	f7ff bffe 	b.w	807a3c4 <TIM1_BRK_IRQHandler>

0807a3c8 <TIM1_UP_IRQHandler>:
 807a3c8:	f7ff bffe 	b.w	807a3c8 <TIM1_UP_IRQHandler>

0807a3cc <TIM1_TRG_COM_IRQHandler>:
 807a3cc:	f7ff bffe 	b.w	807a3cc <TIM1_TRG_COM_IRQHandler>

0807a3d0 <TIM1_CC_IRQHandler>:
 807a3d0:	f7ff bffe 	b.w	807a3d0 <TIM1_CC_IRQHandler>

0807a3d4 <TIM2_IRQHandler>:
 807a3d4:	f7ff bffe 	b.w	807a3d4 <TIM2_IRQHandler>

0807a3d8 <TIM3_IRQHandler>:
 807a3d8:	f7ff bffe 	b.w	807a3d8 <TIM3_IRQHandler>

0807a3dc <TIM4_IRQHandler>:
 807a3dc:	f7ff bffe 	b.w	807a3dc <TIM4_IRQHandler>

0807a3e0 <TIM5_IRQHandler>:
 807a3e0:	f7ff bffe 	b.w	807a3e0 <TIM5_IRQHandler>

0807a3e4 <TIM6_IRQHandler>:
 807a3e4:	f7ff bffe 	b.w	807a3e4 <TIM6_IRQHandler>

0807a3e8 <TIM7_IRQHandler>:
 807a3e8:	f7ff bffe 	b.w	807a3e8 <TIM7_IRQHandler>

0807a3ec <TIM8_BRK_IRQHandler>:
 807a3ec:	f7ff bffe 	b.w	807a3ec <TIM8_BRK_IRQHandler>

0807a3f0 <TIM8_UP_IRQHandler>:
 807a3f0:	f7ff bffe 	b.w	807a3f0 <TIM8_UP_IRQHandler>

0807a3f4 <TIM8_TRG_COM_IRQHandler>:
 807a3f4:	f7ff bffe 	b.w	807a3f4 <TIM8_TRG_COM_IRQHandler>

0807a3f8 <TIM8_CC_IRQHandler>:
 807a3f8:	f7ff bffe 	b.w	807a3f8 <TIM8_CC_IRQHandler>

0807a3fc <I2C1_EV_IRQHandler>:
 807a3fc:	f7ff bffe 	b.w	807a3fc <I2C1_EV_IRQHandler>

0807a400 <I2C1_ER_IRQHandler>:
 807a400:	f7ff bffe 	b.w	807a400 <I2C1_ER_IRQHandler>

0807a404 <I2C2_EV_IRQHandler>:
 807a404:	f7ff bffe 	b.w	807a404 <I2C2_EV_IRQHandler>

0807a408 <I2C2_ER_IRQHandler>:
 807a408:	f7ff bffe 	b.w	807a408 <I2C2_ER_IRQHandler>

0807a40c <SPI1_IRQHandler>:
 807a40c:	f7ff bffe 	b.w	807a40c <SPI1_IRQHandler>

0807a410 <SPI2_IRQHandler>:
 807a410:	f7ff bffe 	b.w	807a410 <SPI2_IRQHandler>

0807a414 <USART1_IRQHandler>:
 807a414:	f7ff bffe 	b.w	807a414 <USART1_IRQHandler>

0807a418 <USART2_IRQHandler>:
 807a418:	f7ff bffe 	b.w	807a418 <USART2_IRQHandler>

0807a41c <USART3_IRQHandler>:
 807a41c:	f7ff bffe 	b.w	807a41c <USART3_IRQHandler>

0807a420 <UART4_IRQHandler>:
 807a420:	f7ff bffe 	b.w	807a420 <UART4_IRQHandler>

0807a424 <UART5_IRQHandler>:
 807a424:	f7ff bffe 	b.w	807a424 <UART5_IRQHandler>

0807a428 <LPUART1_IRQHandler>:
 807a428:	f7ff bffe 	b.w	807a428 <LPUART1_IRQHandler>

0807a42c <LPTIM1_IRQHandler>:
 807a42c:	f7ff bffe 	b.w	807a42c <LPTIM1_IRQHandler>

0807a430 <LPTIM2_IRQHandler>:
 807a430:	f7ff bffe 	b.w	807a430 <LPTIM2_IRQHandler>

0807a434 <TIM15_IRQHandler>:
 807a434:	f7ff bffe 	b.w	807a434 <TIM15_IRQHandler>

0807a438 <TIM16_IRQHandler>:
 807a438:	f7ff bffe 	b.w	807a438 <TIM16_IRQHandler>

0807a43c <TIM17_IRQHandler>:
 807a43c:	f7ff bffe 	b.w	807a43c <TIM17_IRQHandler>

0807a440 <COMP_IRQHandler>:
 807a440:	f7ff bffe 	b.w	807a440 <COMP_IRQHandler>

0807a444 <USB_FS_IRQHandler>:
 807a444:	f7ff bffe 	b.w	807a444 <USB_FS_IRQHandler>

0807a448 <CRS_IRQHandler>:
 807a448:	f7ff bffe 	b.w	807a448 <CRS_IRQHandler>

0807a44c <FMC_IRQHandler>:
 807a44c:	f7ff bffe 	b.w	807a44c <FMC_IRQHandler>

0807a450 <OCTOSPI1_IRQHandler>:
 807a450:	f7ff bffe 	b.w	807a450 <OCTOSPI1_IRQHandler>

0807a454 <SDMMC1_IRQHandler>:
 807a454:	f7ff bffe 	b.w	807a454 <SDMMC1_IRQHandler>

0807a458 <DMA2_Channel1_IRQHandler>:
 807a458:	f7ff bffe 	b.w	807a458 <DMA2_Channel1_IRQHandler>

0807a45c <DMA2_Channel2_IRQHandler>:
 807a45c:	f7ff bffe 	b.w	807a45c <DMA2_Channel2_IRQHandler>

0807a460 <DMA2_Channel3_IRQHandler>:
 807a460:	f7ff bffe 	b.w	807a460 <DMA2_Channel3_IRQHandler>

0807a464 <DMA2_Channel4_IRQHandler>:
 807a464:	f7ff bffe 	b.w	807a464 <DMA2_Channel4_IRQHandler>

0807a468 <DMA2_Channel5_IRQHandler>:
 807a468:	f7ff bffe 	b.w	807a468 <DMA2_Channel5_IRQHandler>

0807a46c <DMA2_Channel6_IRQHandler>:
 807a46c:	f7ff bffe 	b.w	807a46c <DMA2_Channel6_IRQHandler>

0807a470 <DMA2_Channel7_IRQHandler>:
 807a470:	f7ff bffe 	b.w	807a470 <DMA2_Channel7_IRQHandler>

0807a474 <DMA2_Channel8_IRQHandler>:
 807a474:	f7ff bffe 	b.w	807a474 <DMA2_Channel8_IRQHandler>

0807a478 <I2C3_EV_IRQHandler>:
 807a478:	f7ff bffe 	b.w	807a478 <I2C3_EV_IRQHandler>

0807a47c <I2C3_ER_IRQHandler>:
 807a47c:	f7ff bffe 	b.w	807a47c <I2C3_ER_IRQHandler>

0807a480 <SAI1_IRQHandler>:
 807a480:	f7ff bffe 	b.w	807a480 <SAI1_IRQHandler>

0807a484 <SAI2_IRQHandler>:
 807a484:	f7ff bffe 	b.w	807a484 <SAI2_IRQHandler>

0807a488 <TSC_IRQHandler>:
 807a488:	f7ff bffe 	b.w	807a488 <TSC_IRQHandler>

0807a48c <RNG_IRQHandler>:
 807a48c:	f7ff bffe 	b.w	807a48c <RNG_IRQHandler>

0807a490 <FPU_IRQHandler>:
 807a490:	f7ff bffe 	b.w	807a490 <FPU_IRQHandler>

0807a494 <LPTIM3_IRQHandler>:
 807a494:	f7ff bffe 	b.w	807a494 <LPTIM3_IRQHandler>

0807a498 <SPI3_IRQHandler>:
 807a498:	f7ff bffe 	b.w	807a498 <SPI3_IRQHandler>

0807a49c <I2C4_ER_IRQHandler>:
 807a49c:	f7ff bffe 	b.w	807a49c <I2C4_ER_IRQHandler>

0807a4a0 <I2C4_EV_IRQHandler>:
 807a4a0:	f7ff bffe 	b.w	807a4a0 <I2C4_EV_IRQHandler>

0807a4a4 <DFSDM1_FLT0_IRQHandler>:
 807a4a4:	f7ff bffe 	b.w	807a4a4 <DFSDM1_FLT0_IRQHandler>

0807a4a8 <DFSDM1_FLT1_IRQHandler>:
 807a4a8:	f7ff bffe 	b.w	807a4a8 <DFSDM1_FLT1_IRQHandler>

0807a4ac <DFSDM1_FLT2_IRQHandler>:
 807a4ac:	f7ff bffe 	b.w	807a4ac <DFSDM1_FLT2_IRQHandler>

0807a4b0 <DFSDM1_FLT3_IRQHandler>:
 807a4b0:	f7ff bffe 	b.w	807a4b0 <DFSDM1_FLT3_IRQHandler>

0807a4b4 <UCPD1_IRQHandler>:
 807a4b4:	f7ff bffe 	b.w	807a4b4 <UCPD1_IRQHandler>

0807a4b8 <ICACHE_IRQHandler>:
 807a4b8:	f7ff bffe 	b.w	807a4b8 <ICACHE_IRQHandler>

0807a4bc <OTFDEC1_IRQHandler>:
 807a4bc:	f7ff bffe 	b.w	807a4bc <OTFDEC1_IRQHandler>

0807a4c0 <COM_Init>:
  * @brief  Initialize COM module.
  * @param  None.
  * @retval HAL Status.
  */
HAL_StatusTypeDef  COM_Init(void)
{
 807a4c0:	b508      	push	{r3, lr}
#if defined(__GNUC__)
  setvbuf(stdout, NULL, _IONBF, 0);
 807a4c2:	4b10      	ldr	r3, [pc, #64]	; (807a504 <COM_Init+0x44>)
 807a4c4:	2202      	movs	r2, #2
 807a4c6:	6818      	ldr	r0, [r3, #0]
 807a4c8:	2300      	movs	r3, #0
 807a4ca:	6880      	ldr	r0, [r0, #8]
 807a4cc:	4619      	mov	r1, r3
 807a4ce:	f002 fff1 	bl	807d4b4 <setvbuf>
  - No parity
  - Hardware flow control disabled (RTS and CTS signals)
  - Receive and transmit enabled
  */
  UartHandle.Instance = COM_UART;
  UartHandle.Init.BaudRate = 115200U;
 807a4d2:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  UartHandle.Instance = COM_UART;
 807a4d6:	480c      	ldr	r0, [pc, #48]	; (807a508 <COM_Init+0x48>)
  UartHandle.Init.BaudRate = 115200U;
 807a4d8:	4a0c      	ldr	r2, [pc, #48]	; (807a50c <COM_Init+0x4c>)
 807a4da:	e9c0 2300 	strd	r2, r3, [r0]
  UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
 807a4de:	2300      	movs	r3, #0
  UartHandle.Init.StopBits = UART_STOPBITS_1;
 807a4e0:	e9c0 3302 	strd	r3, r3, [r0, #8]
  UartHandle.Init.Parity = UART_PARITY_NONE;
 807a4e4:	6103      	str	r3, [r0, #16]
  UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 807a4e6:	6183      	str	r3, [r0, #24]
  UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX;
 807a4e8:	230c      	movs	r3, #12
 807a4ea:	6143      	str	r3, [r0, #20]
  UartHandle.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_RXOVERRUNDISABLE_INIT;
 807a4ec:	2310      	movs	r3, #16
 807a4ee:	6283      	str	r3, [r0, #40]	; 0x28
  UartHandle.AdvancedInit.OverrunDisable = UART_ADVFEATURE_OVERRUN_DISABLE;
 807a4f0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 807a4f4:	63c3      	str	r3, [r0, #60]	; 0x3c
  UartHandle.FifoMode = UART_FIFOMODE_ENABLE;
 807a4f6:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 807a4fa:	6643      	str	r3, [r0, #100]	; 0x64
  return HAL_UART_Init(&UartHandle);
}
 807a4fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  return HAL_UART_Init(&UartHandle);
 807a500:	f002 beeb 	b.w	807d2da <HAL_UART_Init>
 807a504:	2000002c 	.word	0x2000002c
 807a508:	200000b4 	.word	0x200000b4
 807a50c:	40013800 	.word	0x40013800

0807a510 <HAL_UART_MspInit>:
  * @brief  UART MSP Init.
  * @param  huart: UART handler pointer.
  * @retval None.
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 807a510:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == COM_UART)
 807a512:	6802      	ldr	r2, [r0, #0]
 807a514:	4b1e      	ldr	r3, [pc, #120]	; (807a590 <HAL_UART_MspInit+0x80>)
{
 807a516:	b089      	sub	sp, #36	; 0x24
  if (huart->Instance == COM_UART)
 807a518:	429a      	cmp	r2, r3
 807a51a:	d136      	bne.n	807a58a <HAL_UART_MspInit+0x7a>
  {
    /* Peripheral Clock Enable */
    COM_UART_CLK_ENABLE();
 807a51c:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
 807a520:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    COM_UART_TX_GPIO_CLK_ENABLE();
    COM_UART_RX_GPIO_CLK_ENABLE();

    /*Configure GPIO pins : COM_UART_TX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_TX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 807a522:	2702      	movs	r7, #2
    COM_UART_CLK_ENABLE();
 807a524:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 807a528:	661a      	str	r2, [r3, #96]	; 0x60
 807a52a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 807a52c:	2600      	movs	r6, #0
    COM_UART_CLK_ENABLE();
 807a52e:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 807a532:	9200      	str	r2, [sp, #0]
 807a534:	9a00      	ldr	r2, [sp, #0]
    COM_UART_TX_GPIO_CLK_ENABLE();
 807a536:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 807a538:	2503      	movs	r5, #3
    COM_UART_TX_GPIO_CLK_ENABLE();
 807a53a:	f042 0201 	orr.w	r2, r2, #1
 807a53e:	64da      	str	r2, [r3, #76]	; 0x4c
 807a540:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 807a542:	2407      	movs	r4, #7
    COM_UART_TX_GPIO_CLK_ENABLE();
 807a544:	f002 0201 	and.w	r2, r2, #1
 807a548:	9201      	str	r2, [sp, #4]
 807a54a:	9a01      	ldr	r2, [sp, #4]
    COM_UART_RX_GPIO_CLK_ENABLE();
 807a54c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 807a54e:	a903      	add	r1, sp, #12
    COM_UART_RX_GPIO_CLK_ENABLE();
 807a550:	f042 0201 	orr.w	r2, r2, #1
 807a554:	64da      	str	r2, [r3, #76]	; 0x4c
 807a556:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 807a558:	480e      	ldr	r0, [pc, #56]	; (807a594 <HAL_UART_MspInit+0x84>)
    COM_UART_RX_GPIO_CLK_ENABLE();
 807a55a:	f003 0301 	and.w	r3, r3, #1
 807a55e:	9302      	str	r3, [sp, #8]
 807a560:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 807a562:	f44f 7300 	mov.w	r3, #512	; 0x200
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 807a566:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 807a56a:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Alternate = COM_UART_TX_AF;
 807a56e:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(COM_UART_TX_GPIO_PORT, &GPIO_InitStruct);
 807a570:	f001 fecc 	bl	807c30c <HAL_GPIO_Init>

    /*Configure GPIO pins : COM_UART_RX_Pin  */
    GPIO_InitStruct.Pin = COM_UART_RX_PIN;
 807a574:	f44f 6380 	mov.w	r3, #1024	; 0x400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 807a578:	a903      	add	r1, sp, #12
 807a57a:	4806      	ldr	r0, [pc, #24]	; (807a594 <HAL_UART_MspInit+0x84>)
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 807a57c:	e9cd 3703 	strd	r3, r7, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 807a580:	e9cd 6505 	strd	r6, r5, [sp, #20]
    GPIO_InitStruct.Alternate = COM_UART_RX_AF;
 807a584:	9407      	str	r4, [sp, #28]
    HAL_GPIO_Init(COM_UART_RX_GPIO_PORT, &GPIO_InitStruct);
 807a586:	f001 fec1 	bl	807c30c <HAL_GPIO_Init>

  }

}
 807a58a:	b009      	add	sp, #36	; 0x24
 807a58c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 807a58e:	bf00      	nop
 807a590:	40013800 	.word	0x40013800
 807a594:	42020000 	.word	0x42020000

0807a598 <COM_Transmit>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Transmit operation.
  */
HAL_StatusTypeDef COM_Transmit(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Transmit(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 807a598:	4613      	mov	r3, r2
 807a59a:	460a      	mov	r2, r1
 807a59c:	4601      	mov	r1, r0
 807a59e:	4801      	ldr	r0, [pc, #4]	; (807a5a4 <COM_Transmit+0xc>)
 807a5a0:	f002 bd94 	b.w	807d0cc <HAL_UART_Transmit>
 807a5a4:	200000b4 	.word	0x200000b4

0807a5a8 <COM_Receive>:
  * @param uTimeout: Timeout duration.
  * @retval Status of the Receive operation.
  */
HAL_StatusTypeDef COM_Receive(uint8_t *Data, uint16_t uDataLength, uint32_t uTimeout)
{
  return HAL_UART_Receive(&UartHandle, (uint8_t *)Data, uDataLength, uTimeout);
 807a5a8:	4613      	mov	r3, r2
 807a5aa:	460a      	mov	r2, r1
 807a5ac:	4601      	mov	r1, r0
 807a5ae:	4801      	ldr	r0, [pc, #4]	; (807a5b4 <COM_Receive+0xc>)
 807a5b0:	f002 bde8 	b.w	807d184 <HAL_UART_Receive>
 807a5b4:	200000b4 	.word	0x200000b4

0807a5b8 <COM_Flush>:
  * @retval HAL_Status.
  */
HAL_StatusTypeDef COM_Flush(void)
{
  /* Clean the input path */
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 807a5b8:	4b05      	ldr	r3, [pc, #20]	; (807a5d0 <COM_Flush+0x18>)
  return HAL_OK;
}
 807a5ba:	2000      	movs	r0, #0
  __HAL_UART_FLUSH_DRREGISTER(&UartHandle);
 807a5bc:	681b      	ldr	r3, [r3, #0]
 807a5be:	699a      	ldr	r2, [r3, #24]
 807a5c0:	f042 0208 	orr.w	r2, r2, #8
 807a5c4:	619a      	str	r2, [r3, #24]
 807a5c6:	699a      	ldr	r2, [r3, #24]
 807a5c8:	f042 0210 	orr.w	r2, r2, #16
 807a5cc:	619a      	str	r2, [r3, #24]
}
 807a5ce:	4770      	bx	lr
 807a5d0:	200000b4 	.word	0x200000b4

0807a5d4 <Str2Int>:
  * @param  pIntNum: The integer value
  * @retval 1: Correct
  *         0: Error
  */
uint32_t Str2Int(uint8_t *pInputStr, uint32_t *pIntNum)
{
 807a5d4:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t i = 0U;
  uint32_t res = 0U;
  uint32_t val = 0U;

  if ((pInputStr[0U] == '0') && ((pInputStr[1U] == 'x') || (pInputStr[1U] == 'X')))
 807a5d6:	7803      	ldrb	r3, [r0, #0]
 807a5d8:	2b30      	cmp	r3, #48	; 0x30
 807a5da:	d127      	bne.n	807a62c <Str2Int+0x58>
 807a5dc:	7843      	ldrb	r3, [r0, #1]
 807a5de:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 807a5e2:	2b58      	cmp	r3, #88	; 0x58
 807a5e4:	d122      	bne.n	807a62c <Str2Int+0x58>
 807a5e6:	2400      	movs	r4, #0
 807a5e8:	2502      	movs	r5, #2
  {
    i = 2U;
    while ((i < 11U) && (pInputStr[i] != '\0'))
 807a5ea:	5d43      	ldrb	r3, [r0, r5]
 807a5ec:	b193      	cbz	r3, 807a614 <Str2Int+0x40>
    {
      if (ISVALIDHEX(pInputStr[i]))
 807a5ee:	f023 0620 	bic.w	r6, r3, #32
 807a5f2:	3e41      	subs	r6, #65	; 0x41
 807a5f4:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 807a5f8:	2e05      	cmp	r6, #5
 807a5fa:	b2d7      	uxtb	r7, r2
 807a5fc:	d901      	bls.n	807a602 <Str2Int+0x2e>
 807a5fe:	2f09      	cmp	r7, #9
 807a600:	d808      	bhi.n	807a614 <Str2Int+0x40>
      {
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 807a602:	2f09      	cmp	r7, #9
 807a604:	ea4f 1404 	mov.w	r4, r4, lsl #4
 807a608:	d809      	bhi.n	807a61e <Str2Int+0x4a>
 807a60a:	4613      	mov	r3, r2
      {
        /* Return 0, Invalid input */
        res = 0U;
        break;
      }
      i++;
 807a60c:	3501      	adds	r5, #1
    while ((i < 11U) && (pInputStr[i] != '\0'))
 807a60e:	2d0b      	cmp	r5, #11
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 807a610:	441c      	add	r4, r3
    while ((i < 11U) && (pInputStr[i] != '\0'))
 807a612:	d1ea      	bne.n	807a5ea <Str2Int+0x16>
    }

    /* valid result */
    if (pInputStr[i] == '\0')
 807a614:	5d43      	ldrb	r3, [r0, r5]
 807a616:	bb4b      	cbnz	r3, 807a66c <Str2Int+0x98>
    {
      *pIntNum = val;
 807a618:	600c      	str	r4, [r1, #0]
      res = 1U;
 807a61a:	2001      	movs	r0, #1
 807a61c:	e027      	b.n	807a66e <Str2Int+0x9a>
        val = (val << 4U) + CONVERTHEX(pInputStr[i]);
 807a61e:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
 807a622:	2a05      	cmp	r2, #5
 807a624:	bf94      	ite	ls
 807a626:	3b37      	subls	r3, #55	; 0x37
 807a628:	3b57      	subhi	r3, #87	; 0x57
 807a62a:	e7ef      	b.n	807a60c <Str2Int+0x38>
 807a62c:	2300      	movs	r3, #0
        *pIntNum = val;
        res = 1U;
      }
      else if (ISVALIDDEC(pInputStr[i]))
      {
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 807a62e:	270a      	movs	r7, #10
 807a630:	1e44      	subs	r4, r0, #1
 807a632:	f100 060a 	add.w	r6, r0, #10
      if (pInputStr[i] == '\0')
 807a636:	f814 2f01 	ldrb.w	r2, [r4, #1]!
 807a63a:	b90a      	cbnz	r2, 807a640 <Str2Int+0x6c>
        *pIntNum = val;
 807a63c:	600b      	str	r3, [r1, #0]
        res = 1U;
 807a63e:	e7ec      	b.n	807a61a <Str2Int+0x46>
      else if (((pInputStr[i] == 'k') || (pInputStr[i] == 'K')) && (i > 0U))
 807a640:	f002 05df 	and.w	r5, r2, #223	; 0xdf
 807a644:	2d4b      	cmp	r5, #75	; 0x4b
 807a646:	d103      	bne.n	807a650 <Str2Int+0x7c>
 807a648:	4284      	cmp	r4, r0
 807a64a:	d007      	beq.n	807a65c <Str2Int+0x88>
        val = val << 10U;
 807a64c:	029b      	lsls	r3, r3, #10
 807a64e:	e7f5      	b.n	807a63c <Str2Int+0x68>
      else if (((pInputStr[i] == 'm') || (pInputStr[i] == 'M')) && (i > 0U))
 807a650:	2d4d      	cmp	r5, #77	; 0x4d
 807a652:	d103      	bne.n	807a65c <Str2Int+0x88>
 807a654:	4284      	cmp	r4, r0
 807a656:	d009      	beq.n	807a66c <Str2Int+0x98>
        val = val << 20U;
 807a658:	051b      	lsls	r3, r3, #20
 807a65a:	e7ef      	b.n	807a63c <Str2Int+0x68>
      else if (ISVALIDDEC(pInputStr[i]))
 807a65c:	3a30      	subs	r2, #48	; 0x30
 807a65e:	b2d5      	uxtb	r5, r2
 807a660:	2d09      	cmp	r5, #9
 807a662:	d803      	bhi.n	807a66c <Str2Int+0x98>
    while ((i < 11U) && (res != 1U))
 807a664:	42b4      	cmp	r4, r6
        val = val * 10U + CONVERTDEC(pInputStr[i]);
 807a666:	fb07 2303 	mla	r3, r7, r3, r2
    while ((i < 11U) && (res != 1U))
 807a66a:	d1e4      	bne.n	807a636 <Str2Int+0x62>
      res = 1U;
 807a66c:	2000      	movs	r0, #0
      i++;
    }
  }

  return res;
}
 807a66e:	bdf0      	pop	{r4, r5, r6, r7, pc}

0807a670 <Serial_PutByte>:
  * @brief  Transmit a byte to the HyperTerminal
  * @param  param The byte to be sent
  * @retval HAL_StatusTypeDef HAL_OK if OK
  */
HAL_StatusTypeDef Serial_PutByte(uint8_t uParam)
{
 807a670:	b507      	push	{r0, r1, r2, lr}
 807a672:	ab02      	add	r3, sp, #8
 807a674:	f803 0d01 	strb.w	r0, [r3, #-1]!
  return COM_Transmit(&uParam, 1U, TX_TIMEOUT);
 807a678:	2264      	movs	r2, #100	; 0x64
 807a67a:	2101      	movs	r1, #1
 807a67c:	4618      	mov	r0, r3
 807a67e:	f7ff ff8b 	bl	807a598 <COM_Transmit>
}
 807a682:	b003      	add	sp, #12
 807a684:	f85d fb04 	ldr.w	pc, [sp], #4

0807a688 <FW_UPDATE_PrintWelcome>:
  * @brief  Display the FW_UPDATE Main Menu choices on HyperTerminal
  * @param  None.
  * @retval None.
  */
static void FW_UPDATE_PrintWelcome(void)
{
 807a688:	b508      	push	{r3, lr}
  printf("\r\n================ New Fw Download =========================\r\n\n");
 807a68a:	4807      	ldr	r0, [pc, #28]	; (807a6a8 <FW_UPDATE_PrintWelcome+0x20>)
 807a68c:	f002 ff0a 	bl	807d4a4 <puts>
  printf("  Reset to trigger Installation ------------------------- 1\r\n\n");
 807a690:	4806      	ldr	r0, [pc, #24]	; (807a6ac <FW_UPDATE_PrintWelcome+0x24>)
 807a692:	f002 ff07 	bl	807d4a4 <puts>
#if (MCUBOOT_IMAGE_NUMBER == 2)
  printf("  Download Secure Image --------------------------------- 2\r\n\n");
 807a696:	4806      	ldr	r0, [pc, #24]	; (807a6b0 <FW_UPDATE_PrintWelcome+0x28>)
 807a698:	f002 ff04 	bl	807d4a4 <puts>
  printf("  Download NonSecure Image ------------------------------ 3\r\n\n");
#else
  printf("  Download Image ---------------------------------------- 2\r\n\n");
#endif /* (MCUBOOT_IMAGE_NUMBER == 2) */
}
 807a69c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  printf("  Download NonSecure Image ------------------------------ 3\r\n\n");
 807a6a0:	4804      	ldr	r0, [pc, #16]	; (807a6b4 <FW_UPDATE_PrintWelcome+0x2c>)
 807a6a2:	f002 beff 	b.w	807d4a4 <puts>
 807a6a6:	bf00      	nop
 807a6a8:	0807e872 	.word	0x0807e872
 807a6ac:	0807e8b1 	.word	0x0807e8b1
 807a6b0:	0807e8ef 	.word	0x0807e8ef
 807a6b4:	0807e92d 	.word	0x0807e92d

0807a6b8 <FW_UPDATE_DownloadNewFirmware.constprop.0>:
/**
  * @brief Download a new Firmware from the host.
  * @retval HAL status
  */
static HAL_StatusTypeDef FW_UPDATE_DownloadNewFirmware(SFU_FwImageFlashTypeDef *pFwImageDwlArea)
 807a6b8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 807a6ba:	4605      	mov	r5, r0
{
  HAL_StatusTypeDef ret = HAL_ERROR;
  COM_StatusTypeDef e_result;
  int32_t ret_arm;
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 807a6bc:	6803      	ldr	r3, [r0, #0]
  uint32_t sector_address;

  /* Clear download area */
  printf("  -- Erasing download area \r\n\n");
 807a6be:	482b      	ldr	r0, [pc, #172]	; (807a76c <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb4>)
  uint32_t u_fw_size = pFwImageDwlArea->MaxSizeInBytes ;
 807a6c0:	9301      	str	r3, [sp, #4]

  for (sector_address = pFwImageDwlArea->DownloadAddr;
       sector_address < pFwImageDwlArea->DownloadAddr + pFwImageDwlArea->MaxSizeInBytes;
       sector_address += m_uFlashSectorSize)
  {
    ret_arm = LOADER_FLASH_DEV_NAME.EraseSector(sector_address);
 807a6c2:	4e2b      	ldr	r6, [pc, #172]	; (807a770 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb8>)
  printf("  -- Erasing download area \r\n\n");
 807a6c4:	f002 feee 	bl	807d4a4 <puts>
       sector_address += m_uFlashSectorSize)
 807a6c8:	4f2a      	ldr	r7, [pc, #168]	; (807a774 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xbc>)
  for (sector_address = pFwImageDwlArea->DownloadAddr;
 807a6ca:	686c      	ldr	r4, [r5, #4]
       sector_address < pFwImageDwlArea->DownloadAddr + pFwImageDwlArea->MaxSizeInBytes;
 807a6cc:	e9d5 2300 	ldrd	r2, r3, [r5]
 807a6d0:	4413      	add	r3, r2
  for (sector_address = pFwImageDwlArea->DownloadAddr;
 807a6d2:	429c      	cmp	r4, r3
 807a6d4:	d32f      	bcc.n	807a736 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x7e>
    {
      return HAL_ERROR;
    }
  }

  printf("  -- Send Firmware \r\n\n");
 807a6d6:	4828      	ldr	r0, [pc, #160]	; (807a778 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xc0>)
 807a6d8:	f002 fee4 	bl	807d4a4 <puts>

  /* Download binary */
  printf("  -- -- File> Transfer> YMODEM> Send \t\n");
 807a6dc:	4827      	ldr	r0, [pc, #156]	; (807a77c <FW_UPDATE_DownloadNewFirmware.constprop.0+0xc4>)
 807a6de:	f002 fee1 	bl	807d4a4 <puts>

  /*Init of Ymodem*/
  Ymodem_Init();
 807a6e2:	f000 fb39 	bl	807ad58 <Ymodem_Init>

  /*Receive through Ymodem*/
  e_result = Ymodem_Receive(&u_fw_size, pFwImageDwlArea->DownloadAddr);
 807a6e6:	6869      	ldr	r1, [r5, #4]
 807a6e8:	a801      	add	r0, sp, #4
 807a6ea:	f000 fb5f 	bl	807adac <Ymodem_Receive>
 807a6ee:	4604      	mov	r4, r0
  printf("\r\n\n");
 807a6f0:	4823      	ldr	r0, [pc, #140]	; (807a780 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xc8>)
 807a6f2:	f002 fed7 	bl	807d4a4 <puts>

  if ((e_result == COM_OK))
 807a6f6:	bb34      	cbnz	r4, 807a746 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x8e>
  {
    printf("  -- -- Programming Completed Successfully!\r\n\n");
 807a6f8:	4822      	ldr	r0, [pc, #136]	; (807a784 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xcc>)
 807a6fa:	f002 fed3 	bl	807d4a4 <puts>
#if defined(__ARMCC_VERSION)
    printf("  -- -- Bytes: %u\r\n\n", u_fw_size);
#else
    printf("  -- -- Bytes: %lu\r\n\n", u_fw_size);
 807a6fe:	9901      	ldr	r1, [sp, #4]
 807a700:	4821      	ldr	r0, [pc, #132]	; (807a788 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xd0>)
 807a702:	f002 fe5b 	bl	807d3bc <iprintf>
#endif /*  __ARMCC_VERSION */
    ret = HAL_OK;
#if !defined(MCUBOOT_PRIMARY_ONLY)
    if (u_fw_size <= (pFwImageDwlArea->MaxSizeInBytes - sizeof(MagicTrailerValue)))
 807a706:	682b      	ldr	r3, [r5, #0]
 807a708:	9a01      	ldr	r2, [sp, #4]
 807a70a:	f1a3 0110 	sub.w	r1, r3, #16
 807a70e:	4291      	cmp	r1, r2
 807a710:	d32a      	bcc.n	807a768 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb0>
    {
      uint32_t MagicAddress =
        pFwImageDwlArea->DownloadAddr + (pFwImageDwlArea->MaxSizeInBytes - sizeof(MagicTrailerValue));
 807a712:	686c      	ldr	r4, [r5, #4]
      /* write the magic to trigger installation at next reset */
#if defined(__ARMCC_VERSION)
      printf("  Write Magic Trailer at %x\r\n\n", MagicAddress);
#else
      printf("  Write Magic Trailer at %lx\r\n\n", MagicAddress);
 807a714:	481d      	ldr	r0, [pc, #116]	; (807a78c <FW_UPDATE_DownloadNewFirmware.constprop.0+0xd4>)
        pFwImageDwlArea->DownloadAddr + (pFwImageDwlArea->MaxSizeInBytes - sizeof(MagicTrailerValue));
 807a716:	441c      	add	r4, r3
      uint32_t MagicAddress =
 807a718:	3c10      	subs	r4, #16
      printf("  Write Magic Trailer at %lx\r\n\n", MagicAddress);
 807a71a:	4621      	mov	r1, r4
 807a71c:	f002 fe4e 	bl	807d3bc <iprintf>
#endif /*  __ARMCC_VERSION */
      if (LOADER_FLASH_DEV_NAME.ProgramData(MagicAddress, MagicTrailerValue, sizeof(MagicTrailerValue)) != ARM_DRIVER_OK)
 807a720:	4b13      	ldr	r3, [pc, #76]	; (807a770 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xb8>)
 807a722:	2210      	movs	r2, #16
 807a724:	491a      	ldr	r1, [pc, #104]	; (807a790 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xd8>)
 807a726:	4620      	mov	r0, r4
 807a728:	699b      	ldr	r3, [r3, #24]
 807a72a:	4798      	blx	r3
      return HAL_ERROR;
 807a72c:	3000      	adds	r0, #0
 807a72e:	bf18      	it	ne
 807a730:	2001      	movne	r0, #1
    HAL_Delay(500U);
    COM_Flush();
  }

  return ret;
}
 807a732:	b003      	add	sp, #12
 807a734:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ret_arm = LOADER_FLASH_DEV_NAME.EraseSector(sector_address);
 807a736:	69f3      	ldr	r3, [r6, #28]
 807a738:	4620      	mov	r0, r4
 807a73a:	4798      	blx	r3
    if (ret_arm < 0)
 807a73c:	2800      	cmp	r0, #0
 807a73e:	db09      	blt.n	807a754 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x9c>
       sector_address += m_uFlashSectorSize)
 807a740:	683b      	ldr	r3, [r7, #0]
 807a742:	441c      	add	r4, r3
 807a744:	e7c2      	b.n	807a6cc <FW_UPDATE_DownloadNewFirmware.constprop.0+0x14>
  else if (e_result == COM_ABORT)
 807a746:	2c02      	cmp	r4, #2
 807a748:	d106      	bne.n	807a758 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xa0>
    printf("  -- -- !!Aborted by user!!\r\n\n");
 807a74a:	4812      	ldr	r0, [pc, #72]	; (807a794 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xdc>)
 807a74c:	f002 feaa 	bl	807d4a4 <puts>
    COM_Flush();
 807a750:	f7ff ff32 	bl	807a5b8 <COM_Flush>
    ret = HAL_ERROR;
 807a754:	2001      	movs	r0, #1
 807a756:	e7ec      	b.n	807a732 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x7a>
    printf("  -- -- !!Error during file download!!\r\n\n");
 807a758:	480f      	ldr	r0, [pc, #60]	; (807a798 <FW_UPDATE_DownloadNewFirmware.constprop.0+0xe0>)
 807a75a:	f002 fea3 	bl	807d4a4 <puts>
    HAL_Delay(500U);
 807a75e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 807a762:	f001 fcad 	bl	807c0c0 <HAL_Delay>
 807a766:	e7f3      	b.n	807a750 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x98>
    ret = HAL_OK;
 807a768:	4620      	mov	r0, r4
 807a76a:	e7e2      	b.n	807a732 <FW_UPDATE_DownloadNewFirmware.constprop.0+0x7a>
 807a76c:	0807e76c 	.word	0x0807e76c
 807a770:	0807ea50 	.word	0x0807ea50
 807a774:	2000014c 	.word	0x2000014c
 807a778:	0807e78a 	.word	0x0807e78a
 807a77c:	0807e7a0 	.word	0x0807e7a0
 807a780:	0807e787 	.word	0x0807e787
 807a784:	0807e7c7 	.word	0x0807e7c7
 807a788:	0807e7f5 	.word	0x0807e7f5
 807a78c:	0807e80b 	.word	0x0807e80b
 807a790:	0807ea24 	.word	0x0807ea24
 807a794:	0807e82b 	.word	0x0807e82b
 807a798:	0807e849 	.word	0x0807e849

0807a79c <FW_UPDATE_Run>:
  uint8_t key = 0U;
 807a79c:	2300      	movs	r3, #0
{
 807a79e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 807a7a2:	b086      	sub	sp, #24
  uint8_t key = 0U;
 807a7a4:	f88d 3007 	strb.w	r3, [sp, #7]
  FW_UPDATE_PrintWelcome();
 807a7a8:	f7ff ff6e 	bl	807a688 <FW_UPDATE_PrintWelcome>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 807a7ac:	4d33      	ldr	r5, [pc, #204]	; (807a87c <FW_UPDATE_Run+0xe0>)
  printf("Download Secure Image\r\n");
 807a7ae:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 807a8a4 <FW_UPDATE_Run+0x108>
  m_uFlashSectorSize = data->sector_size;
 807a7b2:	4e33      	ldr	r6, [pc, #204]	; (807a880 <FW_UPDATE_Run+0xe4>)
    key = 0U;
 807a7b4:	2700      	movs	r7, #0
 807a7b6:	f88d 7007 	strb.w	r7, [sp, #7]
    COM_Flush();
 807a7ba:	f7ff fefd 	bl	807a5b8 <COM_Flush>
    if (COM_Receive(&key, 1U, RX_TIMEOUT) == HAL_OK)
 807a7be:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 807a7c2:	2101      	movs	r1, #1
 807a7c4:	f10d 0007 	add.w	r0, sp, #7
 807a7c8:	f7ff feee 	bl	807a5a8 <COM_Receive>
 807a7cc:	4604      	mov	r4, r0
 807a7ce:	2800      	cmp	r0, #0
 807a7d0:	d1f1      	bne.n	807a7b6 <FW_UPDATE_Run+0x1a>
      switch (key)
 807a7d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
 807a7d6:	2b32      	cmp	r3, #50	; 0x32
 807a7d8:	d013      	beq.n	807a802 <FW_UPDATE_Run+0x66>
 807a7da:	2b33      	cmp	r3, #51	; 0x33
 807a7dc:	d031      	beq.n	807a842 <FW_UPDATE_Run+0xa6>
 807a7de:	2b31      	cmp	r3, #49	; 0x31
 807a7e0:	d148      	bne.n	807a874 <FW_UPDATE_Run+0xd8>
          printf("  -- Install image : reboot\r\n\n");
 807a7e2:	4828      	ldr	r0, [pc, #160]	; (807a884 <FW_UPDATE_Run+0xe8>)
 807a7e4:	f002 fe5e 	bl	807d4a4 <puts>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 807a7e8:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 807a7ec:	4926      	ldr	r1, [pc, #152]	; (807a888 <FW_UPDATE_Run+0xec>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 807a7ee:	4b27      	ldr	r3, [pc, #156]	; (807a88c <FW_UPDATE_Run+0xf0>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 807a7f0:	68ca      	ldr	r2, [r1, #12]
 807a7f2:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 807a7f6:	4313      	orrs	r3, r2
 807a7f8:	60cb      	str	r3, [r1, #12]
 807a7fa:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 807a7fe:	bf00      	nop
 807a800:	e7fd      	b.n	807a7fe <FW_UPDATE_Run+0x62>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 807a802:	6aab      	ldr	r3, [r5, #40]	; 0x28
 807a804:	4798      	blx	r3
 807a806:	4607      	mov	r7, r0
  printf("Download Secure Image\r\n");
 807a808:	4640      	mov	r0, r8
 807a80a:	f002 fe4b 	bl	807d4a4 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_AREA_2_SIZE;
 807a80e:	f44f 3310 	mov.w	r3, #147456	; 0x24000
 807a812:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
 807a816:	e9cd 3102 	strd	r3, r1, [sp, #8]
  m_uFlashSectorSize = data->sector_size;
 807a81a:	68bb      	ldr	r3, [r7, #8]
  m_uFlashMinWriteSize = data->program_unit;
 807a81c:	693a      	ldr	r2, [r7, #16]
  m_uFlashSectorSize = data->sector_size;
 807a81e:	6033      	str	r3, [r6, #0]
  m_uFlashMinWriteSize = data->program_unit;
 807a820:	4b1b      	ldr	r3, [pc, #108]	; (807a890 <FW_UPDATE_Run+0xf4>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 807a822:	a802      	add	r0, sp, #8
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 807a824:	9404      	str	r4, [sp, #16]
  m_uFlashMinWriteSize = data->program_unit;
 807a826:	601a      	str	r2, [r3, #0]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 807a828:	f7ff ff46 	bl	807a6b8 <FW_UPDATE_DownloadNewFirmware.constprop.0>
  if (HAL_OK == ret)
 807a82c:	b930      	cbnz	r0, 807a83c <FW_UPDATE_Run+0xa0>
    printf("  -- Secure Image correctly downloaded \r\n\n");
 807a82e:	4819      	ldr	r0, [pc, #100]	; (807a894 <FW_UPDATE_Run+0xf8>)
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 807a830:	f002 fe38 	bl	807d4a4 <puts>
    HAL_Delay(1000U);
 807a834:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 807a838:	f001 fc42 	bl	807c0c0 <HAL_Delay>
      FW_UPDATE_PrintWelcome();
 807a83c:	f7ff ff24 	bl	807a688 <FW_UPDATE_PrintWelcome>
 807a840:	e7b8      	b.n	807a7b4 <FW_UPDATE_Run+0x18>
  ARM_FLASH_INFO *data = LOADER_FLASH_DEV_NAME.GetInfo();
 807a842:	6aab      	ldr	r3, [r5, #40]	; 0x28
 807a844:	4798      	blx	r3
 807a846:	4607      	mov	r7, r0
  printf("Download NonSecure Image\r\n");
 807a848:	4813      	ldr	r0, [pc, #76]	; (807a898 <FW_UPDATE_Run+0xfc>)
 807a84a:	f002 fe2b 	bl	807d4a4 <puts>
  fw_image_dwl_area.MaxSizeInBytes = FLASH_NS_PARTITION_SIZE;
 807a84e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 807a852:	f44f 1292 	mov.w	r2, #1196032	; 0x124000
 807a856:	e9cd 3202 	strd	r3, r2, [sp, #8]
  m_uFlashSectorSize = data->sector_size;
 807a85a:	68bb      	ldr	r3, [r7, #8]
  m_uFlashMinWriteSize = data->program_unit;
 807a85c:	693a      	ldr	r2, [r7, #16]
  m_uFlashSectorSize = data->sector_size;
 807a85e:	6033      	str	r3, [r6, #0]
  m_uFlashMinWriteSize = data->program_unit;
 807a860:	4b0b      	ldr	r3, [pc, #44]	; (807a890 <FW_UPDATE_Run+0xf4>)
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 807a862:	a802      	add	r0, sp, #8
  fw_image_dwl_area.ImageOffsetInBytes = 0x0;
 807a864:	9404      	str	r4, [sp, #16]
  m_uFlashMinWriteSize = data->program_unit;
 807a866:	601a      	str	r2, [r3, #0]
  ret = FW_UPDATE_DownloadNewFirmware(&fw_image_dwl_area);
 807a868:	f7ff ff26 	bl	807a6b8 <FW_UPDATE_DownloadNewFirmware.constprop.0>
  if (HAL_OK == ret)
 807a86c:	2800      	cmp	r0, #0
 807a86e:	d1e5      	bne.n	807a83c <FW_UPDATE_Run+0xa0>
    printf("  -- NonSecure Image correctly downloaded \r\n\n");
 807a870:	480a      	ldr	r0, [pc, #40]	; (807a89c <FW_UPDATE_Run+0x100>)
 807a872:	e7dd      	b.n	807a830 <FW_UPDATE_Run+0x94>
          printf("Invalid Number !\r");
 807a874:	480a      	ldr	r0, [pc, #40]	; (807a8a0 <FW_UPDATE_Run+0x104>)
 807a876:	f002 fda1 	bl	807d3bc <iprintf>
          break;
 807a87a:	e7df      	b.n	807a83c <FW_UPDATE_Run+0xa0>
 807a87c:	0807ea50 	.word	0x0807ea50
 807a880:	2000014c 	.word	0x2000014c
 807a884:	0807e96b 	.word	0x0807e96b
 807a888:	e000ed00 	.word	0xe000ed00
 807a88c:	05fa0004 	.word	0x05fa0004
 807a890:	20000148 	.word	0x20000148
 807a894:	0807e9a0 	.word	0x0807e9a0
 807a898:	0807e9ca 	.word	0x0807e9ca
 807a89c:	0807e9e4 	.word	0x0807e9e4
 807a8a0:	0807ea11 	.word	0x0807ea11
 807a8a4:	0807e989 	.word	0x0807e989

0807a8a8 <Ymodem_HeaderPktRxCpltCallback>:
  * @brief  Ymodem Header Packet Transfer completed callback.
  * @param  uFileSize Dimension of the file that will be received (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_HeaderPktRxCpltCallback(uint32_t uFlashDestination, uint32_t uFileSize)
{
 807a8a8:	b510      	push	{r4, lr}
  /*Reset of the ymodem variables */
  m_uFileSizeYmodem = 0U;
  m_uPacketsReceived = 0U;
 807a8aa:	2400      	movs	r4, #0
 807a8ac:	4b07      	ldr	r3, [pc, #28]	; (807a8cc <Ymodem_HeaderPktRxCpltCallback+0x24>)

  /* compute the number of 1K blocks */
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;

  /* NOTE : delay inserted for Ymodem protocol*/
  HAL_Delay(1000);
 807a8ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  m_uPacketsReceived = 0U;
 807a8b2:	601c      	str	r4, [r3, #0]
  m_uFileSizeYmodem = uFileSize;
 807a8b4:	4b06      	ldr	r3, [pc, #24]	; (807a8d0 <Ymodem_HeaderPktRxCpltCallback+0x28>)
 807a8b6:	6019      	str	r1, [r3, #0]
  m_uNbrBlocksYmodem = (m_uFileSizeYmodem + (PACKET_1K_SIZE - 1U)) / PACKET_1K_SIZE;
 807a8b8:	4b06      	ldr	r3, [pc, #24]	; (807a8d4 <Ymodem_HeaderPktRxCpltCallback+0x2c>)
 807a8ba:	f201 31ff 	addw	r1, r1, #1023	; 0x3ff
 807a8be:	0a89      	lsrs	r1, r1, #10
 807a8c0:	6019      	str	r1, [r3, #0]
  HAL_Delay(1000);
 807a8c2:	f001 fbfd 	bl	807c0c0 <HAL_Delay>
  return HAL_OK;
}
 807a8c6:	4620      	mov	r0, r4
 807a8c8:	bd10      	pop	{r4, pc}
 807a8ca:	bf00      	nop
 807a8cc:	20000154 	.word	0x20000154
 807a8d0:	20000144 	.word	0x20000144
 807a8d4:	20000150 	.word	0x20000150

0807a8d8 <Ymodem_DataPktRxCpltCallback>:
  * @param  pData Pointer to the buffer.
  * @param  uSize Packet dimension (Bytes).
  * @retval None
  */
HAL_StatusTypeDef Ymodem_DataPktRxCpltCallback(uint8_t *pData, uint32_t uFlashDestination, uint32_t uSize)
{
 807a8d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  int32_t ret;
  m_uPacketsReceived++;
 807a8dc:	4d1a      	ldr	r5, [pc, #104]	; (807a948 <Ymodem_DataPktRxCpltCallback+0x70>)

  /*Increase the number of received packets*/
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 807a8de:	4f1b      	ldr	r7, [pc, #108]	; (807a94c <Ymodem_DataPktRxCpltCallback+0x74>)
  m_uPacketsReceived++;
 807a8e0:	682b      	ldr	r3, [r5, #0]
{
 807a8e2:	4614      	mov	r4, r2
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 807a8e4:	683a      	ldr	r2, [r7, #0]
  m_uPacketsReceived++;
 807a8e6:	3301      	adds	r3, #1
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 807a8e8:	4293      	cmp	r3, r2
{
 807a8ea:	4680      	mov	r8, r0
 807a8ec:	4689      	mov	r9, r1
  m_uPacketsReceived++;
 807a8ee:	602b      	str	r3, [r5, #0]
  if (m_uPacketsReceived == m_uNbrBlocksYmodem) /*Last Packet*/
 807a8f0:	d109      	bne.n	807a906 <Ymodem_DataPktRxCpltCallback+0x2e>
  {
    /*Extracting actual payload from last packet*/
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 807a8f2:	4b17      	ldr	r3, [pc, #92]	; (807a950 <Ymodem_DataPktRxCpltCallback+0x78>)
 807a8f4:	681c      	ldr	r4, [r3, #0]
    {
      /* The last packet is not full, drop the extra bytes */
      uSize = m_uFileSizeYmodem - ((uint32_t)(m_uFileSizeYmodem / PACKET_1K_SIZE) * PACKET_1K_SIZE);
    }

    m_uPacketsReceived = 0U;
 807a8f6:	2300      	movs	r3, #0
    if (0 == (m_uFileSizeYmodem % PACKET_1K_SIZE))
 807a8f8:	f3c4 0409 	ubfx	r4, r4, #0, #10
      uSize = PACKET_1K_SIZE;
 807a8fc:	2c00      	cmp	r4, #0
 807a8fe:	bf08      	it	eq
 807a900:	f44f 6480 	moveq.w	r4, #1024	; 0x400
    m_uPacketsReceived = 0U;
 807a904:	602b      	str	r3, [r5, #0]
  }
  /*Adjust dimension to 64-bit length */
  if (uSize %  m_uFlashMinWriteSize != 0U)
 807a906:	4b13      	ldr	r3, [pc, #76]	; (807a954 <Ymodem_DataPktRxCpltCallback+0x7c>)
 807a908:	681b      	ldr	r3, [r3, #0]
 807a90a:	fbb4 f6f3 	udiv	r6, r4, r3
 807a90e:	fb03 4616 	mls	r6, r3, r6, r4
 807a912:	b13e      	cbz	r6, 807a924 <Ymodem_DataPktRxCpltCallback+0x4c>
  {
    memset(&pData[uSize], 0xff, (m_uFlashMinWriteSize - (uSize %  m_uFlashMinWriteSize)));
 807a914:	1b9e      	subs	r6, r3, r6
 807a916:	eb08 0004 	add.w	r0, r8, r4
 807a91a:	4632      	mov	r2, r6
 807a91c:	21ff      	movs	r1, #255	; 0xff
 807a91e:	f002 fd45 	bl	807d3ac <memset>
    uSize += (m_uFlashMinWriteSize - (uSize %  m_uFlashMinWriteSize));
 807a922:	4434      	add	r4, r6
    ret = SECURE_Flash_ProgramData(uFlashDestination, pData, uSize);
  }
  else
    ret = LOADER_FLASH_DEV_NAME.ProgramData(uFlashDestination, pData, uSize);
#else
  ret = LOADER_FLASH_DEV_NAME.ProgramData(uFlashDestination, pData, uSize);
 807a924:	4b0c      	ldr	r3, [pc, #48]	; (807a958 <Ymodem_DataPktRxCpltCallback+0x80>)
 807a926:	4622      	mov	r2, r4
 807a928:	4641      	mov	r1, r8
 807a92a:	4648      	mov	r0, r9
 807a92c:	699b      	ldr	r3, [r3, #24]
 807a92e:	4798      	blx	r3
#endif /*defined(MCUBOOT_PRIMARY_ONLY) */
  if (ret < 0)
 807a930:	2800      	cmp	r0, #0
 807a932:	f04f 0000 	mov.w	r0, #0
 807a936:	da04      	bge.n	807a942 <Ymodem_DataPktRxCpltCallback+0x6a>
  {
    /*Reset of the ymodem variables */
    m_uFileSizeYmodem = 0U;
 807a938:	4b05      	ldr	r3, [pc, #20]	; (807a950 <Ymodem_DataPktRxCpltCallback+0x78>)
    m_uPacketsReceived = 0U;
 807a93a:	6028      	str	r0, [r5, #0]
    m_uFileSizeYmodem = 0U;
 807a93c:	6018      	str	r0, [r3, #0]
    m_uNbrBlocksYmodem = 0U;
 807a93e:	6038      	str	r0, [r7, #0]
    return HAL_ERROR;
 807a940:	2001      	movs	r0, #1
  }
  else
    return HAL_OK;
}
 807a942:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 807a946:	bf00      	nop
 807a948:	20000154 	.word	0x20000154
 807a94c:	20000150 	.word	0x20000150
 807a950:	20000144 	.word	0x20000144
 807a954:	20000148 	.word	0x20000148
 807a958:	0807ea50 	.word	0x0807ea50

0807a95c <Ospi_Flash_GetVersion>:
/* Flash Status */
static ARM_FLASH_STATUS ARM_OSPI_FLASH0_STATUS = {0, 0, 0};

static ARM_DRIVER_VERSION Ospi_Flash_GetVersion(void)
{
  return DriverVersion;
 807a95c:	4b03      	ldr	r3, [pc, #12]	; (807a96c <Ospi_Flash_GetVersion+0x10>)
{
 807a95e:	b082      	sub	sp, #8
  return DriverVersion;
 807a960:	6818      	ldr	r0, [r3, #0]
 807a962:	b283      	uxth	r3, r0
}
 807a964:	f363 000f 	bfi	r0, r3, #0, #16
 807a968:	b002      	add	sp, #8
 807a96a:	4770      	bx	lr
 807a96c:	0807ea4c 	.word	0x0807ea4c

0807a970 <Ospi_Flash_GetCapabilities>:

static ARM_FLASH_CAPABILITIES Ospi_Flash_GetCapabilities(void)
{
  return DriverCapabilities;
}
 807a970:	200a      	movs	r0, #10
 807a972:	4770      	bx	lr

0807a974 <Ospi_Flash_PowerControl>:
  }
}

static int32_t Ospi_Flash_PowerControl(ARM_POWER_STATE state)
{
  switch (state)
 807a974:	2801      	cmp	r0, #1
 807a976:	d905      	bls.n	807a984 <Ospi_Flash_PowerControl+0x10>
 807a978:	2802      	cmp	r0, #2
      return ARM_DRIVER_OK;
    case ARM_POWER_OFF:
    case ARM_POWER_LOW:
      return ARM_DRIVER_ERROR_UNSUPPORTED;
    default:
      return ARM_DRIVER_ERROR_PARAMETER;
 807a97a:	bf0c      	ite	eq
 807a97c:	2000      	moveq	r0, #0
 807a97e:	f06f 0004 	mvnne.w	r0, #4
 807a982:	4770      	bx	lr
      return ARM_DRIVER_ERROR_UNSUPPORTED;
 807a984:	f06f 0003 	mvn.w	r0, #3
  }
}
 807a988:	4770      	bx	lr

0807a98a <Ospi_Flash_EraseChip>:
}

static int32_t Ospi_Flash_EraseChip(void)
{
  return ARM_DRIVER_ERROR_UNSUPPORTED;
}
 807a98a:	f06f 0003 	mvn.w	r0, #3
 807a98e:	4770      	bx	lr

0807a990 <Ospi_Flash_GetStatus>:

static ARM_FLASH_STATUS Ospi_Flash_GetStatus(void)
{
  return ARM_OSPI_FLASH0_STATUS;
 807a990:	4b01      	ldr	r3, [pc, #4]	; (807a998 <Ospi_Flash_GetStatus+0x8>)
 807a992:	6818      	ldr	r0, [r3, #0]
}
 807a994:	4770      	bx	lr
 807a996:	bf00      	nop
 807a998:	20000158 	.word	0x20000158

0807a99c <Ospi_Flash_GetInfo>:

static ARM_FLASH_INFO *Ospi_Flash_GetInfo(void)
{
  return ARM_OSPI_FLASH0_DEV.data;
}
 807a99c:	4800      	ldr	r0, [pc, #0]	; (807a9a0 <Ospi_Flash_GetInfo+0x4>)
 807a99e:	4770      	bx	lr
 807a9a0:	0807ea34 	.word	0x0807ea34

0807a9a4 <Ospi_Flash_ReadData>:
{
 807a9a4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 807a9a8:	4616      	mov	r6, r2
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807a9aa:	4b35      	ldr	r3, [pc, #212]	; (807aa80 <Ospi_Flash_ReadData+0xdc>)
 807a9ac:	1e77      	subs	r7, r6, #1
 807a9ae:	681a      	ldr	r2, [r3, #0]
  if (!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1))
 807a9b0:	eb07 0900 	add.w	r9, r7, r0
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807a9b4:	f36f 0241 	bfc	r2, #1, #1
  if (!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1))
 807a9b8:	f1b9 6f80 	cmp.w	r9, #67108864	; 0x4000000
{
 807a9bc:	4605      	mov	r5, r0
 807a9be:	460c      	mov	r4, r1
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807a9c0:	601a      	str	r2, [r3, #0]
 807a9c2:	4698      	mov	r8, r3
  if (!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1))
 807a9c4:	d308      	bcc.n	807a9d8 <Ospi_Flash_ReadData+0x34>
    return ARM_DRIVER_ERROR_PARAMETER;
 807a9c6:	f06f 0004 	mvn.w	r0, #4
    ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 807a9ca:	681a      	ldr	r2, [r3, #0]
 807a9cc:	f042 0202 	orr.w	r2, r2, #2
 807a9d0:	601a      	str	r2, [r3, #0]
}
 807a9d2:	b003      	add	sp, #12
 807a9d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 807a9d8:	681b      	ldr	r3, [r3, #0]
 807a9da:	f043 0301 	orr.w	r3, r3, #1
 807a9de:	f8c8 3000 	str.w	r3, [r8]
  while (BSP_OSPI_NOR_GetStatus(0) !=  BSP_ERROR_NONE)
 807a9e2:	2000      	movs	r0, #0
 807a9e4:	f001 f8f4 	bl	807bbd0 <BSP_OSPI_NOR_GetStatus>
 807a9e8:	2800      	cmp	r0, #0
 807a9ea:	d1fa      	bne.n	807a9e2 <Ospi_Flash_ReadData+0x3e>
  if (addr % 2)
 807a9ec:	07e9      	lsls	r1, r5, #31
 807a9ee:	d530      	bpl.n	807aa52 <Ospi_Flash_ReadData+0xae>
    err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr - 1, 2);
 807a9f0:	2302      	movs	r3, #2
 807a9f2:	1e6a      	subs	r2, r5, #1
 807a9f4:	a901      	add	r1, sp, #4
 807a9f6:	f001 f84f 	bl	807ba98 <BSP_OSPI_NOR_Read>
    *(uint8_t*)data = data_tmp[1];
 807a9fa:	f89d 2005 	ldrb.w	r2, [sp, #5]
    if (cnt > 1)
 807a9fe:	2e01      	cmp	r6, #1
    err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr - 1, 2);
 807aa00:	4603      	mov	r3, r0
    *(uint8_t*)data = data_tmp[1];
 807aa02:	7022      	strb	r2, [r4, #0]
    if (cnt > 1)
 807aa04:	d91a      	bls.n	807aa3c <Ospi_Flash_ReadData+0x98>
      if (cnt % 2)
 807aa06:	07f2      	lsls	r2, r6, #31
 807aa08:	d507      	bpl.n	807aa1a <Ospi_Flash_ReadData+0x76>
        if (err == BSP_ERROR_NONE)
 807aa0a:	b9b8      	cbnz	r0, 807aa3c <Ospi_Flash_ReadData+0x98>
          err = BSP_OSPI_NOR_Read(0, (uint8_t *)data + 1, (addr + 1), cnt - 1);
 807aa0c:	463b      	mov	r3, r7
 807aa0e:	1c6a      	adds	r2, r5, #1
 807aa10:	1c61      	adds	r1, r4, #1
      err = BSP_OSPI_NOR_Read(0, (uint8_t *)data, addr, cnt);
 807aa12:	f001 f841 	bl	807ba98 <BSP_OSPI_NOR_Read>
 807aa16:	4603      	mov	r3, r0
 807aa18:	e010      	b.n	807aa3c <Ospi_Flash_ReadData+0x98>
        if (err == BSP_ERROR_NONE)
 807aa1a:	b978      	cbnz	r0, 807aa3c <Ospi_Flash_ReadData+0x98>
          err = BSP_OSPI_NOR_Read(0, (uint8_t *)data + 1, (addr + 1), cnt - 2);
 807aa1c:	1eb3      	subs	r3, r6, #2
 807aa1e:	1c6a      	adds	r2, r5, #1
 807aa20:	1c61      	adds	r1, r4, #1
 807aa22:	f001 f839 	bl	807ba98 <BSP_OSPI_NOR_Read>
        if (err == BSP_ERROR_NONE)
 807aa26:	4603      	mov	r3, r0
 807aa28:	b940      	cbnz	r0, 807aa3c <Ospi_Flash_ReadData+0x98>
          err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr + cnt - 1, 2);
 807aa2a:	2302      	movs	r3, #2
 807aa2c:	464a      	mov	r2, r9
 807aa2e:	a901      	add	r1, sp, #4
        err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr + cnt - 1, 2);
 807aa30:	f001 f832 	bl	807ba98 <BSP_OSPI_NOR_Read>
 807aa34:	4603      	mov	r3, r0
        *((uint8_t*)data + cnt -1) = data_tmp[0];
 807aa36:	f89d 2004 	ldrb.w	r2, [sp, #4]
 807aa3a:	55e2      	strb	r2, [r4, r7]
  if (err != BSP_ERROR_NONE)
 807aa3c:	1c18      	adds	r0, r3, #0
 807aa3e:	bf18      	it	ne
 807aa40:	2001      	movne	r0, #1
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 807aa42:	f8d8 2000 	ldr.w	r2, [r8]
  if (err != BSP_ERROR_NONE)
 807aa46:	4240      	negs	r0, r0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 807aa48:	f36f 0200 	bfc	r2, #0, #1
 807aa4c:	f8c8 2000 	str.w	r2, [r8]
 807aa50:	e7bf      	b.n	807a9d2 <Ospi_Flash_ReadData+0x2e>
    if (cnt % 2)
 807aa52:	07f3      	lsls	r3, r6, #31
 807aa54:	d50f      	bpl.n	807aa76 <Ospi_Flash_ReadData+0xd2>
      if (cnt > 1)
 807aa56:	2e01      	cmp	r6, #1
 807aa58:	d104      	bne.n	807aa64 <Ospi_Flash_ReadData+0xc0>
        err = BSP_OSPI_NOR_Read(0, (uint8_t *)data_tmp, addr + cnt - 1, 2);
 807aa5a:	2302      	movs	r3, #2
 807aa5c:	464a      	mov	r2, r9
 807aa5e:	a901      	add	r1, sp, #4
 807aa60:	2000      	movs	r0, #0
 807aa62:	e7e5      	b.n	807aa30 <Ospi_Flash_ReadData+0x8c>
        err = BSP_OSPI_NOR_Read(0, (uint8_t *)data, addr, cnt - 1);
 807aa64:	463b      	mov	r3, r7
 807aa66:	462a      	mov	r2, r5
 807aa68:	4621      	mov	r1, r4
 807aa6a:	f001 f815 	bl	807ba98 <BSP_OSPI_NOR_Read>
      if (err == BSP_ERROR_NONE)
 807aa6e:	4603      	mov	r3, r0
 807aa70:	2800      	cmp	r0, #0
 807aa72:	d0f2      	beq.n	807aa5a <Ospi_Flash_ReadData+0xb6>
 807aa74:	e7e2      	b.n	807aa3c <Ospi_Flash_ReadData+0x98>
      err = BSP_OSPI_NOR_Read(0, (uint8_t *)data, addr, cnt);
 807aa76:	4633      	mov	r3, r6
 807aa78:	462a      	mov	r2, r5
 807aa7a:	4621      	mov	r1, r4
 807aa7c:	e7c9      	b.n	807aa12 <Ospi_Flash_ReadData+0x6e>
 807aa7e:	bf00      	nop
 807aa80:	20000158 	.word	0x20000158

0807aa84 <Ospi_Flash_Uninitialize>:
{
 807aa84:	b508      	push	{r3, lr}
  if (BSP_OSPI_NOR_DeInit(0) != BSP_ERROR_NONE)
 807aa86:	2000      	movs	r0, #0
 807aa88:	f001 f8ec 	bl	807bc64 <BSP_OSPI_NOR_DeInit>
 807aa8c:	2800      	cmp	r0, #0
}
 807aa8e:	bf18      	it	ne
 807aa90:	f06f 0005 	mvnne.w	r0, #5
 807aa94:	bd08      	pop	{r3, pc}

0807aa96 <Ospi_Flash_Initialize>:
  flash.InterfaceMode = BSP_OSPI_NOR_OPI_MODE;
 807aa96:	2301      	movs	r3, #1
{
 807aa98:	b507      	push	{r0, r1, r2, lr}
  if (BSP_OSPI_NOR_Init(0, &flash) != BSP_ERROR_NONE)
 807aa9a:	2000      	movs	r0, #0
 807aa9c:	a901      	add	r1, sp, #4
  flash.InterfaceMode = BSP_OSPI_NOR_OPI_MODE;
 807aa9e:	f88d 3004 	strb.w	r3, [sp, #4]
  flash.TransferRate  = BSP_OSPI_NOR_DTR_TRANSFER;
 807aaa2:	f88d 3005 	strb.w	r3, [sp, #5]
  if (BSP_OSPI_NOR_Init(0, &flash) != BSP_ERROR_NONE)
 807aaa6:	f001 f9b1 	bl	807be0c <BSP_OSPI_NOR_Init>
 807aaaa:	2800      	cmp	r0, #0
}
 807aaac:	bf18      	it	ne
 807aaae:	f06f 0005 	mvnne.w	r0, #5
 807aab2:	b003      	add	sp, #12
 807aab4:	f85d fb04 	ldr.w	pc, [sp], #4

0807aab8 <Ospi_Flash_EraseSector>:
{
 807aab8:	b538      	push	{r3, r4, r5, lr}
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807aaba:	4c1a      	ldr	r4, [pc, #104]	; (807ab24 <Ospi_Flash_EraseSector+0x6c>)
  if (!(is_range_valid(&ARM_OSPI_FLASH0_DEV, addr)) ||
 807aabc:	f1b0 6f80 	cmp.w	r0, #67108864	; 0x4000000
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807aac0:	6823      	ldr	r3, [r4, #0]
{
 807aac2:	4601      	mov	r1, r0
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807aac4:	f36f 0341 	bfc	r3, #1, #1
 807aac8:	6023      	str	r3, [r4, #0]
  if (!(is_range_valid(&ARM_OSPI_FLASH0_DEV, addr)) ||
 807aaca:	d207      	bcs.n	807aadc <Ospi_Flash_EraseSector+0x24>
  return ((param % (flash_dev->data->sector_size)) != 0) ? (false) : (true);
 807aacc:	f3c0 030b 	ubfx	r3, r0, #0, #12
  if (!(is_range_valid(&ARM_OSPI_FLASH0_DEV, addr)) ||
 807aad0:	b923      	cbnz	r3, 807aadc <Ospi_Flash_EraseSector+0x24>
  for (nb = 0; nb < vect->nb; nb++)
 807aad2:	4a15      	ldr	r2, [pc, #84]	; (807ab28 <Ospi_Flash_EraseSector+0x70>)
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 807aad4:	e9d2 0200 	ldrd	r0, r2, [r2]
  for (nb = 0; nb < vect->nb; nb++)
 807aad8:	4283      	cmp	r3, r0
 807aada:	d106      	bne.n	807aaea <Ospi_Flash_EraseSector+0x32>
    return ARM_DRIVER_ERROR_PARAMETER;
 807aadc:	f06f 0004 	mvn.w	r0, #4
    ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 807aae0:	6823      	ldr	r3, [r4, #0]
 807aae2:	f043 0302 	orr.w	r3, r3, #2
 807aae6:	6023      	str	r3, [r4, #0]
}
 807aae8:	bd38      	pop	{r3, r4, r5, pc}
    if ((param >= vect->range[nb].base) && (param <= vect->range[nb].limit))
 807aaea:	f852 5033 	ldr.w	r5, [r2, r3, lsl #3]
 807aaee:	42a9      	cmp	r1, r5
 807aaf0:	d304      	bcc.n	807aafc <Ospi_Flash_EraseSector+0x44>
 807aaf2:	eb02 05c3 	add.w	r5, r2, r3, lsl #3
 807aaf6:	686d      	ldr	r5, [r5, #4]
 807aaf8:	42a9      	cmp	r1, r5
 807aafa:	d901      	bls.n	807ab00 <Ospi_Flash_EraseSector+0x48>
  for (nb = 0; nb < vect->nb; nb++)
 807aafc:	3301      	adds	r3, #1
 807aafe:	e7eb      	b.n	807aad8 <Ospi_Flash_EraseSector+0x20>
    err = BSP_OSPI_NOR_Erase_Block(0, addr, MX25LM51245G_ERASE_4K);
 807ab00:	2200      	movs	r2, #0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 807ab02:	6823      	ldr	r3, [r4, #0]
    err = BSP_OSPI_NOR_Erase_Block(0, addr, MX25LM51245G_ERASE_4K);
 807ab04:	4610      	mov	r0, r2
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 807ab06:	f043 0301 	orr.w	r3, r3, #1
 807ab0a:	6023      	str	r3, [r4, #0]
    err = BSP_OSPI_NOR_Erase_Block(0, addr, MX25LM51245G_ERASE_4K);
 807ab0c:	f001 f838 	bl	807bb80 <BSP_OSPI_NOR_Erase_Block>
  if (err != BSP_ERROR_NONE)
 807ab10:	3000      	adds	r0, #0
 807ab12:	bf18      	it	ne
 807ab14:	2001      	movne	r0, #1
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 807ab16:	6823      	ldr	r3, [r4, #0]
  if (err != BSP_ERROR_NONE)
 807ab18:	4240      	negs	r0, r0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 807ab1a:	f36f 0300 	bfc	r3, #0, #1
 807ab1e:	6023      	str	r3, [r4, #0]
 807ab20:	e7e2      	b.n	807aae8 <Ospi_Flash_EraseSector+0x30>
 807ab22:	bf00      	nop
 807ab24:	20000158 	.word	0x20000158
 807ab28:	20000000 	.word	0x20000000

0807ab2c <Ospi_Flash_ProgramData>:
{
 807ab2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 807ab2e:	4613      	mov	r3, r2
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807ab30:	4c1b      	ldr	r4, [pc, #108]	; (807aba0 <Ospi_Flash_ProgramData+0x74>)
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 807ab32:	1e5e      	subs	r6, r3, #1
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807ab34:	6822      	ldr	r2, [r4, #0]
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 807ab36:	4406      	add	r6, r0
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807ab38:	f36f 0241 	bfc	r2, #1, #1
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 807ab3c:	f1b6 6f80 	cmp.w	r6, #67108864	; 0x4000000
  ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_NO_ERROR;
 807ab40:	6022      	str	r2, [r4, #0]
  if ((!is_range_valid(&ARM_OSPI_FLASH0_DEV, addr + cnt - 1)) ||
 807ab42:	d209      	bcs.n	807ab58 <Ospi_Flash_ProgramData+0x2c>
      (!is_write_aligned(&ARM_OSPI_FLASH0_DEV, addr))     ||
 807ab44:	ea40 0503 	orr.w	r5, r0, r3
 807ab48:	f015 0501 	ands.w	r5, r5, #1
 807ab4c:	d104      	bne.n	807ab58 <Ospi_Flash_ProgramData+0x2c>
  for (nb = 0; nb < vect->nb; nb++)
 807ab4e:	4a15      	ldr	r2, [pc, #84]	; (807aba4 <Ospi_Flash_ProgramData+0x78>)
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 807ab50:	e9d2 c202 	ldrd	ip, r2, [r2, #8]
  for (nb = 0; nb < vect->nb; nb++)
 807ab54:	4565      	cmp	r5, ip
 807ab56:	d106      	bne.n	807ab66 <Ospi_Flash_ProgramData+0x3a>
    return ARM_DRIVER_ERROR_PARAMETER;
 807ab58:	f06f 0004 	mvn.w	r0, #4
    ARM_OSPI_FLASH0_STATUS.error = DRIVER_STATUS_ERROR;
 807ab5c:	6823      	ldr	r3, [r4, #0]
 807ab5e:	f043 0302 	orr.w	r3, r3, #2
 807ab62:	6023      	str	r3, [r4, #0]
}
 807ab64:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((start >= vect->range[nb].base) && ((start + len - 1) <= vect->range[nb].limit))
 807ab66:	f852 7035 	ldr.w	r7, [r2, r5, lsl #3]
 807ab6a:	42b8      	cmp	r0, r7
 807ab6c:	d304      	bcc.n	807ab78 <Ospi_Flash_ProgramData+0x4c>
 807ab6e:	eb02 07c5 	add.w	r7, r2, r5, lsl #3
 807ab72:	687f      	ldr	r7, [r7, #4]
 807ab74:	42be      	cmp	r6, r7
 807ab76:	d901      	bls.n	807ab7c <Ospi_Flash_ProgramData+0x50>
  for (nb = 0; nb < vect->nb; nb++)
 807ab78:	3501      	adds	r5, #1
 807ab7a:	e7eb      	b.n	807ab54 <Ospi_Flash_ProgramData+0x28>
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_BUSY;
 807ab7c:	6822      	ldr	r2, [r4, #0]
 807ab7e:	f042 0201 	orr.w	r2, r2, #1
 807ab82:	6022      	str	r2, [r4, #0]
  err = BSP_OSPI_NOR_Write(0, (uint8_t *) data, addr, cnt);
 807ab84:	4602      	mov	r2, r0
 807ab86:	2000      	movs	r0, #0
 807ab88:	f000 ffa6 	bl	807bad8 <BSP_OSPI_NOR_Write>
  if (err != BSP_ERROR_NONE)
 807ab8c:	3000      	adds	r0, #0
 807ab8e:	bf18      	it	ne
 807ab90:	2001      	movne	r0, #1
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 807ab92:	6823      	ldr	r3, [r4, #0]
  if (err != BSP_ERROR_NONE)
 807ab94:	4240      	negs	r0, r0
  ARM_OSPI_FLASH0_STATUS.busy = DRIVER_STATUS_IDLE;
 807ab96:	f36f 0300 	bfc	r3, #0, #1
 807ab9a:	6023      	str	r3, [r4, #0]
 807ab9c:	e7e2      	b.n	807ab64 <Ospi_Flash_ProgramData+0x38>
 807ab9e:	bf00      	nop
 807aba0:	20000158 	.word	0x20000158
 807aba4:	20000000 	.word	0x20000000

0807aba8 <_write>:
  return ch;
}
#elif defined(__GNUC__)
/* Redirects printf to TFM_DRIVER_STDIO in case of GNUARM */
int _write(int fd, char *str, int len)
{
 807aba8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 807abaa:	460e      	mov	r6, r1
 807abac:	4615      	mov	r5, r2
  int i;

  for (i = 0; i < len; i++)
 807abae:	460c      	mov	r4, r1
 807abb0:	1ba3      	subs	r3, r4, r6
 807abb2:	429d      	cmp	r5, r3
 807abb4:	dc02      	bgt.n	807abbc <_write+0x14>
    uart_putc(str[i]);
  }

  /* Return the number of characters written */
  return len;
}
 807abb6:	4628      	mov	r0, r5
 807abb8:	b002      	add	sp, #8
 807abba:	bd70      	pop	{r4, r5, r6, pc}
    uart_putc(str[i]);
 807abbc:	f814 3b01 	ldrb.w	r3, [r4], #1
  COM_Transmit(&c, 1, 1000U);
 807abc0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 807abc4:	2101      	movs	r1, #1
 807abc6:	f10d 0007 	add.w	r0, sp, #7
 807abca:	f88d 3007 	strb.w	r3, [sp, #7]
 807abce:	f7ff fce3 	bl	807a598 <COM_Transmit>
 807abd2:	e7ed      	b.n	807abb0 <_write+0x8>

0807abd4 <main>:
  * @param  None
  * @retval None
  */
int main(int argc, char **argv)
/*int main(void) */
{
 807abd4:	b508      	push	{r3, lr}
  duration should be kept 1ms since PPP_TIMEOUT_VALUEs are defined and
  handled in milliseconds basis.
  - Set NVIC Group Priority to 3
  - Low Level Initialization
  */
  HAL_Init();
 807abd6:	f001 fa62 	bl	807c09e <HAL_Init>

  /* Configure Communication module */
  COM_Init();
 807abda:	f7ff fc71 	bl	807a4c0 <COM_Init>

  printf("\r\n======================================================================");
 807abde:	480e      	ldr	r0, [pc, #56]	; (807ac18 <main+0x44>)
 807abe0:	f002 fbec 	bl	807d3bc <iprintf>
  printf("\r\n=              (C) COPYRIGHT 2020 STMicroelectronics                 =");
 807abe4:	480d      	ldr	r0, [pc, #52]	; (807ac1c <main+0x48>)
 807abe6:	f002 fbe9 	bl	807d3bc <iprintf>
  printf("\r\n=                                                                    =");
 807abea:	480d      	ldr	r0, [pc, #52]	; (807ac20 <main+0x4c>)
 807abec:	f002 fbe6 	bl	807d3bc <iprintf>
  printf("\r\n=                          LOCAL LOADER                              =");
 807abf0:	480c      	ldr	r0, [pc, #48]	; (807ac24 <main+0x50>)
 807abf2:	f002 fbe3 	bl	807d3bc <iprintf>
  printf("\r\n======================================================================");
 807abf6:	4808      	ldr	r0, [pc, #32]	; (807ac18 <main+0x44>)
 807abf8:	f002 fbe0 	bl	807d3bc <iprintf>
  printf("\r\n\r\n");
 807abfc:	480a      	ldr	r0, [pc, #40]	; (807ac28 <main+0x54>)
 807abfe:	f002 fc51 	bl	807d4a4 <puts>

  if ( LOADER_FLASH_DEV_NAME.Initialize(NULL) != ARM_DRIVER_OK)
 807ac02:	4b0a      	ldr	r3, [pc, #40]	; (807ac2c <main+0x58>)
 807ac04:	2000      	movs	r0, #0
 807ac06:	689b      	ldr	r3, [r3, #8]
 807ac08:	4798      	blx	r3
 807ac0a:	b110      	cbz	r0, 807ac12 <main+0x3e>
    printf("Driver Flash Init : Failed");
 807ac0c:	4808      	ldr	r0, [pc, #32]	; (807ac30 <main+0x5c>)
 807ac0e:	f002 fbd5 	bl	807d3bc <iprintf>
  /* User App firmware runs*/
  FW_UPDATE_Run();
 807ac12:	f7ff fdc3 	bl	807a79c <FW_UPDATE_Run>
 807ac16:	e7fe      	b.n	807ac16 <main+0x42>
 807ac18:	0807ea7c 	.word	0x0807ea7c
 807ac1c:	0807eac5 	.word	0x0807eac5
 807ac20:	0807eb0e 	.word	0x0807eb0e
 807ac24:	0807eb57 	.word	0x0807eb57
 807ac28:	0807eba0 	.word	0x0807eba0
 807ac2c:	0807ea50 	.word	0x0807ea50
 807ac30:	0807eba4 	.word	0x0807eba4

0807ac34 <SystemInit>:
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET;
#endif

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
 807ac34:	4a03      	ldr	r2, [pc, #12]	; (807ac44 <SystemInit+0x10>)
 807ac36:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 807ac3a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 807ac3e:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
#endif
}
 807ac42:	4770      	bx	lr
 807ac44:	e000ed00 	.word	0xe000ed00

0807ac48 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, msirange, pllvco, pllsource, pllm, pllr;

  /* Get MSI Range frequency--------------------------------------------------*/
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 807ac48:	4a21      	ldr	r2, [pc, #132]	; (807acd0 <SystemCoreClockUpdate+0x88>)
  else
  { /* MSIRANGE from RCC_CR applies */
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
  }
  /*MSI frequency range in HZ*/
  msirange = MSIRangeTable[msirange];
 807ac4a:	4922      	ldr	r1, [pc, #136]	; (807acd4 <SystemCoreClockUpdate+0x8c>)
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 807ac4c:	6813      	ldr	r3, [r2, #0]
{
 807ac4e:	b510      	push	{r4, lr}
  if((RCC->CR & RCC_CR_MSIRGSEL) == 0U)
 807ac50:	071b      	lsls	r3, r3, #28
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 807ac52:	bf55      	itete	pl
 807ac54:	f8d2 3094 	ldrpl.w	r3, [r2, #148]	; 0x94
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 807ac58:	6813      	ldrmi	r3, [r2, #0]
    msirange = (RCC->CSR & RCC_CSR_MSISRANGE) >> 8U;
 807ac5a:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
    msirange = (RCC->CR & RCC_CR_MSIRANGE) >> 4U;
 807ac5e:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
  msirange = MSIRangeTable[msirange];
 807ac62:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 807ac66:	6891      	ldr	r1, [r2, #8]
 807ac68:	481b      	ldr	r0, [pc, #108]	; (807acd8 <SystemCoreClockUpdate+0x90>)
 807ac6a:	f001 010c 	and.w	r1, r1, #12
 807ac6e:	2908      	cmp	r1, #8
 807ac70:	d003      	beq.n	807ac7a <SystemCoreClockUpdate+0x32>
 807ac72:	290c      	cmp	r1, #12
 807ac74:	d00c      	beq.n	807ac90 <SystemCoreClockUpdate+0x48>
 807ac76:	2904      	cmp	r1, #4
 807ac78:	d127      	bne.n	807acca <SystemCoreClockUpdate+0x82>
    case 0x00:  /* MSI used as system clock source */
      SystemCoreClock = msirange;
      break;

    case 0x04:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 807ac7a:	4b18      	ldr	r3, [pc, #96]	; (807acdc <SystemCoreClockUpdate+0x94>)
          pllvco = (msirange / pllm);
          break;
      }
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
      SystemCoreClock = pllvco/pllr;
 807ac7c:	6003      	str	r3, [r0, #0]
      SystemCoreClock = msirange;
      break;
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4U)];
 807ac7e:	6893      	ldr	r3, [r2, #8]
 807ac80:	4a17      	ldr	r2, [pc, #92]	; (807ace0 <SystemCoreClockUpdate+0x98>)
 807ac82:	f3c3 1303 	ubfx	r3, r3, #4, #4
 807ac86:	5cd2      	ldrb	r2, [r2, r3]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 807ac88:	6803      	ldr	r3, [r0, #0]
 807ac8a:	40d3      	lsrs	r3, r2
 807ac8c:	6003      	str	r3, [r0, #0]
}
 807ac8e:	bd10      	pop	{r4, pc}
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 807ac90:	68d1      	ldr	r1, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 807ac92:	68d3      	ldr	r3, [r2, #12]
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 807ac94:	f001 0103 	and.w	r1, r1, #3
      switch (pllsource)
 807ac98:	3902      	subs	r1, #2
 807ac9a:	2901      	cmp	r1, #1
          pllvco = (HSE_VALUE / pllm);
 807ac9c:	bf98      	it	ls
 807ac9e:	490f      	ldrls	r1, [pc, #60]	; (807acdc <SystemCoreClockUpdate+0x94>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4U) + 1U ;
 807aca0:	f3c3 1303 	ubfx	r3, r3, #4, #4
 807aca4:	f103 0301 	add.w	r3, r3, #1
          pllvco = (HSE_VALUE / pllm);
 807aca8:	bf94      	ite	ls
 807acaa:	fbb1 f3f3 	udivls	r3, r1, r3
          pllvco = (msirange / pllm);
 807acae:	fbb4 f3f3 	udivhi	r3, r4, r3
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 807acb2:	68d4      	ldr	r4, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 807acb4:	68d1      	ldr	r1, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8U);
 807acb6:	f3c4 2406 	ubfx	r4, r4, #8, #7
 807acba:	4363      	muls	r3, r4
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25U) + 1U) * 2U;
 807acbc:	f3c1 6141 	ubfx	r1, r1, #25, #2
 807acc0:	3101      	adds	r1, #1
 807acc2:	0049      	lsls	r1, r1, #1
      SystemCoreClock = pllvco/pllr;
 807acc4:	fbb3 f3f1 	udiv	r3, r3, r1
 807acc8:	e7d8      	b.n	807ac7c <SystemCoreClockUpdate+0x34>
      SystemCoreClock = msirange;
 807acca:	6004      	str	r4, [r0, #0]
      break;
 807accc:	e7d7      	b.n	807ac7e <SystemCoreClockUpdate+0x36>
 807acce:	bf00      	nop
 807acd0:	40021000 	.word	0x40021000
 807acd4:	0807ebd8 	.word	0x0807ebd8
 807acd8:	20000024 	.word	0x20000024
 807acdc:	00f42400 	.word	0x00f42400
 807ace0:	0807ebbf 	.word	0x0807ebbf

0807ace4 <HAL_InitTick>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* load 1Hz for timeout 1 second */
  uint32_t ticks = SystemCoreClock ;
 807ace4:	4b04      	ldr	r3, [pc, #16]	; (807acf8 <HAL_InitTick+0x14>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 807ace6:	2000      	movs	r0, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 807ace8:	681a      	ldr	r2, [r3, #0]
 807acea:	4b04      	ldr	r3, [pc, #16]	; (807acfc <HAL_InitTick+0x18>)
 807acec:	3a01      	subs	r2, #1
 807acee:	605a      	str	r2, [r3, #4]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 807acf0:	2205      	movs	r2, #5
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 807acf2:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 807acf4:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_ENABLE_Msk;
  return HAL_OK;
}
 807acf6:	4770      	bx	lr
 807acf8:	20000024 	.word	0x20000024
 807acfc:	e000e010 	.word	0xe000e010

0807ad00 <HAL_GetTick>:
  * @note This function overwrites the one declared as __weak in HAL.
  *       In this implementation, time is counted without using SysTick timer interrupts.
  * @retval tick value
  */
uint32_t HAL_GetTick(void)
{
 807ad00:	b530      	push	{r4, r5, lr}
  static uint32_t t1 = 0U, tdelta = 0U;
  uint32_t t2;

  t2 =  SysTick->VAL;

  if (t2 <= t1)
 807ad02:	4910      	ldr	r1, [pc, #64]	; (807ad44 <HAL_GetTick+0x44>)
  t2 =  SysTick->VAL;
 807ad04:	4c10      	ldr	r4, [pc, #64]	; (807ad48 <HAL_GetTick+0x48>)
 807ad06:	4a11      	ldr	r2, [pc, #68]	; (807ad4c <HAL_GetTick+0x4c>)
 807ad08:	68a0      	ldr	r0, [r4, #8]
  if (t2 <= t1)
 807ad0a:	680b      	ldr	r3, [r1, #0]
 807ad0c:	6815      	ldr	r5, [r2, #0]
 807ad0e:	4283      	cmp	r3, r0
  {
    tdelta += t1 - t2;
  }
  else
  {
    tdelta += t1 + SysTick->LOAD - t2;
 807ad10:	bf38      	it	cc
 807ad12:	6864      	ldrcc	r4, [r4, #4]
 807ad14:	442b      	add	r3, r5
 807ad16:	bf38      	it	cc
 807ad18:	191b      	addcc	r3, r3, r4
  }

  if (tdelta > (SystemCoreClock / (1000U)))
 807ad1a:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
    tdelta += t1 + SysTick->LOAD - t2;
 807ad1e:	1a1b      	subs	r3, r3, r0
 807ad20:	6013      	str	r3, [r2, #0]
  if (tdelta > (SystemCoreClock / (1000U)))
 807ad22:	4b0b      	ldr	r3, [pc, #44]	; (807ad50 <HAL_GetTick+0x50>)
 807ad24:	681b      	ldr	r3, [r3, #0]
 807ad26:	fbb3 f3f4 	udiv	r3, r3, r4
 807ad2a:	6814      	ldr	r4, [r2, #0]
 807ad2c:	42a3      	cmp	r3, r4
 807ad2e:	4b09      	ldr	r3, [pc, #36]	; (807ad54 <HAL_GetTick+0x54>)
 807ad30:	d204      	bcs.n	807ad3c <HAL_GetTick+0x3c>
  {
    tdelta = 0U;
 807ad32:	2500      	movs	r5, #0
 807ad34:	681c      	ldr	r4, [r3, #0]
 807ad36:	6015      	str	r5, [r2, #0]
    m_uTick ++;
 807ad38:	3401      	adds	r4, #1
 807ad3a:	601c      	str	r4, [r3, #0]
  }

  t1 = t2;
 807ad3c:	6008      	str	r0, [r1, #0]
  return m_uTick;
 807ad3e:	6818      	ldr	r0, [r3, #0]
 807ad40:	bd30      	pop	{r4, r5, pc}
 807ad42:	bf00      	nop
 807ad44:	20000160 	.word	0x20000160
 807ad48:	e000e010 	.word	0xe000e010
 807ad4c:	20000164 	.word	0x20000164
 807ad50:	20000024 	.word	0x20000024
 807ad54:	2000015c 	.word	0x2000015c

0807ad58 <Ymodem_Init>:
  * @param None.
  * @retval None.
  */
void Ymodem_Init(void)
{
  __HAL_RCC_CRC_CLK_ENABLE();
 807ad58:	4b11      	ldr	r3, [pc, #68]	; (807ada0 <Ymodem_Init+0x48>)
{
 807ad5a:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_CRC_CLK_ENABLE();
 807ad5c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  /*-1- Configure the CRC peripheral */
  CrcHandle.Instance = CRC;

  /* The CRC-16-CCIT polynomial is used */
  CrcHandle.Init.DefaultPolynomialUse    = DEFAULT_POLYNOMIAL_DISABLE;
  CrcHandle.Init.GeneratingPolynomial    = 0x1021U;
 807ad5e:	4811      	ldr	r0, [pc, #68]	; (807ada4 <Ymodem_Init+0x4c>)
  __HAL_RCC_CRC_CLK_ENABLE();
 807ad60:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 807ad64:	649a      	str	r2, [r3, #72]	; 0x48
 807ad66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 807ad68:	f241 0221 	movw	r2, #4129	; 0x1021
  __HAL_RCC_CRC_CLK_ENABLE();
 807ad6c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 807ad70:	9301      	str	r3, [sp, #4]
 807ad72:	9b01      	ldr	r3, [sp, #4]
  CrcHandle.Init.CRCLength               = CRC_POLYLENGTH_16B;
 807ad74:	2308      	movs	r3, #8
 807ad76:	e9c0 2302 	strd	r2, r3, [r0, #8]
  CrcHandle.Instance = CRC;
 807ad7a:	4b0b      	ldr	r3, [pc, #44]	; (807ada8 <Ymodem_Init+0x50>)
 807ad7c:	6003      	str	r3, [r0, #0]
 807ad7e:	f240 1301 	movw	r3, #257	; 0x101
 807ad82:	8083      	strh	r3, [r0, #4]

  /* The zero init value is used */
  CrcHandle.Init.DefaultInitValueUse     = DEFAULT_INIT_VALUE_DISABLE;
  CrcHandle.Init.InitValue               = 0U;
 807ad84:	2300      	movs	r3, #0

  /* The input data are not inverted */
  CrcHandle.Init.InputDataInversionMode  = CRC_INPUTDATA_INVERSION_NONE;
 807ad86:	e9c0 3304 	strd	r3, r3, [r0, #16]

  /* The output data are not inverted */
  CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 807ad8a:	6183      	str	r3, [r0, #24]

  /* The input data are 32-bit long words */
  CrcHandle.InputDataFormat              = CRC_INPUTDATA_FORMAT_BYTES;
 807ad8c:	2301      	movs	r3, #1
 807ad8e:	6203      	str	r3, [r0, #32]

  if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
 807ad90:	f001 fa08 	bl	807c1a4 <HAL_CRC_Init>
 807ad94:	b100      	cbz	r0, 807ad98 <Ymodem_Init+0x40>
 807ad96:	e7fe      	b.n	807ad96 <Ymodem_Init+0x3e>
  {
    /* Initialization Error */
    while (1);
  }
}
 807ad98:	b003      	add	sp, #12
 807ad9a:	f85d fb04 	ldr.w	pc, [sp], #4
 807ad9e:	bf00      	nop
 807ada0:	40021000 	.word	0x40021000
 807ada4:	20000168 	.word	0x20000168
 807ada8:	40023000 	.word	0x40023000

0807adac <Ymodem_Receive>:
  * @param  puSize The uSize of the file.
  * @param  uFlashDestination where the file has to be downloaded.
  * @retval COM_StatusTypeDef result of reception/programming
  */
COM_StatusTypeDef Ymodem_Receive(uint32_t *puSize, uint32_t uFlashDestination)
{
 807adac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t ramsource, filesize;
  uint8_t *file_ptr;
  uint8_t file_size[FILE_SIZE_LENGTH + 1U], tmp;
  uint32_t packets_received;
  COM_StatusTypeDef e_result = COM_OK;
  uint32_t cause = 0;
 807adb0:	2500      	movs	r5, #0
{
 807adb2:	4681      	mov	r9, r0
 807adb4:	468a      	mov	sl, r1
  uint32_t i, packet_length, session_done = 0U, file_done, errors = 0U, session_begin = 0U;
 807adb6:	46ab      	mov	fp, r5
    *pData = char1;
 807adb8:	4f9a      	ldr	r7, [pc, #616]	; (807b024 <Ymodem_Receive+0x278>)
{
 807adba:	b08b      	sub	sp, #44	; 0x2c
 807adbc:	2600      	movs	r6, #0
 807adbe:	e0e2      	b.n	807af86 <Ymodem_Receive+0x1da>
    switch (char1)
 807adc0:	2a61      	cmp	r2, #97	; 0x61
 807adc2:	d003      	beq.n	807adcc <Ymodem_Receive+0x20>
 807adc4:	2a72      	cmp	r2, #114	; 0x72
 807adc6:	d053      	beq.n	807ae70 <Ymodem_Receive+0xc4>
 807adc8:	2a41      	cmp	r2, #65	; 0x41
 807adca:	d163      	bne.n	807ae94 <Ymodem_Receive+0xe8>
        status = HAL_BUSY;
 807adcc:	2302      	movs	r3, #2
  uint32_t packet_size = 0U;
 807adce:	2400      	movs	r4, #0
 807add0:	e001      	b.n	807add6 <Ymodem_Receive+0x2a>
        packet_size = PACKET_1K_SIZE;
 807add2:	f44f 6480 	mov.w	r4, #1024	; 0x400
    *pData = char1;
 807add6:	f89d 200f 	ldrb.w	r2, [sp, #15]
    if (packet_size >= PACKET_SIZE)
 807adda:	2c7f      	cmp	r4, #127	; 0x7f
    *pData = char1;
 807addc:	703a      	strb	r2, [r7, #0]
    if (packet_size >= PACKET_SIZE)
 807adde:	d95d      	bls.n	807ae9c <Ymodem_Receive+0xf0>
      status = COM_Receive(&pData[PACKET_NUMBER_INDEX], packet_size + PACKET_OVERHEAD_SIZE, uTimeout);
 807ade0:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 807ade4:	1d21      	adds	r1, r4, #4
 807ade6:	4890      	ldr	r0, [pc, #576]	; (807b028 <Ymodem_Receive+0x27c>)
 807ade8:	f7ff fbde 	bl	807a5a8 <COM_Receive>
      if (status == HAL_OK)
 807adec:	4603      	mov	r3, r0
 807adee:	2800      	cmp	r0, #0
 807adf0:	d155      	bne.n	807ae9e <Ymodem_Receive+0xf2>
        if (pData[PACKET_NUMBER_INDEX] != ((pData[PACKET_CNUMBER_INDEX]) ^ NEGATIVE_BYTE))
 807adf2:	78fb      	ldrb	r3, [r7, #3]
 807adf4:	78ba      	ldrb	r2, [r7, #2]
 807adf6:	43db      	mvns	r3, r3
 807adf8:	b2db      	uxtb	r3, r3
 807adfa:	429a      	cmp	r2, r3
 807adfc:	d152      	bne.n	807aea4 <Ymodem_Receive+0xf8>
          crc = pData[ packet_size + PACKET_DATA_INDEX ] << 8U;
 807adfe:	193a      	adds	r2, r7, r4
 807ae00:	7911      	ldrb	r1, [r2, #4]
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 807ae02:	7953      	ldrb	r3, [r2, #5]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 807ae04:	4889      	ldr	r0, [pc, #548]	; (807b02c <Ymodem_Receive+0x280>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 807ae06:	eb03 2301 	add.w	r3, r3, r1, lsl #8
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 807ae0a:	4622      	mov	r2, r4
 807ae0c:	4988      	ldr	r1, [pc, #544]	; (807b030 <Ymodem_Receive+0x284>)
          crc += pData[ packet_size + PACKET_DATA_INDEX + 1U ];
 807ae0e:	9301      	str	r3, [sp, #4]
          if (HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&pData[PACKET_DATA_INDEX], packet_size) != crc)
 807ae10:	f001 fa02 	bl	807c218 <HAL_CRC_Calculate>
 807ae14:	9b01      	ldr	r3, [sp, #4]
 807ae16:	4283      	cmp	r3, r0
 807ae18:	d144      	bne.n	807aea4 <Ymodem_Receive+0xf8>
              *puSize = filesize;
              file_done = 1U;
              break;
            default:
              /* Normal packet */
              if (m_aPacketData[PACKET_NUMBER_INDEX] != (packets_received & 0xff))
 807ae1a:	78ba      	ldrb	r2, [r7, #2]
 807ae1c:	b2f3      	uxtb	r3, r6
 807ae1e:	429a      	cmp	r2, r3
 807ae20:	f040 80b1 	bne.w	807af86 <Ymodem_Receive+0x1da>
              {
                /*             Serial_PutByte(NAK);*/
              }
              else
              {
                if (packets_received == 0U)
 807ae24:	2e00      	cmp	r6, #0
 807ae26:	f040 80ce 	bne.w	807afc6 <Ymodem_Receive+0x21a>
                {
                  /* File name packet */
                  if (m_aPacketData[PACKET_DATA_INDEX] != 0U)
 807ae2a:	793b      	ldrb	r3, [r7, #4]
 807ae2c:	2b00      	cmp	r3, #0
 807ae2e:	f040 8091 	bne.w	807af54 <Ymodem_Receive+0x1a8>

                  }
                  /* File header packet is empty, end session */
                  else
                  {
                    Serial_PutByte(ACK);
 807ae32:	2006      	movs	r0, #6
 807ae34:	f7ff fc1c 	bl	807a670 <Serial_PutByte>
 807ae38:	4634      	mov	r4, r6
                    file_done = 1;
                    session_done = 1;
                    cause = 3;
 807ae3a:	2503      	movs	r5, #3
    }
  }
#if defined(__ARMCC_VERSION)
  printf("e_result = %x , %u\n", e_result, cause);
#else
  printf("e_result = %x , %lu\n", e_result, cause);
 807ae3c:	462a      	mov	r2, r5
 807ae3e:	4621      	mov	r1, r4
 807ae40:	487c      	ldr	r0, [pc, #496]	; (807b034 <Ymodem_Receive+0x288>)
 807ae42:	f002 fabb 	bl	807d3bc <iprintf>
#endif /* __ARMCC_VERSION */
  return e_result;
}
 807ae46:	4620      	mov	r0, r4
 807ae48:	b00b      	add	sp, #44	; 0x2c
 807ae4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((COM_Receive(&char1, 1U, uTimeout) == HAL_OK) && (char1 == CA))
 807ae4e:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 807ae52:	2101      	movs	r1, #1
 807ae54:	f10d 000f 	add.w	r0, sp, #15
 807ae58:	f7ff fba6 	bl	807a5a8 <COM_Receive>
 807ae5c:	4603      	mov	r3, r0
 807ae5e:	b9d8      	cbnz	r0, 807ae98 <Ymodem_Receive+0xec>
 807ae60:	f89d 200f 	ldrb.w	r2, [sp, #15]
          packet_size = 2U;
 807ae64:	2a18      	cmp	r2, #24
 807ae66:	bf16      	itet	ne
 807ae68:	2400      	movne	r4, #0
 807ae6a:	2402      	moveq	r4, #2
 807ae6c:	2301      	movne	r3, #1
 807ae6e:	e7b2      	b.n	807add6 <Ymodem_Receive+0x2a>
 807ae70:	9001      	str	r0, [sp, #4]
        COM_Receive(&char1, 1U, uTimeout);                /* Ymodem startup sequence : rb ==> 0x72 + 0x62 + 0x0D */
 807ae72:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 807ae76:	2101      	movs	r1, #1
 807ae78:	f10d 000f 	add.w	r0, sp, #15
 807ae7c:	f7ff fb94 	bl	807a5a8 <COM_Receive>
        COM_Receive(&char1, 1U, uTimeout);
 807ae80:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 807ae84:	2101      	movs	r1, #1
 807ae86:	f10d 000f 	add.w	r0, sp, #15
 807ae8a:	f7ff fb8d 	bl	807a5a8 <COM_Receive>
        packet_size = 3U;
 807ae8e:	2403      	movs	r4, #3
 807ae90:	9b01      	ldr	r3, [sp, #4]
 807ae92:	e7a0      	b.n	807add6 <Ymodem_Receive+0x2a>
        status = HAL_ERROR;
 807ae94:	2301      	movs	r3, #1
 807ae96:	e79a      	b.n	807adce <Ymodem_Receive+0x22>
          status = HAL_ERROR;
 807ae98:	2301      	movs	r3, #1
 807ae9a:	e79c      	b.n	807add6 <Ymodem_Receive+0x2a>
      switch (ReceivePacket(m_aPacketData, &packet_length, DOWNLOAD_TIMEOUT))
 807ae9c:	b193      	cbz	r3, 807aec4 <Ymodem_Receive+0x118>
 807ae9e:	2b02      	cmp	r3, #2
 807aea0:	f000 80b0 	beq.w	807b004 <Ymodem_Receive+0x258>
          if (session_begin > 0U)
 807aea4:	f1bb 0f00 	cmp.w	fp, #0
 807aea8:	d001      	beq.n	807aeae <Ymodem_Receive+0x102>
            errors ++;
 807aeaa:	f108 0801 	add.w	r8, r8, #1
          if (errors > MAX_ERRORS)
 807aeae:	f1b8 0f05 	cmp.w	r8, #5
 807aeb2:	f240 80af 	bls.w	807b014 <Ymodem_Receive+0x268>
            Serial_PutByte(CA);
 807aeb6:	2018      	movs	r0, #24
 807aeb8:	f7ff fbda 	bl	807a670 <Serial_PutByte>
            Serial_PutByte(CA);
 807aebc:	2018      	movs	r0, #24
 807aebe:	f7ff fbd7 	bl	807a670 <Serial_PutByte>
 807aec2:	e062      	b.n	807af8a <Ymodem_Receive+0x1de>
          switch (packet_length)
 807aec4:	2c02      	cmp	r4, #2
 807aec6:	d00a      	beq.n	807aede <Ymodem_Receive+0x132>
 807aec8:	2c03      	cmp	r4, #3
 807aeca:	d05c      	beq.n	807af86 <Ymodem_Receive+0x1da>
 807aecc:	2c00      	cmp	r4, #0
 807aece:	d1a4      	bne.n	807ae1a <Ymodem_Receive+0x6e>
              Serial_PutByte(ACK);
 807aed0:	2006      	movs	r0, #6
 807aed2:	f7ff fbcd 	bl	807a670 <Serial_PutByte>
              *puSize = filesize;
 807aed6:	9b04      	ldr	r3, [sp, #16]
 807aed8:	f8c9 3000 	str.w	r3, [r9]
 807aedc:	e76e      	b.n	807adbc <Ymodem_Receive+0x10>
              Serial_PutByte(ACK);
 807aede:	2006      	movs	r0, #6
 807aee0:	f7ff fbc6 	bl	807a670 <Serial_PutByte>
          switch (packet_length)
 807aee4:	2402      	movs	r4, #2
 807aee6:	e7a9      	b.n	807ae3c <Ymodem_Receive+0x90>
                      m_aFileName[i++] = *file_ptr++;
 807aee8:	5483      	strb	r3, [r0, r2]
 807aeea:	3201      	adds	r2, #1
                    while ((*file_ptr != 0U) && (i < FILE_NAME_LENGTH))
 807aeec:	f811 3b01 	ldrb.w	r3, [r1], #1
 807aef0:	b10b      	cbz	r3, 807aef6 <Ymodem_Receive+0x14a>
 807aef2:	2a40      	cmp	r2, #64	; 0x40
 807aef4:	d1f8      	bne.n	807aee8 <Ymodem_Receive+0x13c>
                    m_aFileName[i++] = '\0';
 807aef6:	2300      	movs	r3, #0
 807aef8:	5483      	strb	r3, [r0, r2]
 807aefa:	a805      	add	r0, sp, #20
                    while ((*file_ptr != ' ') && (i < FILE_SIZE_LENGTH))
 807aefc:	5cca      	ldrb	r2, [r1, r3]
 807aefe:	2a20      	cmp	r2, #32
 807af00:	d001      	beq.n	807af06 <Ymodem_Receive+0x15a>
 807af02:	2b10      	cmp	r3, #16
 807af04:	d12a      	bne.n	807af5c <Ymodem_Receive+0x1b0>
                    file_size[i++] = '\0';
 807af06:	2400      	movs	r4, #0
 807af08:	aa0a      	add	r2, sp, #40	; 0x28
 807af0a:	4413      	add	r3, r2
                    Str2Int(file_size, &filesize);
 807af0c:	a904      	add	r1, sp, #16
                    file_size[i++] = '\0';
 807af0e:	f803 4c14 	strb.w	r4, [r3, #-20]
                    Str2Int(file_size, &filesize);
 807af12:	f7ff fb5f 	bl	807a5d4 <Str2Int>
                    if ((uint32_t)filesize > *puSize)
 807af16:	9904      	ldr	r1, [sp, #16]
 807af18:	f8d9 3000 	ldr.w	r3, [r9]
 807af1c:	428b      	cmp	r3, r1
 807af1e:	d206      	bcs.n	807af2e <Ymodem_Receive+0x182>
                      tmp = CA;
 807af20:	2318      	movs	r3, #24
                      *puSize = 0;
 807af22:	f8c9 4000 	str.w	r4, [r9]
                      cause = 1;
 807af26:	2501      	movs	r5, #1
                      e_result = COM_ABORT;
 807af28:	2402      	movs	r4, #2
                      tmp = CA;
 807af2a:	f88d 300e 	strb.w	r3, [sp, #14]
                    if ((*puSize) && (Ymodem_HeaderPktRxCpltCallback(uFlashDestination, (uint32_t) filesize) == HAL_OK))
 807af2e:	f8d9 3000 	ldr.w	r3, [r9]
 807af32:	b1b3      	cbz	r3, 807af62 <Ymodem_Receive+0x1b6>
 807af34:	4650      	mov	r0, sl
 807af36:	f7ff fcb7 	bl	807a8a8 <Ymodem_HeaderPktRxCpltCallback>
 807af3a:	b990      	cbnz	r0, 807af62 <Ymodem_Receive+0x1b6>
                      Serial_PutByte(ACK);
 807af3c:	2006      	movs	r0, #6
 807af3e:	f7ff fb97 	bl	807a670 <Serial_PutByte>
                      COM_Flush();
 807af42:	f7ff fb39 	bl	807a5b8 <COM_Flush>
                      Serial_PutByte(CRC16);
 807af46:	2043      	movs	r0, #67	; 0x43
 807af48:	f7ff fb92 	bl	807a670 <Serial_PutByte>
                packets_received ++;
 807af4c:	3601      	adds	r6, #1
                session_begin = 1U;
 807af4e:	f04f 0b01 	mov.w	fp, #1
 807af52:	e015      	b.n	807af80 <Ymodem_Receive+0x1d4>
 807af54:	4632      	mov	r2, r6
                    file_ptr = m_aPacketData + PACKET_DATA_INDEX;
 807af56:	4936      	ldr	r1, [pc, #216]	; (807b030 <Ymodem_Receive+0x284>)
 807af58:	4837      	ldr	r0, [pc, #220]	; (807b038 <Ymodem_Receive+0x28c>)
 807af5a:	e7c7      	b.n	807aeec <Ymodem_Receive+0x140>
                      file_size[i++] = *file_ptr++;
 807af5c:	54c2      	strb	r2, [r0, r3]
 807af5e:	3301      	adds	r3, #1
 807af60:	e7cc      	b.n	807aefc <Ymodem_Receive+0x150>
                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 807af62:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 807af66:	2101      	movs	r1, #1
 807af68:	f10d 000e 	add.w	r0, sp, #14
 807af6c:	f7ff fb14 	bl	807a598 <COM_Transmit>
                      COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 807af70:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 807af74:	2101      	movs	r1, #1
 807af76:	f10d 000e 	add.w	r0, sp, #14
 807af7a:	f7ff fb0d 	bl	807a598 <COM_Transmit>
                      cause = 2;
 807af7e:	2502      	movs	r5, #2
    while ((file_done == 0U) && (e_result == COM_OK))
 807af80:	2c00      	cmp	r4, #0
 807af82:	f47f af5b 	bne.w	807ae3c <Ymodem_Receive+0x90>
 807af86:	f04f 0800 	mov.w	r8, #0
  status = (HAL_StatusTypeDef)COM_Receive(&char1, 1, uTimeout);
 807af8a:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 807af8e:	2101      	movs	r1, #1
 807af90:	f10d 000f 	add.w	r0, sp, #15
 807af94:	f7ff fb08 	bl	807a5a8 <COM_Receive>
 807af98:	4603      	mov	r3, r0
 807af9a:	4604      	mov	r4, r0
  if (status == HAL_OK)
 807af9c:	2800      	cmp	r0, #0
 807af9e:	f47f af7e 	bne.w	807ae9e <Ymodem_Receive+0xf2>
    switch (char1)
 807afa2:	f89d 200f 	ldrb.w	r2, [sp, #15]
 807afa6:	2a18      	cmp	r2, #24
 807afa8:	f43f af51 	beq.w	807ae4e <Ymodem_Receive+0xa2>
 807afac:	f63f af08 	bhi.w	807adc0 <Ymodem_Receive+0x14>
 807afb0:	2a02      	cmp	r2, #2
 807afb2:	f43f af0e 	beq.w	807add2 <Ymodem_Receive+0x26>
 807afb6:	2a04      	cmp	r2, #4
 807afb8:	f43f af09 	beq.w	807adce <Ymodem_Receive+0x22>
 807afbc:	2a01      	cmp	r2, #1
 807afbe:	f47f af69 	bne.w	807ae94 <Ymodem_Receive+0xe8>
        packet_size = PACKET_SIZE;
 807afc2:	2480      	movs	r4, #128	; 0x80
 807afc4:	e707      	b.n	807add6 <Ymodem_Receive+0x2a>
                  if ((*puSize) && (Ymodem_DataPktRxCpltCallback((uint8_t *)
 807afc6:	f8d9 3000 	ldr.w	r3, [r9]
 807afca:	b15b      	cbz	r3, 807afe4 <Ymodem_Receive+0x238>
 807afcc:	4622      	mov	r2, r4
 807afce:	4651      	mov	r1, sl
 807afd0:	4817      	ldr	r0, [pc, #92]	; (807b030 <Ymodem_Receive+0x284>)
 807afd2:	f7ff fc81 	bl	807a8d8 <Ymodem_DataPktRxCpltCallback>
 807afd6:	b928      	cbnz	r0, 807afe4 <Ymodem_Receive+0x238>
                    Serial_PutByte(ACK);
 807afd8:	2006      	movs	r0, #6
                    uFlashDestination += (packet_length);
 807afda:	44a2      	add	sl, r4
                    Serial_PutByte(ACK);
 807afdc:	f7ff fb48 	bl	807a670 <Serial_PutByte>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 807afe0:	2400      	movs	r4, #0
 807afe2:	e7b3      	b.n	807af4c <Ymodem_Receive+0x1a0>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 807afe4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 807afe8:	2101      	movs	r1, #1
 807afea:	f10d 000e 	add.w	r0, sp, #14
 807afee:	f7ff fad3 	bl	807a598 <COM_Transmit>
                    COM_Transmit(&tmp, 1U, NAK_TIMEOUT);
 807aff2:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 807aff6:	2101      	movs	r1, #1
 807aff8:	f10d 000e 	add.w	r0, sp, #14
 807affc:	f7ff facc 	bl	807a598 <COM_Transmit>
                    cause = 4;
 807b000:	2504      	movs	r5, #4
 807b002:	e7ed      	b.n	807afe0 <Ymodem_Receive+0x234>
          Serial_PutByte(CA);
 807b004:	2018      	movs	r0, #24
 807b006:	f7ff fb33 	bl	807a670 <Serial_PutByte>
          Serial_PutByte(CA);
 807b00a:	2018      	movs	r0, #24
 807b00c:	f7ff fb30 	bl	807a670 <Serial_PutByte>
          cause  = 5;
 807b010:	2505      	movs	r5, #5
          break;
 807b012:	e767      	b.n	807aee4 <Ymodem_Receive+0x138>
            Serial_PutByte(CRC16); /* Ask for a packet */
 807b014:	2043      	movs	r0, #67	; 0x43
 807b016:	f7ff fb2b 	bl	807a670 <Serial_PutByte>
            printf("\b.");         /* Replace C char by . on display console */
 807b01a:	4808      	ldr	r0, [pc, #32]	; (807b03c <Ymodem_Receive+0x290>)
 807b01c:	f002 f9ce 	bl	807d3bc <iprintf>
 807b020:	e7b3      	b.n	807af8a <Ymodem_Receive+0x1de>
 807b022:	bf00      	nop
 807b024:	2000018c 	.word	0x2000018c
 807b028:	2000018e 	.word	0x2000018e
 807b02c:	20000168 	.word	0x20000168
 807b030:	20000190 	.word	0x20000190
 807b034:	0807ec1b 	.word	0x0807ec1b
 807b038:	20000600 	.word	0x20000600
 807b03c:	0807ec18 	.word	0x0807ec18

0807b040 <MX25LM51245G_GetFlashInfo>:
  */
int32_t MX25LM51245G_GetFlashInfo(MX25LM51245G_Info_t *pInfo)
{
  /* Configure the structure with the memory configuration */
  pInfo->FlashSize              = MX25LM51245G_FLASH_SIZE;
  pInfo->EraseSectorSize        = MX25LM51245G_SECTOR_64K;
 807b040:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 807b044:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 807b048:	e9c0 2300 	strd	r2, r3, [r0]
  pInfo->EraseSectorsNumber     = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SECTOR_64K);
  pInfo->EraseSubSectorSize     = MX25LM51245G_SUBSECTOR_4K;
 807b04c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 807b050:	f44f 6380 	mov.w	r3, #1024	; 0x400
 807b054:	e9c0 3202 	strd	r3, r2, [r0, #8]
  pInfo->EraseSubSectorNumber   = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SUBSECTOR_4K);
 807b058:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  pInfo->EraseSubSector1Size    = MX25LM51245G_SUBSECTOR_4K;
  pInfo->EraseSubSector1Number  = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SUBSECTOR_4K);
  pInfo->ProgPageSize           = MX25LM51245G_PAGE_SIZE;
  pInfo->ProgPagesNumber        = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_PAGE_SIZE);
 807b05c:	f44f 7180 	mov.w	r1, #256	; 0x100
  pInfo->EraseSubSector1Size    = MX25LM51245G_SUBSECTOR_4K;
 807b060:	e9c0 3204 	strd	r3, r2, [r0, #16]
  pInfo->EraseSubSector1Number  = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_SUBSECTOR_4K);
 807b064:	6183      	str	r3, [r0, #24]
  pInfo->ProgPagesNumber        = (MX25LM51245G_FLASH_SIZE / MX25LM51245G_PAGE_SIZE);
 807b066:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 807b06a:	e9c0 1307 	strd	r1, r3, [r0, #28]

  return MX25LM51245G_OK;
};
 807b06e:	2000      	movs	r0, #0
 807b070:	4770      	bx	lr

0807b072 <MX25LM51245G_AutoPollingMemReady>:
  * @param  Rate Transfer rate
  * @retval error status
  */
int32_t MX25LM51245G_AutoPollingMemReady(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                         MX25LM51245G_Transfer_t Rate)
{
 807b072:	b570      	push	{r4, r5, r6, lr}
 807b074:	460c      	mov	r4, r1
 807b076:	b09a      	sub	sp, #104	; 0x68
  OSPI_RegularCmdTypeDef  s_command = {0};
 807b078:	2100      	movs	r1, #0
{
 807b07a:	4606      	mov	r6, r0
 807b07c:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef  s_command = {0};
 807b07e:	a806      	add	r0, sp, #24
 807b080:	2250      	movs	r2, #80	; 0x50
 807b082:	f002 f993 	bl	807d3ac <memset>
  OSPI_AutoPollingTypeDef s_config = {0};
 807b086:	2214      	movs	r2, #20
 807b088:	2100      	movs	r1, #0
 807b08a:	a801      	add	r0, sp, #4
 807b08c:	f002 f98e 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b090:	b92c      	cbnz	r4, 807b09e <MX25LM51245G_AutoPollingMemReady+0x2c>
 807b092:	2d01      	cmp	r5, #1
 807b094:	d159      	bne.n	807b14a <MX25LM51245G_AutoPollingMemReady+0xd8>
  {
    return MX25LM51245G_ERROR;
 807b096:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b09a:	b01a      	add	sp, #104	; 0x68
 807b09c:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b09e:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b0a0:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b0a2:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b0a4:	bf0c      	ite	eq
 807b0a6:	2308      	moveq	r3, #8
 807b0a8:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b0aa:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b0ac:	930b      	str	r3, [sp, #44]	; 0x2c
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b0ae:	bf0c      	ite	eq
 807b0b0:	2300      	moveq	r3, #0
 807b0b2:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b0b4:	930a      	str	r3, [sp, #40]	; 0x28
                                 : MX25LM51245G_OCTA_READ_STATUS_REG_CMD;
 807b0b6:	f240 53fa 	movw	r3, #1530	; 0x5fa
 807b0ba:	bf08      	it	eq
 807b0bc:	2305      	moveq	r3, #5
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b0be:	9308      	str	r3, [sp, #32]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b0c0:	bf0c      	ite	eq
 807b0c2:	2300      	moveq	r3, #0
 807b0c4:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b0c8:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b0ca:	930d      	str	r3, [sp, #52]	; 0x34
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b0cc:	bf0c      	ite	eq
 807b0ce:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b0d2:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b0d4:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b0d6:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b0da:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b0dc:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b0de:	bf0c      	ite	eq
 807b0e0:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b0e4:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b0e8:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b0ea:	9314      	str	r3, [sp, #80]	; 0x50
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b0ec:	bf0c      	ite	eq
 807b0ee:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 807b0f2:	2300      	movne	r3, #0
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b0f4:	9316      	str	r3, [sp, #88]	; 0x58
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 807b0f6:	b11c      	cbz	r4, 807b100 <MX25LM51245G_AutoPollingMemReady+0x8e>
 807b0f8:	2d01      	cmp	r5, #1
 807b0fa:	bf0c      	ite	eq
 807b0fc:	2405      	moveq	r4, #5
 807b0fe:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 807b100:	2d01      	cmp	r5, #1
 807b102:	bf0c      	ite	eq
 807b104:	2302      	moveq	r3, #2
 807b106:	2301      	movne	r3, #1
 807b108:	9315      	str	r3, [sp, #84]	; 0x54
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b10a:	bf0c      	ite	eq
 807b10c:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 807b110:	2300      	movne	r3, #0
 807b112:	9318      	str	r3, [sp, #96]	; 0x60
  s_config.Mask          = MX25LM51245G_SR_WIP;
 807b114:	2301      	movs	r3, #1
  s_config.AutomaticStop = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 807b116:	2110      	movs	r1, #16
  s_config.Mask          = MX25LM51245G_SR_WIP;
 807b118:	9302      	str	r3, [sp, #8]
  s_config.AutomaticStop = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 807b11a:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b11e:	f241 3288 	movw	r2, #5000	; 0x1388
  s_config.AutomaticStop = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 807b122:	e9cd 3104 	strd	r3, r1, [sp, #16]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b126:	4630      	mov	r0, r6
 807b128:	a906      	add	r1, sp, #24
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 807b12a:	9417      	str	r4, [sp, #92]	; 0x5c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b12c:	f001 fbc6 	bl	807c8bc <HAL_OSPI_Command>
 807b130:	2800      	cmp	r0, #0
 807b132:	d1b0      	bne.n	807b096 <MX25LM51245G_AutoPollingMemReady+0x24>
  if (HAL_OSPI_AutoPolling(Ctx, &s_config, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b134:	f241 3288 	movw	r2, #5000	; 0x1388
 807b138:	a901      	add	r1, sp, #4
 807b13a:	4630      	mov	r0, r6
 807b13c:	f001 fca7 	bl	807ca8e <HAL_OSPI_AutoPolling>
 807b140:	3000      	adds	r0, #0
 807b142:	bf18      	it	ne
 807b144:	2001      	movne	r0, #1
 807b146:	4240      	negs	r0, r0
 807b148:	e7a7      	b.n	807b09a <MX25LM51245G_AutoPollingMemReady+0x28>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b14a:	2301      	movs	r3, #1
 807b14c:	e7a8      	b.n	807b0a0 <MX25LM51245G_AutoPollingMemReady+0x2e>

0807b14e <MX25LM51245G_ReadSTR>:
  * @param  Size Size of data to read
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_ReadSTR(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                             MX25LM51245G_AddressSize_t AddressSize, uint8_t *pData, uint32_t ReadAddr, uint32_t Size)
{
 807b14e:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b150:	460c      	mov	r4, r1
 807b152:	b095      	sub	sp, #84	; 0x54
 807b154:	4606      	mov	r6, r0
 807b156:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b158:	2100      	movs	r1, #0
 807b15a:	2250      	movs	r2, #80	; 0x50
 807b15c:	4668      	mov	r0, sp
{
 807b15e:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b160:	f002 f924 	bl	807d3ac <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 807b164:	2c01      	cmp	r4, #1
 807b166:	d105      	bne.n	807b174 <MX25LM51245G_ReadSTR+0x26>
 807b168:	2d00      	cmp	r5, #0
 807b16a:	d143      	bne.n	807b1f4 <MX25LM51245G_ReadSTR+0xa6>
  {
    return MX25LM51245G_ERROR;
 807b16c:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b170:	b015      	add	sp, #84	; 0x54
 807b172:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b174:	2c00      	cmp	r4, #0
 807b176:	bf0c      	ite	eq
 807b178:	2301      	moveq	r3, #1
 807b17a:	2304      	movne	r3, #4
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b17c:	2c00      	cmp	r4, #0
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b17e:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b180:	bf0c      	ite	eq
 807b182:	2300      	moveq	r3, #0
 807b184:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b186:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_READ_CMD;
 807b188:	d136      	bne.n	807b1f8 <MX25LM51245G_ReadSTR+0xaa>
 807b18a:	2d00      	cmp	r5, #0
 807b18c:	bf0c      	ite	eq
 807b18e:	230b      	moveq	r3, #11
 807b190:	230c      	movne	r3, #12
                                 : HAL_OSPI_ADDRESS_8_LINES;
 807b192:	2c00      	cmp	r4, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b194:	9302      	str	r3, [sp, #8]
                                 : HAL_OSPI_ADDRESS_8_LINES;
 807b196:	bf0c      	ite	eq
 807b198:	f44f 7380 	moveq.w	r3, #256	; 0x100
 807b19c:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_32_BITS;
 807b1a0:	2d00      	cmp	r5, #0
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE)
 807b1a2:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_32_BITS;
 807b1a4:	bf0c      	ite	eq
 807b1a6:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 807b1aa:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 807b1ae:	9308      	str	r3, [sp, #32]
  s_command.Address            = ReadAddr;
 807b1b0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b1b2:	2c00      	cmp	r4, #0
  s_command.Address            = ReadAddr;
 807b1b4:	9306      	str	r3, [sp, #24]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b1b6:	bf0c      	ite	eq
 807b1b8:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b1bc:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 807b1c0:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE) ? DUMMY_CYCLES_READ : DUMMY_CYCLES_READ_OCTAL;
 807b1c2:	bf0c      	ite	eq
 807b1c4:	2308      	moveq	r3, #8
 807b1c6:	2306      	movne	r3, #6
 807b1c8:	9311      	str	r3, [sp, #68]	; 0x44
  s_command.NbData             = Size;
 807b1ca:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b1cc:	f241 3288 	movw	r2, #5000	; 0x1388
 807b1d0:	4669      	mov	r1, sp
 807b1d2:	4630      	mov	r0, r6
  s_command.NbData             = Size;
 807b1d4:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b1d6:	f001 fb71 	bl	807c8bc <HAL_OSPI_Command>
 807b1da:	2800      	cmp	r0, #0
 807b1dc:	d1c6      	bne.n	807b16c <MX25LM51245G_ReadSTR+0x1e>
  if (HAL_OSPI_Receive(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b1de:	f241 3288 	movw	r2, #5000	; 0x1388
 807b1e2:	4639      	mov	r1, r7
 807b1e4:	4630      	mov	r0, r6
 807b1e6:	f001 fbfc 	bl	807c9e2 <HAL_OSPI_Receive>
 807b1ea:	3000      	adds	r0, #0
 807b1ec:	bf18      	it	ne
 807b1ee:	2001      	movne	r0, #1
 807b1f0:	4240      	negs	r0, r0
 807b1f2:	e7bd      	b.n	807b170 <MX25LM51245G_ReadSTR+0x22>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b1f4:	2304      	movs	r3, #4
 807b1f6:	e7c1      	b.n	807b17c <MX25LM51245G_ReadSTR+0x2e>
                                 : MX25LM51245G_OCTA_READ_CMD;
 807b1f8:	f64e 4313 	movw	r3, #60435	; 0xec13
 807b1fc:	e7c9      	b.n	807b192 <MX25LM51245G_ReadSTR+0x44>

0807b1fe <MX25LM51245G_ReadDTR>:
  * @param  Size Size of data to read
  * @note   Only OPI mode support DTR transfer rate
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_ReadDTR(OSPI_HandleTypeDef *Ctx, uint8_t *pData, uint32_t ReadAddr, uint32_t Size)
{
 807b1fe:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b200:	b095      	sub	sp, #84	; 0x54
 807b202:	4604      	mov	r4, r0
 807b204:	4617      	mov	r7, r2
 807b206:	460d      	mov	r5, r1
  OSPI_RegularCmdTypeDef s_command = {0};
 807b208:	2250      	movs	r2, #80	; 0x50
 807b20a:	2100      	movs	r1, #0
 807b20c:	4668      	mov	r0, sp
{
 807b20e:	461e      	mov	r6, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b210:	f002 f8cc 	bl	807d3ac <memset>
#if defined (OCTOSPI_CR_MSEL)
  s_command.FlashSelect        = HAL_OSPI_FLASH_SELECT_IO_7_0;
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 807b214:	2304      	movs	r3, #4
  s_command.InstructionDtrMode = HAL_OSPI_INSTRUCTION_DTR_ENABLE;
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 807b216:	2108      	movs	r1, #8
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 807b218:	9303      	str	r3, [sp, #12]
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 807b21a:	2310      	movs	r3, #16
 807b21c:	e9cd 3104 	strd	r3, r1, [sp, #16]
  s_command.Instruction        = MX25LM51245G_OCTA_READ_DTR_CMD;
 807b220:	f64e 6311 	movw	r3, #60945	; 0xee11
 807b224:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 807b226:	f44f 6380 	mov.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = HAL_OSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b22a:	f44f 6e00 	mov.w	lr, #2048	; 0x800
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 807b22e:	9307      	str	r3, [sp, #28]
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b230:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 807b234:	e9cd 3e08 	strd	r3, lr, [sp, #32]
  s_command.Address            = ReadAddr;
  s_command.AlternateBytesMode = HAL_OSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 807b238:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  s_command.DataDtrMode        = HAL_OSPI_DATA_DTR_ENABLE;
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
 807b23c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 807b240:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DummyCycles        = DUMMY_CYCLES_READ_OCTAL_DTR;
 807b242:	2306      	movs	r3, #6
 807b244:	e9cd 1310 	strd	r1, r3, [sp, #64]	; 0x40
  s_command.NbData             = Size;
  s_command.DQSMode            = HAL_OSPI_DQS_ENABLE;
 807b248:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b24c:	f241 3288 	movw	r2, #5000	; 0x1388
 807b250:	4669      	mov	r1, sp
 807b252:	4620      	mov	r0, r4
  s_command.Address            = ReadAddr;
 807b254:	9706      	str	r7, [sp, #24]
  s_command.NbData             = Size;
 807b256:	960f      	str	r6, [sp, #60]	; 0x3c
  s_command.DQSMode            = HAL_OSPI_DQS_ENABLE;
 807b258:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b25a:	f001 fb2f 	bl	807c8bc <HAL_OSPI_Command>
 807b25e:	b958      	cbnz	r0, 807b278 <MX25LM51245G_ReadDTR+0x7a>
  {
    return MX25LM51245G_ERROR;
  }

  /* Reception of the data */
  if (HAL_OSPI_Receive(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b260:	f241 3288 	movw	r2, #5000	; 0x1388
 807b264:	4629      	mov	r1, r5
 807b266:	4620      	mov	r0, r4
 807b268:	f001 fbbb 	bl	807c9e2 <HAL_OSPI_Receive>
 807b26c:	3000      	adds	r0, #0
 807b26e:	bf18      	it	ne
 807b270:	2001      	movne	r0, #1
 807b272:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b274:	b015      	add	sp, #84	; 0x54
 807b276:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return MX25LM51245G_ERROR;
 807b278:	f04f 30ff 	mov.w	r0, #4294967295
 807b27c:	e7fa      	b.n	807b274 <MX25LM51245G_ReadDTR+0x76>

0807b27e <MX25LM51245G_PageProgram>:
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_PageProgram(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                 MX25LM51245G_AddressSize_t AddressSize, uint8_t *pData, uint32_t WriteAddr,
                                 uint32_t Size)
{
 807b27e:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b280:	460c      	mov	r4, r1
 807b282:	b095      	sub	sp, #84	; 0x54
 807b284:	4606      	mov	r6, r0
 807b286:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b288:	2100      	movs	r1, #0
 807b28a:	2250      	movs	r2, #80	; 0x50
 807b28c:	4668      	mov	r0, sp
{
 807b28e:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b290:	f002 f88c 	bl	807d3ac <memset>

  /* OPI mode and 3-bytes address size not supported by memory */
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 807b294:	2c01      	cmp	r4, #1
 807b296:	d105      	bne.n	807b2a4 <MX25LM51245G_PageProgram+0x26>
 807b298:	2d00      	cmp	r5, #0
 807b29a:	d13f      	bne.n	807b31c <MX25LM51245G_PageProgram+0x9e>
  {
    return MX25LM51245G_ERROR;
 807b29c:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b2a0:	b015      	add	sp, #84	; 0x54
 807b2a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b2a4:	2c00      	cmp	r4, #0
 807b2a6:	bf0c      	ite	eq
 807b2a8:	2301      	moveq	r3, #1
 807b2aa:	2304      	movne	r3, #4
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b2ac:	2c00      	cmp	r4, #0
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b2ae:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b2b0:	bf0c      	ite	eq
 807b2b2:	2300      	moveq	r3, #0
 807b2b4:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b2b6:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_PAGE_PROG_CMD;
 807b2b8:	d132      	bne.n	807b320 <MX25LM51245G_PageProgram+0xa2>
 807b2ba:	2d00      	cmp	r5, #0
 807b2bc:	bf0c      	ite	eq
 807b2be:	2302      	moveq	r3, #2
 807b2c0:	2312      	movne	r3, #18
                                 : HAL_OSPI_ADDRESS_8_LINES;
 807b2c2:	2c00      	cmp	r4, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b2c4:	9302      	str	r3, [sp, #8]
                                 : HAL_OSPI_ADDRESS_8_LINES;
 807b2c6:	bf0c      	ite	eq
 807b2c8:	f44f 7380 	moveq.w	r3, #256	; 0x100
 807b2cc:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_32_BITS;
 807b2d0:	2d00      	cmp	r5, #0
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE)
 807b2d2:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_32_BITS;
 807b2d4:	bf0c      	ite	eq
 807b2d6:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 807b2da:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 807b2de:	9308      	str	r3, [sp, #32]
  s_command.Address            = WriteAddr;
 807b2e0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b2e2:	2c00      	cmp	r4, #0
  s_command.Address            = WriteAddr;
 807b2e4:	9306      	str	r3, [sp, #24]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b2e6:	bf0c      	ite	eq
 807b2e8:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b2ec:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
 807b2f0:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.NbData             = Size;
 807b2f2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b2f4:	f241 3288 	movw	r2, #5000	; 0x1388
 807b2f8:	4669      	mov	r1, sp
 807b2fa:	4630      	mov	r0, r6
  s_command.NbData             = Size;
 807b2fc:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b2fe:	f001 fadd 	bl	807c8bc <HAL_OSPI_Command>
 807b302:	2800      	cmp	r0, #0
 807b304:	d1ca      	bne.n	807b29c <MX25LM51245G_PageProgram+0x1e>
  if (HAL_OSPI_Transmit(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b306:	f241 3288 	movw	r2, #5000	; 0x1388
 807b30a:	4639      	mov	r1, r7
 807b30c:	4630      	mov	r0, r6
 807b30e:	f001 fb24 	bl	807c95a <HAL_OSPI_Transmit>
 807b312:	3000      	adds	r0, #0
 807b314:	bf18      	it	ne
 807b316:	2001      	movne	r0, #1
 807b318:	4240      	negs	r0, r0
 807b31a:	e7c1      	b.n	807b2a0 <MX25LM51245G_PageProgram+0x22>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b31c:	2304      	movs	r3, #4
 807b31e:	e7c5      	b.n	807b2ac <MX25LM51245G_PageProgram+0x2e>
                                 : MX25LM51245G_OCTA_PAGE_PROG_CMD;
 807b320:	f241 23ed 	movw	r3, #4845	; 0x12ed
 807b324:	e7cd      	b.n	807b2c2 <MX25LM51245G_PageProgram+0x44>

0807b326 <MX25LM51245G_PageProgramDTR>:
  * @param  Size Size of data to write. Range 1 ~ MX25LM51245G_PAGE_SIZE
  * @note   Only OPI mode support DTR transfer rate
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_PageProgramDTR(OSPI_HandleTypeDef *Ctx, uint8_t *pData, uint32_t WriteAddr, uint32_t Size)
{
 807b326:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b328:	b095      	sub	sp, #84	; 0x54
 807b32a:	4604      	mov	r4, r0
 807b32c:	4617      	mov	r7, r2
 807b32e:	460d      	mov	r5, r1
  OSPI_RegularCmdTypeDef s_command = {0};
 807b330:	2250      	movs	r2, #80	; 0x50
 807b332:	2100      	movs	r1, #0
 807b334:	4668      	mov	r0, sp
{
 807b336:	461e      	mov	r6, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b338:	f002 f838 	bl	807d3ac <memset>
#if defined (OCTOSPI_CR_MSEL)
  s_command.FlashSelect        = HAL_OSPI_FLASH_SELECT_IO_7_0;
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 807b33c:	2304      	movs	r3, #4
  s_command.InstructionDtrMode = HAL_OSPI_INSTRUCTION_DTR_ENABLE;
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 807b33e:	2108      	movs	r1, #8
  s_command.InstructionMode    = HAL_OSPI_INSTRUCTION_8_LINES;
 807b340:	9303      	str	r3, [sp, #12]
  s_command.InstructionSize    = HAL_OSPI_INSTRUCTION_16_BITS;
 807b342:	2310      	movs	r3, #16
 807b344:	e9cd 3104 	strd	r3, r1, [sp, #16]
  s_command.Instruction        = MX25LM51245G_OCTA_PAGE_PROG_CMD;
 807b348:	f241 23ed 	movw	r3, #4845	; 0x12ed
 807b34c:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 807b34e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = HAL_OSPI_ADDRESS_DTR_ENABLE;
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b352:	f44f 6e00 	mov.w	lr, #2048	; 0x800
  s_command.AddressMode        = HAL_OSPI_ADDRESS_8_LINES;
 807b356:	9307      	str	r3, [sp, #28]
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b358:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 807b35c:	e9cd 3e08 	strd	r3, lr, [sp, #32]
  s_command.Address            = WriteAddr;
  s_command.AlternateBytesMode = HAL_OSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode           = HAL_OSPI_DATA_8_LINES;
 807b360:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 807b364:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DataDtrMode        = HAL_OSPI_DATA_DTR_ENABLE;
 807b366:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  s_command.NbData             = Size;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Configure the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b36a:	f241 3288 	movw	r2, #5000	; 0x1388
 807b36e:	4669      	mov	r1, sp
 807b370:	4620      	mov	r0, r4
  s_command.Address            = WriteAddr;
 807b372:	9706      	str	r7, [sp, #24]
  s_command.NbData             = Size;
 807b374:	e9cd 630f 	strd	r6, r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b378:	f001 faa0 	bl	807c8bc <HAL_OSPI_Command>
 807b37c:	b958      	cbnz	r0, 807b396 <MX25LM51245G_PageProgramDTR+0x70>
  {
    return MX25LM51245G_ERROR;
  }

  /* Transmission of the data */
  if (HAL_OSPI_Transmit(Ctx, pData, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b37e:	f241 3288 	movw	r2, #5000	; 0x1388
 807b382:	4629      	mov	r1, r5
 807b384:	4620      	mov	r0, r4
 807b386:	f001 fae8 	bl	807c95a <HAL_OSPI_Transmit>
 807b38a:	3000      	adds	r0, #0
 807b38c:	bf18      	it	ne
 807b38e:	2001      	movne	r0, #1
 807b390:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b392:	b015      	add	sp, #84	; 0x54
 807b394:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return MX25LM51245G_ERROR;
 807b396:	f04f 30ff 	mov.w	r0, #4294967295
 807b39a:	e7fa      	b.n	807b392 <MX25LM51245G_PageProgramDTR+0x6c>

0807b39c <MX25LM51245G_BlockErase>:
  * @retval OSPI memory status
  */
int32_t MX25LM51245G_BlockErase(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate,
                                MX25LM51245G_AddressSize_t AddressSize, uint32_t BlockAddress,
                                MX25LM51245G_Erase_t BlockSize)
{
 807b39c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 807b3a0:	460d      	mov	r5, r1
 807b3a2:	b094      	sub	sp, #80	; 0x50
 807b3a4:	4680      	mov	r8, r0
 807b3a6:	4616      	mov	r6, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b3a8:	2100      	movs	r1, #0
 807b3aa:	2250      	movs	r2, #80	; 0x50
 807b3ac:	4668      	mov	r0, sp
{
 807b3ae:	461c      	mov	r4, r3
 807b3b0:	f89d 706c 	ldrb.w	r7, [sp, #108]	; 0x6c
  OSPI_RegularCmdTypeDef s_command = {0};
 807b3b4:	f001 fffa 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b3b8:	2d00      	cmp	r5, #0
 807b3ba:	d138      	bne.n	807b42e <MX25LM51245G_BlockErase+0x92>
 807b3bc:	2e01      	cmp	r6, #1
 807b3be:	d047      	beq.n	807b450 <MX25LM51245G_BlockErase+0xb4>
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif  /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_1_LINE
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b3c0:	2301      	movs	r3, #1
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b3c2:	2e01      	cmp	r6, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b3c4:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b3c6:	bf0c      	ite	eq
 807b3c8:	2308      	moveq	r3, #8
 807b3ca:	2300      	movne	r3, #0
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_8_BITS
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b3cc:	2d00      	cmp	r5, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b3ce:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b3d0:	bf0c      	ite	eq
 807b3d2:	2300      	moveq	r3, #0
 807b3d4:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b3d6:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 807b3d8:	bf0c      	ite	eq
 807b3da:	f44f 7380 	moveq.w	r3, #256	; 0x100
 807b3de:	f44f 6380 	movne.w	r3, #1024	; 0x400
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_ADDRESS_DTR_ENABLE
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b3e2:	2e01      	cmp	r6, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 807b3e4:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b3e6:	bf0c      	ite	eq
 807b3e8:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b3ec:	2300      	movne	r3, #0
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
                                 ? HAL_OSPI_ADDRESS_24_BITS
                                 : HAL_OSPI_ADDRESS_32_BITS;
 807b3ee:	2c00      	cmp	r4, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b3f0:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_ADDRESS_32_BITS;
 807b3f2:	bf0c      	ite	eq
 807b3f4:	f44f 5300 	moveq.w	r3, #8192	; 0x2000
 807b3f8:	f44f 5340 	movne.w	r3, #12288	; 0x3000
  s_command.AddressSize        = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 807b3fc:	9308      	str	r3, [sp, #32]
  s_command.Address            = BlockAddress;
 807b3fe:	9b1a      	ldr	r3, [sp, #104]	; 0x68
  s_command.DataMode           = HAL_OSPI_DATA_NONE;
  s_command.DummyCycles        = 0U;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  switch (Mode)
 807b400:	2d01      	cmp	r5, #1
  s_command.Address            = BlockAddress;
 807b402:	9306      	str	r3, [sp, #24]
  switch (Mode)
 807b404:	d118      	bne.n	807b438 <MX25LM51245G_BlockErase+0x9c>
  {
    case MX25LM51245G_OPI_MODE :
      if (BlockSize == MX25LM51245G_ERASE_64K)
 807b406:	2f01      	cmp	r7, #1
      {
        s_command.Instruction = MX25LM51245G_OCTA_SECTOR_ERASE_64K_CMD;
 807b408:	bf0c      	ite	eq
 807b40a:	f64d 4323 	movweq	r3, #56355	; 0xdc23
      }
      else
      {
        s_command.Instruction = MX25LM51245G_OCTA_SUBSECTOR_ERASE_4K_CMD;
 807b40e:	f242 13de 	movwne	r3, #8670	; 0x21de
      }
      break;
  }

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b412:	f241 3288 	movw	r2, #5000	; 0x1388
 807b416:	4669      	mov	r1, sp
 807b418:	4640      	mov	r0, r8
        s_command.Instruction = (AddressSize == MX25LM51245G_3BYTES_SIZE)
 807b41a:	9302      	str	r3, [sp, #8]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b41c:	f001 fa4e 	bl	807c8bc <HAL_OSPI_Command>
 807b420:	3000      	adds	r0, #0
 807b422:	bf18      	it	ne
 807b424:	2001      	movne	r0, #1
 807b426:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b428:	b014      	add	sp, #80	; 0x50
 807b42a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((Mode == MX25LM51245G_OPI_MODE) && (AddressSize == MX25LM51245G_3BYTES_SIZE))
 807b42e:	2d01      	cmp	r5, #1
 807b430:	d100      	bne.n	807b434 <MX25LM51245G_BlockErase+0x98>
 807b432:	b16c      	cbz	r4, 807b450 <MX25LM51245G_BlockErase+0xb4>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b434:	2304      	movs	r3, #4
 807b436:	e7c4      	b.n	807b3c2 <MX25LM51245G_BlockErase+0x26>
      if (BlockSize == MX25LM51245G_ERASE_64K)
 807b438:	2f01      	cmp	r7, #1
 807b43a:	d104      	bne.n	807b446 <MX25LM51245G_BlockErase+0xaa>
                                : MX25LM51245G_4_BYTE_SECTOR_ERASE_64K_CMD;
 807b43c:	2c00      	cmp	r4, #0
 807b43e:	bf0c      	ite	eq
 807b440:	23d8      	moveq	r3, #216	; 0xd8
 807b442:	23dc      	movne	r3, #220	; 0xdc
 807b444:	e7e5      	b.n	807b412 <MX25LM51245G_BlockErase+0x76>
                                : MX25LM51245G_4_BYTE_SUBSECTOR_ERASE_4K_CMD;
 807b446:	2c00      	cmp	r4, #0
 807b448:	bf0c      	ite	eq
 807b44a:	2320      	moveq	r3, #32
 807b44c:	2321      	movne	r3, #33	; 0x21
 807b44e:	e7e0      	b.n	807b412 <MX25LM51245G_BlockErase+0x76>
    return MX25LM51245G_ERROR;
 807b450:	f04f 30ff 	mov.w	r0, #4294967295
 807b454:	e7e8      	b.n	807b428 <MX25LM51245G_BlockErase+0x8c>

0807b456 <MX25LM51245G_WriteEnable>:
  * @param  Mode Interface mode
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25LM51245G_WriteEnable(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate)
{
 807b456:	b570      	push	{r4, r5, r6, lr}
 807b458:	460c      	mov	r4, r1
 807b45a:	b09a      	sub	sp, #104	; 0x68
  OSPI_RegularCmdTypeDef     s_command = {0};
 807b45c:	2100      	movs	r1, #0
{
 807b45e:	4606      	mov	r6, r0
 807b460:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef     s_command = {0};
 807b462:	a806      	add	r0, sp, #24
 807b464:	2250      	movs	r2, #80	; 0x50
 807b466:	f001 ffa1 	bl	807d3ac <memset>
  OSPI_AutoPollingTypeDef s_config = {0};
 807b46a:	2214      	movs	r2, #20
 807b46c:	2100      	movs	r1, #0
 807b46e:	a801      	add	r0, sp, #4
 807b470:	f001 ff9c 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b474:	b92c      	cbnz	r4, 807b482 <MX25LM51245G_WriteEnable+0x2c>
 807b476:	2d01      	cmp	r5, #1
 807b478:	d16a      	bne.n	807b550 <MX25LM51245G_WriteEnable+0xfa>
  {
    return MX25LM51245G_ERROR;
 807b47a:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b47e:	b01a      	add	sp, #104	; 0x68
 807b480:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b482:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b484:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b486:	9309      	str	r3, [sp, #36]	; 0x24
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b488:	bf0c      	ite	eq
 807b48a:	2308      	moveq	r3, #8
 807b48c:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b48e:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b490:	930b      	str	r3, [sp, #44]	; 0x2c
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b492:	bf0c      	ite	eq
 807b494:	2300      	moveq	r3, #0
 807b496:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b498:	930a      	str	r3, [sp, #40]	; 0x28
                                 : MX25LM51245G_OCTA_WRITE_ENABLE_CMD;
 807b49a:	f240 63f9 	movw	r3, #1785	; 0x6f9
 807b49e:	bf08      	it	eq
 807b4a0:	2306      	moveq	r3, #6
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b4a2:	f241 3288 	movw	r2, #5000	; 0x1388
 807b4a6:	a906      	add	r1, sp, #24
 807b4a8:	4630      	mov	r0, r6
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b4aa:	9308      	str	r3, [sp, #32]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b4ac:	f001 fa06 	bl	807c8bc <HAL_OSPI_Command>
 807b4b0:	2800      	cmp	r0, #0
 807b4b2:	d1e2      	bne.n	807b47a <MX25LM51245G_WriteEnable+0x24>
                             : MX25LM51245G_OCTA_READ_STATUS_REG_CMD;
 807b4b4:	2c00      	cmp	r4, #0
 807b4b6:	f240 53fa 	movw	r3, #1530	; 0x5fa
 807b4ba:	bf08      	it	eq
 807b4bc:	2305      	moveq	r3, #5
  s_command.Instruction    = (Mode == MX25LM51245G_SPI_MODE)
 807b4be:	9308      	str	r3, [sp, #32]
  s_command.AddressMode    = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b4c0:	bf0c      	ite	eq
 807b4c2:	2300      	moveq	r3, #0
 807b4c4:	f44f 6380 	movne.w	r3, #1024	; 0x400
                             : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b4c8:	2d01      	cmp	r5, #1
  s_command.AddressMode    = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b4ca:	930d      	str	r3, [sp, #52]	; 0x34
                             : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b4cc:	bf0c      	ite	eq
 807b4ce:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b4d2:	2300      	movne	r3, #0
  s_command.AddressDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b4d4:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.AddressSize    = HAL_OSPI_ADDRESS_32_BITS;
 807b4d6:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode       = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b4da:	2c00      	cmp	r4, #0
  s_command.AddressSize    = HAL_OSPI_ADDRESS_32_BITS;
 807b4dc:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DataMode       = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b4de:	bf0c      	ite	eq
 807b4e0:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b4e4:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
  s_command.DataDtrMode    = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DATA_DTR_ENABLE : HAL_OSPI_DATA_DTR_DISABLE;
 807b4e8:	2d01      	cmp	r5, #1
  s_command.DataMode       = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b4ea:	9314      	str	r3, [sp, #80]	; 0x50
  s_command.DataDtrMode    = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DATA_DTR_ENABLE : HAL_OSPI_DATA_DTR_DISABLE;
 807b4ec:	bf0c      	ite	eq
 807b4ee:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 807b4f2:	2300      	movne	r3, #0
  s_command.Address        = 0U;
 807b4f4:	900c      	str	r0, [sp, #48]	; 0x30
  s_command.DataDtrMode    = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DATA_DTR_ENABLE : HAL_OSPI_DATA_DTR_DISABLE;
 807b4f6:	9316      	str	r3, [sp, #88]	; 0x58
                             : ((Rate == MX25LM51245G_DTR_TRANSFER)
 807b4f8:	b11c      	cbz	r4, 807b502 <MX25LM51245G_WriteEnable+0xac>
 807b4fa:	2d01      	cmp	r5, #1
 807b4fc:	bf0c      	ite	eq
 807b4fe:	2405      	moveq	r4, #5
 807b500:	2404      	movne	r4, #4
  s_command.NbData         = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 807b502:	2d01      	cmp	r5, #1
 807b504:	bf0c      	ite	eq
 807b506:	2302      	moveq	r3, #2
 807b508:	2301      	movne	r3, #1
 807b50a:	9315      	str	r3, [sp, #84]	; 0x54
  s_command.DQSMode        = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b50c:	bf0c      	ite	eq
 807b50e:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 807b512:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b514:	f241 3288 	movw	r2, #5000	; 0x1388
 807b518:	a906      	add	r1, sp, #24
 807b51a:	4630      	mov	r0, r6
  s_command.DummyCycles    = (Mode == MX25LM51245G_SPI_MODE)
 807b51c:	9417      	str	r4, [sp, #92]	; 0x5c
  s_command.DQSMode        = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b51e:	9318      	str	r3, [sp, #96]	; 0x60
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b520:	f001 f9cc 	bl	807c8bc <HAL_OSPI_Command>
 807b524:	2800      	cmp	r0, #0
 807b526:	d1a8      	bne.n	807b47a <MX25LM51245G_WriteEnable+0x24>
  s_config.Match           = 2U;
 807b528:	2302      	movs	r3, #2
  s_config.AutomaticStop   = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 807b52a:	2210      	movs	r2, #16
  s_config.Mask            = 2U;
 807b52c:	e9cd 3301 	strd	r3, r3, [sp, #4]
  s_config.AutomaticStop   = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 807b530:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  s_config.MatchMode       = HAL_OSPI_MATCH_MODE_AND;
 807b534:	9003      	str	r0, [sp, #12]
  s_config.AutomaticStop   = HAL_OSPI_AUTOMATIC_STOP_ENABLE;
 807b536:	e9cd 3204 	strd	r3, r2, [sp, #16]
  if (HAL_OSPI_AutoPolling(Ctx, &s_config, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b53a:	a901      	add	r1, sp, #4
 807b53c:	f241 3288 	movw	r2, #5000	; 0x1388
 807b540:	4630      	mov	r0, r6
 807b542:	f001 faa4 	bl	807ca8e <HAL_OSPI_AutoPolling>
 807b546:	3000      	adds	r0, #0
 807b548:	bf18      	it	ne
 807b54a:	2001      	movne	r0, #1
 807b54c:	4240      	negs	r0, r0
 807b54e:	e796      	b.n	807b47e <MX25LM51245G_WriteEnable+0x28>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b550:	2301      	movs	r3, #1
 807b552:	e797      	b.n	807b484 <MX25LM51245G_WriteEnable+0x2e>

0807b554 <MX25LM51245G_ReadStatusRegister>:
  * @param  Value Status register value pointer
  * @retval error status
  */
int32_t MX25LM51245G_ReadStatusRegister(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                        MX25LM51245G_Transfer_t Rate, uint8_t *Value)
{
 807b554:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b556:	460c      	mov	r4, r1
 807b558:	b095      	sub	sp, #84	; 0x54
 807b55a:	4606      	mov	r6, r0
 807b55c:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b55e:	2100      	movs	r1, #0
 807b560:	2250      	movs	r2, #80	; 0x50
 807b562:	4668      	mov	r0, sp
{
 807b564:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b566:	f001 ff21 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b56a:	b92c      	cbnz	r4, 807b578 <MX25LM51245G_ReadStatusRegister+0x24>
 807b56c:	2d01      	cmp	r5, #1
 807b56e:	d152      	bne.n	807b616 <MX25LM51245G_ReadStatusRegister+0xc2>
  {
    return MX25LM51245G_ERROR;
 807b570:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b574:	b015      	add	sp, #84	; 0x54
 807b576:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b578:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b57a:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b57c:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b57e:	bf0c      	ite	eq
 807b580:	2308      	moveq	r3, #8
 807b582:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b584:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b586:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b588:	bf0c      	ite	eq
 807b58a:	2300      	moveq	r3, #0
 807b58c:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b58e:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_READ_STATUS_REG_CMD;
 807b590:	f240 53fa 	movw	r3, #1530	; 0x5fa
 807b594:	bf08      	it	eq
 807b596:	2305      	moveq	r3, #5
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b598:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b59a:	bf0c      	ite	eq
 807b59c:	2300      	moveq	r3, #0
 807b59e:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b5a2:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b5a4:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b5a6:	bf0c      	ite	eq
 807b5a8:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b5ac:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b5ae:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b5b0:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b5b4:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b5b6:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b5b8:	bf0c      	ite	eq
 807b5ba:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b5be:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b5c2:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b5c4:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b5c6:	bf0c      	ite	eq
 807b5c8:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 807b5cc:	2300      	movne	r3, #0
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b5ce:	9310      	str	r3, [sp, #64]	; 0x40
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 807b5d0:	b11c      	cbz	r4, 807b5da <MX25LM51245G_ReadStatusRegister+0x86>
 807b5d2:	2d01      	cmp	r5, #1
 807b5d4:	bf0c      	ite	eq
 807b5d6:	2405      	moveq	r4, #5
 807b5d8:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 807b5da:	2d01      	cmp	r5, #1
 807b5dc:	bf0c      	ite	eq
 807b5de:	2302      	moveq	r3, #2
 807b5e0:	2301      	movne	r3, #1
 807b5e2:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b5e4:	bf0c      	ite	eq
 807b5e6:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 807b5ea:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b5ec:	f241 3288 	movw	r2, #5000	; 0x1388
 807b5f0:	4669      	mov	r1, sp
 807b5f2:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 807b5f4:	9411      	str	r4, [sp, #68]	; 0x44
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b5f6:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b5f8:	f001 f960 	bl	807c8bc <HAL_OSPI_Command>
 807b5fc:	2800      	cmp	r0, #0
 807b5fe:	d1b7      	bne.n	807b570 <MX25LM51245G_ReadStatusRegister+0x1c>
  if (HAL_OSPI_Receive(Ctx, Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b600:	f241 3288 	movw	r2, #5000	; 0x1388
 807b604:	4639      	mov	r1, r7
 807b606:	4630      	mov	r0, r6
 807b608:	f001 f9eb 	bl	807c9e2 <HAL_OSPI_Receive>
 807b60c:	3000      	adds	r0, #0
 807b60e:	bf18      	it	ne
 807b610:	2001      	movne	r0, #1
 807b612:	4240      	negs	r0, r0
 807b614:	e7ae      	b.n	807b574 <MX25LM51245G_ReadStatusRegister+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b616:	2301      	movs	r3, #1
 807b618:	e7af      	b.n	807b57a <MX25LM51245G_ReadStatusRegister+0x26>

0807b61a <MX25LM51245G_WriteCfg2Register>:
  * @param  Value Value to write to configuration register
  * @retval error status
  */
int32_t MX25LM51245G_WriteCfg2Register(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                       MX25LM51245G_Transfer_t Rate, uint32_t WriteAddr, uint8_t Value)
{
 807b61a:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b61c:	460d      	mov	r5, r1
 807b61e:	b095      	sub	sp, #84	; 0x54
 807b620:	4606      	mov	r6, r0
 807b622:	4614      	mov	r4, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b624:	2100      	movs	r1, #0
 807b626:	2250      	movs	r2, #80	; 0x50
 807b628:	4668      	mov	r0, sp
{
 807b62a:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b62c:	f001 febe 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b630:	b92d      	cbnz	r5, 807b63e <MX25LM51245G_WriteCfg2Register+0x24>
 807b632:	2c01      	cmp	r4, #1
 807b634:	d14a      	bne.n	807b6cc <MX25LM51245G_WriteCfg2Register+0xb2>
  {
    return MX25LM51245G_ERROR;
 807b636:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b63a:	b015      	add	sp, #84	; 0x54
 807b63c:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b63e:	2204      	movs	r2, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b640:	2c01      	cmp	r4, #1
 807b642:	bf0c      	ite	eq
 807b644:	2308      	moveq	r3, #8
 807b646:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b648:	2d00      	cmp	r5, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b64a:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b64c:	bf0c      	ite	eq
 807b64e:	2300      	moveq	r3, #0
 807b650:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b652:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 807b654:	bf0c      	ite	eq
 807b656:	f44f 7380 	moveq.w	r3, #256	; 0x100
 807b65a:	f44f 6380 	movne.w	r3, #1024	; 0x400
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b65e:	9203      	str	r2, [sp, #12]
                                 : MX25LM51245G_OCTA_WRITE_CFG_REG2_CMD;
 807b660:	f247 228d 	movw	r2, #29325	; 0x728d
 807b664:	bf08      	it	eq
 807b666:	2272      	moveq	r2, #114	; 0x72
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b668:	2c01      	cmp	r4, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 807b66a:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b66c:	bf0c      	ite	eq
 807b66e:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b672:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b674:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b676:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b67a:	2d00      	cmp	r5, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b67c:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b67e:	bf0c      	ite	eq
 807b680:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b684:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b688:	2c01      	cmp	r4, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b68a:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b68c:	bf0c      	ite	eq
 807b68e:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 807b692:	2300      	movne	r3, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b694:	9202      	str	r2, [sp, #8]
  s_command.Address            = WriteAddr;
 807b696:	9706      	str	r7, [sp, #24]
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b698:	9310      	str	r3, [sp, #64]	; 0x40
  s_command.NbData             = (Mode == MX25LM51245G_SPI_MODE) ? 1U : ((Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U);
 807b69a:	b1cd      	cbz	r5, 807b6d0 <MX25LM51245G_WriteCfg2Register+0xb6>
 807b69c:	2c01      	cmp	r4, #1
 807b69e:	bf14      	ite	ne
 807b6a0:	2301      	movne	r3, #1
 807b6a2:	2302      	moveq	r3, #2
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b6a4:	f241 3288 	movw	r2, #5000	; 0x1388
 807b6a8:	4669      	mov	r1, sp
 807b6aa:	4630      	mov	r0, r6
  s_command.NbData             = (Mode == MX25LM51245G_SPI_MODE) ? 1U : ((Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U);
 807b6ac:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b6ae:	f001 f905 	bl	807c8bc <HAL_OSPI_Command>
 807b6b2:	2800      	cmp	r0, #0
 807b6b4:	d1bf      	bne.n	807b636 <MX25LM51245G_WriteCfg2Register+0x1c>
  if (HAL_OSPI_Transmit(Ctx, &Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b6b6:	f241 3288 	movw	r2, #5000	; 0x1388
 807b6ba:	a91a      	add	r1, sp, #104	; 0x68
 807b6bc:	4630      	mov	r0, r6
 807b6be:	f001 f94c 	bl	807c95a <HAL_OSPI_Transmit>
 807b6c2:	3000      	adds	r0, #0
 807b6c4:	bf18      	it	ne
 807b6c6:	2001      	movne	r0, #1
 807b6c8:	4240      	negs	r0, r0
 807b6ca:	e7b6      	b.n	807b63a <MX25LM51245G_WriteCfg2Register+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b6cc:	2201      	movs	r2, #1
 807b6ce:	e7b7      	b.n	807b640 <MX25LM51245G_WriteCfg2Register+0x26>
  s_command.NbData             = (Mode == MX25LM51245G_SPI_MODE) ? 1U : ((Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U);
 807b6d0:	2301      	movs	r3, #1
 807b6d2:	e7e7      	b.n	807b6a4 <MX25LM51245G_WriteCfg2Register+0x8a>

0807b6d4 <MX25LM51245G_ReadCfg2Register>:
  * @param  Value configuration register 2 value pointer
  * @retval error status
  */
int32_t MX25LM51245G_ReadCfg2Register(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                      MX25LM51245G_Transfer_t Rate, uint32_t ReadAddr, uint8_t *Value)
{
 807b6d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b6d6:	460c      	mov	r4, r1
 807b6d8:	b095      	sub	sp, #84	; 0x54
 807b6da:	4606      	mov	r6, r0
 807b6dc:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b6de:	2100      	movs	r1, #0
 807b6e0:	2250      	movs	r2, #80	; 0x50
 807b6e2:	4668      	mov	r0, sp
{
 807b6e4:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b6e6:	f001 fe61 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b6ea:	b92c      	cbnz	r4, 807b6f8 <MX25LM51245G_ReadCfg2Register+0x24>
 807b6ec:	2d01      	cmp	r5, #1
 807b6ee:	d154      	bne.n	807b79a <MX25LM51245G_ReadCfg2Register+0xc6>
  {
    return MX25LM51245G_ERROR;
 807b6f0:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b6f4:	b015      	add	sp, #84	; 0x54
 807b6f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b6f8:	2204      	movs	r2, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b6fa:	2d01      	cmp	r5, #1
 807b6fc:	bf0c      	ite	eq
 807b6fe:	2308      	moveq	r3, #8
 807b700:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b702:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b704:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b706:	bf0c      	ite	eq
 807b708:	2300      	moveq	r3, #0
 807b70a:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b70c:	9304      	str	r3, [sp, #16]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 807b70e:	bf0c      	ite	eq
 807b710:	f44f 7380 	moveq.w	r3, #256	; 0x100
 807b714:	f44f 6380 	movne.w	r3, #1024	; 0x400
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b718:	9203      	str	r2, [sp, #12]
                                 : MX25LM51245G_OCTA_READ_CFG_REG2_CMD;
 807b71a:	f247 128e 	movw	r2, #29070	; 0x718e
 807b71e:	bf08      	it	eq
 807b720:	2271      	moveq	r2, #113	; 0x71
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b722:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_1_LINE : HAL_OSPI_ADDRESS_8_LINES;
 807b724:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b726:	bf0c      	ite	eq
 807b728:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b72c:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b72e:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b730:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b734:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b736:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b738:	bf0c      	ite	eq
 807b73a:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b73e:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b742:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b744:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b746:	bf0c      	ite	eq
 807b748:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 807b74c:	2300      	movne	r3, #0
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b74e:	9202      	str	r2, [sp, #8]
  s_command.Address            = ReadAddr;
 807b750:	9706      	str	r7, [sp, #24]
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b752:	9310      	str	r3, [sp, #64]	; 0x40
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 807b754:	b11c      	cbz	r4, 807b75e <MX25LM51245G_ReadCfg2Register+0x8a>
 807b756:	2d01      	cmp	r5, #1
 807b758:	bf0c      	ite	eq
 807b75a:	2405      	moveq	r4, #5
 807b75c:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 807b75e:	2d01      	cmp	r5, #1
 807b760:	bf0c      	ite	eq
 807b762:	2302      	moveq	r3, #2
 807b764:	2301      	movne	r3, #1
 807b766:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b768:	bf0c      	ite	eq
 807b76a:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 807b76e:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b770:	f241 3288 	movw	r2, #5000	; 0x1388
 807b774:	4669      	mov	r1, sp
 807b776:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 807b778:	9411      	str	r4, [sp, #68]	; 0x44
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b77a:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b77c:	f001 f89e 	bl	807c8bc <HAL_OSPI_Command>
 807b780:	2800      	cmp	r0, #0
 807b782:	d1b5      	bne.n	807b6f0 <MX25LM51245G_ReadCfg2Register+0x1c>
  if (HAL_OSPI_Receive(Ctx, Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b784:	f241 3288 	movw	r2, #5000	; 0x1388
 807b788:	991a      	ldr	r1, [sp, #104]	; 0x68
 807b78a:	4630      	mov	r0, r6
 807b78c:	f001 f929 	bl	807c9e2 <HAL_OSPI_Receive>
 807b790:	3000      	adds	r0, #0
 807b792:	bf18      	it	ne
 807b794:	2001      	movne	r0, #1
 807b796:	4240      	negs	r0, r0
 807b798:	e7ac      	b.n	807b6f4 <MX25LM51245G_ReadCfg2Register+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b79a:	2201      	movs	r2, #1
 807b79c:	e7ad      	b.n	807b6fa <MX25LM51245G_ReadCfg2Register+0x26>

0807b79e <MX25LM51245G_ReadSecurityRegister>:
  * @param  Value Security register value pointer
  * @retval error status
  */
int32_t MX25LM51245G_ReadSecurityRegister(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode,
                                          MX25LM51245G_Transfer_t Rate, uint8_t *Value)
{
 807b79e:	b5f0      	push	{r4, r5, r6, r7, lr}
 807b7a0:	460c      	mov	r4, r1
 807b7a2:	b095      	sub	sp, #84	; 0x54
 807b7a4:	4606      	mov	r6, r0
 807b7a6:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b7a8:	2100      	movs	r1, #0
 807b7aa:	2250      	movs	r2, #80	; 0x50
 807b7ac:	4668      	mov	r0, sp
{
 807b7ae:	461f      	mov	r7, r3
  OSPI_RegularCmdTypeDef s_command = {0};
 807b7b0:	f001 fdfc 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b7b4:	b92c      	cbnz	r4, 807b7c2 <MX25LM51245G_ReadSecurityRegister+0x24>
 807b7b6:	2d01      	cmp	r5, #1
 807b7b8:	d152      	bne.n	807b860 <MX25LM51245G_ReadSecurityRegister+0xc2>
  {
    return MX25LM51245G_ERROR;
 807b7ba:	f04f 30ff 	mov.w	r0, #4294967295
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b7be:	b015      	add	sp, #84	; 0x54
 807b7c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b7c2:	2304      	movs	r3, #4
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b7c4:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b7c6:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b7c8:	bf0c      	ite	eq
 807b7ca:	2308      	moveq	r3, #8
 807b7cc:	2300      	movne	r3, #0
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b7ce:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b7d0:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b7d2:	bf0c      	ite	eq
 807b7d4:	2300      	moveq	r3, #0
 807b7d6:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b7d8:	9304      	str	r3, [sp, #16]
                                 : MX25LM51245G_OCTA_READ_SECURITY_REG_CMD;
 807b7da:	f642 33d4 	movw	r3, #11220	; 0x2bd4
 807b7de:	bf08      	it	eq
 807b7e0:	232b      	moveq	r3, #43	; 0x2b
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b7e2:	9302      	str	r3, [sp, #8]
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b7e4:	bf0c      	ite	eq
 807b7e6:	2300      	moveq	r3, #0
 807b7e8:	f44f 6380 	movne.w	r3, #1024	; 0x400
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b7ec:	2d01      	cmp	r5, #1
  s_command.AddressMode        = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_ADDRESS_NONE : HAL_OSPI_ADDRESS_8_LINES;
 807b7ee:	9307      	str	r3, [sp, #28]
                                 : HAL_OSPI_ADDRESS_DTR_DISABLE;
 807b7f0:	bf0c      	ite	eq
 807b7f2:	f44f 6300 	moveq.w	r3, #2048	; 0x800
 807b7f6:	2300      	movne	r3, #0
  s_command.AddressDtrMode     = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b7f8:	9309      	str	r3, [sp, #36]	; 0x24
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b7fa:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b7fe:	2c00      	cmp	r4, #0
  s_command.AddressSize        = HAL_OSPI_ADDRESS_32_BITS;
 807b800:	9308      	str	r3, [sp, #32]
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b802:	bf0c      	ite	eq
 807b804:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807b808:	f04f 6380 	movne.w	r3, #67108864	; 0x4000000
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b80c:	2d01      	cmp	r5, #1
  s_command.DataMode           = (Mode == MX25LM51245G_SPI_MODE) ? HAL_OSPI_DATA_1_LINE : HAL_OSPI_DATA_8_LINES;
 807b80e:	930e      	str	r3, [sp, #56]	; 0x38
                                 : HAL_OSPI_DATA_DTR_DISABLE;
 807b810:	bf0c      	ite	eq
 807b812:	f04f 6300 	moveq.w	r3, #134217728	; 0x8000000
 807b816:	2300      	movne	r3, #0
  s_command.DataDtrMode        = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b818:	9310      	str	r3, [sp, #64]	; 0x40
                                 : ((Rate == MX25LM51245G_DTR_TRANSFER)
 807b81a:	b11c      	cbz	r4, 807b824 <MX25LM51245G_ReadSecurityRegister+0x86>
 807b81c:	2d01      	cmp	r5, #1
 807b81e:	bf0c      	ite	eq
 807b820:	2405      	moveq	r4, #5
 807b822:	2404      	movne	r4, #4
  s_command.NbData             = (Rate == MX25LM51245G_DTR_TRANSFER) ? 2U : 1U;
 807b824:	2d01      	cmp	r5, #1
 807b826:	bf0c      	ite	eq
 807b828:	2302      	moveq	r3, #2
 807b82a:	2301      	movne	r3, #1
 807b82c:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b82e:	bf0c      	ite	eq
 807b830:	f04f 5300 	moveq.w	r3, #536870912	; 0x20000000
 807b834:	2300      	movne	r3, #0
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b836:	f241 3288 	movw	r2, #5000	; 0x1388
 807b83a:	4669      	mov	r1, sp
 807b83c:	4630      	mov	r0, r6
  s_command.DummyCycles        = (Mode == MX25LM51245G_SPI_MODE)
 807b83e:	9411      	str	r4, [sp, #68]	; 0x44
  s_command.DQSMode            = (Rate == MX25LM51245G_DTR_TRANSFER) ? HAL_OSPI_DQS_ENABLE : HAL_OSPI_DQS_DISABLE;
 807b840:	9312      	str	r3, [sp, #72]	; 0x48
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b842:	f001 f83b 	bl	807c8bc <HAL_OSPI_Command>
 807b846:	2800      	cmp	r0, #0
 807b848:	d1b7      	bne.n	807b7ba <MX25LM51245G_ReadSecurityRegister+0x1c>
  if (HAL_OSPI_Receive(Ctx, Value, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b84a:	f241 3288 	movw	r2, #5000	; 0x1388
 807b84e:	4639      	mov	r1, r7
 807b850:	4630      	mov	r0, r6
 807b852:	f001 f8c6 	bl	807c9e2 <HAL_OSPI_Receive>
 807b856:	3000      	adds	r0, #0
 807b858:	bf18      	it	ne
 807b85a:	2001      	movne	r0, #1
 807b85c:	4240      	negs	r0, r0
 807b85e:	e7ae      	b.n	807b7be <MX25LM51245G_ReadSecurityRegister+0x20>
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b860:	2301      	movs	r3, #1
 807b862:	e7af      	b.n	807b7c4 <MX25LM51245G_ReadSecurityRegister+0x26>

0807b864 <MX25LM51245G_ResetEnable>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25LM51245G_ResetEnable(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate)
{
 807b864:	b570      	push	{r4, r5, r6, lr}
 807b866:	460c      	mov	r4, r1
 807b868:	b094      	sub	sp, #80	; 0x50
 807b86a:	4606      	mov	r6, r0
 807b86c:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b86e:	2100      	movs	r1, #0
 807b870:	2250      	movs	r2, #80	; 0x50
 807b872:	4668      	mov	r0, sp
 807b874:	f001 fd9a 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b878:	b9f4      	cbnz	r4, 807b8b8 <MX25LM51245G_ResetEnable+0x54>
 807b87a:	2d01      	cmp	r5, #1
 807b87c:	d01e      	beq.n	807b8bc <MX25LM51245G_ResetEnable+0x58>
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_1_LINE
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b87e:	2301      	movs	r3, #1
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b880:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b882:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b884:	bf0c      	ite	eq
 807b886:	2308      	moveq	r3, #8
 807b888:	2300      	movne	r3, #0
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_8_BITS
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b88a:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b88c:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b88e:	bf0c      	ite	eq
 807b890:	2300      	moveq	r3, #0
 807b892:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b894:	9304      	str	r3, [sp, #16]
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
                                 ? MX25LM51245G_RESET_ENABLE_CMD
                                 : MX25LM51245G_OCTA_RESET_ENABLE_CMD;
 807b896:	f246 6399 	movw	r3, #26265	; 0x6699
 807b89a:	bf08      	it	eq
 807b89c:	2366      	moveq	r3, #102	; 0x66
  s_command.DummyCycles        = 0U;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b89e:	f241 3288 	movw	r2, #5000	; 0x1388
 807b8a2:	4669      	mov	r1, sp
 807b8a4:	4630      	mov	r0, r6
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b8a6:	9302      	str	r3, [sp, #8]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b8a8:	f001 f808 	bl	807c8bc <HAL_OSPI_Command>
 807b8ac:	3000      	adds	r0, #0
 807b8ae:	bf18      	it	ne
 807b8b0:	2001      	movne	r0, #1
 807b8b2:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b8b4:	b014      	add	sp, #80	; 0x50
 807b8b6:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b8b8:	2304      	movs	r3, #4
 807b8ba:	e7e1      	b.n	807b880 <MX25LM51245G_ResetEnable+0x1c>
    return MX25LM51245G_ERROR;
 807b8bc:	f04f 30ff 	mov.w	r0, #4294967295
 807b8c0:	e7f8      	b.n	807b8b4 <MX25LM51245G_ResetEnable+0x50>

0807b8c2 <MX25LM51245G_ResetMemory>:
  * @param  Mode Interface select
  * @param  Rate Transfer rate STR or DTR
  * @retval error status
  */
int32_t MX25LM51245G_ResetMemory(OSPI_HandleTypeDef *Ctx, MX25LM51245G_Interface_t Mode, MX25LM51245G_Transfer_t Rate)
{
 807b8c2:	b570      	push	{r4, r5, r6, lr}
 807b8c4:	460c      	mov	r4, r1
 807b8c6:	b094      	sub	sp, #80	; 0x50
 807b8c8:	4606      	mov	r6, r0
 807b8ca:	4615      	mov	r5, r2
  OSPI_RegularCmdTypeDef s_command = {0};
 807b8cc:	2100      	movs	r1, #0
 807b8ce:	2250      	movs	r2, #80	; 0x50
 807b8d0:	4668      	mov	r0, sp
 807b8d2:	f001 fd6b 	bl	807d3ac <memset>

  /* SPI mode and DTR transfer not supported by memory */
  if ((Mode == MX25LM51245G_SPI_MODE) && (Rate == MX25LM51245G_DTR_TRANSFER))
 807b8d6:	b9f4      	cbnz	r4, 807b916 <MX25LM51245G_ResetMemory+0x54>
 807b8d8:	2d01      	cmp	r5, #1
 807b8da:	d01e      	beq.n	807b91a <MX25LM51245G_ResetMemory+0x58>
#else
  s_command.FlashId            = HAL_OSPI_FLASH_ID_1;
#endif /* defined (OCTOSPI_CR_MSEL) */
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_1_LINE
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b8dc:	2301      	movs	r3, #1
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
                                 ? HAL_OSPI_INSTRUCTION_DTR_ENABLE
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b8de:	2d01      	cmp	r5, #1
  s_command.InstructionMode    = (Mode == MX25LM51245G_SPI_MODE)
 807b8e0:	9303      	str	r3, [sp, #12]
                                 : HAL_OSPI_INSTRUCTION_DTR_DISABLE;
 807b8e2:	bf0c      	ite	eq
 807b8e4:	2308      	moveq	r3, #8
 807b8e6:	2300      	movne	r3, #0
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
                                 ? HAL_OSPI_INSTRUCTION_8_BITS
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b8e8:	2c00      	cmp	r4, #0
  s_command.InstructionDtrMode = (Rate == MX25LM51245G_DTR_TRANSFER)
 807b8ea:	9305      	str	r3, [sp, #20]
                                 : HAL_OSPI_INSTRUCTION_16_BITS;
 807b8ec:	bf0c      	ite	eq
 807b8ee:	2300      	moveq	r3, #0
 807b8f0:	2310      	movne	r3, #16
  s_command.InstructionSize    = (Mode == MX25LM51245G_SPI_MODE)
 807b8f2:	9304      	str	r3, [sp, #16]
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
                                 ? MX25LM51245G_RESET_MEMORY_CMD
                                 : MX25LM51245G_OCTA_RESET_MEMORY_CMD;
 807b8f4:	f649 1366 	movw	r3, #39270	; 0x9966
 807b8f8:	bf08      	it	eq
 807b8fa:	2399      	moveq	r3, #153	; 0x99
  s_command.DummyCycles        = 0U;
  s_command.DQSMode            = HAL_OSPI_DQS_DISABLE;
  s_command.SIOOMode           = HAL_OSPI_SIOO_INST_EVERY_CMD;

  /* Send the command */
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b8fc:	f241 3288 	movw	r2, #5000	; 0x1388
 807b900:	4669      	mov	r1, sp
 807b902:	4630      	mov	r0, r6
  s_command.Instruction        = (Mode == MX25LM51245G_SPI_MODE)
 807b904:	9302      	str	r3, [sp, #8]
  if (HAL_OSPI_Command(Ctx, &s_command, HAL_OSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 807b906:	f000 ffd9 	bl	807c8bc <HAL_OSPI_Command>
 807b90a:	3000      	adds	r0, #0
 807b90c:	bf18      	it	ne
 807b90e:	2001      	movne	r0, #1
 807b910:	4240      	negs	r0, r0
  {
    return MX25LM51245G_ERROR;
  }

  return MX25LM51245G_OK;
}
 807b912:	b014      	add	sp, #80	; 0x50
 807b914:	bd70      	pop	{r4, r5, r6, pc}
                                 : HAL_OSPI_INSTRUCTION_8_LINES;
 807b916:	2304      	movs	r3, #4
 807b918:	e7e1      	b.n	807b8de <MX25LM51245G_ResetMemory+0x1c>
    return MX25LM51245G_ERROR;
 807b91a:	f04f 30ff 	mov.w	r0, #4294967295
 807b91e:	e7f8      	b.n	807b912 <MX25LM51245G_ResetMemory+0x50>

0807b920 <OSPI_NOR_EnterSOPIMode.constprop.4>:
/**
  * @brief  This function enables the octal STR mode of the memory.
  * @param  Instance  OSPI instance
  * @retval BSP status
  */
static int32_t OSPI_NOR_EnterSOPIMode(uint32_t Instance)
 807b920:	b530      	push	{r4, r5, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  /* Enable write operations */
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807b922:	4c21      	ldr	r4, [pc, #132]	; (807b9a8 <OSPI_NOR_EnterSOPIMode.constprop.4+0x88>)
static int32_t OSPI_NOR_EnterSOPIMode(uint32_t Instance)
 807b924:	b085      	sub	sp, #20
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807b926:	78a2      	ldrb	r2, [r4, #2]
 807b928:	7861      	ldrb	r1, [r4, #1]
 807b92a:	4820      	ldr	r0, [pc, #128]	; (807b9ac <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 807b92c:	f7ff fd93 	bl	807b456 <MX25LM51245G_WriteEnable>
 807b930:	b118      	cbz	r0, 807b93a <OSPI_NOR_EnterSOPIMode.constprop.4+0x1a>
  {
    ret = BSP_ERROR_COMPONENT_FAILURE;
 807b932:	f06f 0004 	mvn.w	r0, #4
    }
  }

  /* Return BSP status */
  return ret;
}
 807b936:	b005      	add	sp, #20
 807b938:	bd30      	pop	{r4, r5, pc}
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG3_ADDR, MX25LM51245G_CR2_DC_6_CYCLES) != MX25LM51245G_OK)
 807b93a:	2307      	movs	r3, #7
 807b93c:	78a2      	ldrb	r2, [r4, #2]
 807b93e:	7861      	ldrb	r1, [r4, #1]
 807b940:	481a      	ldr	r0, [pc, #104]	; (807b9ac <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 807b942:	9300      	str	r3, [sp, #0]
 807b944:	f44f 7340 	mov.w	r3, #768	; 0x300
 807b948:	f7ff fe67 	bl	807b61a <MX25LM51245G_WriteCfg2Register>
 807b94c:	2800      	cmp	r0, #0
 807b94e:	d1f0      	bne.n	807b932 <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807b950:	78a2      	ldrb	r2, [r4, #2]
 807b952:	7861      	ldrb	r1, [r4, #1]
 807b954:	4815      	ldr	r0, [pc, #84]	; (807b9ac <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 807b956:	f7ff fd7e 	bl	807b456 <MX25LM51245G_WriteEnable>
 807b95a:	4603      	mov	r3, r0
 807b95c:	2800      	cmp	r0, #0
 807b95e:	d1e8      	bne.n	807b932 <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, MX25LM51245G_CR2_SOPI) != MX25LM51245G_OK)
 807b960:	78a2      	ldrb	r2, [r4, #2]
 807b962:	7861      	ldrb	r1, [r4, #1]
 807b964:	2401      	movs	r4, #1
 807b966:	4811      	ldr	r0, [pc, #68]	; (807b9ac <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 807b968:	9400      	str	r4, [sp, #0]
 807b96a:	f7ff fe56 	bl	807b61a <MX25LM51245G_WriteCfg2Register>
 807b96e:	4605      	mov	r5, r0
 807b970:	2800      	cmp	r0, #0
 807b972:	d1de      	bne.n	807b932 <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
    HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
 807b974:	2028      	movs	r0, #40	; 0x28
 807b976:	f000 fba3 	bl	807c0c0 <HAL_Delay>
    if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 807b97a:	462a      	mov	r2, r5
 807b97c:	4621      	mov	r1, r4
 807b97e:	480b      	ldr	r0, [pc, #44]	; (807b9ac <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 807b980:	f7ff fb77 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807b984:	4603      	mov	r3, r0
 807b986:	2800      	cmp	r0, #0
 807b988:	d1d3      	bne.n	807b932 <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
    else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
 807b98a:	aa03      	add	r2, sp, #12
 807b98c:	9200      	str	r2, [sp, #0]
 807b98e:	4621      	mov	r1, r4
 807b990:	4602      	mov	r2, r0
 807b992:	4806      	ldr	r0, [pc, #24]	; (807b9ac <OSPI_NOR_EnterSOPIMode.constprop.4+0x8c>)
 807b994:	f7ff fe9e 	bl	807b6d4 <MX25LM51245G_ReadCfg2Register>
 807b998:	2800      	cmp	r0, #0
 807b99a:	d1ca      	bne.n	807b932 <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
    else if (reg[0] != MX25LM51245G_CR2_SOPI)
 807b99c:	f89d 300c 	ldrb.w	r3, [sp, #12]
 807b9a0:	42a3      	cmp	r3, r4
 807b9a2:	d0c8      	beq.n	807b936 <OSPI_NOR_EnterSOPIMode.constprop.4+0x16>
 807b9a4:	e7c5      	b.n	807b932 <OSPI_NOR_EnterSOPIMode.constprop.4+0x12>
 807b9a6:	bf00      	nop
 807b9a8:	20000592 	.word	0x20000592
 807b9ac:	20000598 	.word	0x20000598

0807b9b0 <OSPI_NOR_EnterDOPIMode.constprop.5>:
static int32_t OSPI_NOR_EnterDOPIMode(uint32_t Instance)
 807b9b0:	b530      	push	{r4, r5, lr}
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807b9b2:	4d27      	ldr	r5, [pc, #156]	; (807ba50 <OSPI_NOR_EnterDOPIMode.constprop.5+0xa0>)
 807b9b4:	4c27      	ldr	r4, [pc, #156]	; (807ba54 <OSPI_NOR_EnterDOPIMode.constprop.5+0xa4>)
static int32_t OSPI_NOR_EnterDOPIMode(uint32_t Instance)
 807b9b6:	b085      	sub	sp, #20
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807b9b8:	78aa      	ldrb	r2, [r5, #2]
 807b9ba:	7869      	ldrb	r1, [r5, #1]
 807b9bc:	4620      	mov	r0, r4
 807b9be:	f7ff fd4a 	bl	807b456 <MX25LM51245G_WriteEnable>
 807b9c2:	b118      	cbz	r0, 807b9cc <OSPI_NOR_EnterDOPIMode.constprop.5+0x1c>
    ret = BSP_ERROR_COMPONENT_FAILURE;
 807b9c4:	f06f 0004 	mvn.w	r0, #4
}
 807b9c8:	b005      	add	sp, #20
 807b9ca:	bd30      	pop	{r4, r5, pc}
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG3_ADDR, MX25LM51245G_CR2_DC_6_CYCLES) != MX25LM51245G_OK)
 807b9cc:	2307      	movs	r3, #7
 807b9ce:	78aa      	ldrb	r2, [r5, #2]
 807b9d0:	9300      	str	r3, [sp, #0]
 807b9d2:	7869      	ldrb	r1, [r5, #1]
 807b9d4:	f44f 7340 	mov.w	r3, #768	; 0x300
 807b9d8:	4620      	mov	r0, r4
 807b9da:	f7ff fe1e 	bl	807b61a <MX25LM51245G_WriteCfg2Register>
 807b9de:	2800      	cmp	r0, #0
 807b9e0:	d1f0      	bne.n	807b9c4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807b9e2:	78aa      	ldrb	r2, [r5, #2]
 807b9e4:	7869      	ldrb	r1, [r5, #1]
 807b9e6:	4620      	mov	r0, r4
 807b9e8:	f7ff fd35 	bl	807b456 <MX25LM51245G_WriteEnable>
 807b9ec:	4603      	mov	r3, r0
 807b9ee:	2800      	cmp	r0, #0
 807b9f0:	d1e8      	bne.n	807b9c4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
  else if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, MX25LM51245G_CR2_DOPI) != MX25LM51245G_OK)
 807b9f2:	2002      	movs	r0, #2
 807b9f4:	78aa      	ldrb	r2, [r5, #2]
 807b9f6:	9000      	str	r0, [sp, #0]
 807b9f8:	7869      	ldrb	r1, [r5, #1]
 807b9fa:	4620      	mov	r0, r4
 807b9fc:	f7ff fe0d 	bl	807b61a <MX25LM51245G_WriteCfg2Register>
 807ba00:	2800      	cmp	r0, #0
 807ba02:	d1df      	bne.n	807b9c4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
    HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
 807ba04:	2028      	movs	r0, #40	; 0x28
 807ba06:	f000 fb5b 	bl	807c0c0 <HAL_Delay>
    hospi_nor[Instance].Init.MemoryType            = HAL_OSPI_MEMTYPE_MACRONIX;
 807ba0a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 807ba0e:	60e3      	str	r3, [r4, #12]
    hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 807ba10:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 807ba14:	4620      	mov	r0, r4
    hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 807ba16:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 807ba18:	f000 fecc 	bl	807c7b4 <HAL_OSPI_Init>
 807ba1c:	b9a8      	cbnz	r0, 807ba4a <OSPI_NOR_EnterDOPIMode.constprop.5+0x9a>
    else if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
 807ba1e:	2201      	movs	r2, #1
 807ba20:	4620      	mov	r0, r4
 807ba22:	4611      	mov	r1, r2
 807ba24:	f7ff fb25 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807ba28:	4603      	mov	r3, r0
 807ba2a:	2800      	cmp	r0, #0
 807ba2c:	d1ca      	bne.n	807b9c4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
    else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
 807ba2e:	aa03      	add	r2, sp, #12
 807ba30:	9200      	str	r2, [sp, #0]
 807ba32:	2201      	movs	r2, #1
 807ba34:	4620      	mov	r0, r4
 807ba36:	4611      	mov	r1, r2
 807ba38:	f7ff fe4c 	bl	807b6d4 <MX25LM51245G_ReadCfg2Register>
 807ba3c:	2800      	cmp	r0, #0
 807ba3e:	d1c1      	bne.n	807b9c4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
    else if (reg[0] != MX25LM51245G_CR2_DOPI)
 807ba40:	f89d 300c 	ldrb.w	r3, [sp, #12]
 807ba44:	2b02      	cmp	r3, #2
 807ba46:	d0bf      	beq.n	807b9c8 <OSPI_NOR_EnterDOPIMode.constprop.5+0x18>
 807ba48:	e7bc      	b.n	807b9c4 <OSPI_NOR_EnterDOPIMode.constprop.5+0x14>
      ret = BSP_ERROR_PERIPH_FAILURE;
 807ba4a:	f06f 0003 	mvn.w	r0, #3
 807ba4e:	e7bb      	b.n	807b9c8 <OSPI_NOR_EnterDOPIMode.constprop.5+0x18>
 807ba50:	20000592 	.word	0x20000592
 807ba54:	20000598 	.word	0x20000598

0807ba58 <MX_OSPI_NOR_Init>:
  hospi->Init.FifoThreshold      = 4;
 807ba58:	2304      	movs	r3, #4
 807ba5a:	4a0e      	ldr	r2, [pc, #56]	; (807ba94 <MX_OSPI_NOR_Init+0x3c>)
 807ba5c:	e9c0 2300 	strd	r2, r3, [r0]
  hospi->Init.DeviceSize         = Init->MemorySize; /* 512 MBits */
 807ba60:	680a      	ldr	r2, [r1, #0]
  hospi->Init.DualQuad           = HAL_OSPI_DUALQUAD_DISABLE;
 807ba62:	2300      	movs	r3, #0
  hospi->Init.DeviceSize         = Init->MemorySize; /* 512 MBits */
 807ba64:	6102      	str	r2, [r0, #16]
  hospi->Init.ChipSelectHighTime = 2;
 807ba66:	2202      	movs	r2, #2
  hospi->Init.FreeRunningClock   = HAL_OSPI_FREERUNCLK_DISABLE;
 807ba68:	e9c0 2305 	strd	r2, r3, [r0, #20]
  hospi->Init.ClockPrescaler     = Init->ClockPrescaler;
 807ba6c:	684a      	ldr	r2, [r1, #4]
  hospi->Init.DualQuad           = HAL_OSPI_DUALQUAD_DISABLE;
 807ba6e:	6083      	str	r3, [r0, #8]
  hospi->Init.ClockPrescaler     = Init->ClockPrescaler;
 807ba70:	6242      	str	r2, [r0, #36]	; 0x24
  hospi->Init.SampleShifting     = Init->SampleShifting;
 807ba72:	688a      	ldr	r2, [r1, #8]
  hospi->Init.WrapSize           = HAL_OSPI_WRAP_NOT_SUPPORTED;
 807ba74:	e9c0 3307 	strd	r3, r3, [r0, #28]
  hospi->Init.SampleShifting     = Init->SampleShifting;
 807ba78:	6282      	str	r2, [r0, #40]	; 0x28
  if (Init->TransferRate == (uint32_t) BSP_OSPI_NOR_DTR_TRANSFER)
 807ba7a:	68ca      	ldr	r2, [r1, #12]
  hospi->Init.ChipSelectBoundary = 0;
 807ba7c:	6303      	str	r3, [r0, #48]	; 0x30
  if (Init->TransferRate == (uint32_t) BSP_OSPI_NOR_DTR_TRANSFER)
 807ba7e:	2a01      	cmp	r2, #1
    hospi->Init.MemoryType            = HAL_OSPI_MEMTYPE_MACRONIX;
 807ba80:	bf03      	ittte	eq
 807ba82:	f04f 7380 	moveq.w	r3, #16777216	; 0x1000000
 807ba86:	60c3      	streq	r3, [r0, #12]
    hospi->Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_ENABLE;
 807ba88:	f04f 5380 	moveq.w	r3, #268435456	; 0x10000000
    hospi->Init.MemoryType            = HAL_OSPI_MEMTYPE_MICRON;
 807ba8c:	60c3      	strne	r3, [r0, #12]
    hospi->Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
 807ba8e:	62c3      	str	r3, [r0, #44]	; 0x2c
  return HAL_OSPI_Init(hospi);
 807ba90:	f000 be90 	b.w	807c7b4 <HAL_OSPI_Init>
 807ba94:	44021000 	.word	0x44021000

0807ba98 <BSP_OSPI_NOR_Read>:
{
 807ba98:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 807ba9a:	460c      	mov	r4, r1
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807ba9c:	b9a8      	cbnz	r0, 807baca <BSP_OSPI_NOR_Read+0x32>
    if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 807ba9e:	480c      	ldr	r0, [pc, #48]	; (807bad0 <BSP_OSPI_NOR_Read+0x38>)
 807baa0:	7887      	ldrb	r7, [r0, #2]
 807baa2:	b977      	cbnz	r7, 807bac2 <BSP_OSPI_NOR_Read+0x2a>
      if(MX25LM51245G_ReadSTR(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE, pData, ReadAddr, Size) != MX25LM51245G_OK)
 807baa4:	7841      	ldrb	r1, [r0, #1]
 807baa6:	e9cd 2300 	strd	r2, r3, [sp]
 807baaa:	480a      	ldr	r0, [pc, #40]	; (807bad4 <BSP_OSPI_NOR_Read+0x3c>)
 807baac:	4623      	mov	r3, r4
 807baae:	2201      	movs	r2, #1
 807bab0:	f7ff fb4d 	bl	807b14e <MX25LM51245G_ReadSTR>
 807bab4:	b118      	cbz	r0, 807babe <BSP_OSPI_NOR_Read+0x26>
        ret = BSP_ERROR_COMPONENT_FAILURE;
 807bab6:	f06f 0004 	mvn.w	r0, #4
}
 807baba:	b003      	add	sp, #12
 807babc:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ret = BSP_ERROR_NONE;
 807babe:	2000      	movs	r0, #0
 807bac0:	e7fb      	b.n	807baba <BSP_OSPI_NOR_Read+0x22>
      if(MX25LM51245G_ReadDTR(&hospi_nor[Instance], pData, ReadAddr, Size) != MX25LM51245G_OK)
 807bac2:	4804      	ldr	r0, [pc, #16]	; (807bad4 <BSP_OSPI_NOR_Read+0x3c>)
 807bac4:	f7ff fb9b 	bl	807b1fe <MX25LM51245G_ReadDTR>
 807bac8:	e7f4      	b.n	807bab4 <BSP_OSPI_NOR_Read+0x1c>
    ret = BSP_ERROR_WRONG_PARAM;
 807baca:	f06f 0001 	mvn.w	r0, #1
  return ret;
 807bace:	e7f4      	b.n	807baba <BSP_OSPI_NOR_Read+0x22>
 807bad0:	20000592 	.word	0x20000592
 807bad4:	20000598 	.word	0x20000598

0807bad8 <BSP_OSPI_NOR_Write>:
{
 807bad8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 807badc:	4691      	mov	r9, r2
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807bade:	2800      	cmp	r0, #0
 807bae0:	d144      	bne.n	807bb6c <BSP_OSPI_NOR_Write+0x94>
    current_size = MX25LM51245G_PAGE_SIZE - (WriteAddr % MX25LM51245G_PAGE_SIZE);
 807bae2:	b2d4      	uxtb	r4, r2
 807bae4:	f5c4 7480 	rsb	r4, r4, #256	; 0x100
      if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bae8:	4d23      	ldr	r5, [pc, #140]	; (807bb78 <BSP_OSPI_NOR_Write+0xa0>)
 807baea:	429c      	cmp	r4, r3
 807baec:	bf28      	it	cs
 807baee:	461c      	movcs	r4, r3
    data_addr = (uint32_t)pData;
 807baf0:	460f      	mov	r7, r1
 807baf2:	46aa      	mov	sl, r5
      if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807baf4:	f8df 8084 	ldr.w	r8, [pc, #132]	; 807bb7c <BSP_OSPI_NOR_Write+0xa4>
    end_addr = WriteAddr + Size;
 807baf8:	18d6      	adds	r6, r2, r3
      if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bafa:	78aa      	ldrb	r2, [r5, #2]
 807bafc:	7869      	ldrb	r1, [r5, #1]
 807bafe:	4640      	mov	r0, r8
 807bb00:	f7ff fab7 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807bb04:	b120      	cbz	r0, 807bb10 <BSP_OSPI_NOR_Write+0x38>
    ret = BSP_ERROR_WRONG_PARAM;
 807bb06:	f06f 0004 	mvn.w	r0, #4
}
 807bb0a:	b002      	add	sp, #8
 807bb0c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bb10:	78aa      	ldrb	r2, [r5, #2]
 807bb12:	7869      	ldrb	r1, [r5, #1]
 807bb14:	4640      	mov	r0, r8
 807bb16:	f7ff fc9e 	bl	807b456 <MX25LM51245G_WriteEnable>
 807bb1a:	2800      	cmp	r0, #0
 807bb1c:	d1f3      	bne.n	807bb06 <BSP_OSPI_NOR_Write+0x2e>
        if(Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 807bb1e:	78ab      	ldrb	r3, [r5, #2]
 807bb20:	b9eb      	cbnz	r3, 807bb5e <BSP_OSPI_NOR_Write+0x86>
          if(MX25LM51245G_PageProgram(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, MX25LM51245G_4BYTES_SIZE, (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
 807bb22:	7869      	ldrb	r1, [r5, #1]
 807bb24:	e9cd 9400 	strd	r9, r4, [sp]
 807bb28:	463b      	mov	r3, r7
 807bb2a:	2201      	movs	r2, #1
 807bb2c:	4640      	mov	r0, r8
 807bb2e:	f7ff fba6 	bl	807b27e <MX25LM51245G_PageProgram>
          if(MX25LM51245G_PageProgramDTR(&hospi_nor[Instance], (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
 807bb32:	2800      	cmp	r0, #0
 807bb34:	d1e7      	bne.n	807bb06 <BSP_OSPI_NOR_Write+0x2e>
          if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bb36:	f89a 2002 	ldrb.w	r2, [sl, #2]
 807bb3a:	f89a 1001 	ldrb.w	r1, [sl, #1]
 807bb3e:	4640      	mov	r0, r8
 807bb40:	f7ff fa97 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807bb44:	2800      	cmp	r0, #0
 807bb46:	d1de      	bne.n	807bb06 <BSP_OSPI_NOR_Write+0x2e>
            current_addr += current_size;
 807bb48:	44a1      	add	r9, r4
            current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
 807bb4a:	f509 7380 	add.w	r3, r9, #256	; 0x100
 807bb4e:	42b3      	cmp	r3, r6
            data_addr += current_size;
 807bb50:	4427      	add	r7, r4
            current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
 807bb52:	d90e      	bls.n	807bb72 <BSP_OSPI_NOR_Write+0x9a>
 807bb54:	eba6 0409 	sub.w	r4, r6, r9
    } while ((current_addr < end_addr) && (ret == BSP_ERROR_NONE));
 807bb58:	454e      	cmp	r6, r9
 807bb5a:	d8ce      	bhi.n	807bafa <BSP_OSPI_NOR_Write+0x22>
 807bb5c:	e7d5      	b.n	807bb0a <BSP_OSPI_NOR_Write+0x32>
          if(MX25LM51245G_PageProgramDTR(&hospi_nor[Instance], (uint8_t*)data_addr, current_addr, current_size) != MX25LM51245G_OK)
 807bb5e:	4623      	mov	r3, r4
 807bb60:	464a      	mov	r2, r9
 807bb62:	4639      	mov	r1, r7
 807bb64:	4640      	mov	r0, r8
 807bb66:	f7ff fbde 	bl	807b326 <MX25LM51245G_PageProgramDTR>
 807bb6a:	e7e2      	b.n	807bb32 <BSP_OSPI_NOR_Write+0x5a>
    ret = BSP_ERROR_WRONG_PARAM;
 807bb6c:	f06f 0001 	mvn.w	r0, #1
  return ret;
 807bb70:	e7cb      	b.n	807bb0a <BSP_OSPI_NOR_Write+0x32>
            current_size = ((current_addr + MX25LM51245G_PAGE_SIZE) > end_addr) ? (end_addr - current_addr) : MX25LM51245G_PAGE_SIZE;
 807bb72:	f44f 7480 	mov.w	r4, #256	; 0x100
 807bb76:	e7ef      	b.n	807bb58 <BSP_OSPI_NOR_Write+0x80>
 807bb78:	20000592 	.word	0x20000592
 807bb7c:	20000598 	.word	0x20000598

0807bb80 <BSP_OSPI_NOR_Erase_Block>:
{
 807bb80:	b573      	push	{r0, r1, r4, r5, r6, lr}
 807bb82:	460d      	mov	r5, r1
 807bb84:	4616      	mov	r6, r2
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807bb86:	b9e0      	cbnz	r0, 807bbc2 <BSP_OSPI_NOR_Erase_Block+0x42>
    if(MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bb88:	4c0f      	ldr	r4, [pc, #60]	; (807bbc8 <BSP_OSPI_NOR_Erase_Block+0x48>)
 807bb8a:	4810      	ldr	r0, [pc, #64]	; (807bbcc <BSP_OSPI_NOR_Erase_Block+0x4c>)
 807bb8c:	78a2      	ldrb	r2, [r4, #2]
 807bb8e:	7861      	ldrb	r1, [r4, #1]
 807bb90:	f7ff fa6f 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807bb94:	b118      	cbz	r0, 807bb9e <BSP_OSPI_NOR_Erase_Block+0x1e>
      ret = BSP_ERROR_COMPONENT_FAILURE;
 807bb96:	f06f 0004 	mvn.w	r0, #4
}
 807bb9a:	b002      	add	sp, #8
 807bb9c:	bd70      	pop	{r4, r5, r6, pc}
    else if(MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bb9e:	78a2      	ldrb	r2, [r4, #2]
 807bba0:	7861      	ldrb	r1, [r4, #1]
 807bba2:	480a      	ldr	r0, [pc, #40]	; (807bbcc <BSP_OSPI_NOR_Erase_Block+0x4c>)
 807bba4:	f7ff fc57 	bl	807b456 <MX25LM51245G_WriteEnable>
 807bba8:	2800      	cmp	r0, #0
 807bbaa:	d1f4      	bne.n	807bb96 <BSP_OSPI_NOR_Erase_Block+0x16>
    else if(MX25LM51245G_BlockErase(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_4BYTES_SIZE, BlockAddress, BlockSize) != MX25LM51245G_OK)
 807bbac:	78a2      	ldrb	r2, [r4, #2]
 807bbae:	7861      	ldrb	r1, [r4, #1]
 807bbb0:	e9cd 5600 	strd	r5, r6, [sp]
 807bbb4:	2301      	movs	r3, #1
 807bbb6:	4805      	ldr	r0, [pc, #20]	; (807bbcc <BSP_OSPI_NOR_Erase_Block+0x4c>)
 807bbb8:	f7ff fbf0 	bl	807b39c <MX25LM51245G_BlockErase>
 807bbbc:	2800      	cmp	r0, #0
 807bbbe:	d0ec      	beq.n	807bb9a <BSP_OSPI_NOR_Erase_Block+0x1a>
 807bbc0:	e7e9      	b.n	807bb96 <BSP_OSPI_NOR_Erase_Block+0x16>
    ret = BSP_ERROR_WRONG_PARAM;
 807bbc2:	f06f 0001 	mvn.w	r0, #1
  return ret;
 807bbc6:	e7e8      	b.n	807bb9a <BSP_OSPI_NOR_Erase_Block+0x1a>
 807bbc8:	20000592 	.word	0x20000592
 807bbcc:	20000598 	.word	0x20000598

0807bbd0 <BSP_OSPI_NOR_GetStatus>:
{
 807bbd0:	b538      	push	{r3, r4, r5, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807bbd2:	bb08      	cbnz	r0, 807bc18 <BSP_OSPI_NOR_GetStatus+0x48>
    if(MX25LM51245G_ReadSecurityRegister(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, reg) != MX25LM51245G_OK)
 807bbd4:	4d13      	ldr	r5, [pc, #76]	; (807bc24 <BSP_OSPI_NOR_GetStatus+0x54>)
 807bbd6:	4c14      	ldr	r4, [pc, #80]	; (807bc28 <BSP_OSPI_NOR_GetStatus+0x58>)
 807bbd8:	78aa      	ldrb	r2, [r5, #2]
 807bbda:	4623      	mov	r3, r4
 807bbdc:	7869      	ldrb	r1, [r5, #1]
 807bbde:	4813      	ldr	r0, [pc, #76]	; (807bc2c <BSP_OSPI_NOR_GetStatus+0x5c>)
 807bbe0:	f7ff fddd 	bl	807b79e <MX25LM51245G_ReadSecurityRegister>
 807bbe4:	b110      	cbz	r0, 807bbec <BSP_OSPI_NOR_GetStatus+0x1c>
      ret = BSP_ERROR_COMPONENT_FAILURE;
 807bbe6:	f06f 0004 	mvn.w	r0, #4
}
 807bbea:	bd38      	pop	{r3, r4, r5, pc}
    else if ((reg[0] & (MX25LM51245G_SECR_P_FAIL | MX25LM51245G_SECR_E_FAIL)) != 0U)
 807bbec:	7823      	ldrb	r3, [r4, #0]
 807bbee:	f013 0f60 	tst.w	r3, #96	; 0x60
 807bbf2:	d1f8      	bne.n	807bbe6 <BSP_OSPI_NOR_GetStatus+0x16>
    else if ((reg[0] & (MX25LM51245G_SECR_PSB | MX25LM51245G_SECR_ESB)) != 0U)
 807bbf4:	f013 0f0c 	tst.w	r3, #12
 807bbf8:	d111      	bne.n	807bc1e <BSP_OSPI_NOR_GetStatus+0x4e>
    else if(MX25LM51245G_ReadStatusRegister(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, reg) != MX25LM51245G_OK)
 807bbfa:	4623      	mov	r3, r4
 807bbfc:	78aa      	ldrb	r2, [r5, #2]
 807bbfe:	7869      	ldrb	r1, [r5, #1]
 807bc00:	480a      	ldr	r0, [pc, #40]	; (807bc2c <BSP_OSPI_NOR_GetStatus+0x5c>)
 807bc02:	f7ff fca7 	bl	807b554 <MX25LM51245G_ReadStatusRegister>
 807bc06:	2800      	cmp	r0, #0
 807bc08:	d1ed      	bne.n	807bbe6 <BSP_OSPI_NOR_GetStatus+0x16>
    else if ((reg[0] & MX25LM51245G_SR_WIP) != 0U)
 807bc0a:	7823      	ldrb	r3, [r4, #0]
      ret = BSP_ERROR_BUSY;
 807bc0c:	f013 0f01 	tst.w	r3, #1
 807bc10:	bf18      	it	ne
 807bc12:	f06f 0002 	mvnne.w	r0, #2
 807bc16:	e7e8      	b.n	807bbea <BSP_OSPI_NOR_GetStatus+0x1a>
    ret = BSP_ERROR_WRONG_PARAM;
 807bc18:	f06f 0001 	mvn.w	r0, #1
 807bc1c:	e7e5      	b.n	807bbea <BSP_OSPI_NOR_GetStatus+0x1a>
      ret = BSP_ERROR_OSPI_SUSPENDED;
 807bc1e:	f06f 0013 	mvn.w	r0, #19
 807bc22:	e7e2      	b.n	807bbea <BSP_OSPI_NOR_GetStatus+0x1a>
 807bc24:	20000592 	.word	0x20000592
 807bc28:	200005f0 	.word	0x200005f0
 807bc2c:	20000598 	.word	0x20000598

0807bc30 <BSP_OSPI_NOR_DisableMemoryMappedMode>:
{
 807bc30:	b510      	push	{r4, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807bc32:	b950      	cbnz	r0, 807bc4a <BSP_OSPI_NOR_DisableMemoryMappedMode+0x1a>
    if(Ospi_Nor_Ctx[Instance].IsInitialized != OSPI_ACCESS_MMP)
 807bc34:	4c09      	ldr	r4, [pc, #36]	; (807bc5c <BSP_OSPI_NOR_DisableMemoryMappedMode+0x2c>)
 807bc36:	7823      	ldrb	r3, [r4, #0]
 807bc38:	2b02      	cmp	r3, #2
 807bc3a:	d109      	bne.n	807bc50 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x20>
    else if(HAL_OSPI_Abort(&hospi_nor[Instance]) != HAL_OK)
 807bc3c:	4808      	ldr	r0, [pc, #32]	; (807bc60 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x30>)
 807bc3e:	f000 ff78 	bl	807cb32 <HAL_OSPI_Abort>
 807bc42:	b940      	cbnz	r0, 807bc56 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x26>
      Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
 807bc44:	2301      	movs	r3, #1
 807bc46:	7023      	strb	r3, [r4, #0]
}
 807bc48:	bd10      	pop	{r4, pc}
    ret = BSP_ERROR_WRONG_PARAM;
 807bc4a:	f06f 0001 	mvn.w	r0, #1
 807bc4e:	e7fb      	b.n	807bc48 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x18>
      ret = BSP_ERROR_OSPI_MMP_UNLOCK_FAILURE;
 807bc50:	f06f 0014 	mvn.w	r0, #20
 807bc54:	e7f8      	b.n	807bc48 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x18>
      ret = BSP_ERROR_PERIPH_FAILURE;
 807bc56:	f06f 0003 	mvn.w	r0, #3
  return ret;
 807bc5a:	e7f5      	b.n	807bc48 <BSP_OSPI_NOR_DisableMemoryMappedMode+0x18>
 807bc5c:	20000592 	.word	0x20000592
 807bc60:	20000598 	.word	0x20000598

0807bc64 <BSP_OSPI_NOR_DeInit>:
{
 807bc64:	b510      	push	{r4, lr}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807bc66:	2800      	cmp	r0, #0
 807bc68:	d152      	bne.n	807bd10 <BSP_OSPI_NOR_DeInit+0xac>
    if (Ospi_Nor_Ctx[Instance].IsInitialized != OSPI_ACCESS_NONE)
 807bc6a:	4c2b      	ldr	r4, [pc, #172]	; (807bd18 <BSP_OSPI_NOR_DeInit+0xb4>)
 807bc6c:	7823      	ldrb	r3, [r4, #0]
 807bc6e:	b90b      	cbnz	r3, 807bc74 <BSP_OSPI_NOR_DeInit+0x10>
  int32_t ret = BSP_ERROR_NONE;
 807bc70:	2000      	movs	r0, #0
}
 807bc72:	bd10      	pop	{r4, pc}
      if(Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_MMP)
 807bc74:	2b02      	cmp	r3, #2
 807bc76:	d044      	beq.n	807bd02 <BSP_OSPI_NOR_DeInit+0x9e>
      Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_NONE;
 807bc78:	2300      	movs	r3, #0
  HAL_GPIO_DeInit(OSPI_CLK_GPIO_PORT, OSPI_CLK_PIN);
 807bc7a:	2108      	movs	r1, #8
 807bc7c:	4827      	ldr	r0, [pc, #156]	; (807bd1c <BSP_OSPI_NOR_DeInit+0xb8>)
      Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_NONE;
 807bc7e:	7023      	strb	r3, [r4, #0]
      Ospi_Nor_Ctx[Instance].InterfaceMode = BSP_OSPI_NOR_SPI_MODE;
 807bc80:	7063      	strb	r3, [r4, #1]
      Ospi_Nor_Ctx[Instance].TransferRate  = BSP_OSPI_NOR_STR_TRANSFER;
 807bc82:	70a3      	strb	r3, [r4, #2]
  HAL_GPIO_DeInit(OSPI_CLK_GPIO_PORT, OSPI_CLK_PIN);
 807bc84:	f000 fc0a 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_DQS_GPIO_PORT, OSPI_DQS_PIN);
 807bc88:	2104      	movs	r1, #4
 807bc8a:	4825      	ldr	r0, [pc, #148]	; (807bd20 <BSP_OSPI_NOR_DeInit+0xbc>)
 807bc8c:	f000 fc06 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_CS_GPIO_PORT, OSPI_CS_PIN);
 807bc90:	2104      	movs	r1, #4
 807bc92:	4822      	ldr	r0, [pc, #136]	; (807bd1c <BSP_OSPI_NOR_DeInit+0xb8>)
 807bc94:	f000 fc02 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D0_GPIO_PORT, OSPI_D0_PIN);
 807bc98:	2102      	movs	r1, #2
 807bc9a:	4821      	ldr	r0, [pc, #132]	; (807bd20 <BSP_OSPI_NOR_DeInit+0xbc>)
 807bc9c:	f000 fbfe 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D1_GPIO_PORT, OSPI_D1_PIN);
 807bca0:	2101      	movs	r1, #1
 807bca2:	481f      	ldr	r0, [pc, #124]	; (807bd20 <BSP_OSPI_NOR_DeInit+0xbc>)
 807bca4:	f000 fbfa 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D2_GPIO_PORT, OSPI_D2_PIN);
 807bca8:	2180      	movs	r1, #128	; 0x80
 807bcaa:	481c      	ldr	r0, [pc, #112]	; (807bd1c <BSP_OSPI_NOR_DeInit+0xb8>)
 807bcac:	f000 fbf6 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D3_GPIO_PORT, OSPI_D3_PIN);
 807bcb0:	2140      	movs	r1, #64	; 0x40
 807bcb2:	481a      	ldr	r0, [pc, #104]	; (807bd1c <BSP_OSPI_NOR_DeInit+0xb8>)
 807bcb4:	f000 fbf2 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D4_GPIO_PORT, OSPI_D4_PIN);
 807bcb8:	2102      	movs	r1, #2
 807bcba:	481a      	ldr	r0, [pc, #104]	; (807bd24 <BSP_OSPI_NOR_DeInit+0xc0>)
 807bcbc:	f000 fbee 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D5_GPIO_PORT, OSPI_D5_PIN);
 807bcc0:	2104      	movs	r1, #4
 807bcc2:	4818      	ldr	r0, [pc, #96]	; (807bd24 <BSP_OSPI_NOR_DeInit+0xc0>)
 807bcc4:	f000 fbea 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D6_GPIO_PORT, OSPI_D6_PIN);
 807bcc8:	2108      	movs	r1, #8
 807bcca:	4816      	ldr	r0, [pc, #88]	; (807bd24 <BSP_OSPI_NOR_DeInit+0xc0>)
 807bccc:	f000 fbe6 	bl	807c49c <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(OSPI_D7_GPIO_PORT, OSPI_D7_PIN);
 807bcd0:	4814      	ldr	r0, [pc, #80]	; (807bd24 <BSP_OSPI_NOR_DeInit+0xc0>)
 807bcd2:	2101      	movs	r1, #1
 807bcd4:	f000 fbe2 	bl	807c49c <HAL_GPIO_DeInit>
  OSPI_FORCE_RESET();
 807bcd8:	4b13      	ldr	r3, [pc, #76]	; (807bd28 <BSP_OSPI_NOR_DeInit+0xc4>)
      if (HAL_OSPI_DeInit(&hospi_nor[Instance]) != HAL_OK)
 807bcda:	4814      	ldr	r0, [pc, #80]	; (807bd2c <BSP_OSPI_NOR_DeInit+0xc8>)
  OSPI_FORCE_RESET();
 807bcdc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 807bcde:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 807bce2:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_RELEASE_RESET();
 807bce4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 807bce6:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 807bcea:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_CLK_DISABLE();
 807bcec:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 807bcee:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 807bcf2:	651a      	str	r2, [r3, #80]	; 0x50
      if (HAL_OSPI_DeInit(&hospi_nor[Instance]) != HAL_OK)
 807bcf4:	f000 fdcf 	bl	807c896 <HAL_OSPI_DeInit>
 807bcf8:	2800      	cmp	r0, #0
 807bcfa:	d0b9      	beq.n	807bc70 <BSP_OSPI_NOR_DeInit+0xc>
        ret = BSP_ERROR_PERIPH_FAILURE;
 807bcfc:	f06f 0003 	mvn.w	r0, #3
 807bd00:	e7b7      	b.n	807bc72 <BSP_OSPI_NOR_DeInit+0xe>
        if(BSP_OSPI_NOR_DisableMemoryMappedMode(Instance) != BSP_ERROR_NONE)
 807bd02:	f7ff ff95 	bl	807bc30 <BSP_OSPI_NOR_DisableMemoryMappedMode>
 807bd06:	2800      	cmp	r0, #0
 807bd08:	d0b6      	beq.n	807bc78 <BSP_OSPI_NOR_DeInit+0x14>
          return BSP_ERROR_COMPONENT_FAILURE;
 807bd0a:	f06f 0004 	mvn.w	r0, #4
 807bd0e:	e7b0      	b.n	807bc72 <BSP_OSPI_NOR_DeInit+0xe>
    ret = BSP_ERROR_WRONG_PARAM;
 807bd10:	f06f 0001 	mvn.w	r0, #1
 807bd14:	e7ad      	b.n	807bc72 <BSP_OSPI_NOR_DeInit+0xe>
 807bd16:	bf00      	nop
 807bd18:	20000592 	.word	0x20000592
 807bd1c:	42020000 	.word	0x42020000
 807bd20:	42020400 	.word	0x42020400
 807bd24:	42020800 	.word	0x42020800
 807bd28:	40021000 	.word	0x40021000
 807bd2c:	20000598 	.word	0x20000598

0807bd30 <BSP_OSPI_NOR_ConfigFlash>:
{
 807bd30:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 807bd34:	460e      	mov	r6, r1
 807bd36:	4617      	mov	r7, r2
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807bd38:	2800      	cmp	r0, #0
 807bd3a:	d15d      	bne.n	807bdf8 <BSP_OSPI_NOR_ConfigFlash+0xc8>
    if(Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_MMP)
 807bd3c:	4c31      	ldr	r4, [pc, #196]	; (807be04 <BSP_OSPI_NOR_ConfigFlash+0xd4>)
 807bd3e:	7823      	ldrb	r3, [r4, #0]
 807bd40:	2b02      	cmp	r3, #2
 807bd42:	d05c      	beq.n	807bdfe <BSP_OSPI_NOR_ConfigFlash+0xce>
      switch(Ospi_Nor_Ctx[Instance].InterfaceMode)
 807bd44:	7863      	ldrb	r3, [r4, #1]
 807bd46:	2b01      	cmp	r3, #1
 807bd48:	d14d      	bne.n	807bde6 <BSP_OSPI_NOR_ConfigFlash+0xb6>
        if((Mode != BSP_OSPI_NOR_OPI_MODE) || (Rate != Ospi_Nor_Ctx[Instance].TransferRate))
 807bd4a:	2901      	cmp	r1, #1
 807bd4c:	78a2      	ldrb	r2, [r4, #2]
 807bd4e:	d109      	bne.n	807bd64 <BSP_OSPI_NOR_ConfigFlash+0x34>
 807bd50:	4297      	cmp	r7, r2
 807bd52:	d107      	bne.n	807bd64 <BSP_OSPI_NOR_ConfigFlash+0x34>
        Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
 807bd54:	2301      	movs	r3, #1
        Ospi_Nor_Ctx[Instance].TransferRate  = Rate;
 807bd56:	2000      	movs	r0, #0
        Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;
 807bd58:	7023      	strb	r3, [r4, #0]
        Ospi_Nor_Ctx[Instance].InterfaceMode = Mode;
 807bd5a:	7066      	strb	r6, [r4, #1]
        Ospi_Nor_Ctx[Instance].TransferRate  = Rate;
 807bd5c:	70a7      	strb	r7, [r4, #2]
}
 807bd5e:	b004      	add	sp, #16
 807bd60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
  {
    ret = BSP_ERROR_WRONG_PARAM;
  }
  /* Enable write operations */
  else if (MX25LM51245G_WriteEnable(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807bd64:	4d28      	ldr	r5, [pc, #160]	; (807be08 <BSP_OSPI_NOR_ConfigFlash+0xd8>)
 807bd66:	2101      	movs	r1, #1
 807bd68:	4628      	mov	r0, r5
 807bd6a:	f7ff fb74 	bl	807b456 <MX25LM51245G_WriteEnable>
 807bd6e:	4603      	mov	r3, r0
 807bd70:	b9b0      	cbnz	r0, 807bda0 <BSP_OSPI_NOR_ConfigFlash+0x70>
    ret = BSP_ERROR_COMPONENT_FAILURE;
  }
  else
  {
    /* Write Configuration register 2 (with SPI protocol) */
    reg[0] = 0;
 807bd72:	f8ad 000c 	strh.w	r0, [sp, #12]
    reg[1] = 0;
    if (MX25LM51245G_WriteCfg2Register(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate, MX25LM51245G_CR2_REG1_ADDR, reg[0]) != MX25LM51245G_OK)
 807bd76:	9000      	str	r0, [sp, #0]
 807bd78:	78a2      	ldrb	r2, [r4, #2]
 807bd7a:	7861      	ldrb	r1, [r4, #1]
 807bd7c:	4628      	mov	r0, r5
 807bd7e:	f7ff fc4c 	bl	807b61a <MX25LM51245G_WriteCfg2Register>
 807bd82:	4680      	mov	r8, r0
 807bd84:	b960      	cbnz	r0, 807bda0 <BSP_OSPI_NOR_ConfigFlash+0x70>
      ret = BSP_ERROR_COMPONENT_FAILURE;
    }
    else
    {
      /* Wait that the configuration is effective and check that memory is ready */
      HAL_Delay(MX25LM51245G_WRITE_REG_MAX_TIME);
 807bd86:	2028      	movs	r0, #40	; 0x28
 807bd88:	f000 f99a 	bl	807c0c0 <HAL_Delay>

      if (Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_DTR_TRANSFER)
 807bd8c:	78a3      	ldrb	r3, [r4, #2]
 807bd8e:	2b01      	cmp	r3, #1
 807bd90:	d009      	beq.n	807bda6 <BSP_OSPI_NOR_ConfigFlash+0x76>
      }

      if (ret == BSP_ERROR_NONE)
      {
        /* Check Flash busy ? */
        if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 807bd92:	2200      	movs	r2, #0
 807bd94:	481c      	ldr	r0, [pc, #112]	; (807be08 <BSP_OSPI_NOR_ConfigFlash+0xd8>)
 807bd96:	4611      	mov	r1, r2
 807bd98:	f7ff f96b 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807bd9c:	4603      	mov	r3, r0
 807bd9e:	b170      	cbz	r0, 807bdbe <BSP_OSPI_NOR_ConfigFlash+0x8e>
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
        }
        else if (reg[0] != 0U)
        {
          ret = BSP_ERROR_COMPONENT_FAILURE;
 807bda0:	f06f 0004 	mvn.w	r0, #4
 807bda4:	e7db      	b.n	807bd5e <BSP_OSPI_NOR_ConfigFlash+0x2e>
        if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 807bda6:	4628      	mov	r0, r5
        hospi_nor[Instance].Init.MemoryType            = HAL_OSPI_MEMTYPE_MICRON;
 807bda8:	f8c5 800c 	str.w	r8, [r5, #12]
        hospi_nor[Instance].Init.DelayHoldQuarterCycle = HAL_OSPI_DHQC_DISABLE;
 807bdac:	f8c5 802c 	str.w	r8, [r5, #44]	; 0x2c
        if (HAL_OSPI_Init(&hospi_nor[Instance]) != HAL_OK)
 807bdb0:	f000 fd00 	bl	807c7b4 <HAL_OSPI_Init>
 807bdb4:	2800      	cmp	r0, #0
 807bdb6:	d0ec      	beq.n	807bd92 <BSP_OSPI_NOR_ConfigFlash+0x62>
          ret = BSP_ERROR_PERIPH_FAILURE;
 807bdb8:	f06f 0003 	mvn.w	r0, #3
 807bdbc:	e7cf      	b.n	807bd5e <BSP_OSPI_NOR_ConfigFlash+0x2e>
        else if (MX25LM51245G_ReadCfg2Register(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER, MX25LM51245G_CR2_REG1_ADDR, reg) != MX25LM51245G_OK)
 807bdbe:	aa03      	add	r2, sp, #12
 807bdc0:	9200      	str	r2, [sp, #0]
 807bdc2:	4601      	mov	r1, r0
 807bdc4:	4602      	mov	r2, r0
 807bdc6:	4810      	ldr	r0, [pc, #64]	; (807be08 <BSP_OSPI_NOR_ConfigFlash+0xd8>)
 807bdc8:	f7ff fc84 	bl	807b6d4 <MX25LM51245G_ReadCfg2Register>
 807bdcc:	2800      	cmp	r0, #0
 807bdce:	d1e7      	bne.n	807bda0 <BSP_OSPI_NOR_ConfigFlash+0x70>
        else if (reg[0] != 0U)
 807bdd0:	f89d 300c 	ldrb.w	r3, [sp, #12]
 807bdd4:	2b00      	cmp	r3, #0
 807bdd6:	d1e3      	bne.n	807bda0 <BSP_OSPI_NOR_ConfigFlash+0x70>
          if ((ret == BSP_ERROR_NONE) && (Mode == BSP_OSPI_NOR_OPI_MODE))
 807bdd8:	2e01      	cmp	r6, #1
 807bdda:	d1bb      	bne.n	807bd54 <BSP_OSPI_NOR_ConfigFlash+0x24>
            if (Ospi_Nor_Ctx[Instance].TransferRate == BSP_OSPI_NOR_STR_TRANSFER)
 807bddc:	78a3      	ldrb	r3, [r4, #2]
 807bdde:	b933      	cbnz	r3, 807bdee <BSP_OSPI_NOR_ConfigFlash+0xbe>
            ret = OSPI_NOR_EnterDOPIMode(Instance);
 807bde0:	f7ff fde6 	bl	807b9b0 <OSPI_NOR_EnterDOPIMode.constprop.5>
 807bde4:	e005      	b.n	807bdf2 <BSP_OSPI_NOR_ConfigFlash+0xc2>
        if(Mode == BSP_OSPI_NOR_OPI_MODE)
 807bde6:	2901      	cmp	r1, #1
 807bde8:	d1b4      	bne.n	807bd54 <BSP_OSPI_NOR_ConfigFlash+0x24>
          if(Rate == BSP_OSPI_NOR_STR_TRANSFER)
 807bdea:	2a00      	cmp	r2, #0
 807bdec:	d1f8      	bne.n	807bde0 <BSP_OSPI_NOR_ConfigFlash+0xb0>
            ret = OSPI_NOR_EnterSOPIMode(Instance);
 807bdee:	f7ff fd97 	bl	807b920 <OSPI_NOR_EnterSOPIMode.constprop.4>
      if(ret == BSP_ERROR_NONE)
 807bdf2:	2800      	cmp	r0, #0
 807bdf4:	d1b3      	bne.n	807bd5e <BSP_OSPI_NOR_ConfigFlash+0x2e>
 807bdf6:	e7ad      	b.n	807bd54 <BSP_OSPI_NOR_ConfigFlash+0x24>
    ret = BSP_ERROR_WRONG_PARAM;
 807bdf8:	f06f 0001 	mvn.w	r0, #1
 807bdfc:	e7af      	b.n	807bd5e <BSP_OSPI_NOR_ConfigFlash+0x2e>
      ret = BSP_ERROR_OSPI_MMP_LOCK_FAILURE;
 807bdfe:	f06f 0015 	mvn.w	r0, #21
  return ret;
 807be02:	e7ac      	b.n	807bd5e <BSP_OSPI_NOR_ConfigFlash+0x2e>
 807be04:	20000592 	.word	0x20000592
 807be08:	20000598 	.word	0x20000598

0807be0c <BSP_OSPI_NOR_Init>:
{
 807be0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 807be10:	460e      	mov	r6, r1
 807be12:	b09d      	sub	sp, #116	; 0x74
  if(Instance >= OSPI_NOR_INSTANCES_NUMBER)
 807be14:	2800      	cmp	r0, #0
 807be16:	f040 812e 	bne.w	807c076 <BSP_OSPI_NOR_Init+0x26a>
    if (Ospi_Nor_Ctx[Instance].IsInitialized == OSPI_ACCESS_NONE)
 807be1a:	4d9a      	ldr	r5, [pc, #616]	; (807c084 <BSP_OSPI_NOR_Init+0x278>)
 807be1c:	f895 b000 	ldrb.w	fp, [r5]
 807be20:	f1bb 0f00 	cmp.w	fp, #0
 807be24:	f040 8125 	bne.w	807c072 <BSP_OSPI_NOR_Init+0x266>
  OSPI_CLK_ENABLE();
 807be28:	4b97      	ldr	r3, [pc, #604]	; (807c088 <BSP_OSPI_NOR_Init+0x27c>)
  GPIO_InitStruct.Alternate = OSPI_CS_PIN_AF;
 807be2a:	240a      	movs	r4, #10
  OSPI_CLK_ENABLE();
 807be2c:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 807be2e:	f04f 0904 	mov.w	r9, #4
  OSPI_CLK_ENABLE();
 807be32:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 807be36:	651a      	str	r2, [r3, #80]	; 0x50
 807be38:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 807be3a:	f04f 0a02 	mov.w	sl, #2
  OSPI_CLK_ENABLE();
 807be3e:	f402 7280 	and.w	r2, r2, #256	; 0x100
 807be42:	9203      	str	r2, [sp, #12]
 807be44:	9a03      	ldr	r2, [sp, #12]
  OSPI_FORCE_RESET();
 807be46:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 807be48:	f04f 0801 	mov.w	r8, #1
  OSPI_FORCE_RESET();
 807be4c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 807be50:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_RELEASE_RESET();
 807be52:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 807be54:	2703      	movs	r7, #3
  OSPI_RELEASE_RESET();
 807be56:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 807be5a:	631a      	str	r2, [r3, #48]	; 0x30
  OSPI_CLK_GPIO_CLK_ENABLE();
 807be5c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 807be5e:	a913      	add	r1, sp, #76	; 0x4c
  OSPI_CLK_GPIO_CLK_ENABLE();
 807be60:	f042 0201 	orr.w	r2, r2, #1
 807be64:	64da      	str	r2, [r3, #76]	; 0x4c
 807be66:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 807be68:	4888      	ldr	r0, [pc, #544]	; (807c08c <BSP_OSPI_NOR_Init+0x280>)
  OSPI_CLK_GPIO_CLK_ENABLE();
 807be6a:	f002 0201 	and.w	r2, r2, #1
 807be6e:	9204      	str	r2, [sp, #16]
 807be70:	9a04      	ldr	r2, [sp, #16]
  OSPI_DQS_GPIO_CLK_ENABLE();
 807be72:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807be74:	f042 0202 	orr.w	r2, r2, #2
 807be78:	64da      	str	r2, [r3, #76]	; 0x4c
 807be7a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807be7c:	f002 0202 	and.w	r2, r2, #2
 807be80:	9205      	str	r2, [sp, #20]
 807be82:	9a05      	ldr	r2, [sp, #20]
  OSPI_CS_GPIO_CLK_ENABLE();
 807be84:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807be86:	f042 0201 	orr.w	r2, r2, #1
 807be8a:	64da      	str	r2, [r3, #76]	; 0x4c
 807be8c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807be8e:	f002 0201 	and.w	r2, r2, #1
 807be92:	9206      	str	r2, [sp, #24]
 807be94:	9a06      	ldr	r2, [sp, #24]
  OSPI_D0_GPIO_CLK_ENABLE();
 807be96:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807be98:	f042 0202 	orr.w	r2, r2, #2
 807be9c:	64da      	str	r2, [r3, #76]	; 0x4c
 807be9e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bea0:	f002 0202 	and.w	r2, r2, #2
 807bea4:	9207      	str	r2, [sp, #28]
 807bea6:	9a07      	ldr	r2, [sp, #28]
  OSPI_D1_GPIO_CLK_ENABLE();
 807bea8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807beaa:	f042 0202 	orr.w	r2, r2, #2
 807beae:	64da      	str	r2, [r3, #76]	; 0x4c
 807beb0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807beb2:	f002 0202 	and.w	r2, r2, #2
 807beb6:	9208      	str	r2, [sp, #32]
 807beb8:	9a08      	ldr	r2, [sp, #32]
  OSPI_D2_GPIO_CLK_ENABLE();
 807beba:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bebc:	f042 0201 	orr.w	r2, r2, #1
 807bec0:	64da      	str	r2, [r3, #76]	; 0x4c
 807bec2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bec4:	f002 0201 	and.w	r2, r2, #1
 807bec8:	9209      	str	r2, [sp, #36]	; 0x24
 807beca:	9a09      	ldr	r2, [sp, #36]	; 0x24
  OSPI_D3_GPIO_CLK_ENABLE();
 807becc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bece:	f042 0201 	orr.w	r2, r2, #1
 807bed2:	64da      	str	r2, [r3, #76]	; 0x4c
 807bed4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bed6:	f002 0201 	and.w	r2, r2, #1
 807beda:	920a      	str	r2, [sp, #40]	; 0x28
 807bedc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
  OSPI_D4_GPIO_CLK_ENABLE();
 807bede:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bee0:	f042 0204 	orr.w	r2, r2, #4
 807bee4:	64da      	str	r2, [r3, #76]	; 0x4c
 807bee6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bee8:	f002 0204 	and.w	r2, r2, #4
 807beec:	920b      	str	r2, [sp, #44]	; 0x2c
 807beee:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
  OSPI_D5_GPIO_CLK_ENABLE();
 807bef0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bef2:	f042 0204 	orr.w	r2, r2, #4
 807bef6:	64da      	str	r2, [r3, #76]	; 0x4c
 807bef8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807befa:	f002 0204 	and.w	r2, r2, #4
 807befe:	920c      	str	r2, [sp, #48]	; 0x30
 807bf00:	9a0c      	ldr	r2, [sp, #48]	; 0x30
  OSPI_D6_GPIO_CLK_ENABLE();
 807bf02:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bf04:	f042 0204 	orr.w	r2, r2, #4
 807bf08:	64da      	str	r2, [r3, #76]	; 0x4c
 807bf0a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bf0c:	f002 0204 	and.w	r2, r2, #4
 807bf10:	920d      	str	r2, [sp, #52]	; 0x34
 807bf12:	9a0d      	ldr	r2, [sp, #52]	; 0x34
  OSPI_D7_GPIO_CLK_ENABLE();
 807bf14:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 807bf16:	f042 0204 	orr.w	r2, r2, #4
 807bf1a:	64da      	str	r2, [r3, #76]	; 0x4c
 807bf1c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 807bf1e:	f003 0304 	and.w	r3, r3, #4
 807bf22:	930e      	str	r3, [sp, #56]	; 0x38
 807bf24:	9b0e      	ldr	r3, [sp, #56]	; 0x38
  GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP;
 807bf26:	e9cd 9a13 	strd	r9, sl, [sp, #76]	; 0x4c
  GPIO_InitStruct.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
 807bf2a:	e9cd 8715 	strd	r8, r7, [sp, #84]	; 0x54
  GPIO_InitStruct.Alternate = OSPI_CS_PIN_AF;
 807bf2e:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_CS_GPIO_PORT, &GPIO_InitStruct);
 807bf30:	f000 f9ec 	bl	807c30c <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_DQS_GPIO_PORT, &GPIO_InitStruct);
 807bf34:	a913      	add	r1, sp, #76	; 0x4c
 807bf36:	4856      	ldr	r0, [pc, #344]	; (807c090 <BSP_OSPI_NOR_Init+0x284>)
  GPIO_InitStruct.Pin       = OSPI_DQS_PIN;
 807bf38:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_DQS_PIN_AF;
 807bf3c:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_DQS_GPIO_PORT, &GPIO_InitStruct);
 807bf3e:	f000 f9e5 	bl	807c30c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_CLK_PIN;
 807bf42:	2308      	movs	r3, #8
  HAL_GPIO_Init(OSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 807bf44:	a913      	add	r1, sp, #76	; 0x4c
 807bf46:	4851      	ldr	r0, [pc, #324]	; (807c08c <BSP_OSPI_NOR_Init+0x280>)
  GPIO_InitStruct.Pin       = OSPI_CLK_PIN;
 807bf48:	9313      	str	r3, [sp, #76]	; 0x4c
 807bf4a:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull      = GPIO_NOPULL;
 807bf4c:	f8cd b054 	str.w	fp, [sp, #84]	; 0x54
  GPIO_InitStruct.Alternate = OSPI_CLK_PIN_AF;
 807bf50:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_CLK_GPIO_PORT, &GPIO_InitStruct);
 807bf52:	f000 f9db 	bl	807c30c <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 807bf56:	a913      	add	r1, sp, #76	; 0x4c
 807bf58:	484d      	ldr	r0, [pc, #308]	; (807c090 <BSP_OSPI_NOR_Init+0x284>)
  GPIO_InitStruct.Pin       = OSPI_D0_PIN;
 807bf5a:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D0_PIN_AF;
 807bf5e:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D0_GPIO_PORT, &GPIO_InitStruct);
 807bf60:	f000 f9d4 	bl	807c30c <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 807bf64:	a913      	add	r1, sp, #76	; 0x4c
 807bf66:	484a      	ldr	r0, [pc, #296]	; (807c090 <BSP_OSPI_NOR_Init+0x284>)
  GPIO_InitStruct.Pin       = OSPI_D1_PIN;
 807bf68:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D1_PIN_AF;
 807bf6c:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D1_GPIO_PORT, &GPIO_InitStruct);
 807bf6e:	f000 f9cd 	bl	807c30c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_D2_PIN;
 807bf72:	2280      	movs	r2, #128	; 0x80
  HAL_GPIO_Init(OSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 807bf74:	a913      	add	r1, sp, #76	; 0x4c
 807bf76:	4845      	ldr	r0, [pc, #276]	; (807c08c <BSP_OSPI_NOR_Init+0x280>)
  GPIO_InitStruct.Pin       = OSPI_D2_PIN;
 807bf78:	9213      	str	r2, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D2_PIN_AF;
 807bf7a:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D2_GPIO_PORT, &GPIO_InitStruct);
 807bf7c:	f000 f9c6 	bl	807c30c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_D3_PIN;
 807bf80:	2240      	movs	r2, #64	; 0x40
  HAL_GPIO_Init(OSPI_D3_GPIO_PORT, &GPIO_InitStruct);
 807bf82:	a913      	add	r1, sp, #76	; 0x4c
 807bf84:	4841      	ldr	r0, [pc, #260]	; (807c08c <BSP_OSPI_NOR_Init+0x280>)
  GPIO_InitStruct.Pin       = OSPI_D3_PIN;
 807bf86:	9213      	str	r2, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D3_PIN_AF;
 807bf88:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D3_GPIO_PORT, &GPIO_InitStruct);
 807bf8a:	f000 f9bf 	bl	807c30c <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D4_GPIO_PORT, &GPIO_InitStruct);
 807bf8e:	a913      	add	r1, sp, #76	; 0x4c
 807bf90:	4840      	ldr	r0, [pc, #256]	; (807c094 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D4_PIN;
 807bf92:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D4_PIN_AF;
 807bf96:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D4_GPIO_PORT, &GPIO_InitStruct);
 807bf98:	f000 f9b8 	bl	807c30c <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D5_GPIO_PORT, &GPIO_InitStruct);
 807bf9c:	a913      	add	r1, sp, #76	; 0x4c
 807bf9e:	483d      	ldr	r0, [pc, #244]	; (807c094 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D5_PIN;
 807bfa0:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D5_PIN_AF;
 807bfa4:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D5_GPIO_PORT, &GPIO_InitStruct);
 807bfa6:	f000 f9b1 	bl	807c30c <HAL_GPIO_Init>
  GPIO_InitStruct.Pin       = OSPI_D6_PIN;
 807bfaa:	9b01      	ldr	r3, [sp, #4]
  HAL_GPIO_Init(OSPI_D6_GPIO_PORT, &GPIO_InitStruct);
 807bfac:	a913      	add	r1, sp, #76	; 0x4c
 807bfae:	4839      	ldr	r0, [pc, #228]	; (807c094 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D6_PIN;
 807bfb0:	9313      	str	r3, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D6_PIN_AF;
 807bfb2:	9417      	str	r4, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D6_GPIO_PORT, &GPIO_InitStruct);
 807bfb4:	f000 f9aa 	bl	807c30c <HAL_GPIO_Init>
  HAL_GPIO_Init(OSPI_D7_GPIO_PORT, &GPIO_InitStruct);
 807bfb8:	a913      	add	r1, sp, #76	; 0x4c
 807bfba:	4836      	ldr	r0, [pc, #216]	; (807c094 <BSP_OSPI_NOR_Init+0x288>)
  GPIO_InitStruct.Pin       = OSPI_D7_PIN;
 807bfbc:	f8cd 804c 	str.w	r8, [sp, #76]	; 0x4c
  GPIO_InitStruct.Alternate = OSPI_D7_PIN_AF;
 807bfc0:	9717      	str	r7, [sp, #92]	; 0x5c
  HAL_GPIO_Init(OSPI_D7_GPIO_PORT, &GPIO_InitStruct);
 807bfc2:	f000 f9a3 	bl	807c30c <HAL_GPIO_Init>
      (void)MX25LM51245G_GetFlashInfo(&pInfo);
 807bfc6:	a813      	add	r0, sp, #76	; 0x4c
 807bfc8:	f7ff f83a 	bl	807b040 <MX25LM51245G_GetFlashInfo>
      ospi_init.ClockPrescaler = 3; /* OctoSPI clock = 120MHz / ClockPrescaler = 40MHz */
 807bfcc:	9710      	str	r7, [sp, #64]	; 0x40
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 807bfce:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 807bfd0:	fa93 f3a3 	rbit	r3, r3
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 807bfd4:	fab3 f383 	clz	r3, r3
      ospi_init.MemorySize     = (uint32_t)POSITION_VAL((uint32_t)pInfo.FlashSize);
 807bfd8:	930f      	str	r3, [sp, #60]	; 0x3c
      ospi_init.SampleShifting = HAL_OSPI_SAMPLE_SHIFTING_NONE;
 807bfda:	2300      	movs	r3, #0
 807bfdc:	9311      	str	r3, [sp, #68]	; 0x44
      ospi_init.TransferRate   = (uint32_t) Init->TransferRate;
 807bfde:	7873      	ldrb	r3, [r6, #1]
      if (MX_OSPI_NOR_Init(&hospi_nor[Instance], &ospi_init) != HAL_OK)
 807bfe0:	a90f      	add	r1, sp, #60	; 0x3c
 807bfe2:	482d      	ldr	r0, [pc, #180]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
      ospi_init.TransferRate   = (uint32_t) Init->TransferRate;
 807bfe4:	9312      	str	r3, [sp, #72]	; 0x48
      if (MX_OSPI_NOR_Init(&hospi_nor[Instance], &ospi_init) != HAL_OK)
 807bfe6:	f7ff fd37 	bl	807ba58 <MX_OSPI_NOR_Init>
 807bfea:	4602      	mov	r2, r0
 807bfec:	2800      	cmp	r0, #0
 807bfee:	d145      	bne.n	807c07c <BSP_OSPI_NOR_Init+0x270>
  else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 807bff0:	4601      	mov	r1, r0
 807bff2:	4829      	ldr	r0, [pc, #164]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807bff4:	f7ff fc36 	bl	807b864 <MX25LM51245G_ResetEnable>
 807bff8:	4602      	mov	r2, r0
 807bffa:	b120      	cbz	r0, 807c006 <BSP_OSPI_NOR_Init+0x1fa>
        ret = BSP_ERROR_COMPONENT_FAILURE;
 807bffc:	f06f 0004 	mvn.w	r0, #4
}
 807c000:	b01d      	add	sp, #116	; 0x74
 807c002:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_SPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 807c006:	4601      	mov	r1, r0
 807c008:	4823      	ldr	r0, [pc, #140]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807c00a:	f7ff fc5a 	bl	807b8c2 <MX25LM51245G_ResetMemory>
 807c00e:	4602      	mov	r2, r0
 807c010:	2800      	cmp	r0, #0
 807c012:	d1f3      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 807c014:	2101      	movs	r1, #1
 807c016:	4820      	ldr	r0, [pc, #128]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807c018:	f7ff fc24 	bl	807b864 <MX25LM51245G_ResetEnable>
 807c01c:	4602      	mov	r2, r0
 807c01e:	2800      	cmp	r0, #0
 807c020:	d1ec      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_STR_TRANSFER) != MX25LM51245G_OK)
 807c022:	2101      	movs	r1, #1
 807c024:	481c      	ldr	r0, [pc, #112]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807c026:	f7ff fc4c 	bl	807b8c2 <MX25LM51245G_ResetMemory>
 807c02a:	2800      	cmp	r0, #0
 807c02c:	d1e6      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetEnable(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
 807c02e:	2201      	movs	r2, #1
 807c030:	4819      	ldr	r0, [pc, #100]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807c032:	4611      	mov	r1, r2
 807c034:	f7ff fc16 	bl	807b864 <MX25LM51245G_ResetEnable>
 807c038:	2800      	cmp	r0, #0
 807c03a:	d1df      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
  else if(MX25LM51245G_ResetMemory(&hospi_nor[Instance], BSP_OSPI_NOR_OPI_MODE, BSP_OSPI_NOR_DTR_TRANSFER) != MX25LM51245G_OK)
 807c03c:	2201      	movs	r2, #1
 807c03e:	4816      	ldr	r0, [pc, #88]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807c040:	4611      	mov	r1, r2
 807c042:	f7ff fc3e 	bl	807b8c2 <MX25LM51245G_ResetMemory>
 807c046:	2800      	cmp	r0, #0
 807c048:	d1d8      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
    Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access   */
 807c04a:	2301      	movs	r3, #1
    Ospi_Nor_Ctx[Instance].InterfaceMode = BSP_OSPI_NOR_SPI_MODE;         /* After reset H/W back to SPI mode by default  */
 807c04c:	7068      	strb	r0, [r5, #1]
    Ospi_Nor_Ctx[Instance].TransferRate  = BSP_OSPI_NOR_STR_TRANSFER;     /* After reset S/W setting to STR mode          */
 807c04e:	70a8      	strb	r0, [r5, #2]
    HAL_Delay(MX25LM51245G_RESET_MAX_TIME);
 807c050:	2064      	movs	r0, #100	; 0x64
    Ospi_Nor_Ctx[Instance].IsInitialized = OSPI_ACCESS_INDIRECT;      /* After reset S/W setting to indirect access   */
 807c052:	702b      	strb	r3, [r5, #0]
    HAL_Delay(MX25LM51245G_RESET_MAX_TIME);
 807c054:	f000 f834 	bl	807c0c0 <HAL_Delay>
      else if (MX25LM51245G_AutoPollingMemReady(&hospi_nor[Instance], Ospi_Nor_Ctx[Instance].InterfaceMode, Ospi_Nor_Ctx[Instance].TransferRate) != MX25LM51245G_OK)
 807c058:	78aa      	ldrb	r2, [r5, #2]
 807c05a:	7869      	ldrb	r1, [r5, #1]
 807c05c:	480e      	ldr	r0, [pc, #56]	; (807c098 <BSP_OSPI_NOR_Init+0x28c>)
 807c05e:	f7ff f808 	bl	807b072 <MX25LM51245G_AutoPollingMemReady>
 807c062:	2800      	cmp	r0, #0
 807c064:	d1ca      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
      else if (BSP_OSPI_NOR_ConfigFlash(Instance, Init->InterfaceMode, Init->TransferRate) != BSP_ERROR_NONE)
 807c066:	7872      	ldrb	r2, [r6, #1]
 807c068:	7831      	ldrb	r1, [r6, #0]
 807c06a:	f7ff fe61 	bl	807bd30 <BSP_OSPI_NOR_ConfigFlash>
 807c06e:	2800      	cmp	r0, #0
 807c070:	d1c4      	bne.n	807bffc <BSP_OSPI_NOR_Init+0x1f0>
        ret = BSP_ERROR_NONE;
 807c072:	2000      	movs	r0, #0
 807c074:	e7c4      	b.n	807c000 <BSP_OSPI_NOR_Init+0x1f4>
    ret = BSP_ERROR_WRONG_PARAM;
 807c076:	f06f 0001 	mvn.w	r0, #1
 807c07a:	e7c1      	b.n	807c000 <BSP_OSPI_NOR_Init+0x1f4>
        ret = BSP_ERROR_PERIPH_FAILURE;
 807c07c:	f06f 0003 	mvn.w	r0, #3
  return ret;
 807c080:	e7be      	b.n	807c000 <BSP_OSPI_NOR_Init+0x1f4>
 807c082:	bf00      	nop
 807c084:	20000592 	.word	0x20000592
 807c088:	40021000 	.word	0x40021000
 807c08c:	42020000 	.word	0x42020000
 807c090:	42020400 	.word	0x42020400
 807c094:	42020800 	.word	0x42020800
 807c098:	20000598 	.word	0x20000598

0807c09c <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 807c09c:	4770      	bx	lr

0807c09e <HAL_Init>:
{
 807c09e:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_3);
 807c0a0:	2004      	movs	r0, #4
 807c0a2:	f000 f81f 	bl	807c0e4 <HAL_NVIC_SetPriorityGrouping>
  SystemCoreClockUpdate();
 807c0a6:	f7fe fdcf 	bl	807ac48 <SystemCoreClockUpdate>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 807c0aa:	2007      	movs	r0, #7
 807c0ac:	f7fe fe1a 	bl	807ace4 <HAL_InitTick>
 807c0b0:	4604      	mov	r4, r0
 807c0b2:	b918      	cbnz	r0, 807c0bc <HAL_Init+0x1e>
    HAL_MspInit();
 807c0b4:	f7ff fff2 	bl	807c09c <HAL_MspInit>
}
 807c0b8:	4620      	mov	r0, r4
 807c0ba:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 807c0bc:	2401      	movs	r4, #1
 807c0be:	e7fb      	b.n	807c0b8 <HAL_Init+0x1a>

0807c0c0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 807c0c0:	b538      	push	{r3, r4, r5, lr}
 807c0c2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 807c0c4:	f7fe fe1c 	bl	807ad00 <HAL_GetTick>
 807c0c8:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 807c0ca:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)uwTickFreq;
 807c0cc:	bf1e      	ittt	ne
 807c0ce:	4b04      	ldrne	r3, [pc, #16]	; (807c0e0 <HAL_Delay+0x20>)
 807c0d0:	781b      	ldrbne	r3, [r3, #0]
 807c0d2:	18e4      	addne	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 807c0d4:	f7fe fe14 	bl	807ad00 <HAL_GetTick>
 807c0d8:	1b40      	subs	r0, r0, r5
 807c0da:	42a0      	cmp	r0, r4
 807c0dc:	d3fa      	bcc.n	807c0d4 <HAL_Delay+0x14>
  {
  }
}
 807c0de:	bd38      	pop	{r3, r4, r5, pc}
 807c0e0:	20000028 	.word	0x20000028

0807c0e4 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 807c0e4:	4a07      	ldr	r2, [pc, #28]	; (807c104 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 807c0e6:	0200      	lsls	r0, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 807c0e8:	68d3      	ldr	r3, [r2, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 807c0ea:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 807c0ee:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 807c0f2:	041b      	lsls	r3, r3, #16
 807c0f4:	0c1b      	lsrs	r3, r3, #16
 807c0f6:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 807c0fa:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  reg_value  =  (reg_value                                   |
 807c0fe:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 807c100:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 807c102:	4770      	bx	lr
 807c104:	e000ed00 	.word	0xe000ed00

0807c108 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 807c108:	460b      	mov	r3, r1
 807c10a:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the peripheral */
  for (i = 0U; i < (BufferLength / 4U); i++)
 807c10c:	0896      	lsrs	r6, r2, #2
 807c10e:	6805      	ldr	r5, [r0, #0]
 807c110:	eb01 0786 	add.w	r7, r1, r6, lsl #2
 807c114:	42bb      	cmp	r3, r7
 807c116:	d108      	bne.n	807c12a <CRC_Handle_8+0x22>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
                         (uint32_t)pBuffer[(4U * i) + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 807c118:	f012 0203 	ands.w	r2, r2, #3
 807c11c:	d01e      	beq.n	807c15c <CRC_Handle_8+0x54>
  {
    if ((BufferLength % 4U) == 1U)
 807c11e:	2a01      	cmp	r2, #1
 807c120:	d114      	bne.n	807c14c <CRC_Handle_8+0x44>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];         /* Derogation MisraC2012 R.11.5 */
 807c122:	f811 3026 	ldrb.w	r3, [r1, r6, lsl #2]
    {
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
      pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                    /* Derogation MisraC2012 R.11.5 */
      *pReg = data;

      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 807c126:	702b      	strb	r3, [r5, #0]
 807c128:	e018      	b.n	807c15c <CRC_Handle_8+0x54>
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 807c12a:	785c      	ldrb	r4, [r3, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 807c12c:	f893 c000 	ldrb.w	ip, [r3]
                         ((uint32_t)pBuffer[(4U * i) + 1U] << 16U) | \
 807c130:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 807c132:	ea44 640c 	orr.w	r4, r4, ip, lsl #24
                         (uint32_t)pBuffer[(4U * i) + 3U];
 807c136:	f893 c003 	ldrb.w	ip, [r3, #3]
 807c13a:	3304      	adds	r3, #4
                         ((uint32_t)pBuffer[(4U * i) + 2U] << 8U)  | \
 807c13c:	ea44 040c 	orr.w	r4, r4, ip
 807c140:	f813 cc02 	ldrb.w	ip, [r3, #-2]
 807c144:	ea44 240c 	orr.w	r4, r4, ip, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 807c148:	602c      	str	r4, [r5, #0]
 807c14a:	e7e3      	b.n	807c114 <CRC_Handle_8+0xc>
    if ((BufferLength % 4U) == 2U)
 807c14c:	2a02      	cmp	r2, #2
 807c14e:	d108      	bne.n	807c162 <CRC_Handle_8+0x5a>
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 807c150:	f811 2026 	ldrb.w	r2, [r1, r6, lsl #2]
 807c154:	785b      	ldrb	r3, [r3, #1]
 807c156:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
      *pReg = data;
 807c15a:	802b      	strh	r3, [r5, #0]
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 807c15c:	6803      	ldr	r3, [r0, #0]
 807c15e:	6818      	ldr	r0, [r3, #0]
}
 807c160:	bdf0      	pop	{r4, r5, r6, r7, pc}
      data = ((uint16_t)(pBuffer[4U * i]) << 8U) | (uint16_t)pBuffer[(4U * i) + 1U];
 807c162:	785a      	ldrb	r2, [r3, #1]
 807c164:	f811 1026 	ldrb.w	r1, [r1, r6, lsl #2]
 807c168:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
      *pReg = data;
 807c16c:	802a      	strh	r2, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[(4U * i) + 2U];  /* Derogation MisraC2012 R.11.5 */
 807c16e:	789b      	ldrb	r3, [r3, #2]
 807c170:	e7d9      	b.n	807c126 <CRC_Handle_8+0x1e>

0807c172 <CRC_Handle_16>:
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the peripheral */
  for (i = 0U; i < (BufferLength / 2U); i++)
 807c172:	2300      	movs	r3, #0
 807c174:	6800      	ldr	r0, [r0, #0]
{
 807c176:	b570      	push	{r4, r5, r6, lr}
  for (i = 0U; i < (BufferLength / 2U); i++)
 807c178:	0855      	lsrs	r5, r2, #1
 807c17a:	429d      	cmp	r5, r3
 807c17c:	d106      	bne.n	807c18c <CRC_Handle_16+0x1a>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
  }
  if ((BufferLength % 2U) != 0U)
 807c17e:	07d3      	lsls	r3, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);                 /* Derogation MisraC2012 R.11.5 */
    *pReg = pBuffer[2U * i];
 807c180:	bf44      	itt	mi
 807c182:	f831 3025 	ldrhmi.w	r3, [r1, r5, lsl #2]
 807c186:	8003      	strhmi	r3, [r0, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 807c188:	6800      	ldr	r0, [r0, #0]
}
 807c18a:	bd70      	pop	{r4, r5, r6, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 807c18c:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 807c190:	f831 6023 	ldrh.w	r6, [r1, r3, lsl #2]
 807c194:	8864      	ldrh	r4, [r4, #2]
  for (i = 0U; i < (BufferLength / 2U); i++)
 807c196:	3301      	adds	r3, #1
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[(2U * i) + 1U];
 807c198:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
 807c19c:	6004      	str	r4, [r0, #0]
 807c19e:	e7ec      	b.n	807c17a <CRC_Handle_16+0x8>

0807c1a0 <HAL_CRC_MspInit>:
}
 807c1a0:	4770      	bx	lr
	...

0807c1a4 <HAL_CRC_Init>:
{
 807c1a4:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 807c1a6:	4604      	mov	r4, r0
 807c1a8:	b908      	cbnz	r0, 807c1ae <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 807c1aa:	2001      	movs	r0, #1
}
 807c1ac:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 807c1ae:	7f43      	ldrb	r3, [r0, #29]
 807c1b0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 807c1b4:	b913      	cbnz	r3, 807c1bc <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 807c1b6:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 807c1b8:	f7ff fff2 	bl	807c1a0 <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 807c1bc:	2302      	movs	r3, #2
 807c1be:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 807c1c0:	7923      	ldrb	r3, [r4, #4]
 807c1c2:	b9e3      	cbnz	r3, 807c1fe <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 807c1c4:	6823      	ldr	r3, [r4, #0]
 807c1c6:	4a13      	ldr	r2, [pc, #76]	; (807c214 <HAL_CRC_Init+0x70>)
 807c1c8:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 807c1ca:	689a      	ldr	r2, [r3, #8]
 807c1cc:	f022 0218 	bic.w	r2, r2, #24
 807c1d0:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 807c1d2:	7962      	ldrb	r2, [r4, #5]
 807c1d4:	6823      	ldr	r3, [r4, #0]
 807c1d6:	b9d2      	cbnz	r2, 807c20e <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 807c1d8:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 807c1dc:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 807c1de:	689a      	ldr	r2, [r3, #8]
 807c1e0:	6961      	ldr	r1, [r4, #20]
 807c1e2:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 807c1e6:	430a      	orrs	r2, r1
 807c1e8:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 807c1ea:	689a      	ldr	r2, [r3, #8]
 807c1ec:	69a1      	ldr	r1, [r4, #24]
 807c1ee:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 807c1f2:	430a      	orrs	r2, r1
 807c1f4:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 807c1f6:	2301      	movs	r3, #1
  return HAL_OK;
 807c1f8:	2000      	movs	r0, #0
  hcrc->State = HAL_CRC_STATE_READY;
 807c1fa:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 807c1fc:	e7d6      	b.n	807c1ac <HAL_CRC_Init+0x8>
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 807c1fe:	e9d4 1202 	ldrd	r1, r2, [r4, #8]
 807c202:	4620      	mov	r0, r4
 807c204:	f000 f82c 	bl	807c260 <HAL_CRCEx_Polynomial_Set>
 807c208:	2800      	cmp	r0, #0
 807c20a:	d0e2      	beq.n	807c1d2 <HAL_CRC_Init+0x2e>
 807c20c:	e7cd      	b.n	807c1aa <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 807c20e:	6922      	ldr	r2, [r4, #16]
 807c210:	e7e4      	b.n	807c1dc <HAL_CRC_Init+0x38>
 807c212:	bf00      	nop
 807c214:	04c11db7 	.word	0x04c11db7

0807c218 <HAL_CRC_Calculate>:
{
 807c218:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hcrc->State = HAL_CRC_STATE_BUSY;
 807c21a:	2502      	movs	r5, #2
 807c21c:	7745      	strb	r5, [r0, #29]
  __HAL_CRC_DR_RESET(hcrc);
 807c21e:	6805      	ldr	r5, [r0, #0]
{
 807c220:	4604      	mov	r4, r0
  __HAL_CRC_DR_RESET(hcrc);
 807c222:	68af      	ldr	r7, [r5, #8]
 807c224:	f047 0701 	orr.w	r7, r7, #1
 807c228:	60af      	str	r7, [r5, #8]
  switch (hcrc->InputDataFormat)
 807c22a:	6a07      	ldr	r7, [r0, #32]
 807c22c:	2f02      	cmp	r7, #2
 807c22e:	d012      	beq.n	807c256 <HAL_CRC_Calculate+0x3e>
 807c230:	2f03      	cmp	r7, #3
 807c232:	d004      	beq.n	807c23e <HAL_CRC_Calculate+0x26>
 807c234:	2f01      	cmp	r7, #1
 807c236:	d111      	bne.n	807c25c <HAL_CRC_Calculate+0x44>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 807c238:	f7ff ff66 	bl	807c108 <CRC_Handle_8>
      break;
 807c23c:	e004      	b.n	807c248 <HAL_CRC_Calculate+0x30>
 807c23e:	eb01 0682 	add.w	r6, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 807c242:	42b1      	cmp	r1, r6
 807c244:	d103      	bne.n	807c24e <HAL_CRC_Calculate+0x36>
      temp = hcrc->Instance->DR;
 807c246:	6828      	ldr	r0, [r5, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 807c248:	2301      	movs	r3, #1
 807c24a:	7763      	strb	r3, [r4, #29]
}
 807c24c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hcrc->Instance->DR = pBuffer[index];
 807c24e:	f851 3b04 	ldr.w	r3, [r1], #4
 807c252:	602b      	str	r3, [r5, #0]
 807c254:	e7f5      	b.n	807c242 <HAL_CRC_Calculate+0x2a>
      temp = CRC_Handle_16(hcrc, (uint16_t *)(void *)pBuffer, BufferLength);    /* Derogation MisraC2012 R.11.5 */
 807c256:	f7ff ff8c 	bl	807c172 <CRC_Handle_16>
      break;
 807c25a:	e7f5      	b.n	807c248 <HAL_CRC_Calculate+0x30>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 807c25c:	2000      	movs	r0, #0
 807c25e:	e7f3      	b.n	807c248 <HAL_CRC_Calculate+0x30>

0807c260 <HAL_CRCEx_Polynomial_Set>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 807c260:	231f      	movs	r3, #31
{
 807c262:	b510      	push	{r4, lr}
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << (msb & 0x1FU))) == 0U))
 807c264:	f113 33ff 	adds.w	r3, r3, #4294967295
 807c268:	d306      	bcc.n	807c278 <HAL_CRCEx_Polynomial_Set+0x18>
 807c26a:	fa21 f403 	lsr.w	r4, r1, r3
 807c26e:	07e4      	lsls	r4, r4, #31
 807c270:	d5f8      	bpl.n	807c264 <HAL_CRCEx_Polynomial_Set+0x4>
  {
  }

  switch (PolyLength)
 807c272:	2a08      	cmp	r2, #8
 807c274:	d014      	beq.n	807c2a0 <HAL_CRCEx_Polynomial_Set+0x40>
 807c276:	d802      	bhi.n	807c27e <HAL_CRCEx_Polynomial_Set+0x1e>
 807c278:	b13a      	cbz	r2, 807c28a <HAL_CRCEx_Polynomial_Set+0x2a>

    case CRC_POLYLENGTH_32B:
      /* no polynomial definition vs. polynomial length issue possible */
      break;
    default:
      status =  HAL_ERROR;
 807c27a:	2001      	movs	r0, #1

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
  }
  /* Return function status */
  return status;
 807c27c:	e00d      	b.n	807c29a <HAL_CRCEx_Polynomial_Set+0x3a>
  switch (PolyLength)
 807c27e:	2a10      	cmp	r2, #16
 807c280:	d00c      	beq.n	807c29c <HAL_CRCEx_Polynomial_Set+0x3c>
 807c282:	2a18      	cmp	r2, #24
 807c284:	d1f9      	bne.n	807c27a <HAL_CRCEx_Polynomial_Set+0x1a>
      if (msb >= HAL_CRC_LENGTH_7B)
 807c286:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 807c288:	d8f7      	bhi.n	807c27a <HAL_CRCEx_Polynomial_Set+0x1a>
    WRITE_REG(hcrc->Instance->POL, Pol);
 807c28a:	6800      	ldr	r0, [r0, #0]
 807c28c:	6141      	str	r1, [r0, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 807c28e:	6883      	ldr	r3, [r0, #8]
 807c290:	f023 0318 	bic.w	r3, r3, #24
 807c294:	431a      	orrs	r2, r3
 807c296:	6082      	str	r2, [r0, #8]
 807c298:	2000      	movs	r0, #0
}
 807c29a:	bd10      	pop	{r4, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 807c29c:	2b07      	cmp	r3, #7
 807c29e:	e7f3      	b.n	807c288 <HAL_CRCEx_Polynomial_Set+0x28>
      if (msb >= HAL_CRC_LENGTH_16B)
 807c2a0:	2b0f      	cmp	r3, #15
 807c2a2:	e7f1      	b.n	807c288 <HAL_CRCEx_Polynomial_Set+0x28>

0807c2a4 <HAL_DMA_Abort>:
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Check the DMA peripheral state */
  if(hdma->State != HAL_DMA_STATE_BUSY)
 807c2a4:	f890 3025 	ldrb.w	r3, [r0, #37]	; 0x25
 807c2a8:	2b02      	cmp	r3, #2
 807c2aa:	d006      	beq.n	807c2ba <HAL_DMA_Abort+0x16>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 807c2ac:	2304      	movs	r3, #4
 807c2ae:	6443      	str	r3, [r0, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 807c2b0:	2300      	movs	r3, #0
 807c2b2:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

    return HAL_ERROR;
 807c2b6:	2001      	movs	r0, #1
 807c2b8:	4770      	bx	lr
  }
  else
  {
    /* Disable DMA IT */
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 807c2ba:	6803      	ldr	r3, [r0, #0]

    /* disable the DMAMUX sync overrun IT*/
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 807c2bc:	6d01      	ldr	r1, [r0, #80]	; 0x50
    __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 807c2be:	681a      	ldr	r2, [r3, #0]
 807c2c0:	f022 020e 	bic.w	r2, r2, #14
 807c2c4:	601a      	str	r2, [r3, #0]
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 807c2c6:	680a      	ldr	r2, [r1, #0]
 807c2c8:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 807c2cc:	600a      	str	r2, [r1, #0]

    /* Disable the channel */
    __HAL_DMA_DISABLE(hdma);
 807c2ce:	681a      	ldr	r2, [r3, #0]
 807c2d0:	f022 0201 	bic.w	r2, r2, #1
 807c2d4:	601a      	str	r2, [r3, #0]

    /* Clear all flags */
    hdma->DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << (hdma->ChannelIndex & 0x1CU));
 807c2d6:	e9d0 1312 	ldrd	r1, r3, [r0, #72]	; 0x48
 807c2da:	f003 021c 	and.w	r2, r3, #28
 807c2de:	2301      	movs	r3, #1
 807c2e0:	4093      	lsls	r3, r2
 807c2e2:	604b      	str	r3, [r1, #4]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 807c2e4:	e9d0 3215 	ldrd	r3, r2, [r0, #84]	; 0x54
 807c2e8:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
 807c2ea:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 807c2ec:	b133      	cbz	r3, 807c2fc <HAL_DMA_Abort+0x58>
    {
      /* if using DMAMUX request generator, disable the DMAMUX request generator overrun IT*/
      /* disable the request gen overrun IT*/
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 807c2ee:	681a      	ldr	r2, [r3, #0]
 807c2f0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 807c2f4:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 807c2f6:	e9d0 3218 	ldrd	r3, r2, [r0, #96]	; 0x60
 807c2fa:	605a      	str	r2, [r3, #4]
    }

    /* Change the DMA state */
    hdma->State = HAL_DMA_STATE_READY;
 807c2fc:	2301      	movs	r3, #1
 807c2fe:	f880 3025 	strb.w	r3, [r0, #37]	; 0x25

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
 807c302:	2300      	movs	r3, #0
 807c304:	f880 3024 	strb.w	r3, [r0, #36]	; 0x24

    return status;
 807c308:	4618      	mov	r0, r3
  }
}
 807c30a:	4770      	bx	lr

0807c30c <HAL_GPIO_Init>:
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  uint32_t position = 0U;
 807c30c:	2300      	movs	r3, #0
{
 807c30e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
        EXTI->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 807c312:	4a5f      	ldr	r2, [pc, #380]	; (807c490 <HAL_GPIO_Init+0x184>)
  while (((GPIO_Init->Pin) >> position) != 0U)
 807c314:	f8d1 8000 	ldr.w	r8, [r1]
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 807c318:	f8df 917c 	ldr.w	r9, [pc, #380]	; 807c498 <HAL_GPIO_Init+0x18c>
  while (((GPIO_Init->Pin) >> position) != 0U)
 807c31c:	fa38 f403 	lsrs.w	r4, r8, r3
 807c320:	d101      	bne.n	807c326 <HAL_GPIO_Init+0x1a>
      }
    }

    position++;
  }
}
 807c322:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 807c326:	f04f 0c01 	mov.w	ip, #1
 807c32a:	fa0c fc03 	lsl.w	ip, ip, r3
    if(iocurrent != 0U)
 807c32e:	ea1c 0608 	ands.w	r6, ip, r8
 807c332:	f000 809f 	beq.w	807c474 <HAL_GPIO_Init+0x168>
 807c336:	2503      	movs	r5, #3
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 807c338:	684c      	ldr	r4, [r1, #4]
 807c33a:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 807c33e:	f024 0a10 	bic.w	sl, r4, #16
 807c342:	f10a 37ff 	add.w	r7, sl, #4294967295
 807c346:	fa05 f50e 	lsl.w	r5, r5, lr
 807c34a:	2f01      	cmp	r7, #1
 807c34c:	ea6f 0505 	mvn.w	r5, r5
 807c350:	d811      	bhi.n	807c376 <HAL_GPIO_Init+0x6a>
        temp = GPIOx->OSPEEDR;
 807c352:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 807c354:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 807c358:	68cf      	ldr	r7, [r1, #12]
 807c35a:	fa07 f70e 	lsl.w	r7, r7, lr
 807c35e:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 807c362:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 807c364:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 807c366:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 807c36a:	f3c4 1700 	ubfx	r7, r4, #4, #1
 807c36e:	409f      	lsls	r7, r3
 807c370:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 807c374:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 807c376:	68c7      	ldr	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 807c378:	f1ba 0f02 	cmp.w	sl, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 807c37c:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 807c380:	688f      	ldr	r7, [r1, #8]
 807c382:	fa07 f70e 	lsl.w	r7, r7, lr
 807c386:	ea47 070c 	orr.w	r7, r7, ip
      GPIOx->PUPDR = temp;
 807c38a:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 807c38c:	d116      	bne.n	807c3bc <HAL_GPIO_Init+0xb0>
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 807c38e:	f04f 0c0f 	mov.w	ip, #15
        temp = GPIOx->AFR[position >> 3U];
 807c392:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 807c396:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 807c39a:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3U];
 807c39e:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 807c3a2:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 807c3a6:	fa0c fc0b 	lsl.w	ip, ip, fp
 807c3aa:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 807c3ae:	690f      	ldr	r7, [r1, #16]
 807c3b0:	fa07 f70b 	lsl.w	r7, r7, fp
 807c3b4:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3U] = temp;
 807c3b8:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 807c3bc:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 807c3be:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 807c3c0:	f004 0703 	and.w	r7, r4, #3
 807c3c4:	fa07 fe0e 	lsl.w	lr, r7, lr
 807c3c8:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
 807c3cc:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 807c3ce:	00e5      	lsls	r5, r4, #3
 807c3d0:	d550      	bpl.n	807c474 <HAL_GPIO_Init+0x168>
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 807c3d2:	f04f 0c0f 	mov.w	ip, #15
 807c3d6:	f023 0703 	bic.w	r7, r3, #3
 807c3da:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 807c3de:	f507 373d 	add.w	r7, r7, #193536	; 0x2f400
 807c3e2:	f003 0e03 	and.w	lr, r3, #3
        temp = EXTI->EXTICR[position >> 2U];
 807c3e6:	6e3d      	ldr	r5, [r7, #96]	; 0x60
        temp &= ~((0x0FU) << (8U * (position & 0x03U)));
 807c3e8:	ea4f 0ece 	mov.w	lr, lr, lsl #3
 807c3ec:	fa0c fc0e 	lsl.w	ip, ip, lr
 807c3f0:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 807c3f4:	4d27      	ldr	r5, [pc, #156]	; (807c494 <HAL_GPIO_Init+0x188>)
 807c3f6:	42a8      	cmp	r0, r5
 807c3f8:	d03e      	beq.n	807c478 <HAL_GPIO_Init+0x16c>
 807c3fa:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 807c3fe:	42a8      	cmp	r0, r5
 807c400:	d03c      	beq.n	807c47c <HAL_GPIO_Init+0x170>
 807c402:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 807c406:	42a8      	cmp	r0, r5
 807c408:	d03a      	beq.n	807c480 <HAL_GPIO_Init+0x174>
 807c40a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 807c40e:	42a8      	cmp	r0, r5
 807c410:	d038      	beq.n	807c484 <HAL_GPIO_Init+0x178>
 807c412:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 807c416:	42a8      	cmp	r0, r5
 807c418:	d036      	beq.n	807c488 <HAL_GPIO_Init+0x17c>
 807c41a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 807c41e:	42a8      	cmp	r0, r5
 807c420:	d034      	beq.n	807c48c <HAL_GPIO_Init+0x180>
 807c422:	4548      	cmp	r0, r9
 807c424:	bf14      	ite	ne
 807c426:	2507      	movne	r5, #7
 807c428:	2506      	moveq	r5, #6
 807c42a:	fa05 f50e 	lsl.w	r5, r5, lr
 807c42e:	ea45 050c 	orr.w	r5, r5, ip
        EXTI->EXTICR[position >> 2U] = temp;
 807c432:	663d      	str	r5, [r7, #96]	; 0x60
        temp &= ~(iocurrent);
 807c434:	43f7      	mvns	r7, r6
        temp = EXTI->IMR1;
 807c436:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 807c43a:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 807c43e:	bf0c      	ite	eq
 807c440:	403d      	andeq	r5, r7
          temp |= iocurrent;
 807c442:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 807c444:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
        temp = EXTI->EMR1;
 807c448:	f8d2 5084 	ldr.w	r5, [r2, #132]	; 0x84
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 807c44c:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 807c450:	bf0c      	ite	eq
 807c452:	403d      	andeq	r5, r7
          temp |= iocurrent;
 807c454:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 807c456:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
        temp = EXTI->RTSR1;
 807c45a:	6815      	ldr	r5, [r2, #0]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 807c45c:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 807c460:	bf0c      	ite	eq
 807c462:	403d      	andeq	r5, r7
          temp |= iocurrent;
 807c464:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 807c466:	6015      	str	r5, [r2, #0]
        temp = EXTI->FTSR1;
 807c468:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 807c46a:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 807c46c:	bf54      	ite	pl
 807c46e:	403d      	andpl	r5, r7
          temp |= iocurrent;
 807c470:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 807c472:	6055      	str	r5, [r2, #4]
    position++;
 807c474:	3301      	adds	r3, #1
 807c476:	e751      	b.n	807c31c <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 807c478:	2500      	movs	r5, #0
 807c47a:	e7d6      	b.n	807c42a <HAL_GPIO_Init+0x11e>
 807c47c:	2501      	movs	r5, #1
 807c47e:	e7d4      	b.n	807c42a <HAL_GPIO_Init+0x11e>
 807c480:	2502      	movs	r5, #2
 807c482:	e7d2      	b.n	807c42a <HAL_GPIO_Init+0x11e>
 807c484:	2503      	movs	r5, #3
 807c486:	e7d0      	b.n	807c42a <HAL_GPIO_Init+0x11e>
 807c488:	2504      	movs	r5, #4
 807c48a:	e7ce      	b.n	807c42a <HAL_GPIO_Init+0x11e>
 807c48c:	2505      	movs	r5, #5
 807c48e:	e7cc      	b.n	807c42a <HAL_GPIO_Init+0x11e>
 807c490:	4002f400 	.word	0x4002f400
 807c494:	42020000 	.word	0x42020000
 807c498:	42021800 	.word	0x42021800

0807c49c <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 807c49c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0U;
 807c4a0:	2300      	movs	r3, #0

  /* Configure the port pins */
  while ((GPIO_Pin >> position) != 0U)
  {
    /* Get current io position */
    iocurrent = (GPIO_Pin) & (1UL << position);
 807c4a2:	f04f 0901 	mov.w	r9, #1
      temp = EXTI->EXTICR[position >> 2U];
      temp &= ((0x0FUL) << (8U * (position & 0x03U)));
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
 807c4a6:	4c40      	ldr	r4, [pc, #256]	; (807c5a8 <HAL_GPIO_DeInit+0x10c>)
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 807c4a8:	f8df a104 	ldr.w	sl, [pc, #260]	; 807c5b0 <HAL_GPIO_DeInit+0x114>
 807c4ac:	f8df b104 	ldr.w	fp, [pc, #260]	; 807c5b4 <HAL_GPIO_DeInit+0x118>
  while ((GPIO_Pin >> position) != 0U)
 807c4b0:	fa31 f203 	lsrs.w	r2, r1, r3
 807c4b4:	d101      	bne.n	807c4ba <HAL_GPIO_DeInit+0x1e>
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
    }

    position++;
  }
}
 807c4b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1UL << position);
 807c4ba:	fa09 fe03 	lsl.w	lr, r9, r3
    if (iocurrent != 0U)
 807c4be:	ea1e 0501 	ands.w	r5, lr, r1
 807c4c2:	d062      	beq.n	807c58a <HAL_GPIO_DeInit+0xee>
      temp &= ((0x0FUL) << (8U * (position & 0x03U)));
 807c4c4:	270f      	movs	r7, #15
 807c4c6:	f023 0603 	bic.w	r6, r3, #3
 807c4ca:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 807c4ce:	f506 363d 	add.w	r6, r6, #193536	; 0x2f400
 807c4d2:	f003 0c03 	and.w	ip, r3, #3
      temp = EXTI->EXTICR[position >> 2U];
 807c4d6:	6e32      	ldr	r2, [r6, #96]	; 0x60
      temp &= ((0x0FUL) << (8U * (position & 0x03U)));
 807c4d8:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 807c4dc:	fa07 f70c 	lsl.w	r7, r7, ip
 807c4e0:	ea07 0802 	and.w	r8, r7, r2
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 807c4e4:	4a31      	ldr	r2, [pc, #196]	; (807c5ac <HAL_GPIO_DeInit+0x110>)
 807c4e6:	4290      	cmp	r0, r2
 807c4e8:	d051      	beq.n	807c58e <HAL_GPIO_DeInit+0xf2>
 807c4ea:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 807c4ee:	4290      	cmp	r0, r2
 807c4f0:	d04f      	beq.n	807c592 <HAL_GPIO_DeInit+0xf6>
 807c4f2:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 807c4f6:	4290      	cmp	r0, r2
 807c4f8:	d04d      	beq.n	807c596 <HAL_GPIO_DeInit+0xfa>
 807c4fa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 807c4fe:	4290      	cmp	r0, r2
 807c500:	d04b      	beq.n	807c59a <HAL_GPIO_DeInit+0xfe>
 807c502:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 807c506:	4290      	cmp	r0, r2
 807c508:	d049      	beq.n	807c59e <HAL_GPIO_DeInit+0x102>
 807c50a:	4550      	cmp	r0, sl
 807c50c:	d049      	beq.n	807c5a2 <HAL_GPIO_DeInit+0x106>
 807c50e:	4558      	cmp	r0, fp
 807c510:	bf0c      	ite	eq
 807c512:	2206      	moveq	r2, #6
 807c514:	2207      	movne	r2, #7
 807c516:	fa02 f20c 	lsl.w	r2, r2, ip
 807c51a:	4542      	cmp	r2, r8
 807c51c:	d114      	bne.n	807c548 <HAL_GPIO_DeInit+0xac>
        EXTI->IMR1 &= ~(iocurrent);
 807c51e:	43ed      	mvns	r5, r5
 807c520:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 807c524:	402a      	ands	r2, r5
 807c526:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
        EXTI->EMR1 &= ~(iocurrent);
 807c52a:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 807c52e:	402a      	ands	r2, r5
 807c530:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
        EXTI->RTSR1 &= ~(iocurrent);
 807c534:	6822      	ldr	r2, [r4, #0]
 807c536:	402a      	ands	r2, r5
 807c538:	6022      	str	r2, [r4, #0]
        EXTI->FTSR1 &= ~(iocurrent);
 807c53a:	6862      	ldr	r2, [r4, #4]
 807c53c:	4015      	ands	r5, r2
 807c53e:	6065      	str	r5, [r4, #4]
        EXTI->EXTICR[position >> 2U] &= ~temp;
 807c540:	6e32      	ldr	r2, [r6, #96]	; 0x60
 807c542:	ea22 0707 	bic.w	r7, r2, r7
 807c546:	6637      	str	r7, [r6, #96]	; 0x60
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 807c548:	2603      	movs	r6, #3
      GPIOx->AFR[position >> 3U] &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 807c54a:	270f      	movs	r7, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 807c54c:	6805      	ldr	r5, [r0, #0]
 807c54e:	005a      	lsls	r2, r3, #1
 807c550:	fa06 f202 	lsl.w	r2, r6, r2
 807c554:	4315      	orrs	r5, r2
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 807c556:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 807c558:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3U] &= ~(0x0FUL << ((position & 0x07U) * 4U)) ;
 807c55a:	fa23 f506 	lsr.w	r5, r3, r6
 807c55e:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 807c562:	f003 0c07 	and.w	ip, r3, #7
 807c566:	6a2e      	ldr	r6, [r5, #32]
 807c568:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 807c56c:	fa07 f70c 	lsl.w	r7, r7, ip
 807c570:	ea26 0707 	bic.w	r7, r6, r7
 807c574:	622f      	str	r7, [r5, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 807c576:	6885      	ldr	r5, [r0, #8]
 807c578:	4015      	ands	r5, r2
 807c57a:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 807c57c:	6845      	ldr	r5, [r0, #4]
 807c57e:	ea25 050e 	bic.w	r5, r5, lr
 807c582:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 807c584:	68c5      	ldr	r5, [r0, #12]
 807c586:	402a      	ands	r2, r5
 807c588:	60c2      	str	r2, [r0, #12]
    position++;
 807c58a:	3301      	adds	r3, #1
 807c58c:	e790      	b.n	807c4b0 <HAL_GPIO_DeInit+0x14>
      if(temp == (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U))))
 807c58e:	2200      	movs	r2, #0
 807c590:	e7c1      	b.n	807c516 <HAL_GPIO_DeInit+0x7a>
 807c592:	2201      	movs	r2, #1
 807c594:	e7bf      	b.n	807c516 <HAL_GPIO_DeInit+0x7a>
 807c596:	2202      	movs	r2, #2
 807c598:	e7bd      	b.n	807c516 <HAL_GPIO_DeInit+0x7a>
 807c59a:	2203      	movs	r2, #3
 807c59c:	e7bb      	b.n	807c516 <HAL_GPIO_DeInit+0x7a>
 807c59e:	2204      	movs	r2, #4
 807c5a0:	e7b9      	b.n	807c516 <HAL_GPIO_DeInit+0x7a>
 807c5a2:	2205      	movs	r2, #5
 807c5a4:	e7b7      	b.n	807c516 <HAL_GPIO_DeInit+0x7a>
 807c5a6:	bf00      	nop
 807c5a8:	4002f400 	.word	0x4002f400
 807c5ac:	42020000 	.word	0x42020000
 807c5b0:	42021400 	.word	0x42021400
 807c5b4:	42021800 	.word	0x42021800

0807c5b8 <OSPI_ConfigCmd>:
  * @param  hospi : OSPI handle
  * @param  cmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef OSPI_ConfigCmd(OSPI_HandleTypeDef *hospi, OSPI_RegularCmdTypeDef *cmd)
{
 807c5b8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  HAL_StatusTypeDef status = HAL_OK;
  __IO uint32_t *ccr_reg, *tcr_reg, *ir_reg, *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, 0U);
 807c5bc:	6804      	ldr	r4, [r0, #0]
 807c5be:	6823      	ldr	r3, [r4, #0]
 807c5c0:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 807c5c4:	6023      	str	r3, [r4, #0]

  /* Configure the flash ID */
  if (hospi->Init.DualQuad == HAL_OSPI_DUALQUAD_DISABLE)
 807c5c6:	6883      	ldr	r3, [r0, #8]
 807c5c8:	b92b      	cbnz	r3, 807c5d6 <OSPI_ConfigCmd+0x1e>
  {
    MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FSEL, cmd->FlashId);
 807c5ca:	6823      	ldr	r3, [r4, #0]
 807c5cc:	684a      	ldr	r2, [r1, #4]
 807c5ce:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 807c5d2:	4313      	orrs	r3, r2
 807c5d4:	6023      	str	r3, [r4, #0]
  }

  if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 807c5d6:	680b      	ldr	r3, [r1, #0]
 807c5d8:	2b02      	cmp	r3, #2
 807c5da:	d14e      	bne.n	807c67a <OSPI_ConfigCmd+0xc2>
  {
    ccr_reg = &(hospi->Instance->WCCR);
 807c5dc:	f504 72c0 	add.w	r2, r4, #384	; 0x180
    tcr_reg = &(hospi->Instance->WTCR);
 807c5e0:	f504 76c4 	add.w	r6, r4, #392	; 0x188
    ir_reg  = &(hospi->Instance->WIR);
 807c5e4:	f504 75c8 	add.w	r5, r4, #400	; 0x190
    abr_reg = &(hospi->Instance->WABR);
 807c5e8:	f504 7cd0 	add.w	ip, r4, #416	; 0x1a0
    ir_reg  = &(hospi->Instance->IR);
    abr_reg = &(hospi->Instance->ABR);
  }

  /* Configure the CCR register with DQS and SIOO modes */
  *ccr_reg = (cmd->DQSMode | cmd->SIOOMode);
 807c5ec:	e9d1 3712 	ldrd	r3, r7, [r1, #72]	; 0x48
 807c5f0:	433b      	orrs	r3, r7
 807c5f2:	6013      	str	r3, [r2, #0]

  if (cmd->AlternateBytesMode != HAL_OSPI_ALTERNATE_BYTES_NONE)
 807c5f4:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 807c5f6:	b16b      	cbz	r3, 807c614 <OSPI_ConfigCmd+0x5c>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = cmd->AlternateBytes;
 807c5f8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 807c5fa:	f8cc 3000 	str.w	r3, [ip]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ABMODE | OCTOSPI_CCR_ABDTR | OCTOSPI_CCR_ABSIZE),
 807c5fe:	6b4f      	ldr	r7, [r1, #52]	; 0x34
 807c600:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 807c602:	f8d2 c000 	ldr.w	ip, [r2]
 807c606:	433b      	orrs	r3, r7
 807c608:	6b0f      	ldr	r7, [r1, #48]	; 0x30
 807c60a:	433b      	orrs	r3, r7
 807c60c:	f42c 177c 	bic.w	r7, ip, #4128768	; 0x3f0000
 807c610:	433b      	orrs	r3, r7
 807c612:	6013      	str	r3, [r2, #0]
                           (cmd->AlternateBytesMode | cmd->AlternateBytesDtrMode | cmd->AlternateBytesSize));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), OCTOSPI_TCR_DCYC, cmd->DummyCycles);
 807c614:	6833      	ldr	r3, [r6, #0]
 807c616:	6c4f      	ldr	r7, [r1, #68]	; 0x44
 807c618:	f023 031f 	bic.w	r3, r3, #31
 807c61c:	433b      	orrs	r3, r7
 807c61e:	6033      	str	r3, [r6, #0]

  if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 807c620:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 807c622:	b123      	cbz	r3, 807c62e <OSPI_ConfigCmd+0x76>
  {
    if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 807c624:	680e      	ldr	r6, [r1, #0]
 807c626:	b916      	cbnz	r6, 807c62e <OSPI_ConfigCmd+0x76>
    {
      /* Configure the DLR register with the number of data */
      hospi->Instance->DLR = (cmd->NbData - 1U);
 807c628:	6bce      	ldr	r6, [r1, #60]	; 0x3c
 807c62a:	3e01      	subs	r6, #1
 807c62c:	6426      	str	r6, [r4, #64]	; 0x40
    }
  }

  if (cmd->InstructionMode != HAL_OSPI_INSTRUCTION_NONE)
 807c62e:	f8d1 a00c 	ldr.w	sl, [r1, #12]
 807c632:	f8d1 901c 	ldr.w	r9, [r1, #28]
 807c636:	f1ba 0f00 	cmp.w	sl, #0
 807c63a:	d076      	beq.n	807c72a <OSPI_ConfigCmd+0x172>
 807c63c:	e9d1 e804 	ldrd	lr, r8, [r1, #16]
  {
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 807c640:	f1b9 0f00 	cmp.w	r9, #0
 807c644:	d047      	beq.n	807c6d6 <OSPI_ConfigCmd+0x11e>
 807c646:	e9d1 6c08 	ldrd	r6, ip, [r1, #32]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 807c64a:	6817      	ldr	r7, [r2, #0]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 807c64c:	b34b      	cbz	r3, 807c6a2 <OSPI_ConfigCmd+0xea>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 807c64e:	ea43 000a 	orr.w	r0, r3, sl
 807c652:	ea40 0309 	orr.w	r3, r0, r9
 807c656:	ea43 0308 	orr.w	r3, r3, r8
 807c65a:	ea43 030e 	orr.w	r3, r3, lr
 807c65e:	6c08      	ldr	r0, [r1, #64]	; 0x40
 807c660:	ea43 030c 	orr.w	r3, r3, ip
 807c664:	4333      	orrs	r3, r6
 807c666:	4303      	orrs	r3, r0
 807c668:	483e      	ldr	r0, [pc, #248]	; (807c764 <OSPI_ConfigCmd+0x1ac>)
 807c66a:	4038      	ands	r0, r7
 807c66c:	4303      	orrs	r3, r0

        /* The DHQC bit is linked with DDTR bit which should be activated */
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
            (cmd->InstructionDtrMode == HAL_OSPI_INSTRUCTION_DTR_ENABLE))
        {
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 807c66e:	6013      	str	r3, [r2, #0]
        }
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = cmd->Instruction;
 807c670:	688b      	ldr	r3, [r1, #8]
 807c672:	602b      	str	r3, [r5, #0]
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
                               (cmd->AddressMode | cmd->AddressDtrMode | cmd->AddressSize));
      }

      /* Configure the AR register with the instruction value */
      hospi->Instance->AR = cmd->Address;
 807c674:	698b      	ldr	r3, [r1, #24]
 807c676:	64a3      	str	r3, [r4, #72]	; 0x48
 807c678:	e040      	b.n	807c6fc <OSPI_ConfigCmd+0x144>
  else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG)
 807c67a:	2b03      	cmp	r3, #3
    ccr_reg = &(hospi->Instance->WPCCR);
 807c67c:	bf01      	itttt	eq
 807c67e:	f504 72a0 	addeq.w	r2, r4, #320	; 0x140
    tcr_reg = &(hospi->Instance->WPTCR);
 807c682:	f504 76a4 	addeq.w	r6, r4, #328	; 0x148
    ir_reg  = &(hospi->Instance->WPIR);
 807c686:	f504 75a8 	addeq.w	r5, r4, #336	; 0x150
    abr_reg = &(hospi->Instance->WPABR);
 807c68a:	f504 7cb0 	addeq.w	ip, r4, #352	; 0x160
    ccr_reg = &(hospi->Instance->CCR);
 807c68e:	bf1f      	itttt	ne
 807c690:	f504 7280 	addne.w	r2, r4, #256	; 0x100
    tcr_reg = &(hospi->Instance->TCR);
 807c694:	f504 7684 	addne.w	r6, r4, #264	; 0x108
    ir_reg  = &(hospi->Instance->IR);
 807c698:	f504 7588 	addne.w	r5, r4, #272	; 0x110
    abr_reg = &(hospi->Instance->ABR);
 807c69c:	f504 7c90 	addne.w	ip, r4, #288	; 0x120
 807c6a0:	e7a4      	b.n	807c5ec <OSPI_ConfigCmd+0x34>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE  | OCTOSPI_CCR_IDTR  | OCTOSPI_CCR_ISIZE  |
 807c6a2:	ea4a 0309 	orr.w	r3, sl, r9
 807c6a6:	ea43 0308 	orr.w	r3, r3, r8
 807c6aa:	ea43 030e 	orr.w	r3, r3, lr
 807c6ae:	ea43 030c 	orr.w	r3, r3, ip
 807c6b2:	f427 577c 	bic.w	r7, r7, #16128	; 0x3f00
 807c6b6:	4333      	orrs	r3, r6
 807c6b8:	f027 073f 	bic.w	r7, r7, #63	; 0x3f
 807c6bc:	433b      	orrs	r3, r7
 807c6be:	6013      	str	r3, [r2, #0]
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 807c6c0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 807c6c2:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 807c6c6:	d1d3      	bne.n	807c670 <OSPI_ConfigCmd+0xb8>
 807c6c8:	694b      	ldr	r3, [r1, #20]
 807c6ca:	2b08      	cmp	r3, #8
 807c6cc:	d1d0      	bne.n	807c670 <OSPI_ConfigCmd+0xb8>
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 807c6ce:	6813      	ldr	r3, [r2, #0]
 807c6d0:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 807c6d4:	e7cb      	b.n	807c66e <OSPI_ConfigCmd+0xb6>
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 807c6d6:	b1a3      	cbz	r3, 807c702 <OSPI_ConfigCmd+0x14a>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE |
 807c6d8:	6810      	ldr	r0, [r2, #0]
 807c6da:	ea43 030a 	orr.w	r3, r3, sl
 807c6de:	ea43 0308 	orr.w	r3, r3, r8
 807c6e2:	6c0c      	ldr	r4, [r1, #64]	; 0x40
 807c6e4:	ea43 030e 	orr.w	r3, r3, lr
 807c6e8:	f020 6e70 	bic.w	lr, r0, #251658240	; 0xf000000
 807c6ec:	4323      	orrs	r3, r4
 807c6ee:	f02e 0e3f 	bic.w	lr, lr, #63	; 0x3f
 807c6f2:	ea43 030e 	orr.w	r3, r3, lr
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 807c6f6:	6013      	str	r3, [r2, #0]
      *ir_reg = cmd->Instruction;
 807c6f8:	688b      	ldr	r3, [r1, #8]
 807c6fa:	602b      	str	r3, [r5, #0]
  HAL_StatusTypeDef status = HAL_OK;
 807c6fc:	2000      	movs	r0, #0
    }
  }

  /* Return function status */
  return status;
}
 807c6fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_IMODE | OCTOSPI_CCR_IDTR | OCTOSPI_CCR_ISIZE),
 807c702:	6814      	ldr	r4, [r2, #0]
 807c704:	ea4a 0308 	orr.w	r3, sl, r8
 807c708:	ea43 030e 	orr.w	r3, r3, lr
 807c70c:	f024 043f 	bic.w	r4, r4, #63	; 0x3f
 807c710:	4323      	orrs	r3, r4
 807c712:	6013      	str	r3, [r2, #0]
        if ((hospi->Init.DelayHoldQuarterCycle == HAL_OSPI_DHQC_ENABLE) &&
 807c714:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 807c716:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 807c71a:	d1ed      	bne.n	807c6f8 <OSPI_ConfigCmd+0x140>
 807c71c:	694b      	ldr	r3, [r1, #20]
 807c71e:	2b08      	cmp	r3, #8
 807c720:	d1ea      	bne.n	807c6f8 <OSPI_ConfigCmd+0x140>
          MODIFY_REG((*ccr_reg), OCTOSPI_CCR_DDTR, HAL_OSPI_DATA_DTR_ENABLE);
 807c722:	6813      	ldr	r3, [r2, #0]
 807c724:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 807c728:	e7e5      	b.n	807c6f6 <OSPI_ConfigCmd+0x13e>
    if (cmd->AddressMode != HAL_OSPI_ADDRESS_NONE)
 807c72a:	f1b9 0f00 	cmp.w	r9, #0
 807c72e:	d014      	beq.n	807c75a <OSPI_ConfigCmd+0x1a2>
 807c730:	e9d1 5608 	ldrd	r5, r6, [r1, #32]
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 807c734:	6810      	ldr	r0, [r2, #0]
      if (cmd->DataMode != HAL_OSPI_DATA_NONE)
 807c736:	b163      	cbz	r3, 807c752 <OSPI_ConfigCmd+0x19a>
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE |
 807c738:	ea43 0309 	orr.w	r3, r3, r9
 807c73c:	4333      	orrs	r3, r6
 807c73e:	432b      	orrs	r3, r5
 807c740:	6c0d      	ldr	r5, [r1, #64]	; 0x40
 807c742:	f020 6070 	bic.w	r0, r0, #251658240	; 0xf000000
 807c746:	432b      	orrs	r3, r5
        MODIFY_REG((*ccr_reg), (OCTOSPI_CCR_ADMODE | OCTOSPI_CCR_ADDTR | OCTOSPI_CCR_ADSIZE),
 807c748:	f420 507c 	bic.w	r0, r0, #16128	; 0x3f00
 807c74c:	4303      	orrs	r3, r0
 807c74e:	6013      	str	r3, [r2, #0]
 807c750:	e790      	b.n	807c674 <OSPI_ConfigCmd+0xbc>
 807c752:	ea49 0306 	orr.w	r3, r9, r6
 807c756:	432b      	orrs	r3, r5
 807c758:	e7f6      	b.n	807c748 <OSPI_ConfigCmd+0x190>
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 807c75a:	2308      	movs	r3, #8
 807c75c:	6503      	str	r3, [r0, #80]	; 0x50
      status = HAL_ERROR;
 807c75e:	2001      	movs	r0, #1
 807c760:	e7cd      	b.n	807c6fe <OSPI_ConfigCmd+0x146>
 807c762:	bf00      	nop
 807c764:	f0ffc0c0 	.word	0xf0ffc0c0

0807c768 <OSPI_WaitFlagStateUntilTimeout>:
{
 807c768:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 807c76c:	4604      	mov	r4, r0
 807c76e:	460f      	mov	r7, r1
 807c770:	4616      	mov	r6, r2
 807c772:	4698      	mov	r8, r3
 807c774:	9d06      	ldr	r5, [sp, #24]
  while((__HAL_OSPI_GET_FLAG(hospi, Flag)) != State)
 807c776:	6821      	ldr	r1, [r4, #0]
 807c778:	6a0a      	ldr	r2, [r1, #32]
 807c77a:	423a      	tst	r2, r7
 807c77c:	bf14      	ite	ne
 807c77e:	2201      	movne	r2, #1
 807c780:	2200      	moveq	r2, #0
 807c782:	42b2      	cmp	r2, r6
 807c784:	d101      	bne.n	807c78a <OSPI_WaitFlagStateUntilTimeout+0x22>
  return HAL_OK;
 807c786:	2000      	movs	r0, #0
 807c788:	e011      	b.n	807c7ae <OSPI_WaitFlagStateUntilTimeout+0x46>
    if (Timeout != HAL_MAX_DELAY)
 807c78a:	1c6b      	adds	r3, r5, #1
 807c78c:	d0f4      	beq.n	807c778 <OSPI_WaitFlagStateUntilTimeout+0x10>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 807c78e:	f7fe fab7 	bl	807ad00 <HAL_GetTick>
 807c792:	eba0 0008 	sub.w	r0, r0, r8
 807c796:	42a8      	cmp	r0, r5
 807c798:	d801      	bhi.n	807c79e <OSPI_WaitFlagStateUntilTimeout+0x36>
 807c79a:	2d00      	cmp	r5, #0
 807c79c:	d1eb      	bne.n	807c776 <OSPI_WaitFlagStateUntilTimeout+0xe>
        hospi->State     = HAL_OSPI_STATE_ERROR;
 807c79e:	f44f 7300 	mov.w	r3, #512	; 0x200
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 807c7a2:	2001      	movs	r0, #1
        hospi->State     = HAL_OSPI_STATE_ERROR;
 807c7a4:	64e3      	str	r3, [r4, #76]	; 0x4c
        hospi->ErrorCode |= HAL_OSPI_ERROR_TIMEOUT;
 807c7a6:	6d23      	ldr	r3, [r4, #80]	; 0x50
 807c7a8:	f043 0301 	orr.w	r3, r3, #1
 807c7ac:	6523      	str	r3, [r4, #80]	; 0x50
}
 807c7ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0807c7b2 <HAL_OSPI_MspInit>:
}
 807c7b2:	4770      	bx	lr

0807c7b4 <HAL_OSPI_Init>:
{
 807c7b4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 807c7b6:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 807c7b8:	f7fe faa2 	bl	807ad00 <HAL_GetTick>
 807c7bc:	4606      	mov	r6, r0
  if (hospi == NULL)
 807c7be:	2c00      	cmp	r4, #0
 807c7c0:	d064      	beq.n	807c88c <HAL_OSPI_Init+0xd8>
    hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 807c7c2:	2000      	movs	r0, #0
 807c7c4:	6520      	str	r0, [r4, #80]	; 0x50
    if (hospi->State == HAL_OSPI_STATE_RESET)
 807c7c6:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 807c7c8:	2d00      	cmp	r5, #0
 807c7ca:	d15d      	bne.n	807c888 <HAL_OSPI_Init+0xd4>
      HAL_OSPI_MspInit(hospi);
 807c7cc:	4620      	mov	r0, r4
 807c7ce:	f7ff fff0 	bl	807c7b2 <HAL_OSPI_MspInit>
  hospi->Timeout = Timeout;
 807c7d2:	f241 3388 	movw	r3, #5000	; 0x1388
      MODIFY_REG(hospi->Instance->DCR1,
 807c7d6:	6b62      	ldr	r2, [r4, #52]	; 0x34
 807c7d8:	68e1      	ldr	r1, [r4, #12]
 807c7da:	6820      	ldr	r0, [r4, #0]
 807c7dc:	4311      	orrs	r1, r2
 807c7de:	69e2      	ldr	r2, [r4, #28]
 807c7e0:	6887      	ldr	r7, [r0, #8]
 807c7e2:	4311      	orrs	r1, r2
 807c7e4:	4a2a      	ldr	r2, [pc, #168]	; (807c890 <HAL_OSPI_Init+0xdc>)
  hospi->Timeout = Timeout;
 807c7e6:	6563      	str	r3, [r4, #84]	; 0x54
      MODIFY_REG(hospi->Instance->DCR1,
 807c7e8:	403a      	ands	r2, r7
 807c7ea:	4311      	orrs	r1, r2
 807c7ec:	6922      	ldr	r2, [r4, #16]
 807c7ee:	3a01      	subs	r2, #1
 807c7f0:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 807c7f4:	6962      	ldr	r2, [r4, #20]
 807c7f6:	3a01      	subs	r2, #1
 807c7f8:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 807c7fc:	6081      	str	r1, [r0, #8]
      MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_WRAPSIZE, hospi->Init.WrapSize);
 807c7fe:	68c2      	ldr	r2, [r0, #12]
 807c800:	6a21      	ldr	r1, [r4, #32]
 807c802:	f422 22e0 	bic.w	r2, r2, #458752	; 0x70000
 807c806:	430a      	orrs	r2, r1
 807c808:	60c2      	str	r2, [r0, #12]
      hospi->Instance->DCR3 = (hospi->Init.ChipSelectBoundary << OCTOSPI_DCR3_CSBOUND_Pos);
 807c80a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 807c80c:	0412      	lsls	r2, r2, #16
 807c80e:	6102      	str	r2, [r0, #16]
      hospi->Instance->DCR4 = hospi->Init.Refresh;
 807c810:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 807c812:	6142      	str	r2, [r0, #20]
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FTHRES, ((hospi->Init.FifoThreshold - 1U) << OCTOSPI_CR_FTHRES_Pos));
 807c814:	6801      	ldr	r1, [r0, #0]
 807c816:	6862      	ldr	r2, [r4, #4]
 807c818:	f421 51f8 	bic.w	r1, r1, #7936	; 0x1f00
 807c81c:	3a01      	subs	r2, #1
 807c81e:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
 807c822:	6001      	str	r1, [r0, #0]
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 807c824:	462a      	mov	r2, r5
 807c826:	9300      	str	r3, [sp, #0]
 807c828:	2120      	movs	r1, #32
 807c82a:	4633      	mov	r3, r6
 807c82c:	4620      	mov	r0, r4
 807c82e:	f7ff ff9b 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 807c832:	bb48      	cbnz	r0, 807c888 <HAL_OSPI_Init+0xd4>
        MODIFY_REG(hospi->Instance->DCR2, OCTOSPI_DCR2_PRESCALER, ((hospi->Init.ClockPrescaler - 1U) << OCTOSPI_DCR2_PRESCALER_Pos));
 807c834:	6823      	ldr	r3, [r4, #0]
 807c836:	6a62      	ldr	r2, [r4, #36]	; 0x24
 807c838:	68d9      	ldr	r1, [r3, #12]
 807c83a:	3a01      	subs	r2, #1
 807c83c:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
 807c840:	430a      	orrs	r2, r1
 807c842:	60da      	str	r2, [r3, #12]
        MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_DQM, hospi->Init.DualQuad);
 807c844:	681a      	ldr	r2, [r3, #0]
 807c846:	68a1      	ldr	r1, [r4, #8]
 807c848:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 807c84c:	430a      	orrs	r2, r1
 807c84e:	601a      	str	r2, [r3, #0]
        MODIFY_REG(hospi->Instance->TCR, (OCTOSPI_TCR_SSHIFT | OCTOSPI_TCR_DHQC), (hospi->Init.SampleShifting | hospi->Init.DelayHoldQuarterCycle));
 807c850:	f8d3 1108 	ldr.w	r1, [r3, #264]	; 0x108
 807c854:	e9d4 250a 	ldrd	r2, r5, [r4, #40]	; 0x28
 807c858:	f021 41a0 	bic.w	r1, r1, #1342177280	; 0x50000000
 807c85c:	432a      	orrs	r2, r5
 807c85e:	430a      	orrs	r2, r1
 807c860:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
        __HAL_OSPI_ENABLE(hospi);
 807c864:	681a      	ldr	r2, [r3, #0]
 807c866:	f042 0201 	orr.w	r2, r2, #1
 807c86a:	601a      	str	r2, [r3, #0]
        if (hospi->Init.FreeRunningClock == HAL_OSPI_FREERUNCLK_ENABLE)
 807c86c:	69a2      	ldr	r2, [r4, #24]
 807c86e:	2a02      	cmp	r2, #2
          SET_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 807c870:	bf02      	ittt	eq
 807c872:	689a      	ldreq	r2, [r3, #8]
 807c874:	f042 0202 	orreq.w	r2, r2, #2
 807c878:	609a      	streq	r2, [r3, #8]
        if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 807c87a:	68e3      	ldr	r3, [r4, #12]
 807c87c:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
          hospi->State = HAL_OSPI_STATE_HYPERBUS_INIT;
 807c880:	bf0c      	ite	eq
 807c882:	2301      	moveq	r3, #1
          hospi->State = HAL_OSPI_STATE_READY;
 807c884:	2302      	movne	r3, #2
 807c886:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 807c888:	b003      	add	sp, #12
 807c88a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_ERROR;
 807c88c:	2001      	movs	r0, #1
 807c88e:	e7fb      	b.n	807c888 <HAL_OSPI_Init+0xd4>
 807c890:	f8e0f8f4 	.word	0xf8e0f8f4

0807c894 <HAL_OSPI_MspDeInit>:
 807c894:	4770      	bx	lr

0807c896 <HAL_OSPI_DeInit>:
{
 807c896:	b510      	push	{r4, lr}
  if (hospi == NULL)
 807c898:	4604      	mov	r4, r0
 807c89a:	b168      	cbz	r0, 807c8b8 <HAL_OSPI_DeInit+0x22>
     __HAL_OSPI_DISABLE(hospi);
 807c89c:	6803      	ldr	r3, [r0, #0]
 807c89e:	681a      	ldr	r2, [r3, #0]
 807c8a0:	f022 0201 	bic.w	r2, r2, #1
 807c8a4:	601a      	str	r2, [r3, #0]
     CLEAR_BIT(hospi->Instance->DCR1, OCTOSPI_DCR1_FRCK);
 807c8a6:	689a      	ldr	r2, [r3, #8]
 807c8a8:	f022 0202 	bic.w	r2, r2, #2
 807c8ac:	609a      	str	r2, [r3, #8]
     HAL_OSPI_MspDeInit(hospi);
 807c8ae:	f7ff fff1 	bl	807c894 <HAL_OSPI_MspDeInit>
     hospi->State = HAL_OSPI_STATE_RESET;
 807c8b2:	2000      	movs	r0, #0
 807c8b4:	64e0      	str	r0, [r4, #76]	; 0x4c
}
 807c8b6:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 807c8b8:	2001      	movs	r0, #1
 807c8ba:	e7fc      	b.n	807c8b6 <HAL_OSPI_DeInit+0x20>

0807c8bc <HAL_OSPI_Command>:
{
 807c8bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 807c8be:	4604      	mov	r4, r0
 807c8c0:	460d      	mov	r5, r1
 807c8c2:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 807c8c4:	f7fe fa1c 	bl	807ad00 <HAL_GetTick>
  state = hospi->State;
 807c8c8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  uint32_t tickstart = HAL_GetTick();
 807c8ca:	4606      	mov	r6, r0
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 807c8cc:	2b02      	cmp	r3, #2
 807c8ce:	d107      	bne.n	807c8e0 <HAL_OSPI_Command+0x24>
 807c8d0:	68e3      	ldr	r3, [r4, #12]
 807c8d2:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 807c8d6:	d109      	bne.n	807c8ec <HAL_OSPI_Command+0x30>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807c8d8:	2310      	movs	r3, #16
    status = HAL_ERROR;
 807c8da:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807c8dc:	6523      	str	r3, [r4, #80]	; 0x50
 807c8de:	e01f      	b.n	807c920 <HAL_OSPI_Command+0x64>
  if (((state == HAL_OSPI_STATE_READY)         && (hospi->Init.MemoryType != HAL_OSPI_MEMTYPE_HYPERBUS)) ||
 807c8e0:	2b14      	cmp	r3, #20
 807c8e2:	d11f      	bne.n	807c924 <HAL_OSPI_Command+0x68>
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && ((cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG) || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))) ||
 807c8e4:	682b      	ldr	r3, [r5, #0]
 807c8e6:	3b02      	subs	r3, #2
 807c8e8:	2b01      	cmp	r3, #1
 807c8ea:	d8f5      	bhi.n	807c8d8 <HAL_OSPI_Command+0x1c>
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 807c8ec:	9700      	str	r7, [sp, #0]
 807c8ee:	4633      	mov	r3, r6
 807c8f0:	2200      	movs	r2, #0
 807c8f2:	2120      	movs	r1, #32
 807c8f4:	4620      	mov	r0, r4
 807c8f6:	f7ff ff37 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 807c8fa:	b988      	cbnz	r0, 807c920 <HAL_OSPI_Command+0x64>
      hospi->ErrorCode = HAL_OSPI_ERROR_NONE;
 807c8fc:	6520      	str	r0, [r4, #80]	; 0x50
      status = OSPI_ConfigCmd(hospi, cmd);
 807c8fe:	4629      	mov	r1, r5
 807c900:	4620      	mov	r0, r4
 807c902:	f7ff fe59 	bl	807c5b8 <OSPI_ConfigCmd>
      if (status == HAL_OK)
 807c906:	b958      	cbnz	r0, 807c920 <HAL_OSPI_Command+0x64>
        if (cmd->DataMode == HAL_OSPI_DATA_NONE)
 807c908:	6bab      	ldr	r3, [r5, #56]	; 0x38
 807c90a:	b99b      	cbnz	r3, 807c934 <HAL_OSPI_Command+0x78>
          status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 807c90c:	4633      	mov	r3, r6
 807c90e:	2201      	movs	r2, #1
 807c910:	9700      	str	r7, [sp, #0]
 807c912:	2102      	movs	r1, #2
 807c914:	4620      	mov	r0, r4
 807c916:	f7ff ff27 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 807c91a:	2202      	movs	r2, #2
 807c91c:	6823      	ldr	r3, [r4, #0]
 807c91e:	625a      	str	r2, [r3, #36]	; 0x24
}
 807c920:	b003      	add	sp, #12
 807c922:	bdf0      	pop	{r4, r5, r6, r7, pc}
      ((state == HAL_OSPI_STATE_READ_CMD_CFG)  && ((cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG) || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))) ||
 807c924:	2b24      	cmp	r3, #36	; 0x24
 807c926:	d1d7      	bne.n	807c8d8 <HAL_OSPI_Command+0x1c>
      ((state == HAL_OSPI_STATE_WRITE_CMD_CFG) && ((cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)  || (cmd->OperationType == HAL_OSPI_OPTYPE_WRAP_CFG))))
 807c928:	682b      	ldr	r3, [r5, #0]
 807c92a:	f023 0302 	bic.w	r3, r3, #2
 807c92e:	2b01      	cmp	r3, #1
 807c930:	d1d2      	bne.n	807c8d8 <HAL_OSPI_Command+0x1c>
 807c932:	e7db      	b.n	807c8ec <HAL_OSPI_Command+0x30>
          if (cmd->OperationType == HAL_OSPI_OPTYPE_COMMON_CFG)
 807c934:	682b      	ldr	r3, [r5, #0]
 807c936:	b90b      	cbnz	r3, 807c93c <HAL_OSPI_Command+0x80>
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 807c938:	2304      	movs	r3, #4
 807c93a:	e005      	b.n	807c948 <HAL_OSPI_Command+0x8c>
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_READ_CFG)
 807c93c:	2b01      	cmp	r3, #1
 807c93e:	d105      	bne.n	807c94c <HAL_OSPI_Command+0x90>
            if (hospi->State == HAL_OSPI_STATE_WRITE_CMD_CFG)
 807c940:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 807c942:	2b24      	cmp	r3, #36	; 0x24
 807c944:	d0f8      	beq.n	807c938 <HAL_OSPI_Command+0x7c>
              hospi->State = HAL_OSPI_STATE_READ_CMD_CFG;
 807c946:	2314      	movs	r3, #20
              hospi->State = HAL_OSPI_STATE_CMD_CFG;
 807c948:	64e3      	str	r3, [r4, #76]	; 0x4c
 807c94a:	e7e9      	b.n	807c920 <HAL_OSPI_Command+0x64>
          else if (cmd->OperationType == HAL_OSPI_OPTYPE_WRITE_CFG)
 807c94c:	2b02      	cmp	r3, #2
 807c94e:	d1e7      	bne.n	807c920 <HAL_OSPI_Command+0x64>
            if (hospi->State == HAL_OSPI_STATE_READ_CMD_CFG)
 807c950:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 807c952:	2b14      	cmp	r3, #20
 807c954:	d0f0      	beq.n	807c938 <HAL_OSPI_Command+0x7c>
              hospi->State = HAL_OSPI_STATE_WRITE_CMD_CFG;
 807c956:	2324      	movs	r3, #36	; 0x24
 807c958:	e7f6      	b.n	807c948 <HAL_OSPI_Command+0x8c>

0807c95a <HAL_OSPI_Transmit>:
{
 807c95a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 807c95e:	4604      	mov	r4, r0
 807c960:	4688      	mov	r8, r1
 807c962:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 807c964:	f7fe f9cc 	bl	807ad00 <HAL_GetTick>
 807c968:	4606      	mov	r6, r0
  if (pData == NULL)
 807c96a:	f1b8 0f00 	cmp.w	r8, #0
 807c96e:	d103      	bne.n	807c978 <HAL_OSPI_Transmit+0x1e>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 807c970:	2308      	movs	r3, #8
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807c972:	6523      	str	r3, [r4, #80]	; 0x50
      status = HAL_ERROR;
 807c974:	2001      	movs	r0, #1
 807c976:	e02f      	b.n	807c9d8 <HAL_OSPI_Transmit+0x7e>
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 807c978:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 807c97a:	2b04      	cmp	r3, #4
 807c97c:	d12f      	bne.n	807c9de <HAL_OSPI_Transmit+0x84>
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 807c97e:	6825      	ldr	r5, [r4, #0]
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 807c980:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      hospi->pBuffPtr  = pData;
 807c982:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 807c986:	3301      	adds	r3, #1
 807c988:	6463      	str	r3, [r4, #68]	; 0x44
      hospi->XferSize  = hospi->XferCount;
 807c98a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 807c98c:	6423      	str	r3, [r4, #64]	; 0x40
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 807c98e:	682b      	ldr	r3, [r5, #0]
 807c990:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 807c994:	602b      	str	r3, [r5, #0]
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_FT, SET, tickstart, Timeout);
 807c996:	9700      	str	r7, [sp, #0]
 807c998:	4633      	mov	r3, r6
 807c99a:	2201      	movs	r2, #1
 807c99c:	2104      	movs	r1, #4
 807c99e:	4620      	mov	r0, r4
 807c9a0:	f7ff fee2 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
 807c9a4:	b9c0      	cbnz	r0, 807c9d8 <HAL_OSPI_Transmit+0x7e>
        *((__IO uint8_t *)data_reg) = *hospi->pBuffPtr;
 807c9a6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 807c9a8:	781b      	ldrb	r3, [r3, #0]
 807c9aa:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
        hospi->pBuffPtr++;
 807c9ae:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 807c9b0:	3301      	adds	r3, #1
 807c9b2:	63e3      	str	r3, [r4, #60]	; 0x3c
        hospi->XferCount--;
 807c9b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 807c9b6:	3b01      	subs	r3, #1
 807c9b8:	6463      	str	r3, [r4, #68]	; 0x44
      } while (hospi->XferCount > 0U);
 807c9ba:	6c63      	ldr	r3, [r4, #68]	; 0x44
 807c9bc:	2b00      	cmp	r3, #0
 807c9be:	d1ea      	bne.n	807c996 <HAL_OSPI_Transmit+0x3c>
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 807c9c0:	9700      	str	r7, [sp, #0]
 807c9c2:	4633      	mov	r3, r6
 807c9c4:	2201      	movs	r2, #1
 807c9c6:	2102      	movs	r1, #2
 807c9c8:	4620      	mov	r0, r4
 807c9ca:	f7ff fecd 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 807c9ce:	b918      	cbnz	r0, 807c9d8 <HAL_OSPI_Transmit+0x7e>
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 807c9d0:	2302      	movs	r3, #2
 807c9d2:	6822      	ldr	r2, [r4, #0]
 807c9d4:	6253      	str	r3, [r2, #36]	; 0x24
          hospi->State = HAL_OSPI_STATE_READY;
 807c9d6:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 807c9d8:	b002      	add	sp, #8
 807c9da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807c9de:	2310      	movs	r3, #16
 807c9e0:	e7c7      	b.n	807c972 <HAL_OSPI_Transmit+0x18>

0807c9e2 <HAL_OSPI_Receive>:
{
 807c9e2:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 807c9e6:	4604      	mov	r4, r0
 807c9e8:	4688      	mov	r8, r1
 807c9ea:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 807c9ec:	f7fe f988 	bl	807ad00 <HAL_GetTick>
  __IO uint32_t *data_reg = &hospi->Instance->DR;
 807c9f0:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
 807c9f2:	4606      	mov	r6, r0
  uint32_t addr_reg = hospi->Instance->AR;
 807c9f4:	6caa      	ldr	r2, [r5, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 807c9f6:	f8d5 1110 	ldr.w	r1, [r5, #272]	; 0x110
  if (pData == NULL)
 807c9fa:	f1b8 0f00 	cmp.w	r8, #0
 807c9fe:	d103      	bne.n	807ca08 <HAL_OSPI_Receive+0x26>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_PARAM;
 807ca00:	2308      	movs	r3, #8
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807ca02:	6523      	str	r3, [r4, #80]	; 0x50
      status = HAL_ERROR;
 807ca04:	2001      	movs	r0, #1
 807ca06:	e035      	b.n	807ca74 <HAL_OSPI_Receive+0x92>
    if (hospi->State == HAL_OSPI_STATE_CMD_CFG)
 807ca08:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 807ca0a:	2b04      	cmp	r3, #4
 807ca0c:	d13d      	bne.n	807ca8a <HAL_OSPI_Receive+0xa8>
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 807ca0e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
      hospi->pBuffPtr  = pData;
 807ca10:	f8c4 803c 	str.w	r8, [r4, #60]	; 0x3c
      hospi->XferCount = READ_REG(hospi->Instance->DLR) + 1U;
 807ca14:	3301      	adds	r3, #1
 807ca16:	6463      	str	r3, [r4, #68]	; 0x44
      hospi->XferSize  = hospi->XferCount;
 807ca18:	6c63      	ldr	r3, [r4, #68]	; 0x44
 807ca1a:	6423      	str	r3, [r4, #64]	; 0x40
      MODIFY_REG(hospi->Instance->CR, OCTOSPI_CR_FMODE, OSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 807ca1c:	682b      	ldr	r3, [r5, #0]
 807ca1e:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 807ca22:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 807ca26:	602b      	str	r3, [r5, #0]
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 807ca28:	68e3      	ldr	r3, [r4, #12]
 807ca2a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 807ca2e:	d124      	bne.n	807ca7a <HAL_OSPI_Receive+0x98>
          WRITE_REG(hospi->Instance->AR, addr_reg);
 807ca30:	64aa      	str	r2, [r5, #72]	; 0x48
        status = OSPI_WaitFlagStateUntilTimeout(hospi, (HAL_OSPI_FLAG_FT | HAL_OSPI_FLAG_TC), SET, tickstart, Timeout);
 807ca32:	9700      	str	r7, [sp, #0]
 807ca34:	4633      	mov	r3, r6
 807ca36:	2201      	movs	r2, #1
 807ca38:	2106      	movs	r1, #6
 807ca3a:	4620      	mov	r0, r4
 807ca3c:	f7ff fe94 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
 807ca40:	b9c0      	cbnz	r0, 807ca74 <HAL_OSPI_Receive+0x92>
        *hospi->pBuffPtr = *((__IO uint8_t *)data_reg);
 807ca42:	f895 2050 	ldrb.w	r2, [r5, #80]	; 0x50
 807ca46:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 807ca48:	701a      	strb	r2, [r3, #0]
        hospi->pBuffPtr++;
 807ca4a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 807ca4c:	3301      	adds	r3, #1
 807ca4e:	63e3      	str	r3, [r4, #60]	; 0x3c
        hospi->XferCount--;
 807ca50:	6c63      	ldr	r3, [r4, #68]	; 0x44
 807ca52:	3b01      	subs	r3, #1
 807ca54:	6463      	str	r3, [r4, #68]	; 0x44
      } while(hospi->XferCount > 0U);
 807ca56:	6c63      	ldr	r3, [r4, #68]	; 0x44
 807ca58:	2b00      	cmp	r3, #0
 807ca5a:	d1ea      	bne.n	807ca32 <HAL_OSPI_Receive+0x50>
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, Timeout);
 807ca5c:	9700      	str	r7, [sp, #0]
 807ca5e:	4633      	mov	r3, r6
 807ca60:	2201      	movs	r2, #1
 807ca62:	2102      	movs	r1, #2
 807ca64:	4620      	mov	r0, r4
 807ca66:	f7ff fe7f 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 807ca6a:	b918      	cbnz	r0, 807ca74 <HAL_OSPI_Receive+0x92>
          __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 807ca6c:	2302      	movs	r3, #2
 807ca6e:	6822      	ldr	r2, [r4, #0]
 807ca70:	6253      	str	r3, [r2, #36]	; 0x24
          hospi->State = HAL_OSPI_STATE_READY;
 807ca72:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 807ca74:	b002      	add	sp, #8
 807ca76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 807ca7a:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 807ca7e:	f413 6fe0 	tst.w	r3, #1792	; 0x700
 807ca82:	d1d5      	bne.n	807ca30 <HAL_OSPI_Receive+0x4e>
          WRITE_REG(hospi->Instance->IR, ir_reg);
 807ca84:	f8c5 1110 	str.w	r1, [r5, #272]	; 0x110
 807ca88:	e7d3      	b.n	807ca32 <HAL_OSPI_Receive+0x50>
      hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807ca8a:	2310      	movs	r3, #16
 807ca8c:	e7b9      	b.n	807ca02 <HAL_OSPI_Receive+0x20>

0807ca8e <HAL_OSPI_AutoPolling>:
{
 807ca8e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 807ca92:	4604      	mov	r4, r0
 807ca94:	460d      	mov	r5, r1
 807ca96:	4617      	mov	r7, r2
  uint32_t tickstart = HAL_GetTick();
 807ca98:	f7fe f932 	bl	807ad00 <HAL_GetTick>
  uint32_t addr_reg = hospi->Instance->AR;
 807ca9c:	6823      	ldr	r3, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
 807ca9e:	4606      	mov	r6, r0
  uint32_t addr_reg = hospi->Instance->AR;
 807caa0:	f8d3 8048 	ldr.w	r8, [r3, #72]	; 0x48
  uint32_t ir_reg = hospi->Instance->IR;
 807caa4:	f8d3 9110 	ldr.w	r9, [r3, #272]	; 0x110
  if ((hospi->State == HAL_OSPI_STATE_CMD_CFG) && (cfg->AutomaticStop == HAL_OSPI_AUTOMATIC_STOP_ENABLE))
 807caa8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 807caaa:	2b04      	cmp	r3, #4
 807caac:	d13d      	bne.n	807cb2a <HAL_OSPI_AutoPolling+0x9c>
 807caae:	68eb      	ldr	r3, [r5, #12]
 807cab0:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 807cab4:	d139      	bne.n	807cb2a <HAL_OSPI_AutoPolling+0x9c>
    status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 807cab6:	4603      	mov	r3, r0
 807cab8:	9700      	str	r7, [sp, #0]
 807caba:	2200      	movs	r2, #0
 807cabc:	2120      	movs	r1, #32
 807cabe:	4620      	mov	r0, r4
 807cac0:	f7ff fe52 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 807cac4:	bb30      	cbnz	r0, 807cb14 <HAL_OSPI_AutoPolling+0x86>
      WRITE_REG (hospi->Instance->PSMAR, cfg->Match);
 807cac6:	6823      	ldr	r3, [r4, #0]
 807cac8:	682a      	ldr	r2, [r5, #0]
 807caca:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
      WRITE_REG (hospi->Instance->PSMKR, cfg->Mask);
 807cace:	686a      	ldr	r2, [r5, #4]
 807cad0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      WRITE_REG (hospi->Instance->PIR,   cfg->Interval);
 807cad4:	692a      	ldr	r2, [r5, #16]
 807cad6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
      MODIFY_REG(hospi->Instance->CR,    (OCTOSPI_CR_PMM | OCTOSPI_CR_APMS | OCTOSPI_CR_FMODE),
 807cada:	6819      	ldr	r1, [r3, #0]
 807cadc:	e9d5 2002 	ldrd	r2, r0, [r5, #8]
 807cae0:	4302      	orrs	r2, r0
 807cae2:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 807cae6:	f021 5143 	bic.w	r1, r1, #817889280	; 0x30c00000
 807caea:	430a      	orrs	r2, r1
 807caec:	601a      	str	r2, [r3, #0]
      if (hospi->Init.MemoryType == HAL_OSPI_MEMTYPE_HYPERBUS)
 807caee:	68e2      	ldr	r2, [r4, #12]
 807caf0:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 807caf4:	d111      	bne.n	807cb1a <HAL_OSPI_AutoPolling+0x8c>
          WRITE_REG(hospi->Instance->AR, addr_reg);
 807caf6:	f8c3 8048 	str.w	r8, [r3, #72]	; 0x48
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_SM, SET, tickstart, Timeout);
 807cafa:	9700      	str	r7, [sp, #0]
 807cafc:	4633      	mov	r3, r6
 807cafe:	2201      	movs	r2, #1
 807cb00:	2108      	movs	r1, #8
 807cb02:	4620      	mov	r0, r4
 807cb04:	f7ff fe30 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 807cb08:	b920      	cbnz	r0, 807cb14 <HAL_OSPI_AutoPolling+0x86>
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_SM);
 807cb0a:	2208      	movs	r2, #8
 807cb0c:	6823      	ldr	r3, [r4, #0]
 807cb0e:	625a      	str	r2, [r3, #36]	; 0x24
        hospi->State = HAL_OSPI_STATE_READY;
 807cb10:	2302      	movs	r3, #2
 807cb12:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 807cb14:	b003      	add	sp, #12
 807cb16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (READ_BIT(hospi->Instance->CCR, OCTOSPI_CCR_ADMODE) != HAL_OSPI_ADDRESS_NONE)
 807cb1a:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 807cb1e:	f412 6fe0 	tst.w	r2, #1792	; 0x700
 807cb22:	d1e8      	bne.n	807caf6 <HAL_OSPI_AutoPolling+0x68>
          WRITE_REG(hospi->Instance->IR, ir_reg);
 807cb24:	f8c3 9110 	str.w	r9, [r3, #272]	; 0x110
 807cb28:	e7e7      	b.n	807cafa <HAL_OSPI_AutoPolling+0x6c>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807cb2a:	2310      	movs	r3, #16
    status = HAL_ERROR;
 807cb2c:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807cb2e:	6523      	str	r3, [r4, #80]	; 0x50
 807cb30:	e7f0      	b.n	807cb14 <HAL_OSPI_AutoPolling+0x86>

0807cb32 <HAL_OSPI_Abort>:
{
 807cb32:	b573      	push	{r0, r1, r4, r5, r6, lr}
 807cb34:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 807cb36:	f7fe f8e3 	bl	807ad00 <HAL_GetTick>
  state = hospi->State;
 807cb3a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
  uint32_t tickstart = HAL_GetTick();
 807cb3c:	4605      	mov	r5, r0
  if (((state & OSPI_BUSY_STATE_MASK) != 0U) || ((state & OSPI_CFG_STATE_MASK) != 0U))
 807cb3e:	f013 0f0c 	tst.w	r3, #12
 807cb42:	d031      	beq.n	807cba8 <HAL_OSPI_Abort+0x76>
    if ((hospi->Instance->CR & OCTOSPI_CR_DMAEN) != 0U)
 807cb44:	6823      	ldr	r3, [r4, #0]
 807cb46:	6818      	ldr	r0, [r3, #0]
 807cb48:	f010 0004 	ands.w	r0, r0, #4
 807cb4c:	d009      	beq.n	807cb62 <HAL_OSPI_Abort+0x30>
      CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
 807cb4e:	681a      	ldr	r2, [r3, #0]
      status = HAL_DMA_Abort(hospi->hdma);
 807cb50:	6ca0      	ldr	r0, [r4, #72]	; 0x48
      CLEAR_BIT(hospi->Instance->CR, OCTOSPI_CR_DMAEN);
 807cb52:	f022 0204 	bic.w	r2, r2, #4
 807cb56:	601a      	str	r2, [r3, #0]
      status = HAL_DMA_Abort(hospi->hdma);
 807cb58:	f7ff fba4 	bl	807c2a4 <HAL_DMA_Abort>
      if (status != HAL_OK)
 807cb5c:	b108      	cbz	r0, 807cb62 <HAL_OSPI_Abort+0x30>
        hospi->ErrorCode = HAL_OSPI_ERROR_DMA;
 807cb5e:	2304      	movs	r3, #4
 807cb60:	6523      	str	r3, [r4, #80]	; 0x50
    if (__HAL_OSPI_GET_FLAG(hospi, HAL_OSPI_FLAG_BUSY) != RESET)
 807cb62:	6823      	ldr	r3, [r4, #0]
 807cb64:	6a1a      	ldr	r2, [r3, #32]
 807cb66:	0692      	lsls	r2, r2, #26
 807cb68:	d51b      	bpl.n	807cba2 <HAL_OSPI_Abort+0x70>
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
 807cb6a:	681a      	ldr	r2, [r3, #0]
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, hospi->Timeout);
 807cb6c:	2102      	movs	r1, #2
      SET_BIT(hospi->Instance->CR, OCTOSPI_CR_ABORT);
 807cb6e:	f042 0202 	orr.w	r2, r2, #2
 807cb72:	601a      	str	r2, [r3, #0]
      status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_TC, SET, tickstart, hospi->Timeout);
 807cb74:	6d63      	ldr	r3, [r4, #84]	; 0x54
 807cb76:	2201      	movs	r2, #1
 807cb78:	9300      	str	r3, [sp, #0]
 807cb7a:	4620      	mov	r0, r4
 807cb7c:	462b      	mov	r3, r5
 807cb7e:	f7ff fdf3 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 807cb82:	b960      	cbnz	r0, 807cb9e <HAL_OSPI_Abort+0x6c>
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 807cb84:	2602      	movs	r6, #2
 807cb86:	6823      	ldr	r3, [r4, #0]
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 807cb88:	4602      	mov	r2, r0
        __HAL_OSPI_CLEAR_FLAG(hospi, HAL_OSPI_FLAG_TC);
 807cb8a:	625e      	str	r6, [r3, #36]	; 0x24
        status = OSPI_WaitFlagStateUntilTimeout(hospi, HAL_OSPI_FLAG_BUSY, RESET, tickstart, hospi->Timeout);
 807cb8c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 807cb8e:	2120      	movs	r1, #32
 807cb90:	9300      	str	r3, [sp, #0]
 807cb92:	4620      	mov	r0, r4
 807cb94:	462b      	mov	r3, r5
 807cb96:	f7ff fde7 	bl	807c768 <OSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 807cb9a:	b900      	cbnz	r0, 807cb9e <HAL_OSPI_Abort+0x6c>
          hospi->State = HAL_OSPI_STATE_READY;
 807cb9c:	64e6      	str	r6, [r4, #76]	; 0x4c
}
 807cb9e:	b002      	add	sp, #8
 807cba0:	bd70      	pop	{r4, r5, r6, pc}
      hospi->State = HAL_OSPI_STATE_READY;
 807cba2:	2302      	movs	r3, #2
 807cba4:	64e3      	str	r3, [r4, #76]	; 0x4c
 807cba6:	e7fa      	b.n	807cb9e <HAL_OSPI_Abort+0x6c>
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807cba8:	2310      	movs	r3, #16
    status = HAL_ERROR;
 807cbaa:	2001      	movs	r0, #1
    hospi->ErrorCode = HAL_OSPI_ERROR_INVALID_SEQUENCE;
 807cbac:	6523      	str	r3, [r4, #80]	; 0x50
 807cbae:	e7f6      	b.n	807cb9e <HAL_OSPI_Abort+0x6c>

0807cbb0 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t msirange = 0U, sysclockfreq = 0U;
  uint32_t pllvco, pllsource, pllr, pllm;    /* no init needed */
  uint32_t sysclk_source, pll_oscsource;

  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 807cbb0:	4b23      	ldr	r3, [pc, #140]	; (807cc40 <HAL_RCC_GetSysClockFreq+0x90>)
 807cbb2:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 807cbb4:	68d9      	ldr	r1, [r3, #12]

  if ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI) ||
 807cbb6:	f012 020c 	ands.w	r2, r2, #12
 807cbba:	d005      	beq.n	807cbc8 <HAL_RCC_GetSysClockFreq+0x18>
 807cbbc:	2a0c      	cmp	r2, #12
 807cbbe:	d115      	bne.n	807cbec <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 807cbc0:	f001 0103 	and.w	r1, r1, #3
      ((sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 807cbc4:	2901      	cmp	r1, #1
 807cbc6:	d118      	bne.n	807cbfa <HAL_RCC_GetSysClockFreq+0x4a>
  {
    /* MSI or PLL with MSI source used as system clock source */

    /* Get SYSCLK source */
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 807cbc8:	6819      	ldr	r1, [r3, #0]
    {
      /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in Hz*/
    msirange = MSIRangeTable[msirange];
 807cbca:	481e      	ldr	r0, [pc, #120]	; (807cc44 <HAL_RCC_GetSysClockFreq+0x94>)
    if (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 807cbcc:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 807cbce:	bf55      	itete	pl
 807cbd0:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 807cbd4:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 807cbd6:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 807cbda:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 807cbde:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]

    if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_MSI)
 807cbe2:	b112      	cbz	r2, 807cbea <HAL_RCC_GetSysClockFreq+0x3a>
  else
  {
    /* unexpected case: sysclockfreq at 0 */
  }

  if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 807cbe4:	2a0c      	cmp	r2, #12
 807cbe6:	d009      	beq.n	807cbfc <HAL_RCC_GetSysClockFreq+0x4c>
 807cbe8:	2000      	movs	r0, #0
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
    sysclockfreq = pllvco / pllr;
  }

  return sysclockfreq;
}
 807cbea:	4770      	bx	lr
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSI)
 807cbec:	2a04      	cmp	r2, #4
 807cbee:	d024      	beq.n	807cc3a <HAL_RCC_GetSysClockFreq+0x8a>
  else if (sysclk_source == RCC_SYSCLKSOURCE_STATUS_HSE)
 807cbf0:	2a08      	cmp	r2, #8
 807cbf2:	4815      	ldr	r0, [pc, #84]	; (807cc48 <HAL_RCC_GetSysClockFreq+0x98>)
 807cbf4:	bf18      	it	ne
 807cbf6:	2000      	movne	r0, #0
 807cbf8:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 807cbfa:	2000      	movs	r0, #0
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 807cbfc:	68d9      	ldr	r1, [r3, #12]
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 807cbfe:	68da      	ldr	r2, [r3, #12]
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 807cc00:	f001 0103 	and.w	r1, r1, #3
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 807cc04:	f3c2 1203 	ubfx	r2, r2, #4, #4
    switch (pllsource)
 807cc08:	2902      	cmp	r1, #2
    pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 807cc0a:	f102 0201 	add.w	r2, r2, #1
    switch (pllsource)
 807cc0e:	d005      	beq.n	807cc1c <HAL_RCC_GetSysClockFreq+0x6c>
 807cc10:	2903      	cmp	r1, #3
 807cc12:	d003      	beq.n	807cc1c <HAL_RCC_GetSysClockFreq+0x6c>
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 807cc14:	68d9      	ldr	r1, [r3, #12]
 807cc16:	f3c1 2106 	ubfx	r1, r1, #8, #7
 807cc1a:	e003      	b.n	807cc24 <HAL_RCC_GetSysClockFreq+0x74>
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 807cc1c:	68d9      	ldr	r1, [r3, #12]
 807cc1e:	480a      	ldr	r0, [pc, #40]	; (807cc48 <HAL_RCC_GetSysClockFreq+0x98>)
 807cc20:	f3c1 2106 	ubfx	r1, r1, #8, #7
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 807cc24:	fbb0 f0f2 	udiv	r0, r0, r2
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 807cc28:	68db      	ldr	r3, [r3, #12]
        pllvco = (msirange / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 807cc2a:	4348      	muls	r0, r1
    pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U) * 2U;
 807cc2c:	f3c3 6341 	ubfx	r3, r3, #25, #2
 807cc30:	3301      	adds	r3, #1
 807cc32:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco / pllr;
 807cc34:	fbb0 f0f3 	udiv	r0, r0, r3
 807cc38:	4770      	bx	lr
 807cc3a:	4803      	ldr	r0, [pc, #12]	; (807cc48 <HAL_RCC_GetSysClockFreq+0x98>)
 807cc3c:	4770      	bx	lr
 807cc3e:	bf00      	nop
 807cc40:	40021000 	.word	0x40021000
 807cc44:	0807ebd8 	.word	0x0807ebd8
 807cc48:	00f42400 	.word	0x00f42400

0807cc4c <HAL_RCC_GetHCLKFreq>:
  * @note   Each time HCLK changes, this function must be called to update the
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 807cc4c:	b508      	push	{r3, lr}
  return (HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]);
 807cc4e:	f7ff ffaf 	bl	807cbb0 <HAL_RCC_GetSysClockFreq>
 807cc52:	4b04      	ldr	r3, [pc, #16]	; (807cc64 <HAL_RCC_GetHCLKFreq+0x18>)
 807cc54:	4a04      	ldr	r2, [pc, #16]	; (807cc68 <HAL_RCC_GetHCLKFreq+0x1c>)
 807cc56:	689b      	ldr	r3, [r3, #8]
 807cc58:	f3c3 1303 	ubfx	r3, r3, #4, #4
 807cc5c:	5cd3      	ldrb	r3, [r2, r3]
}
 807cc5e:	40d8      	lsrs	r0, r3
 807cc60:	bd08      	pop	{r3, pc}
 807cc62:	bf00      	nop
 807cc64:	40021000 	.word	0x40021000
 807cc68:	0807ebbf 	.word	0x0807ebbf

0807cc6c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 807cc6c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 807cc6e:	f7ff ffed 	bl	807cc4c <HAL_RCC_GetHCLKFreq>
 807cc72:	4b04      	ldr	r3, [pc, #16]	; (807cc84 <HAL_RCC_GetPCLK1Freq+0x18>)
 807cc74:	4a04      	ldr	r2, [pc, #16]	; (807cc88 <HAL_RCC_GetPCLK1Freq+0x1c>)
 807cc76:	689b      	ldr	r3, [r3, #8]
 807cc78:	f3c3 2302 	ubfx	r3, r3, #8, #3
 807cc7c:	5cd3      	ldrb	r3, [r2, r3]
}
 807cc7e:	40d8      	lsrs	r0, r3
 807cc80:	bd08      	pop	{r3, pc}
 807cc82:	bf00      	nop
 807cc84:	40021000 	.word	0x40021000
 807cc88:	0807ebcf 	.word	0x0807ebcf

0807cc8c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 807cc8c:	b508      	push	{r3, lr}
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 807cc8e:	f7ff ffdd 	bl	807cc4c <HAL_RCC_GetHCLKFreq>
 807cc92:	4b04      	ldr	r3, [pc, #16]	; (807cca4 <HAL_RCC_GetPCLK2Freq+0x18>)
 807cc94:	4a04      	ldr	r2, [pc, #16]	; (807cca8 <HAL_RCC_GetPCLK2Freq+0x1c>)
 807cc96:	689b      	ldr	r3, [r3, #8]
 807cc98:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 807cc9c:	5cd3      	ldrb	r3, [r2, r3]
}
 807cc9e:	40d8      	lsrs	r0, r3
 807cca0:	bd08      	pop	{r3, pc}
 807cca2:	bf00      	nop
 807cca4:	40021000 	.word	0x40021000
 807cca8:	0807ebcf 	.word	0x0807ebcf

0807ccac <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 807ccac:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 807ccb0:	4604      	mov	r4, r0
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 807ccb2:	6921      	ldr	r1, [r4, #16]
 807ccb4:	68a2      	ldr	r2, [r4, #8]
  if (UART_INSTANCE_LOWPOWER(huart))
 807ccb6:	6803      	ldr	r3, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 807ccb8:	430a      	orrs	r2, r1
 807ccba:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 807ccbc:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 807ccbe:	69c0      	ldr	r0, [r0, #28]
 807ccc0:	430a      	orrs	r2, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 807ccc2:	49a7      	ldr	r1, [pc, #668]	; (807cf60 <UART_SetConfig+0x2b4>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 807ccc4:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 807ccc6:	4029      	ands	r1, r5
 807ccc8:	430a      	orrs	r2, r1
 807ccca:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 807cccc:	685a      	ldr	r2, [r3, #4]
 807ccce:	68e1      	ldr	r1, [r4, #12]
 807ccd0:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 807ccd4:	430a      	orrs	r2, r1
 807ccd6:	605a      	str	r2, [r3, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 807ccd8:	4aa2      	ldr	r2, [pc, #648]	; (807cf64 <UART_SetConfig+0x2b8>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 807ccda:	69a1      	ldr	r1, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 807ccdc:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 807ccde:	bf1c      	itt	ne
 807cce0:	6a22      	ldrne	r2, [r4, #32]
 807cce2:	4311      	orrne	r1, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 807cce4:	689a      	ldr	r2, [r3, #8]
 807cce6:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 807ccea:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 807ccee:	430a      	orrs	r2, r1
 807ccf0:	609a      	str	r2, [r3, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 807ccf2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 807ccf4:	6a61      	ldr	r1, [r4, #36]	; 0x24
 807ccf6:	f022 020f 	bic.w	r2, r2, #15
 807ccfa:	430a      	orrs	r2, r1
 807ccfc:	62da      	str	r2, [r3, #44]	; 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 807ccfe:	4a9a      	ldr	r2, [pc, #616]	; (807cf68 <UART_SetConfig+0x2bc>)
 807cd00:	4293      	cmp	r3, r2
 807cd02:	d117      	bne.n	807cd34 <UART_SetConfig+0x88>
 807cd04:	4b99      	ldr	r3, [pc, #612]	; (807cf6c <UART_SetConfig+0x2c0>)
 807cd06:	4a9a      	ldr	r2, [pc, #616]	; (807cf70 <UART_SetConfig+0x2c4>)
 807cd08:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 807cd0c:	f003 0303 	and.w	r3, r3, #3
        }
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 807cd10:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 807cd14:	5cd3      	ldrb	r3, [r2, r3]
 807cd16:	f040 80a9 	bne.w	807ce6c <UART_SetConfig+0x1c0>
  {
    switch (clocksource)
 807cd1a:	2b08      	cmp	r3, #8
 807cd1c:	d839      	bhi.n	807cd92 <UART_SetConfig+0xe6>
 807cd1e:	e8df f013 	tbh	[pc, r3, lsl #1]
 807cd22:	00fc      	.short	0x00fc
 807cd24:	00a3009d 	.word	0x00a3009d
 807cd28:	00f00038 	.word	0x00f00038
 807cd2c:	00380038 	.word	0x00380038
 807cd30:	00a00038 	.word	0x00a00038
  UART_GETCLOCKSOURCE(huart, clocksource);
 807cd34:	4a8f      	ldr	r2, [pc, #572]	; (807cf74 <UART_SetConfig+0x2c8>)
 807cd36:	4293      	cmp	r3, r2
 807cd38:	d106      	bne.n	807cd48 <UART_SetConfig+0x9c>
 807cd3a:	4b8c      	ldr	r3, [pc, #560]	; (807cf6c <UART_SetConfig+0x2c0>)
 807cd3c:	4a8e      	ldr	r2, [pc, #568]	; (807cf78 <UART_SetConfig+0x2cc>)
 807cd3e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 807cd42:	f003 030c 	and.w	r3, r3, #12
 807cd46:	e7e3      	b.n	807cd10 <UART_SetConfig+0x64>
 807cd48:	4a8c      	ldr	r2, [pc, #560]	; (807cf7c <UART_SetConfig+0x2d0>)
 807cd4a:	4293      	cmp	r3, r2
 807cd4c:	d123      	bne.n	807cd96 <UART_SetConfig+0xea>
 807cd4e:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 807cd52:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 807cd56:	f002 0230 	and.w	r2, r2, #48	; 0x30
 807cd5a:	2a10      	cmp	r2, #16
 807cd5c:	f000 80c8 	beq.w	807cef0 <UART_SetConfig+0x244>
 807cd60:	d811      	bhi.n	807cd86 <UART_SetConfig+0xda>
 807cd62:	b9b2      	cbnz	r2, 807cd92 <UART_SetConfig+0xe6>
  if (UART_INSTANCE_LOWPOWER(huart))
 807cd64:	4a7f      	ldr	r2, [pc, #508]	; (807cf64 <UART_SetConfig+0x2b8>)
 807cd66:	4293      	cmp	r3, r2
 807cd68:	f040 80d4 	bne.w	807cf14 <UART_SetConfig+0x268>
        pclk = HAL_RCC_GetPCLK1Freq();
 807cd6c:	f7ff ff7e 	bl	807cc6c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 807cd70:	2800      	cmp	r0, #0
 807cd72:	d14a      	bne.n	807ce0a <UART_SetConfig+0x15e>
 807cd74:	2000      	movs	r0, #0
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;
 807cd76:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 807cd7a:	66a3      	str	r3, [r4, #104]	; 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 807cd7c:	2300      	movs	r3, #0
  huart->TxISR = NULL;
 807cd7e:	e9c4 331c 	strd	r3, r3, [r4, #112]	; 0x70

  return ret;
}
 807cd82:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
  UART_GETCLOCKSOURCE(huart, clocksource);
 807cd86:	2a20      	cmp	r2, #32
 807cd88:	f000 80a4 	beq.w	807ced4 <UART_SetConfig+0x228>
 807cd8c:	2a30      	cmp	r2, #48	; 0x30
 807cd8e:	f000 80a9 	beq.w	807cee4 <UART_SetConfig+0x238>
        ret = HAL_ERROR;
 807cd92:	2001      	movs	r0, #1
 807cd94:	e7ef      	b.n	807cd76 <UART_SetConfig+0xca>
  UART_GETCLOCKSOURCE(huart, clocksource);
 807cd96:	4a7a      	ldr	r2, [pc, #488]	; (807cf80 <UART_SetConfig+0x2d4>)
 807cd98:	4293      	cmp	r3, r2
 807cd9a:	d10e      	bne.n	807cdba <UART_SetConfig+0x10e>
 807cd9c:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 807cda0:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 807cda4:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 807cda8:	2a40      	cmp	r2, #64	; 0x40
 807cdaa:	f000 80a1 	beq.w	807cef0 <UART_SetConfig+0x244>
 807cdae:	d9d8      	bls.n	807cd62 <UART_SetConfig+0xb6>
 807cdb0:	2a80      	cmp	r2, #128	; 0x80
 807cdb2:	f000 808f 	beq.w	807ced4 <UART_SetConfig+0x228>
 807cdb6:	2ac0      	cmp	r2, #192	; 0xc0
 807cdb8:	e7e9      	b.n	807cd8e <UART_SetConfig+0xe2>
 807cdba:	4a72      	ldr	r2, [pc, #456]	; (807cf84 <UART_SetConfig+0x2d8>)
 807cdbc:	4293      	cmp	r3, r2
 807cdbe:	d110      	bne.n	807cde2 <UART_SetConfig+0x136>
 807cdc0:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
 807cdc4:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 807cdc8:	f402 7240 	and.w	r2, r2, #768	; 0x300
 807cdcc:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 807cdd0:	f000 808e 	beq.w	807cef0 <UART_SetConfig+0x244>
 807cdd4:	d9c5      	bls.n	807cd62 <UART_SetConfig+0xb6>
 807cdd6:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 807cdda:	d07b      	beq.n	807ced4 <UART_SetConfig+0x228>
 807cddc:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 807cde0:	e7d5      	b.n	807cd8e <UART_SetConfig+0xe2>
 807cde2:	4a60      	ldr	r2, [pc, #384]	; (807cf64 <UART_SetConfig+0x2b8>)
 807cde4:	4293      	cmp	r3, r2
 807cde6:	d1d4      	bne.n	807cd92 <UART_SetConfig+0xe6>
 807cde8:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 807cdec:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 807cdf0:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 807cdf4:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 807cdf8:	d07a      	beq.n	807cef0 <UART_SetConfig+0x244>
 807cdfa:	d9b2      	bls.n	807cd62 <UART_SetConfig+0xb6>
 807cdfc:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 807ce00:	d068      	beq.n	807ced4 <UART_SetConfig+0x228>
 807ce02:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 807ce06:	e7c2      	b.n	807cd8e <UART_SetConfig+0xe2>
        pclk = (uint32_t) HSI_VALUE;
 807ce08:	485f      	ldr	r0, [pc, #380]	; (807cf88 <UART_SetConfig+0x2dc>)
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 807ce0a:	4b60      	ldr	r3, [pc, #384]	; (807cf8c <UART_SetConfig+0x2e0>)
 807ce0c:	6a62      	ldr	r2, [r4, #36]	; 0x24
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 807ce0e:	6865      	ldr	r5, [r4, #4]
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 807ce10:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 807ce14:	eb05 0145 	add.w	r1, r5, r5, lsl #1
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 807ce18:	fbb0 f3f2 	udiv	r3, r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 807ce1c:	4299      	cmp	r1, r3
 807ce1e:	d8b8      	bhi.n	807cd92 <UART_SetConfig+0xe6>
 807ce20:	ebb3 3f05 	cmp.w	r3, r5, lsl #12
 807ce24:	d8b5      	bhi.n	807cd92 <UART_SetConfig+0xe6>
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, (uint64_t)huart->Init.BaudRate, huart->Init.ClockPrescaler));
 807ce26:	2300      	movs	r3, #0
 807ce28:	2100      	movs	r1, #0
 807ce2a:	f001 fad1 	bl	807e3d0 <__aeabi_uldivmod>
 807ce2e:	020f      	lsls	r7, r1, #8
 807ce30:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 807ce34:	0206      	lsls	r6, r0, #8
 807ce36:	0868      	lsrs	r0, r5, #1
 807ce38:	eb16 0b00 	adds.w	fp, r6, r0
 807ce3c:	f147 0c00 	adc.w	ip, r7, #0
 807ce40:	462a      	mov	r2, r5
 807ce42:	2300      	movs	r3, #0
 807ce44:	4658      	mov	r0, fp
 807ce46:	4661      	mov	r1, ip
 807ce48:	f001 fac2 	bl	807e3d0 <__aeabi_uldivmod>
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 807ce4c:	4b50      	ldr	r3, [pc, #320]	; (807cf90 <UART_SetConfig+0x2e4>)
 807ce4e:	f5a0 7240 	sub.w	r2, r0, #768	; 0x300
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 807ce52:	429a      	cmp	r2, r3
 807ce54:	d89d      	bhi.n	807cd92 <UART_SetConfig+0xe6>
        huart->Instance->BRR = usartdiv;
 807ce56:	6823      	ldr	r3, [r4, #0]
 807ce58:	60d8      	str	r0, [r3, #12]
 807ce5a:	e78b      	b.n	807cd74 <UART_SetConfig+0xc8>
        pclk = HAL_RCC_GetPCLK2Freq();
 807ce5c:	f7ff ff16 	bl	807cc8c <HAL_RCC_GetPCLK2Freq>
        break;
 807ce60:	e05d      	b.n	807cf1e <UART_SetConfig+0x272>
        pclk = (uint32_t) LSE_VALUE;
 807ce62:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 807ce66:	e05d      	b.n	807cf24 <UART_SetConfig+0x278>
        pclk = (uint32_t) HSI_VALUE;
 807ce68:	4847      	ldr	r0, [pc, #284]	; (807cf88 <UART_SetConfig+0x2dc>)
 807ce6a:	e05b      	b.n	807cf24 <UART_SetConfig+0x278>
    switch (clocksource)
 807ce6c:	2b08      	cmp	r3, #8
 807ce6e:	d890      	bhi.n	807cd92 <UART_SetConfig+0xe6>
 807ce70:	a201      	add	r2, pc, #4	; (adr r2, 807ce78 <UART_SetConfig+0x1cc>)
 807ce72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 807ce76:	bf00      	nop
 807ce78:	0807ce9d 	.word	0x0807ce9d
 807ce7c:	0807cec9 	.word	0x0807cec9
 807ce80:	0807cee1 	.word	0x0807cee1
 807ce84:	0807cd93 	.word	0x0807cd93
 807ce88:	0807cecf 	.word	0x0807cecf
 807ce8c:	0807cd93 	.word	0x0807cd93
 807ce90:	0807cd93 	.word	0x0807cd93
 807ce94:	0807cd93 	.word	0x0807cd93
 807ce98:	0807cf0f 	.word	0x0807cf0f
        pclk = HAL_RCC_GetPCLK1Freq();
 807ce9c:	f7ff fee6 	bl	807cc6c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 807cea0:	2800      	cmp	r0, #0
 807cea2:	f43f af67 	beq.w	807cd74 <UART_SetConfig+0xc8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 807cea6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 807cea8:	4a38      	ldr	r2, [pc, #224]	; (807cf8c <UART_SetConfig+0x2e0>)
 807ceaa:	6863      	ldr	r3, [r4, #4]
 807ceac:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
 807ceb0:	fbb0 f0f2 	udiv	r0, r0, r2
 807ceb4:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 807ceb8:	fbb0 f0f3 	udiv	r0, r0, r3
 807cebc:	b280      	uxth	r0, r0
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 807cebe:	f1a0 0210 	sub.w	r2, r0, #16
 807cec2:	f64f 73ef 	movw	r3, #65519	; 0xffef
 807cec6:	e7c4      	b.n	807ce52 <UART_SetConfig+0x1a6>
        pclk = HAL_RCC_GetPCLK2Freq();
 807cec8:	f7ff fee0 	bl	807cc8c <HAL_RCC_GetPCLK2Freq>
        break;
 807cecc:	e7e8      	b.n	807cea0 <UART_SetConfig+0x1f4>
        pclk = HAL_RCC_GetSysClockFreq();
 807cece:	f7ff fe6f 	bl	807cbb0 <HAL_RCC_GetSysClockFreq>
        break;
 807ced2:	e7e5      	b.n	807cea0 <UART_SetConfig+0x1f4>
  if (UART_INSTANCE_LOWPOWER(huart))
 807ced4:	4a23      	ldr	r2, [pc, #140]	; (807cf64 <UART_SetConfig+0x2b8>)
 807ced6:	4293      	cmp	r3, r2
 807ced8:	d096      	beq.n	807ce08 <UART_SetConfig+0x15c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 807ceda:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 807cede:	d0c3      	beq.n	807ce68 <UART_SetConfig+0x1bc>
        pclk = (uint32_t) HSI_VALUE;
 807cee0:	4829      	ldr	r0, [pc, #164]	; (807cf88 <UART_SetConfig+0x2dc>)
 807cee2:	e7e0      	b.n	807cea6 <UART_SetConfig+0x1fa>
  if (UART_INSTANCE_LOWPOWER(huart))
 807cee4:	4a1f      	ldr	r2, [pc, #124]	; (807cf64 <UART_SetConfig+0x2b8>)
 807cee6:	4293      	cmp	r3, r2
 807cee8:	d10e      	bne.n	807cf08 <UART_SetConfig+0x25c>
        pclk = (uint32_t) LSE_VALUE;
 807ceea:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 807ceee:	e78c      	b.n	807ce0a <UART_SetConfig+0x15e>
  if (UART_INSTANCE_LOWPOWER(huart))
 807cef0:	4a1c      	ldr	r2, [pc, #112]	; (807cf64 <UART_SetConfig+0x2b8>)
 807cef2:	4293      	cmp	r3, r2
 807cef4:	d102      	bne.n	807cefc <UART_SetConfig+0x250>
        pclk = HAL_RCC_GetSysClockFreq();
 807cef6:	f7ff fe5b 	bl	807cbb0 <HAL_RCC_GetSysClockFreq>
        break;
 807cefa:	e739      	b.n	807cd70 <UART_SetConfig+0xc4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 807cefc:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 807cf00:	d1e5      	bne.n	807cece <UART_SetConfig+0x222>
        pclk = HAL_RCC_GetSysClockFreq();
 807cf02:	f7ff fe55 	bl	807cbb0 <HAL_RCC_GetSysClockFreq>
        break;
 807cf06:	e00a      	b.n	807cf1e <UART_SetConfig+0x272>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 807cf08:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 807cf0c:	d00a      	beq.n	807cf24 <UART_SetConfig+0x278>
        pclk = (uint32_t) LSE_VALUE;
 807cf0e:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 807cf12:	e7c8      	b.n	807cea6 <UART_SetConfig+0x1fa>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 807cf14:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
 807cf18:	d1c0      	bne.n	807ce9c <UART_SetConfig+0x1f0>
        pclk = HAL_RCC_GetPCLK1Freq();
 807cf1a:	f7ff fea7 	bl	807cc6c <HAL_RCC_GetPCLK1Freq>
    if (pclk != 0U)
 807cf1e:	2800      	cmp	r0, #0
 807cf20:	f43f af28 	beq.w	807cd74 <UART_SetConfig+0xc8>
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 807cf24:	6a61      	ldr	r1, [r4, #36]	; 0x24
 807cf26:	4b19      	ldr	r3, [pc, #100]	; (807cf8c <UART_SetConfig+0x2e0>)
 807cf28:	6862      	ldr	r2, [r4, #4]
 807cf2a:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 807cf2e:	fbb0 f3f3 	udiv	r3, r0, r3
 807cf32:	0850      	lsrs	r0, r2, #1
 807cf34:	eb00 0043 	add.w	r0, r0, r3, lsl #1
 807cf38:	fbb0 f0f2 	udiv	r0, r0, r2
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 807cf3c:	f64f 72ef 	movw	r2, #65519	; 0xffef
 807cf40:	b283      	uxth	r3, r0
 807cf42:	f1a3 0110 	sub.w	r1, r3, #16
 807cf46:	4291      	cmp	r1, r2
 807cf48:	f63f af23 	bhi.w	807cd92 <UART_SetConfig+0xe6>
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 807cf4c:	f020 000f 	bic.w	r0, r0, #15
 807cf50:	b280      	uxth	r0, r0
        huart->Instance->BRR = brrtemp;
 807cf52:	6822      	ldr	r2, [r4, #0]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 807cf54:	f3c3 0342 	ubfx	r3, r3, #1, #3
        huart->Instance->BRR = brrtemp;
 807cf58:	4318      	orrs	r0, r3
 807cf5a:	60d0      	str	r0, [r2, #12]
 807cf5c:	e70a      	b.n	807cd74 <UART_SetConfig+0xc8>
 807cf5e:	bf00      	nop
 807cf60:	cfff69f3 	.word	0xcfff69f3
 807cf64:	40008000 	.word	0x40008000
 807cf68:	40013800 	.word	0x40013800
 807cf6c:	40021000 	.word	0x40021000
 807cf70:	0807ec30 	.word	0x0807ec30
 807cf74:	40004400 	.word	0x40004400
 807cf78:	0807ec34 	.word	0x0807ec34
 807cf7c:	40004800 	.word	0x40004800
 807cf80:	40004c00 	.word	0x40004c00
 807cf84:	40005000 	.word	0x40005000
 807cf88:	00f42400 	.word	0x00f42400
 807cf8c:	0807ec42 	.word	0x0807ec42
 807cf90:	000ffcff 	.word	0x000ffcff

0807cf94 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 807cf94:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 807cf96:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 807cf98:	07da      	lsls	r2, r3, #31
 807cf9a:	d506      	bpl.n	807cfaa <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 807cf9c:	6801      	ldr	r1, [r0, #0]
 807cf9e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 807cfa0:	684a      	ldr	r2, [r1, #4]
 807cfa2:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 807cfa6:	4322      	orrs	r2, r4
 807cfa8:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 807cfaa:	079c      	lsls	r4, r3, #30
 807cfac:	d506      	bpl.n	807cfbc <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 807cfae:	6801      	ldr	r1, [r0, #0]
 807cfb0:	6b04      	ldr	r4, [r0, #48]	; 0x30
 807cfb2:	684a      	ldr	r2, [r1, #4]
 807cfb4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 807cfb8:	4322      	orrs	r2, r4
 807cfba:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 807cfbc:	0759      	lsls	r1, r3, #29
 807cfbe:	d506      	bpl.n	807cfce <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 807cfc0:	6801      	ldr	r1, [r0, #0]
 807cfc2:	6b44      	ldr	r4, [r0, #52]	; 0x34
 807cfc4:	684a      	ldr	r2, [r1, #4]
 807cfc6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 807cfca:	4322      	orrs	r2, r4
 807cfcc:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 807cfce:	071a      	lsls	r2, r3, #28
 807cfd0:	d506      	bpl.n	807cfe0 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 807cfd2:	6801      	ldr	r1, [r0, #0]
 807cfd4:	6b84      	ldr	r4, [r0, #56]	; 0x38
 807cfd6:	684a      	ldr	r2, [r1, #4]
 807cfd8:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 807cfdc:	4322      	orrs	r2, r4
 807cfde:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 807cfe0:	06dc      	lsls	r4, r3, #27
 807cfe2:	d506      	bpl.n	807cff2 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 807cfe4:	6801      	ldr	r1, [r0, #0]
 807cfe6:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 807cfe8:	688a      	ldr	r2, [r1, #8]
 807cfea:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 807cfee:	4322      	orrs	r2, r4
 807cff0:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 807cff2:	0699      	lsls	r1, r3, #26
 807cff4:	d506      	bpl.n	807d004 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 807cff6:	6801      	ldr	r1, [r0, #0]
 807cff8:	6c04      	ldr	r4, [r0, #64]	; 0x40
 807cffa:	688a      	ldr	r2, [r1, #8]
 807cffc:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 807d000:	4322      	orrs	r2, r4
 807d002:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 807d004:	065a      	lsls	r2, r3, #25
 807d006:	d510      	bpl.n	807d02a <UART_AdvFeatureConfig+0x96>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 807d008:	6801      	ldr	r1, [r0, #0]
 807d00a:	6c44      	ldr	r4, [r0, #68]	; 0x44
 807d00c:	684a      	ldr	r2, [r1, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 807d00e:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 807d012:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 807d016:	ea42 0204 	orr.w	r2, r2, r4
 807d01a:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 807d01c:	d105      	bne.n	807d02a <UART_AdvFeatureConfig+0x96>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 807d01e:	684a      	ldr	r2, [r1, #4]
 807d020:	6c84      	ldr	r4, [r0, #72]	; 0x48
 807d022:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 807d026:	4322      	orrs	r2, r4
 807d028:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 807d02a:	061b      	lsls	r3, r3, #24
 807d02c:	d506      	bpl.n	807d03c <UART_AdvFeatureConfig+0xa8>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 807d02e:	6802      	ldr	r2, [r0, #0]
 807d030:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 807d032:	6853      	ldr	r3, [r2, #4]
 807d034:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 807d038:	430b      	orrs	r3, r1
 807d03a:	6053      	str	r3, [r2, #4]
  }
}
 807d03c:	bd10      	pop	{r4, pc}

0807d03e <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 807d03e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 807d042:	4604      	mov	r4, r0
 807d044:	460f      	mov	r7, r1
 807d046:	4616      	mov	r6, r2
 807d048:	4698      	mov	r8, r3
 807d04a:	9d06      	ldr	r5, [sp, #24]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 807d04c:	6821      	ldr	r1, [r4, #0]
 807d04e:	69ca      	ldr	r2, [r1, #28]
 807d050:	ea37 0302 	bics.w	r3, r7, r2
 807d054:	bf0c      	ite	eq
 807d056:	2201      	moveq	r2, #1
 807d058:	2200      	movne	r2, #0
 807d05a:	42b2      	cmp	r2, r6
 807d05c:	d001      	beq.n	807d062 <UART_WaitOnFlagUntilTimeout+0x24>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 807d05e:	2000      	movs	r0, #0
 807d060:	e01a      	b.n	807d098 <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
 807d062:	1c68      	adds	r0, r5, #1
 807d064:	d0f3      	beq.n	807d04e <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 807d066:	f7fd fe4b 	bl	807ad00 <HAL_GetTick>
 807d06a:	eba0 0008 	sub.w	r0, r0, r8
 807d06e:	42a8      	cmp	r0, r5
 807d070:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 807d072:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 807d074:	d800      	bhi.n	807d078 <UART_WaitOnFlagUntilTimeout+0x3a>
 807d076:	b98d      	cbnz	r5, 807d09c <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 807d078:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 807d07c:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 807d07e:	6883      	ldr	r3, [r0, #8]
 807d080:	f023 0301 	bic.w	r3, r3, #1
 807d084:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 807d086:	2320      	movs	r3, #32
 807d088:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
        huart->RxState = HAL_UART_STATE_READY;
 807d08c:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          __HAL_UNLOCK(huart);
 807d090:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 807d092:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 807d094:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
}
 807d098:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 807d09c:	075a      	lsls	r2, r3, #29
 807d09e:	d5d5      	bpl.n	807d04c <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 807d0a0:	69c3      	ldr	r3, [r0, #28]
 807d0a2:	051b      	lsls	r3, r3, #20
 807d0a4:	d5d2      	bpl.n	807d04c <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 807d0a6:	f44f 6300 	mov.w	r3, #2048	; 0x800
 807d0aa:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 807d0ac:	6803      	ldr	r3, [r0, #0]
 807d0ae:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 807d0b2:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 807d0b4:	6883      	ldr	r3, [r0, #8]
 807d0b6:	f023 0301 	bic.w	r3, r3, #1
 807d0ba:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 807d0bc:	2320      	movs	r3, #32
 807d0be:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->RxState = HAL_UART_STATE_READY;
 807d0c2:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 807d0c6:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
 807d0ca:	e7e1      	b.n	807d090 <UART_WaitOnFlagUntilTimeout+0x52>

0807d0cc <HAL_UART_Transmit>:
{
 807d0cc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 807d0d0:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 807d0d2:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
{
 807d0d6:	4604      	mov	r4, r0
  if (huart->gState == HAL_UART_STATE_READY)
 807d0d8:	2b20      	cmp	r3, #32
{
 807d0da:	460e      	mov	r6, r1
 807d0dc:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
 807d0de:	d14f      	bne.n	807d180 <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 807d0e0:	2900      	cmp	r1, #0
 807d0e2:	d04b      	beq.n	807d17c <HAL_UART_Transmit+0xb0>
 807d0e4:	2a00      	cmp	r2, #0
 807d0e6:	d049      	beq.n	807d17c <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 807d0e8:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 807d0ec:	2b01      	cmp	r3, #1
 807d0ee:	d047      	beq.n	807d180 <HAL_UART_Transmit+0xb4>
 807d0f0:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 807d0f2:	2500      	movs	r5, #0
    __HAL_LOCK(huart);
 807d0f4:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
 807d0f8:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 807d0fa:	f8c0 508c 	str.w	r5, [r0, #140]	; 0x8c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 807d0fe:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 807d102:	f7fd fdfd 	bl	807ad00 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 807d106:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 807d108:	4607      	mov	r7, r0
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 807d10a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->TxXferSize  = Size;
 807d10e:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    huart->TxXferCount = Size;
 807d112:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 807d116:	d103      	bne.n	807d120 <HAL_UART_Transmit+0x54>
 807d118:	6923      	ldr	r3, [r4, #16]
 807d11a:	b90b      	cbnz	r3, 807d120 <HAL_UART_Transmit+0x54>
 807d11c:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 807d11e:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 807d120:	2300      	movs	r3, #0
 807d122:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->TxXferCount > 0U)
 807d126:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 807d12a:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 807d12e:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 807d130:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
 807d132:	b942      	cbnz	r2, 807d146 <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 807d134:	2140      	movs	r1, #64	; 0x40
 807d136:	4620      	mov	r0, r4
 807d138:	f7ff ff81 	bl	807d03e <UART_WaitOnFlagUntilTimeout>
 807d13c:	b948      	cbnz	r0, 807d152 <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 807d13e:	2320      	movs	r3, #32
 807d140:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
    return HAL_OK;
 807d144:	e006      	b.n	807d154 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 807d146:	2200      	movs	r2, #0
 807d148:	2180      	movs	r1, #128	; 0x80
 807d14a:	4620      	mov	r0, r4
 807d14c:	f7ff ff77 	bl	807d03e <UART_WaitOnFlagUntilTimeout>
 807d150:	b118      	cbz	r0, 807d15a <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 807d152:	2003      	movs	r0, #3
}
 807d154:	b003      	add	sp, #12
 807d156:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 807d15a:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 807d15c:	b95e      	cbnz	r6, 807d176 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 807d15e:	f835 3b02 	ldrh.w	r3, [r5], #2
 807d162:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 807d166:	6293      	str	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 807d168:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 807d16c:	3b01      	subs	r3, #1
 807d16e:	b29b      	uxth	r3, r3
 807d170:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
 807d174:	e7d7      	b.n	807d126 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 807d176:	f816 3b01 	ldrb.w	r3, [r6], #1
 807d17a:	e7f4      	b.n	807d166 <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 807d17c:	2001      	movs	r0, #1
 807d17e:	e7e9      	b.n	807d154 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 807d180:	2002      	movs	r0, #2
 807d182:	e7e7      	b.n	807d154 <HAL_UART_Transmit+0x88>

0807d184 <HAL_UART_Receive>:
{
 807d184:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 807d188:	4699      	mov	r9, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 807d18a:	f8d0 3088 	ldr.w	r3, [r0, #136]	; 0x88
{
 807d18e:	4604      	mov	r4, r0
  if (huart->RxState == HAL_UART_STATE_READY)
 807d190:	2b20      	cmp	r3, #32
{
 807d192:	460d      	mov	r5, r1
 807d194:	4617      	mov	r7, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 807d196:	d168      	bne.n	807d26a <HAL_UART_Receive+0xe6>
    if ((pData == NULL) || (Size == 0U))
 807d198:	2900      	cmp	r1, #0
 807d19a:	d064      	beq.n	807d266 <HAL_UART_Receive+0xe2>
 807d19c:	2a00      	cmp	r2, #0
 807d19e:	d062      	beq.n	807d266 <HAL_UART_Receive+0xe2>
    __HAL_LOCK(huart);
 807d1a0:	f890 3080 	ldrb.w	r3, [r0, #128]	; 0x80
 807d1a4:	2b01      	cmp	r3, #1
 807d1a6:	d060      	beq.n	807d26a <HAL_UART_Receive+0xe6>
 807d1a8:	2301      	movs	r3, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 807d1aa:	2600      	movs	r6, #0
    __HAL_LOCK(huart);
 807d1ac:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 807d1b0:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 807d1b2:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 807d1b6:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 807d1ba:	66c6      	str	r6, [r0, #108]	; 0x6c
    tickstart = HAL_GetTick();
 807d1bc:	f7fd fda0 	bl	807ad00 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 807d1c0:	68a3      	ldr	r3, [r4, #8]
    tickstart = HAL_GetTick();
 807d1c2:	4680      	mov	r8, r0
    UART_MASK_COMPUTATION(huart);
 807d1c4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    huart->RxXferSize  = Size;
 807d1c8:	f8a4 705c 	strh.w	r7, [r4, #92]	; 0x5c
    huart->RxXferCount = Size;
 807d1cc:	f8a4 705e 	strh.w	r7, [r4, #94]	; 0x5e
    UART_MASK_COMPUTATION(huart);
 807d1d0:	d11d      	bne.n	807d20e <HAL_UART_Receive+0x8a>
 807d1d2:	6922      	ldr	r2, [r4, #16]
 807d1d4:	b9ca      	cbnz	r2, 807d20a <HAL_UART_Receive+0x86>
 807d1d6:	f240 12ff 	movw	r2, #511	; 0x1ff
 807d1da:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 807d1de:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    uhMask = huart->Mask;
 807d1e2:	f8b4 7060 	ldrh.w	r7, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 807d1e6:	d123      	bne.n	807d230 <HAL_UART_Receive+0xac>
 807d1e8:	6923      	ldr	r3, [r4, #16]
 807d1ea:	bb0b      	cbnz	r3, 807d230 <HAL_UART_Receive+0xac>
 807d1ec:	462e      	mov	r6, r5
      pdata8bits  = NULL;
 807d1ee:	461d      	mov	r5, r3
    __HAL_UNLOCK(huart);
 807d1f0:	2300      	movs	r3, #0
 807d1f2:	f884 3080 	strb.w	r3, [r4, #128]	; 0x80
    while (huart->RxXferCount > 0U)
 807d1f6:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 807d1fa:	b280      	uxth	r0, r0
 807d1fc:	b9d0      	cbnz	r0, 807d234 <HAL_UART_Receive+0xb0>
    huart->RxState = HAL_UART_STATE_READY;
 807d1fe:	2320      	movs	r3, #32
 807d200:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
}
 807d204:	b003      	add	sp, #12
 807d206:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 807d20a:	22ff      	movs	r2, #255	; 0xff
 807d20c:	e7e5      	b.n	807d1da <HAL_UART_Receive+0x56>
 807d20e:	b923      	cbnz	r3, 807d21a <HAL_UART_Receive+0x96>
 807d210:	6922      	ldr	r2, [r4, #16]
 807d212:	2a00      	cmp	r2, #0
 807d214:	d0f9      	beq.n	807d20a <HAL_UART_Receive+0x86>
 807d216:	227f      	movs	r2, #127	; 0x7f
 807d218:	e7df      	b.n	807d1da <HAL_UART_Receive+0x56>
 807d21a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 807d21e:	d104      	bne.n	807d22a <HAL_UART_Receive+0xa6>
 807d220:	6922      	ldr	r2, [r4, #16]
 807d222:	2a00      	cmp	r2, #0
 807d224:	d0f7      	beq.n	807d216 <HAL_UART_Receive+0x92>
 807d226:	223f      	movs	r2, #63	; 0x3f
 807d228:	e7d7      	b.n	807d1da <HAL_UART_Receive+0x56>
 807d22a:	f8a4 6060 	strh.w	r6, [r4, #96]	; 0x60
 807d22e:	e7d6      	b.n	807d1de <HAL_UART_Receive+0x5a>
      pdata16bits = NULL;
 807d230:	2600      	movs	r6, #0
 807d232:	e7dd      	b.n	807d1f0 <HAL_UART_Receive+0x6c>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 807d234:	f8cd 9000 	str.w	r9, [sp]
 807d238:	4643      	mov	r3, r8
 807d23a:	2200      	movs	r2, #0
 807d23c:	2120      	movs	r1, #32
 807d23e:	4620      	mov	r0, r4
 807d240:	f7ff fefd 	bl	807d03e <UART_WaitOnFlagUntilTimeout>
 807d244:	b998      	cbnz	r0, 807d26e <HAL_UART_Receive+0xea>
 807d246:	6823      	ldr	r3, [r4, #0]
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 807d248:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 807d24a:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
 807d24c:	b945      	cbnz	r5, 807d260 <HAL_UART_Receive+0xdc>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 807d24e:	f826 3b02 	strh.w	r3, [r6], #2
      huart->RxXferCount--;
 807d252:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 807d256:	3b01      	subs	r3, #1
 807d258:	b29b      	uxth	r3, r3
 807d25a:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
 807d25e:	e7ca      	b.n	807d1f6 <HAL_UART_Receive+0x72>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 807d260:	f805 3b01 	strb.w	r3, [r5], #1
 807d264:	e7f5      	b.n	807d252 <HAL_UART_Receive+0xce>
      return  HAL_ERROR;
 807d266:	2001      	movs	r0, #1
 807d268:	e7cc      	b.n	807d204 <HAL_UART_Receive+0x80>
    return HAL_BUSY;
 807d26a:	2002      	movs	r0, #2
 807d26c:	e7ca      	b.n	807d204 <HAL_UART_Receive+0x80>
        return HAL_TIMEOUT;
 807d26e:	2003      	movs	r0, #3
 807d270:	e7c8      	b.n	807d204 <HAL_UART_Receive+0x80>

0807d272 <UART_CheckIdleState>:
{
 807d272:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 807d274:	2600      	movs	r6, #0
{
 807d276:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 807d278:	f8c0 608c 	str.w	r6, [r0, #140]	; 0x8c
  tickstart = HAL_GetTick();
 807d27c:	f7fd fd40 	bl	807ad00 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 807d280:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 807d282:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 807d284:	681b      	ldr	r3, [r3, #0]
 807d286:	071a      	lsls	r2, r3, #28
 807d288:	d418      	bmi.n	807d2bc <UART_CheckIdleState+0x4a>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 807d28a:	6823      	ldr	r3, [r4, #0]
 807d28c:	681b      	ldr	r3, [r3, #0]
 807d28e:	075b      	lsls	r3, r3, #29
 807d290:	d50a      	bpl.n	807d2a8 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 807d292:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 807d296:	2200      	movs	r2, #0
 807d298:	9300      	str	r3, [sp, #0]
 807d29a:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 807d29e:	462b      	mov	r3, r5
 807d2a0:	4620      	mov	r0, r4
 807d2a2:	f7ff fecc 	bl	807d03e <UART_WaitOnFlagUntilTimeout>
 807d2a6:	b9a8      	cbnz	r0, 807d2d4 <UART_CheckIdleState+0x62>
  huart->gState = HAL_UART_STATE_READY;
 807d2a8:	2320      	movs	r3, #32
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 807d2aa:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 807d2ac:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UNLOCK(huart);
 807d2b0:	f884 0080 	strb.w	r0, [r4, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_READY;
 807d2b4:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 807d2b8:	66e0      	str	r0, [r4, #108]	; 0x6c
  return HAL_OK;
 807d2ba:	e00c      	b.n	807d2d6 <UART_CheckIdleState+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 807d2bc:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 807d2c0:	4632      	mov	r2, r6
 807d2c2:	9300      	str	r3, [sp, #0]
 807d2c4:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 807d2c8:	4603      	mov	r3, r0
 807d2ca:	4620      	mov	r0, r4
 807d2cc:	f7ff feb7 	bl	807d03e <UART_WaitOnFlagUntilTimeout>
 807d2d0:	2800      	cmp	r0, #0
 807d2d2:	d0da      	beq.n	807d28a <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 807d2d4:	2003      	movs	r0, #3
}
 807d2d6:	b002      	add	sp, #8
 807d2d8:	bd70      	pop	{r4, r5, r6, pc}

0807d2da <HAL_UART_Init>:
{
 807d2da:	b510      	push	{r4, lr}
  if (huart == NULL)
 807d2dc:	4604      	mov	r4, r0
 807d2de:	b350      	cbz	r0, 807d336 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 807d2e0:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 807d2e4:	b91b      	cbnz	r3, 807d2ee <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 807d2e6:	f880 3080 	strb.w	r3, [r0, #128]	; 0x80
    HAL_UART_MspInit(huart);
 807d2ea:	f7fd f911 	bl	807a510 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 807d2ee:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 807d2f0:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 807d2f2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  __HAL_UART_DISABLE(huart);
 807d2f6:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 807d2f8:	4620      	mov	r0, r4
  __HAL_UART_DISABLE(huart);
 807d2fa:	f023 0301 	bic.w	r3, r3, #1
 807d2fe:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 807d300:	f7ff fcd4 	bl	807ccac <UART_SetConfig>
 807d304:	2801      	cmp	r0, #1
 807d306:	d016      	beq.n	807d336 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 807d308:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 807d30a:	b113      	cbz	r3, 807d312 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 807d30c:	4620      	mov	r0, r4
 807d30e:	f7ff fe41 	bl	807cf94 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 807d312:	6823      	ldr	r3, [r4, #0]
  return (UART_CheckIdleState(huart));
 807d314:	4620      	mov	r0, r4
}
 807d316:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 807d31a:	685a      	ldr	r2, [r3, #4]
 807d31c:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 807d320:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 807d322:	689a      	ldr	r2, [r3, #8]
 807d324:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 807d328:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 807d32a:	681a      	ldr	r2, [r3, #0]
 807d32c:	f042 0201 	orr.w	r2, r2, #1
 807d330:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 807d332:	f7ff bf9e 	b.w	807d272 <UART_CheckIdleState>
}
 807d336:	2001      	movs	r0, #1
 807d338:	bd10      	pop	{r4, pc}
	...

0807d33c <exit>:
 807d33c:	b508      	push	{r3, lr}
 807d33e:	4b07      	ldr	r3, [pc, #28]	; (807d35c <exit+0x20>)
 807d340:	4604      	mov	r4, r0
 807d342:	b113      	cbz	r3, 807d34a <exit+0xe>
 807d344:	2100      	movs	r1, #0
 807d346:	e000      	b.n	807d34a <exit+0xe>
 807d348:	bf00      	nop
 807d34a:	4b05      	ldr	r3, [pc, #20]	; (807d360 <exit+0x24>)
 807d34c:	6818      	ldr	r0, [r3, #0]
 807d34e:	6a83      	ldr	r3, [r0, #40]	; 0x28
 807d350:	b103      	cbz	r3, 807d354 <exit+0x18>
 807d352:	4798      	blx	r3
 807d354:	4620      	mov	r0, r4
 807d356:	f001 f9fb 	bl	807e750 <_exit>
 807d35a:	bf00      	nop
 807d35c:	00000000 	.word	0x00000000
 807d360:	0807ec5c 	.word	0x0807ec5c

0807d364 <__libc_init_array>:
 807d364:	b570      	push	{r4, r5, r6, lr}
 807d366:	4e0d      	ldr	r6, [pc, #52]	; (807d39c <__libc_init_array+0x38>)
 807d368:	2500      	movs	r5, #0
 807d36a:	4c0d      	ldr	r4, [pc, #52]	; (807d3a0 <__libc_init_array+0x3c>)
 807d36c:	1ba4      	subs	r4, r4, r6
 807d36e:	10a4      	asrs	r4, r4, #2
 807d370:	42a5      	cmp	r5, r4
 807d372:	d109      	bne.n	807d388 <__libc_init_array+0x24>
 807d374:	4e0b      	ldr	r6, [pc, #44]	; (807d3a4 <__libc_init_array+0x40>)
 807d376:	2500      	movs	r5, #0
 807d378:	4c0b      	ldr	r4, [pc, #44]	; (807d3a8 <__libc_init_array+0x44>)
 807d37a:	f001 f9eb 	bl	807e754 <_init>
 807d37e:	1ba4      	subs	r4, r4, r6
 807d380:	10a4      	asrs	r4, r4, #2
 807d382:	42a5      	cmp	r5, r4
 807d384:	d105      	bne.n	807d392 <__libc_init_array+0x2e>
 807d386:	bd70      	pop	{r4, r5, r6, pc}
 807d388:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 807d38c:	3501      	adds	r5, #1
 807d38e:	4798      	blx	r3
 807d390:	e7ee      	b.n	807d370 <__libc_init_array+0xc>
 807d392:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 807d396:	3501      	adds	r5, #1
 807d398:	4798      	blx	r3
 807d39a:	e7f2      	b.n	807d382 <__libc_init_array+0x1e>
 807d39c:	20000090 	.word	0x20000090
 807d3a0:	20000090 	.word	0x20000090
 807d3a4:	20000090 	.word	0x20000090
 807d3a8:	20000094 	.word	0x20000094

0807d3ac <memset>:
 807d3ac:	4402      	add	r2, r0
 807d3ae:	4603      	mov	r3, r0
 807d3b0:	4293      	cmp	r3, r2
 807d3b2:	d100      	bne.n	807d3b6 <memset+0xa>
 807d3b4:	4770      	bx	lr
 807d3b6:	f803 1b01 	strb.w	r1, [r3], #1
 807d3ba:	e7f9      	b.n	807d3b0 <memset+0x4>

0807d3bc <iprintf>:
 807d3bc:	b40f      	push	{r0, r1, r2, r3}
 807d3be:	4b0a      	ldr	r3, [pc, #40]	; (807d3e8 <iprintf+0x2c>)
 807d3c0:	b513      	push	{r0, r1, r4, lr}
 807d3c2:	681c      	ldr	r4, [r3, #0]
 807d3c4:	b124      	cbz	r4, 807d3d0 <iprintf+0x14>
 807d3c6:	69a3      	ldr	r3, [r4, #24]
 807d3c8:	b913      	cbnz	r3, 807d3d0 <iprintf+0x14>
 807d3ca:	4620      	mov	r0, r4
 807d3cc:	f000 facc 	bl	807d968 <__sinit>
 807d3d0:	ab05      	add	r3, sp, #20
 807d3d2:	9a04      	ldr	r2, [sp, #16]
 807d3d4:	68a1      	ldr	r1, [r4, #8]
 807d3d6:	4620      	mov	r0, r4
 807d3d8:	9301      	str	r3, [sp, #4]
 807d3da:	f000 fc8d 	bl	807dcf8 <_vfiprintf_r>
 807d3de:	b002      	add	sp, #8
 807d3e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 807d3e4:	b004      	add	sp, #16
 807d3e6:	4770      	bx	lr
 807d3e8:	2000002c 	.word	0x2000002c

0807d3ec <_puts_r>:
 807d3ec:	b570      	push	{r4, r5, r6, lr}
 807d3ee:	460e      	mov	r6, r1
 807d3f0:	4605      	mov	r5, r0
 807d3f2:	b118      	cbz	r0, 807d3fc <_puts_r+0x10>
 807d3f4:	6983      	ldr	r3, [r0, #24]
 807d3f6:	b90b      	cbnz	r3, 807d3fc <_puts_r+0x10>
 807d3f8:	f000 fab6 	bl	807d968 <__sinit>
 807d3fc:	69ab      	ldr	r3, [r5, #24]
 807d3fe:	68ac      	ldr	r4, [r5, #8]
 807d400:	b913      	cbnz	r3, 807d408 <_puts_r+0x1c>
 807d402:	4628      	mov	r0, r5
 807d404:	f000 fab0 	bl	807d968 <__sinit>
 807d408:	4b23      	ldr	r3, [pc, #140]	; (807d498 <_puts_r+0xac>)
 807d40a:	429c      	cmp	r4, r3
 807d40c:	d117      	bne.n	807d43e <_puts_r+0x52>
 807d40e:	686c      	ldr	r4, [r5, #4]
 807d410:	89a3      	ldrh	r3, [r4, #12]
 807d412:	071b      	lsls	r3, r3, #28
 807d414:	d51d      	bpl.n	807d452 <_puts_r+0x66>
 807d416:	6923      	ldr	r3, [r4, #16]
 807d418:	b1db      	cbz	r3, 807d452 <_puts_r+0x66>
 807d41a:	3e01      	subs	r6, #1
 807d41c:	68a3      	ldr	r3, [r4, #8]
 807d41e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 807d422:	3b01      	subs	r3, #1
 807d424:	60a3      	str	r3, [r4, #8]
 807d426:	b9e9      	cbnz	r1, 807d464 <_puts_r+0x78>
 807d428:	2b00      	cmp	r3, #0
 807d42a:	da2e      	bge.n	807d48a <_puts_r+0x9e>
 807d42c:	4622      	mov	r2, r4
 807d42e:	210a      	movs	r1, #10
 807d430:	4628      	mov	r0, r5
 807d432:	f000 f8eb 	bl	807d60c <__swbuf_r>
 807d436:	3001      	adds	r0, #1
 807d438:	d011      	beq.n	807d45e <_puts_r+0x72>
 807d43a:	200a      	movs	r0, #10
 807d43c:	e011      	b.n	807d462 <_puts_r+0x76>
 807d43e:	4b17      	ldr	r3, [pc, #92]	; (807d49c <_puts_r+0xb0>)
 807d440:	429c      	cmp	r4, r3
 807d442:	d101      	bne.n	807d448 <_puts_r+0x5c>
 807d444:	68ac      	ldr	r4, [r5, #8]
 807d446:	e7e3      	b.n	807d410 <_puts_r+0x24>
 807d448:	4b15      	ldr	r3, [pc, #84]	; (807d4a0 <_puts_r+0xb4>)
 807d44a:	429c      	cmp	r4, r3
 807d44c:	bf08      	it	eq
 807d44e:	68ec      	ldreq	r4, [r5, #12]
 807d450:	e7de      	b.n	807d410 <_puts_r+0x24>
 807d452:	4621      	mov	r1, r4
 807d454:	4628      	mov	r0, r5
 807d456:	f000 f92b 	bl	807d6b0 <__swsetup_r>
 807d45a:	2800      	cmp	r0, #0
 807d45c:	d0dd      	beq.n	807d41a <_puts_r+0x2e>
 807d45e:	f04f 30ff 	mov.w	r0, #4294967295
 807d462:	bd70      	pop	{r4, r5, r6, pc}
 807d464:	2b00      	cmp	r3, #0
 807d466:	da04      	bge.n	807d472 <_puts_r+0x86>
 807d468:	69a2      	ldr	r2, [r4, #24]
 807d46a:	429a      	cmp	r2, r3
 807d46c:	dc06      	bgt.n	807d47c <_puts_r+0x90>
 807d46e:	290a      	cmp	r1, #10
 807d470:	d004      	beq.n	807d47c <_puts_r+0x90>
 807d472:	6823      	ldr	r3, [r4, #0]
 807d474:	1c5a      	adds	r2, r3, #1
 807d476:	6022      	str	r2, [r4, #0]
 807d478:	7019      	strb	r1, [r3, #0]
 807d47a:	e7cf      	b.n	807d41c <_puts_r+0x30>
 807d47c:	4622      	mov	r2, r4
 807d47e:	4628      	mov	r0, r5
 807d480:	f000 f8c4 	bl	807d60c <__swbuf_r>
 807d484:	3001      	adds	r0, #1
 807d486:	d1c9      	bne.n	807d41c <_puts_r+0x30>
 807d488:	e7e9      	b.n	807d45e <_puts_r+0x72>
 807d48a:	6823      	ldr	r3, [r4, #0]
 807d48c:	200a      	movs	r0, #10
 807d48e:	1c5a      	adds	r2, r3, #1
 807d490:	6022      	str	r2, [r4, #0]
 807d492:	7018      	strb	r0, [r3, #0]
 807d494:	e7e5      	b.n	807d462 <_puts_r+0x76>
 807d496:	bf00      	nop
 807d498:	0807ec80 	.word	0x0807ec80
 807d49c:	0807eca0 	.word	0x0807eca0
 807d4a0:	0807ec60 	.word	0x0807ec60

0807d4a4 <puts>:
 807d4a4:	4b02      	ldr	r3, [pc, #8]	; (807d4b0 <puts+0xc>)
 807d4a6:	4601      	mov	r1, r0
 807d4a8:	6818      	ldr	r0, [r3, #0]
 807d4aa:	f7ff bf9f 	b.w	807d3ec <_puts_r>
 807d4ae:	bf00      	nop
 807d4b0:	2000002c 	.word	0x2000002c

0807d4b4 <setvbuf>:
 807d4b4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 807d4b8:	461d      	mov	r5, r3
 807d4ba:	4b50      	ldr	r3, [pc, #320]	; (807d5fc <setvbuf+0x148>)
 807d4bc:	4604      	mov	r4, r0
 807d4be:	460f      	mov	r7, r1
 807d4c0:	681e      	ldr	r6, [r3, #0]
 807d4c2:	4690      	mov	r8, r2
 807d4c4:	b126      	cbz	r6, 807d4d0 <setvbuf+0x1c>
 807d4c6:	69b3      	ldr	r3, [r6, #24]
 807d4c8:	b913      	cbnz	r3, 807d4d0 <setvbuf+0x1c>
 807d4ca:	4630      	mov	r0, r6
 807d4cc:	f000 fa4c 	bl	807d968 <__sinit>
 807d4d0:	4b4b      	ldr	r3, [pc, #300]	; (807d600 <setvbuf+0x14c>)
 807d4d2:	429c      	cmp	r4, r3
 807d4d4:	d152      	bne.n	807d57c <setvbuf+0xc8>
 807d4d6:	6874      	ldr	r4, [r6, #4]
 807d4d8:	f1b8 0f02 	cmp.w	r8, #2
 807d4dc:	d006      	beq.n	807d4ec <setvbuf+0x38>
 807d4de:	f1b8 0f01 	cmp.w	r8, #1
 807d4e2:	f200 8088 	bhi.w	807d5f6 <setvbuf+0x142>
 807d4e6:	2d00      	cmp	r5, #0
 807d4e8:	f2c0 8085 	blt.w	807d5f6 <setvbuf+0x142>
 807d4ec:	4621      	mov	r1, r4
 807d4ee:	4630      	mov	r0, r6
 807d4f0:	f000 f9d0 	bl	807d894 <_fflush_r>
 807d4f4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 807d4f6:	b141      	cbz	r1, 807d50a <setvbuf+0x56>
 807d4f8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 807d4fc:	4299      	cmp	r1, r3
 807d4fe:	d002      	beq.n	807d506 <setvbuf+0x52>
 807d500:	4630      	mov	r0, r6
 807d502:	f000 fb27 	bl	807db54 <_free_r>
 807d506:	2300      	movs	r3, #0
 807d508:	6363      	str	r3, [r4, #52]	; 0x34
 807d50a:	2300      	movs	r3, #0
 807d50c:	61a3      	str	r3, [r4, #24]
 807d50e:	6063      	str	r3, [r4, #4]
 807d510:	89a3      	ldrh	r3, [r4, #12]
 807d512:	061b      	lsls	r3, r3, #24
 807d514:	d503      	bpl.n	807d51e <setvbuf+0x6a>
 807d516:	6921      	ldr	r1, [r4, #16]
 807d518:	4630      	mov	r0, r6
 807d51a:	f000 fb1b 	bl	807db54 <_free_r>
 807d51e:	89a3      	ldrh	r3, [r4, #12]
 807d520:	f1b8 0f02 	cmp.w	r8, #2
 807d524:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
 807d528:	f023 0303 	bic.w	r3, r3, #3
 807d52c:	81a3      	strh	r3, [r4, #12]
 807d52e:	d05c      	beq.n	807d5ea <setvbuf+0x136>
 807d530:	ab01      	add	r3, sp, #4
 807d532:	466a      	mov	r2, sp
 807d534:	4621      	mov	r1, r4
 807d536:	4630      	mov	r0, r6
 807d538:	f000 faa0 	bl	807da7c <__swhatbuf_r>
 807d53c:	89a3      	ldrh	r3, [r4, #12]
 807d53e:	4318      	orrs	r0, r3
 807d540:	81a0      	strh	r0, [r4, #12]
 807d542:	bb2d      	cbnz	r5, 807d590 <setvbuf+0xdc>
 807d544:	9d00      	ldr	r5, [sp, #0]
 807d546:	4628      	mov	r0, r5
 807d548:	f000 fafc 	bl	807db44 <malloc>
 807d54c:	4607      	mov	r7, r0
 807d54e:	2800      	cmp	r0, #0
 807d550:	d14d      	bne.n	807d5ee <setvbuf+0x13a>
 807d552:	f8dd 9000 	ldr.w	r9, [sp]
 807d556:	45a9      	cmp	r9, r5
 807d558:	d13b      	bne.n	807d5d2 <setvbuf+0x11e>
 807d55a:	f04f 30ff 	mov.w	r0, #4294967295
 807d55e:	89a3      	ldrh	r3, [r4, #12]
 807d560:	f043 0302 	orr.w	r3, r3, #2
 807d564:	81a3      	strh	r3, [r4, #12]
 807d566:	2300      	movs	r3, #0
 807d568:	60a3      	str	r3, [r4, #8]
 807d56a:	f104 0347 	add.w	r3, r4, #71	; 0x47
 807d56e:	6023      	str	r3, [r4, #0]
 807d570:	6123      	str	r3, [r4, #16]
 807d572:	2301      	movs	r3, #1
 807d574:	6163      	str	r3, [r4, #20]
 807d576:	b003      	add	sp, #12
 807d578:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 807d57c:	4b21      	ldr	r3, [pc, #132]	; (807d604 <setvbuf+0x150>)
 807d57e:	429c      	cmp	r4, r3
 807d580:	d101      	bne.n	807d586 <setvbuf+0xd2>
 807d582:	68b4      	ldr	r4, [r6, #8]
 807d584:	e7a8      	b.n	807d4d8 <setvbuf+0x24>
 807d586:	4b20      	ldr	r3, [pc, #128]	; (807d608 <setvbuf+0x154>)
 807d588:	429c      	cmp	r4, r3
 807d58a:	bf08      	it	eq
 807d58c:	68f4      	ldreq	r4, [r6, #12]
 807d58e:	e7a3      	b.n	807d4d8 <setvbuf+0x24>
 807d590:	2f00      	cmp	r7, #0
 807d592:	d0d8      	beq.n	807d546 <setvbuf+0x92>
 807d594:	69b3      	ldr	r3, [r6, #24]
 807d596:	b913      	cbnz	r3, 807d59e <setvbuf+0xea>
 807d598:	4630      	mov	r0, r6
 807d59a:	f000 f9e5 	bl	807d968 <__sinit>
 807d59e:	f1b8 0f01 	cmp.w	r8, #1
 807d5a2:	6027      	str	r7, [r4, #0]
 807d5a4:	bf02      	ittt	eq
 807d5a6:	89a3      	ldrheq	r3, [r4, #12]
 807d5a8:	f043 0301 	orreq.w	r3, r3, #1
 807d5ac:	81a3      	strheq	r3, [r4, #12]
 807d5ae:	89a3      	ldrh	r3, [r4, #12]
 807d5b0:	f013 0008 	ands.w	r0, r3, #8
 807d5b4:	e9c4 7504 	strd	r7, r5, [r4, #16]
 807d5b8:	d01b      	beq.n	807d5f2 <setvbuf+0x13e>
 807d5ba:	f013 0001 	ands.w	r0, r3, #1
 807d5be:	f04f 0300 	mov.w	r3, #0
 807d5c2:	bf1d      	ittte	ne
 807d5c4:	426d      	negne	r5, r5
 807d5c6:	60a3      	strne	r3, [r4, #8]
 807d5c8:	4618      	movne	r0, r3
 807d5ca:	60a5      	streq	r5, [r4, #8]
 807d5cc:	bf18      	it	ne
 807d5ce:	61a5      	strne	r5, [r4, #24]
 807d5d0:	e7d1      	b.n	807d576 <setvbuf+0xc2>
 807d5d2:	4648      	mov	r0, r9
 807d5d4:	f000 fab6 	bl	807db44 <malloc>
 807d5d8:	4607      	mov	r7, r0
 807d5da:	2800      	cmp	r0, #0
 807d5dc:	d0bd      	beq.n	807d55a <setvbuf+0xa6>
 807d5de:	89a3      	ldrh	r3, [r4, #12]
 807d5e0:	464d      	mov	r5, r9
 807d5e2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 807d5e6:	81a3      	strh	r3, [r4, #12]
 807d5e8:	e7d4      	b.n	807d594 <setvbuf+0xe0>
 807d5ea:	2000      	movs	r0, #0
 807d5ec:	e7b7      	b.n	807d55e <setvbuf+0xaa>
 807d5ee:	46a9      	mov	r9, r5
 807d5f0:	e7f5      	b.n	807d5de <setvbuf+0x12a>
 807d5f2:	60a0      	str	r0, [r4, #8]
 807d5f4:	e7bf      	b.n	807d576 <setvbuf+0xc2>
 807d5f6:	f04f 30ff 	mov.w	r0, #4294967295
 807d5fa:	e7bc      	b.n	807d576 <setvbuf+0xc2>
 807d5fc:	2000002c 	.word	0x2000002c
 807d600:	0807ec80 	.word	0x0807ec80
 807d604:	0807eca0 	.word	0x0807eca0
 807d608:	0807ec60 	.word	0x0807ec60

0807d60c <__swbuf_r>:
 807d60c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 807d60e:	460e      	mov	r6, r1
 807d610:	4614      	mov	r4, r2
 807d612:	4605      	mov	r5, r0
 807d614:	b118      	cbz	r0, 807d61e <__swbuf_r+0x12>
 807d616:	6983      	ldr	r3, [r0, #24]
 807d618:	b90b      	cbnz	r3, 807d61e <__swbuf_r+0x12>
 807d61a:	f000 f9a5 	bl	807d968 <__sinit>
 807d61e:	4b21      	ldr	r3, [pc, #132]	; (807d6a4 <__swbuf_r+0x98>)
 807d620:	429c      	cmp	r4, r3
 807d622:	d12a      	bne.n	807d67a <__swbuf_r+0x6e>
 807d624:	686c      	ldr	r4, [r5, #4]
 807d626:	69a3      	ldr	r3, [r4, #24]
 807d628:	60a3      	str	r3, [r4, #8]
 807d62a:	89a3      	ldrh	r3, [r4, #12]
 807d62c:	071a      	lsls	r2, r3, #28
 807d62e:	d52e      	bpl.n	807d68e <__swbuf_r+0x82>
 807d630:	6923      	ldr	r3, [r4, #16]
 807d632:	b363      	cbz	r3, 807d68e <__swbuf_r+0x82>
 807d634:	6923      	ldr	r3, [r4, #16]
 807d636:	b2f6      	uxtb	r6, r6
 807d638:	6820      	ldr	r0, [r4, #0]
 807d63a:	4637      	mov	r7, r6
 807d63c:	1ac0      	subs	r0, r0, r3
 807d63e:	6963      	ldr	r3, [r4, #20]
 807d640:	4283      	cmp	r3, r0
 807d642:	dc04      	bgt.n	807d64e <__swbuf_r+0x42>
 807d644:	4621      	mov	r1, r4
 807d646:	4628      	mov	r0, r5
 807d648:	f000 f924 	bl	807d894 <_fflush_r>
 807d64c:	bb28      	cbnz	r0, 807d69a <__swbuf_r+0x8e>
 807d64e:	68a3      	ldr	r3, [r4, #8]
 807d650:	3001      	adds	r0, #1
 807d652:	3b01      	subs	r3, #1
 807d654:	60a3      	str	r3, [r4, #8]
 807d656:	6823      	ldr	r3, [r4, #0]
 807d658:	1c5a      	adds	r2, r3, #1
 807d65a:	6022      	str	r2, [r4, #0]
 807d65c:	701e      	strb	r6, [r3, #0]
 807d65e:	6963      	ldr	r3, [r4, #20]
 807d660:	4283      	cmp	r3, r0
 807d662:	d004      	beq.n	807d66e <__swbuf_r+0x62>
 807d664:	89a3      	ldrh	r3, [r4, #12]
 807d666:	07db      	lsls	r3, r3, #31
 807d668:	d519      	bpl.n	807d69e <__swbuf_r+0x92>
 807d66a:	2e0a      	cmp	r6, #10
 807d66c:	d117      	bne.n	807d69e <__swbuf_r+0x92>
 807d66e:	4621      	mov	r1, r4
 807d670:	4628      	mov	r0, r5
 807d672:	f000 f90f 	bl	807d894 <_fflush_r>
 807d676:	b190      	cbz	r0, 807d69e <__swbuf_r+0x92>
 807d678:	e00f      	b.n	807d69a <__swbuf_r+0x8e>
 807d67a:	4b0b      	ldr	r3, [pc, #44]	; (807d6a8 <__swbuf_r+0x9c>)
 807d67c:	429c      	cmp	r4, r3
 807d67e:	d101      	bne.n	807d684 <__swbuf_r+0x78>
 807d680:	68ac      	ldr	r4, [r5, #8]
 807d682:	e7d0      	b.n	807d626 <__swbuf_r+0x1a>
 807d684:	4b09      	ldr	r3, [pc, #36]	; (807d6ac <__swbuf_r+0xa0>)
 807d686:	429c      	cmp	r4, r3
 807d688:	bf08      	it	eq
 807d68a:	68ec      	ldreq	r4, [r5, #12]
 807d68c:	e7cb      	b.n	807d626 <__swbuf_r+0x1a>
 807d68e:	4621      	mov	r1, r4
 807d690:	4628      	mov	r0, r5
 807d692:	f000 f80d 	bl	807d6b0 <__swsetup_r>
 807d696:	2800      	cmp	r0, #0
 807d698:	d0cc      	beq.n	807d634 <__swbuf_r+0x28>
 807d69a:	f04f 37ff 	mov.w	r7, #4294967295
 807d69e:	4638      	mov	r0, r7
 807d6a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 807d6a2:	bf00      	nop
 807d6a4:	0807ec80 	.word	0x0807ec80
 807d6a8:	0807eca0 	.word	0x0807eca0
 807d6ac:	0807ec60 	.word	0x0807ec60

0807d6b0 <__swsetup_r>:
 807d6b0:	4b32      	ldr	r3, [pc, #200]	; (807d77c <__swsetup_r+0xcc>)
 807d6b2:	b570      	push	{r4, r5, r6, lr}
 807d6b4:	681d      	ldr	r5, [r3, #0]
 807d6b6:	4606      	mov	r6, r0
 807d6b8:	460c      	mov	r4, r1
 807d6ba:	b125      	cbz	r5, 807d6c6 <__swsetup_r+0x16>
 807d6bc:	69ab      	ldr	r3, [r5, #24]
 807d6be:	b913      	cbnz	r3, 807d6c6 <__swsetup_r+0x16>
 807d6c0:	4628      	mov	r0, r5
 807d6c2:	f000 f951 	bl	807d968 <__sinit>
 807d6c6:	4b2e      	ldr	r3, [pc, #184]	; (807d780 <__swsetup_r+0xd0>)
 807d6c8:	429c      	cmp	r4, r3
 807d6ca:	d10f      	bne.n	807d6ec <__swsetup_r+0x3c>
 807d6cc:	686c      	ldr	r4, [r5, #4]
 807d6ce:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 807d6d2:	b29a      	uxth	r2, r3
 807d6d4:	0715      	lsls	r5, r2, #28
 807d6d6:	d42c      	bmi.n	807d732 <__swsetup_r+0x82>
 807d6d8:	06d0      	lsls	r0, r2, #27
 807d6da:	d411      	bmi.n	807d700 <__swsetup_r+0x50>
 807d6dc:	2209      	movs	r2, #9
 807d6de:	6032      	str	r2, [r6, #0]
 807d6e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 807d6e4:	f04f 30ff 	mov.w	r0, #4294967295
 807d6e8:	81a3      	strh	r3, [r4, #12]
 807d6ea:	e03e      	b.n	807d76a <__swsetup_r+0xba>
 807d6ec:	4b25      	ldr	r3, [pc, #148]	; (807d784 <__swsetup_r+0xd4>)
 807d6ee:	429c      	cmp	r4, r3
 807d6f0:	d101      	bne.n	807d6f6 <__swsetup_r+0x46>
 807d6f2:	68ac      	ldr	r4, [r5, #8]
 807d6f4:	e7eb      	b.n	807d6ce <__swsetup_r+0x1e>
 807d6f6:	4b24      	ldr	r3, [pc, #144]	; (807d788 <__swsetup_r+0xd8>)
 807d6f8:	429c      	cmp	r4, r3
 807d6fa:	bf08      	it	eq
 807d6fc:	68ec      	ldreq	r4, [r5, #12]
 807d6fe:	e7e6      	b.n	807d6ce <__swsetup_r+0x1e>
 807d700:	0751      	lsls	r1, r2, #29
 807d702:	d512      	bpl.n	807d72a <__swsetup_r+0x7a>
 807d704:	6b61      	ldr	r1, [r4, #52]	; 0x34
 807d706:	b141      	cbz	r1, 807d71a <__swsetup_r+0x6a>
 807d708:	f104 0344 	add.w	r3, r4, #68	; 0x44
 807d70c:	4299      	cmp	r1, r3
 807d70e:	d002      	beq.n	807d716 <__swsetup_r+0x66>
 807d710:	4630      	mov	r0, r6
 807d712:	f000 fa1f 	bl	807db54 <_free_r>
 807d716:	2300      	movs	r3, #0
 807d718:	6363      	str	r3, [r4, #52]	; 0x34
 807d71a:	89a3      	ldrh	r3, [r4, #12]
 807d71c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 807d720:	81a3      	strh	r3, [r4, #12]
 807d722:	2300      	movs	r3, #0
 807d724:	6063      	str	r3, [r4, #4]
 807d726:	6923      	ldr	r3, [r4, #16]
 807d728:	6023      	str	r3, [r4, #0]
 807d72a:	89a3      	ldrh	r3, [r4, #12]
 807d72c:	f043 0308 	orr.w	r3, r3, #8
 807d730:	81a3      	strh	r3, [r4, #12]
 807d732:	6923      	ldr	r3, [r4, #16]
 807d734:	b94b      	cbnz	r3, 807d74a <__swsetup_r+0x9a>
 807d736:	89a3      	ldrh	r3, [r4, #12]
 807d738:	f403 7320 	and.w	r3, r3, #640	; 0x280
 807d73c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 807d740:	d003      	beq.n	807d74a <__swsetup_r+0x9a>
 807d742:	4621      	mov	r1, r4
 807d744:	4630      	mov	r0, r6
 807d746:	f000 f9bd 	bl	807dac4 <__smakebuf_r>
 807d74a:	89a2      	ldrh	r2, [r4, #12]
 807d74c:	f012 0301 	ands.w	r3, r2, #1
 807d750:	d00c      	beq.n	807d76c <__swsetup_r+0xbc>
 807d752:	2300      	movs	r3, #0
 807d754:	60a3      	str	r3, [r4, #8]
 807d756:	6963      	ldr	r3, [r4, #20]
 807d758:	425b      	negs	r3, r3
 807d75a:	61a3      	str	r3, [r4, #24]
 807d75c:	6923      	ldr	r3, [r4, #16]
 807d75e:	b953      	cbnz	r3, 807d776 <__swsetup_r+0xc6>
 807d760:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 807d764:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 807d768:	d1ba      	bne.n	807d6e0 <__swsetup_r+0x30>
 807d76a:	bd70      	pop	{r4, r5, r6, pc}
 807d76c:	0792      	lsls	r2, r2, #30
 807d76e:	bf58      	it	pl
 807d770:	6963      	ldrpl	r3, [r4, #20]
 807d772:	60a3      	str	r3, [r4, #8]
 807d774:	e7f2      	b.n	807d75c <__swsetup_r+0xac>
 807d776:	2000      	movs	r0, #0
 807d778:	e7f7      	b.n	807d76a <__swsetup_r+0xba>
 807d77a:	bf00      	nop
 807d77c:	2000002c 	.word	0x2000002c
 807d780:	0807ec80 	.word	0x0807ec80
 807d784:	0807eca0 	.word	0x0807eca0
 807d788:	0807ec60 	.word	0x0807ec60

0807d78c <__sflush_r>:
 807d78c:	898a      	ldrh	r2, [r1, #12]
 807d78e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 807d792:	4605      	mov	r5, r0
 807d794:	0710      	lsls	r0, r2, #28
 807d796:	460c      	mov	r4, r1
 807d798:	d458      	bmi.n	807d84c <__sflush_r+0xc0>
 807d79a:	684b      	ldr	r3, [r1, #4]
 807d79c:	2b00      	cmp	r3, #0
 807d79e:	dc05      	bgt.n	807d7ac <__sflush_r+0x20>
 807d7a0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 807d7a2:	2b00      	cmp	r3, #0
 807d7a4:	dc02      	bgt.n	807d7ac <__sflush_r+0x20>
 807d7a6:	2000      	movs	r0, #0
 807d7a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 807d7ac:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 807d7ae:	2e00      	cmp	r6, #0
 807d7b0:	d0f9      	beq.n	807d7a6 <__sflush_r+0x1a>
 807d7b2:	2300      	movs	r3, #0
 807d7b4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 807d7b8:	682f      	ldr	r7, [r5, #0]
 807d7ba:	6a21      	ldr	r1, [r4, #32]
 807d7bc:	602b      	str	r3, [r5, #0]
 807d7be:	d032      	beq.n	807d826 <__sflush_r+0x9a>
 807d7c0:	6d60      	ldr	r0, [r4, #84]	; 0x54
 807d7c2:	89a3      	ldrh	r3, [r4, #12]
 807d7c4:	075a      	lsls	r2, r3, #29
 807d7c6:	d505      	bpl.n	807d7d4 <__sflush_r+0x48>
 807d7c8:	6863      	ldr	r3, [r4, #4]
 807d7ca:	1ac0      	subs	r0, r0, r3
 807d7cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 807d7ce:	b10b      	cbz	r3, 807d7d4 <__sflush_r+0x48>
 807d7d0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 807d7d2:	1ac0      	subs	r0, r0, r3
 807d7d4:	2300      	movs	r3, #0
 807d7d6:	4602      	mov	r2, r0
 807d7d8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 807d7da:	4628      	mov	r0, r5
 807d7dc:	6a21      	ldr	r1, [r4, #32]
 807d7de:	47b0      	blx	r6
 807d7e0:	1c43      	adds	r3, r0, #1
 807d7e2:	89a3      	ldrh	r3, [r4, #12]
 807d7e4:	d106      	bne.n	807d7f4 <__sflush_r+0x68>
 807d7e6:	6829      	ldr	r1, [r5, #0]
 807d7e8:	291d      	cmp	r1, #29
 807d7ea:	d847      	bhi.n	807d87c <__sflush_r+0xf0>
 807d7ec:	4a28      	ldr	r2, [pc, #160]	; (807d890 <__sflush_r+0x104>)
 807d7ee:	40ca      	lsrs	r2, r1
 807d7f0:	07d6      	lsls	r6, r2, #31
 807d7f2:	d543      	bpl.n	807d87c <__sflush_r+0xf0>
 807d7f4:	2200      	movs	r2, #0
 807d7f6:	04d9      	lsls	r1, r3, #19
 807d7f8:	6062      	str	r2, [r4, #4]
 807d7fa:	6922      	ldr	r2, [r4, #16]
 807d7fc:	6022      	str	r2, [r4, #0]
 807d7fe:	d504      	bpl.n	807d80a <__sflush_r+0x7e>
 807d800:	1c42      	adds	r2, r0, #1
 807d802:	d101      	bne.n	807d808 <__sflush_r+0x7c>
 807d804:	682b      	ldr	r3, [r5, #0]
 807d806:	b903      	cbnz	r3, 807d80a <__sflush_r+0x7e>
 807d808:	6560      	str	r0, [r4, #84]	; 0x54
 807d80a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 807d80c:	602f      	str	r7, [r5, #0]
 807d80e:	2900      	cmp	r1, #0
 807d810:	d0c9      	beq.n	807d7a6 <__sflush_r+0x1a>
 807d812:	f104 0344 	add.w	r3, r4, #68	; 0x44
 807d816:	4299      	cmp	r1, r3
 807d818:	d002      	beq.n	807d820 <__sflush_r+0x94>
 807d81a:	4628      	mov	r0, r5
 807d81c:	f000 f99a 	bl	807db54 <_free_r>
 807d820:	2000      	movs	r0, #0
 807d822:	6360      	str	r0, [r4, #52]	; 0x34
 807d824:	e7c0      	b.n	807d7a8 <__sflush_r+0x1c>
 807d826:	2301      	movs	r3, #1
 807d828:	4628      	mov	r0, r5
 807d82a:	47b0      	blx	r6
 807d82c:	1c41      	adds	r1, r0, #1
 807d82e:	d1c8      	bne.n	807d7c2 <__sflush_r+0x36>
 807d830:	682b      	ldr	r3, [r5, #0]
 807d832:	2b00      	cmp	r3, #0
 807d834:	d0c5      	beq.n	807d7c2 <__sflush_r+0x36>
 807d836:	2b1d      	cmp	r3, #29
 807d838:	d001      	beq.n	807d83e <__sflush_r+0xb2>
 807d83a:	2b16      	cmp	r3, #22
 807d83c:	d101      	bne.n	807d842 <__sflush_r+0xb6>
 807d83e:	602f      	str	r7, [r5, #0]
 807d840:	e7b1      	b.n	807d7a6 <__sflush_r+0x1a>
 807d842:	89a3      	ldrh	r3, [r4, #12]
 807d844:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 807d848:	81a3      	strh	r3, [r4, #12]
 807d84a:	e7ad      	b.n	807d7a8 <__sflush_r+0x1c>
 807d84c:	690f      	ldr	r7, [r1, #16]
 807d84e:	2f00      	cmp	r7, #0
 807d850:	d0a9      	beq.n	807d7a6 <__sflush_r+0x1a>
 807d852:	0793      	lsls	r3, r2, #30
 807d854:	680e      	ldr	r6, [r1, #0]
 807d856:	600f      	str	r7, [r1, #0]
 807d858:	bf0c      	ite	eq
 807d85a:	694b      	ldreq	r3, [r1, #20]
 807d85c:	2300      	movne	r3, #0
 807d85e:	eba6 0807 	sub.w	r8, r6, r7
 807d862:	608b      	str	r3, [r1, #8]
 807d864:	f1b8 0f00 	cmp.w	r8, #0
 807d868:	dd9d      	ble.n	807d7a6 <__sflush_r+0x1a>
 807d86a:	4643      	mov	r3, r8
 807d86c:	463a      	mov	r2, r7
 807d86e:	6a21      	ldr	r1, [r4, #32]
 807d870:	4628      	mov	r0, r5
 807d872:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 807d874:	47b0      	blx	r6
 807d876:	2800      	cmp	r0, #0
 807d878:	dc06      	bgt.n	807d888 <__sflush_r+0xfc>
 807d87a:	89a3      	ldrh	r3, [r4, #12]
 807d87c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 807d880:	f04f 30ff 	mov.w	r0, #4294967295
 807d884:	81a3      	strh	r3, [r4, #12]
 807d886:	e78f      	b.n	807d7a8 <__sflush_r+0x1c>
 807d888:	4407      	add	r7, r0
 807d88a:	eba8 0800 	sub.w	r8, r8, r0
 807d88e:	e7e9      	b.n	807d864 <__sflush_r+0xd8>
 807d890:	20400001 	.word	0x20400001

0807d894 <_fflush_r>:
 807d894:	b538      	push	{r3, r4, r5, lr}
 807d896:	690b      	ldr	r3, [r1, #16]
 807d898:	4605      	mov	r5, r0
 807d89a:	460c      	mov	r4, r1
 807d89c:	b1db      	cbz	r3, 807d8d6 <_fflush_r+0x42>
 807d89e:	b118      	cbz	r0, 807d8a8 <_fflush_r+0x14>
 807d8a0:	6983      	ldr	r3, [r0, #24]
 807d8a2:	b90b      	cbnz	r3, 807d8a8 <_fflush_r+0x14>
 807d8a4:	f000 f860 	bl	807d968 <__sinit>
 807d8a8:	4b0c      	ldr	r3, [pc, #48]	; (807d8dc <_fflush_r+0x48>)
 807d8aa:	429c      	cmp	r4, r3
 807d8ac:	d109      	bne.n	807d8c2 <_fflush_r+0x2e>
 807d8ae:	686c      	ldr	r4, [r5, #4]
 807d8b0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 807d8b4:	b17b      	cbz	r3, 807d8d6 <_fflush_r+0x42>
 807d8b6:	4621      	mov	r1, r4
 807d8b8:	4628      	mov	r0, r5
 807d8ba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 807d8be:	f7ff bf65 	b.w	807d78c <__sflush_r>
 807d8c2:	4b07      	ldr	r3, [pc, #28]	; (807d8e0 <_fflush_r+0x4c>)
 807d8c4:	429c      	cmp	r4, r3
 807d8c6:	d101      	bne.n	807d8cc <_fflush_r+0x38>
 807d8c8:	68ac      	ldr	r4, [r5, #8]
 807d8ca:	e7f1      	b.n	807d8b0 <_fflush_r+0x1c>
 807d8cc:	4b05      	ldr	r3, [pc, #20]	; (807d8e4 <_fflush_r+0x50>)
 807d8ce:	429c      	cmp	r4, r3
 807d8d0:	bf08      	it	eq
 807d8d2:	68ec      	ldreq	r4, [r5, #12]
 807d8d4:	e7ec      	b.n	807d8b0 <_fflush_r+0x1c>
 807d8d6:	2000      	movs	r0, #0
 807d8d8:	bd38      	pop	{r3, r4, r5, pc}
 807d8da:	bf00      	nop
 807d8dc:	0807ec80 	.word	0x0807ec80
 807d8e0:	0807eca0 	.word	0x0807eca0
 807d8e4:	0807ec60 	.word	0x0807ec60

0807d8e8 <std>:
 807d8e8:	2300      	movs	r3, #0
 807d8ea:	b510      	push	{r4, lr}
 807d8ec:	4604      	mov	r4, r0
 807d8ee:	6083      	str	r3, [r0, #8]
 807d8f0:	8181      	strh	r1, [r0, #12]
 807d8f2:	4619      	mov	r1, r3
 807d8f4:	6643      	str	r3, [r0, #100]	; 0x64
 807d8f6:	81c2      	strh	r2, [r0, #14]
 807d8f8:	2208      	movs	r2, #8
 807d8fa:	6183      	str	r3, [r0, #24]
 807d8fc:	e9c0 3300 	strd	r3, r3, [r0]
 807d900:	e9c0 3304 	strd	r3, r3, [r0, #16]
 807d904:	305c      	adds	r0, #92	; 0x5c
 807d906:	f7ff fd51 	bl	807d3ac <memset>
 807d90a:	4b05      	ldr	r3, [pc, #20]	; (807d920 <std+0x38>)
 807d90c:	6224      	str	r4, [r4, #32]
 807d90e:	6263      	str	r3, [r4, #36]	; 0x24
 807d910:	4b04      	ldr	r3, [pc, #16]	; (807d924 <std+0x3c>)
 807d912:	62a3      	str	r3, [r4, #40]	; 0x28
 807d914:	4b04      	ldr	r3, [pc, #16]	; (807d928 <std+0x40>)
 807d916:	62e3      	str	r3, [r4, #44]	; 0x2c
 807d918:	4b04      	ldr	r3, [pc, #16]	; (807d92c <std+0x44>)
 807d91a:	6323      	str	r3, [r4, #48]	; 0x30
 807d91c:	bd10      	pop	{r4, pc}
 807d91e:	bf00      	nop
 807d920:	0807e259 	.word	0x0807e259
 807d924:	0807e27b 	.word	0x0807e27b
 807d928:	0807e2b3 	.word	0x0807e2b3
 807d92c:	0807e2d7 	.word	0x0807e2d7

0807d930 <_cleanup_r>:
 807d930:	4901      	ldr	r1, [pc, #4]	; (807d938 <_cleanup_r+0x8>)
 807d932:	f000 b885 	b.w	807da40 <_fwalk_reent>
 807d936:	bf00      	nop
 807d938:	0807d895 	.word	0x0807d895

0807d93c <__sfmoreglue>:
 807d93c:	b570      	push	{r4, r5, r6, lr}
 807d93e:	1e4a      	subs	r2, r1, #1
 807d940:	2568      	movs	r5, #104	; 0x68
 807d942:	460e      	mov	r6, r1
 807d944:	4355      	muls	r5, r2
 807d946:	f105 0174 	add.w	r1, r5, #116	; 0x74
 807d94a:	f000 f951 	bl	807dbf0 <_malloc_r>
 807d94e:	4604      	mov	r4, r0
 807d950:	b140      	cbz	r0, 807d964 <__sfmoreglue+0x28>
 807d952:	2100      	movs	r1, #0
 807d954:	f105 0268 	add.w	r2, r5, #104	; 0x68
 807d958:	e9c0 1600 	strd	r1, r6, [r0]
 807d95c:	300c      	adds	r0, #12
 807d95e:	60a0      	str	r0, [r4, #8]
 807d960:	f7ff fd24 	bl	807d3ac <memset>
 807d964:	4620      	mov	r0, r4
 807d966:	bd70      	pop	{r4, r5, r6, pc}

0807d968 <__sinit>:
 807d968:	6983      	ldr	r3, [r0, #24]
 807d96a:	b510      	push	{r4, lr}
 807d96c:	4604      	mov	r4, r0
 807d96e:	bb33      	cbnz	r3, 807d9be <__sinit+0x56>
 807d970:	6503      	str	r3, [r0, #80]	; 0x50
 807d972:	4a13      	ldr	r2, [pc, #76]	; (807d9c0 <__sinit+0x58>)
 807d974:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 807d978:	4b12      	ldr	r3, [pc, #72]	; (807d9c4 <__sinit+0x5c>)
 807d97a:	6282      	str	r2, [r0, #40]	; 0x28
 807d97c:	681b      	ldr	r3, [r3, #0]
 807d97e:	4298      	cmp	r0, r3
 807d980:	bf04      	itt	eq
 807d982:	2301      	moveq	r3, #1
 807d984:	6183      	streq	r3, [r0, #24]
 807d986:	f000 f81f 	bl	807d9c8 <__sfp>
 807d98a:	6060      	str	r0, [r4, #4]
 807d98c:	4620      	mov	r0, r4
 807d98e:	f000 f81b 	bl	807d9c8 <__sfp>
 807d992:	60a0      	str	r0, [r4, #8]
 807d994:	4620      	mov	r0, r4
 807d996:	f000 f817 	bl	807d9c8 <__sfp>
 807d99a:	2200      	movs	r2, #0
 807d99c:	60e0      	str	r0, [r4, #12]
 807d99e:	2104      	movs	r1, #4
 807d9a0:	6860      	ldr	r0, [r4, #4]
 807d9a2:	f7ff ffa1 	bl	807d8e8 <std>
 807d9a6:	2201      	movs	r2, #1
 807d9a8:	2109      	movs	r1, #9
 807d9aa:	68a0      	ldr	r0, [r4, #8]
 807d9ac:	f7ff ff9c 	bl	807d8e8 <std>
 807d9b0:	2202      	movs	r2, #2
 807d9b2:	2112      	movs	r1, #18
 807d9b4:	68e0      	ldr	r0, [r4, #12]
 807d9b6:	f7ff ff97 	bl	807d8e8 <std>
 807d9ba:	2301      	movs	r3, #1
 807d9bc:	61a3      	str	r3, [r4, #24]
 807d9be:	bd10      	pop	{r4, pc}
 807d9c0:	0807d931 	.word	0x0807d931
 807d9c4:	0807ec5c 	.word	0x0807ec5c

0807d9c8 <__sfp>:
 807d9c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 807d9ca:	4b1b      	ldr	r3, [pc, #108]	; (807da38 <__sfp+0x70>)
 807d9cc:	4607      	mov	r7, r0
 807d9ce:	681e      	ldr	r6, [r3, #0]
 807d9d0:	69b3      	ldr	r3, [r6, #24]
 807d9d2:	b913      	cbnz	r3, 807d9da <__sfp+0x12>
 807d9d4:	4630      	mov	r0, r6
 807d9d6:	f7ff ffc7 	bl	807d968 <__sinit>
 807d9da:	3648      	adds	r6, #72	; 0x48
 807d9dc:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 807d9e0:	3b01      	subs	r3, #1
 807d9e2:	d503      	bpl.n	807d9ec <__sfp+0x24>
 807d9e4:	6833      	ldr	r3, [r6, #0]
 807d9e6:	b133      	cbz	r3, 807d9f6 <__sfp+0x2e>
 807d9e8:	6836      	ldr	r6, [r6, #0]
 807d9ea:	e7f7      	b.n	807d9dc <__sfp+0x14>
 807d9ec:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 807d9f0:	b16d      	cbz	r5, 807da0e <__sfp+0x46>
 807d9f2:	3468      	adds	r4, #104	; 0x68
 807d9f4:	e7f4      	b.n	807d9e0 <__sfp+0x18>
 807d9f6:	2104      	movs	r1, #4
 807d9f8:	4638      	mov	r0, r7
 807d9fa:	f7ff ff9f 	bl	807d93c <__sfmoreglue>
 807d9fe:	6030      	str	r0, [r6, #0]
 807da00:	2800      	cmp	r0, #0
 807da02:	d1f1      	bne.n	807d9e8 <__sfp+0x20>
 807da04:	230c      	movs	r3, #12
 807da06:	4604      	mov	r4, r0
 807da08:	603b      	str	r3, [r7, #0]
 807da0a:	4620      	mov	r0, r4
 807da0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 807da0e:	4b0b      	ldr	r3, [pc, #44]	; (807da3c <__sfp+0x74>)
 807da10:	2208      	movs	r2, #8
 807da12:	6665      	str	r5, [r4, #100]	; 0x64
 807da14:	4629      	mov	r1, r5
 807da16:	60a5      	str	r5, [r4, #8]
 807da18:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 807da1c:	e9c4 5500 	strd	r5, r5, [r4]
 807da20:	e9c4 3503 	strd	r3, r5, [r4, #12]
 807da24:	e9c4 5505 	strd	r5, r5, [r4, #20]
 807da28:	f7ff fcc0 	bl	807d3ac <memset>
 807da2c:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 807da30:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 807da34:	e7e9      	b.n	807da0a <__sfp+0x42>
 807da36:	bf00      	nop
 807da38:	0807ec5c 	.word	0x0807ec5c
 807da3c:	ffff0001 	.word	0xffff0001

0807da40 <_fwalk_reent>:
 807da40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 807da44:	4680      	mov	r8, r0
 807da46:	4689      	mov	r9, r1
 807da48:	f100 0448 	add.w	r4, r0, #72	; 0x48
 807da4c:	2600      	movs	r6, #0
 807da4e:	b914      	cbnz	r4, 807da56 <_fwalk_reent+0x16>
 807da50:	4630      	mov	r0, r6
 807da52:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 807da56:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 807da5a:	3f01      	subs	r7, #1
 807da5c:	d501      	bpl.n	807da62 <_fwalk_reent+0x22>
 807da5e:	6824      	ldr	r4, [r4, #0]
 807da60:	e7f5      	b.n	807da4e <_fwalk_reent+0xe>
 807da62:	89ab      	ldrh	r3, [r5, #12]
 807da64:	2b01      	cmp	r3, #1
 807da66:	d907      	bls.n	807da78 <_fwalk_reent+0x38>
 807da68:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 807da6c:	3301      	adds	r3, #1
 807da6e:	d003      	beq.n	807da78 <_fwalk_reent+0x38>
 807da70:	4629      	mov	r1, r5
 807da72:	4640      	mov	r0, r8
 807da74:	47c8      	blx	r9
 807da76:	4306      	orrs	r6, r0
 807da78:	3568      	adds	r5, #104	; 0x68
 807da7a:	e7ee      	b.n	807da5a <_fwalk_reent+0x1a>

0807da7c <__swhatbuf_r>:
 807da7c:	b570      	push	{r4, r5, r6, lr}
 807da7e:	460e      	mov	r6, r1
 807da80:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 807da84:	b096      	sub	sp, #88	; 0x58
 807da86:	4614      	mov	r4, r2
 807da88:	2900      	cmp	r1, #0
 807da8a:	461d      	mov	r5, r3
 807da8c:	da07      	bge.n	807da9e <__swhatbuf_r+0x22>
 807da8e:	2300      	movs	r3, #0
 807da90:	602b      	str	r3, [r5, #0]
 807da92:	89b3      	ldrh	r3, [r6, #12]
 807da94:	061a      	lsls	r2, r3, #24
 807da96:	d410      	bmi.n	807daba <__swhatbuf_r+0x3e>
 807da98:	f44f 6380 	mov.w	r3, #1024	; 0x400
 807da9c:	e00e      	b.n	807dabc <__swhatbuf_r+0x40>
 807da9e:	466a      	mov	r2, sp
 807daa0:	f000 fc40 	bl	807e324 <_fstat_r>
 807daa4:	2800      	cmp	r0, #0
 807daa6:	dbf2      	blt.n	807da8e <__swhatbuf_r+0x12>
 807daa8:	9a01      	ldr	r2, [sp, #4]
 807daaa:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 807daae:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 807dab2:	425a      	negs	r2, r3
 807dab4:	415a      	adcs	r2, r3
 807dab6:	602a      	str	r2, [r5, #0]
 807dab8:	e7ee      	b.n	807da98 <__swhatbuf_r+0x1c>
 807daba:	2340      	movs	r3, #64	; 0x40
 807dabc:	2000      	movs	r0, #0
 807dabe:	6023      	str	r3, [r4, #0]
 807dac0:	b016      	add	sp, #88	; 0x58
 807dac2:	bd70      	pop	{r4, r5, r6, pc}

0807dac4 <__smakebuf_r>:
 807dac4:	898b      	ldrh	r3, [r1, #12]
 807dac6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 807dac8:	079d      	lsls	r5, r3, #30
 807daca:	4606      	mov	r6, r0
 807dacc:	460c      	mov	r4, r1
 807dace:	d507      	bpl.n	807dae0 <__smakebuf_r+0x1c>
 807dad0:	f104 0347 	add.w	r3, r4, #71	; 0x47
 807dad4:	6023      	str	r3, [r4, #0]
 807dad6:	6123      	str	r3, [r4, #16]
 807dad8:	2301      	movs	r3, #1
 807dada:	6163      	str	r3, [r4, #20]
 807dadc:	b002      	add	sp, #8
 807dade:	bd70      	pop	{r4, r5, r6, pc}
 807dae0:	ab01      	add	r3, sp, #4
 807dae2:	466a      	mov	r2, sp
 807dae4:	f7ff ffca 	bl	807da7c <__swhatbuf_r>
 807dae8:	9900      	ldr	r1, [sp, #0]
 807daea:	4605      	mov	r5, r0
 807daec:	4630      	mov	r0, r6
 807daee:	f000 f87f 	bl	807dbf0 <_malloc_r>
 807daf2:	b948      	cbnz	r0, 807db08 <__smakebuf_r+0x44>
 807daf4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 807daf8:	059a      	lsls	r2, r3, #22
 807dafa:	d4ef      	bmi.n	807dadc <__smakebuf_r+0x18>
 807dafc:	f023 0303 	bic.w	r3, r3, #3
 807db00:	f043 0302 	orr.w	r3, r3, #2
 807db04:	81a3      	strh	r3, [r4, #12]
 807db06:	e7e3      	b.n	807dad0 <__smakebuf_r+0xc>
 807db08:	4b0d      	ldr	r3, [pc, #52]	; (807db40 <__smakebuf_r+0x7c>)
 807db0a:	62b3      	str	r3, [r6, #40]	; 0x28
 807db0c:	89a3      	ldrh	r3, [r4, #12]
 807db0e:	6020      	str	r0, [r4, #0]
 807db10:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 807db14:	6120      	str	r0, [r4, #16]
 807db16:	81a3      	strh	r3, [r4, #12]
 807db18:	9b00      	ldr	r3, [sp, #0]
 807db1a:	6163      	str	r3, [r4, #20]
 807db1c:	9b01      	ldr	r3, [sp, #4]
 807db1e:	b15b      	cbz	r3, 807db38 <__smakebuf_r+0x74>
 807db20:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 807db24:	4630      	mov	r0, r6
 807db26:	f000 fc0f 	bl	807e348 <_isatty_r>
 807db2a:	b128      	cbz	r0, 807db38 <__smakebuf_r+0x74>
 807db2c:	89a3      	ldrh	r3, [r4, #12]
 807db2e:	f023 0303 	bic.w	r3, r3, #3
 807db32:	f043 0301 	orr.w	r3, r3, #1
 807db36:	81a3      	strh	r3, [r4, #12]
 807db38:	89a3      	ldrh	r3, [r4, #12]
 807db3a:	431d      	orrs	r5, r3
 807db3c:	81a5      	strh	r5, [r4, #12]
 807db3e:	e7cd      	b.n	807dadc <__smakebuf_r+0x18>
 807db40:	0807d931 	.word	0x0807d931

0807db44 <malloc>:
 807db44:	4b02      	ldr	r3, [pc, #8]	; (807db50 <malloc+0xc>)
 807db46:	4601      	mov	r1, r0
 807db48:	6818      	ldr	r0, [r3, #0]
 807db4a:	f000 b851 	b.w	807dbf0 <_malloc_r>
 807db4e:	bf00      	nop
 807db50:	2000002c 	.word	0x2000002c

0807db54 <_free_r>:
 807db54:	b538      	push	{r3, r4, r5, lr}
 807db56:	4605      	mov	r5, r0
 807db58:	2900      	cmp	r1, #0
 807db5a:	d045      	beq.n	807dbe8 <_free_r+0x94>
 807db5c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 807db60:	1f0c      	subs	r4, r1, #4
 807db62:	2b00      	cmp	r3, #0
 807db64:	bfb8      	it	lt
 807db66:	18e4      	addlt	r4, r4, r3
 807db68:	f000 fc1e 	bl	807e3a8 <__malloc_lock>
 807db6c:	4a1f      	ldr	r2, [pc, #124]	; (807dbec <_free_r+0x98>)
 807db6e:	6813      	ldr	r3, [r2, #0]
 807db70:	4610      	mov	r0, r2
 807db72:	b933      	cbnz	r3, 807db82 <_free_r+0x2e>
 807db74:	6063      	str	r3, [r4, #4]
 807db76:	6014      	str	r4, [r2, #0]
 807db78:	4628      	mov	r0, r5
 807db7a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 807db7e:	f000 bc14 	b.w	807e3aa <__malloc_unlock>
 807db82:	42a3      	cmp	r3, r4
 807db84:	d90c      	bls.n	807dba0 <_free_r+0x4c>
 807db86:	6821      	ldr	r1, [r4, #0]
 807db88:	1862      	adds	r2, r4, r1
 807db8a:	4293      	cmp	r3, r2
 807db8c:	bf02      	ittt	eq
 807db8e:	681a      	ldreq	r2, [r3, #0]
 807db90:	685b      	ldreq	r3, [r3, #4]
 807db92:	1852      	addeq	r2, r2, r1
 807db94:	6063      	str	r3, [r4, #4]
 807db96:	bf08      	it	eq
 807db98:	6022      	streq	r2, [r4, #0]
 807db9a:	6004      	str	r4, [r0, #0]
 807db9c:	e7ec      	b.n	807db78 <_free_r+0x24>
 807db9e:	4613      	mov	r3, r2
 807dba0:	685a      	ldr	r2, [r3, #4]
 807dba2:	b10a      	cbz	r2, 807dba8 <_free_r+0x54>
 807dba4:	42a2      	cmp	r2, r4
 807dba6:	d9fa      	bls.n	807db9e <_free_r+0x4a>
 807dba8:	6819      	ldr	r1, [r3, #0]
 807dbaa:	1858      	adds	r0, r3, r1
 807dbac:	42a0      	cmp	r0, r4
 807dbae:	d10b      	bne.n	807dbc8 <_free_r+0x74>
 807dbb0:	6820      	ldr	r0, [r4, #0]
 807dbb2:	4401      	add	r1, r0
 807dbb4:	1858      	adds	r0, r3, r1
 807dbb6:	6019      	str	r1, [r3, #0]
 807dbb8:	4282      	cmp	r2, r0
 807dbba:	d1dd      	bne.n	807db78 <_free_r+0x24>
 807dbbc:	6810      	ldr	r0, [r2, #0]
 807dbbe:	6852      	ldr	r2, [r2, #4]
 807dbc0:	4401      	add	r1, r0
 807dbc2:	605a      	str	r2, [r3, #4]
 807dbc4:	6019      	str	r1, [r3, #0]
 807dbc6:	e7d7      	b.n	807db78 <_free_r+0x24>
 807dbc8:	d902      	bls.n	807dbd0 <_free_r+0x7c>
 807dbca:	230c      	movs	r3, #12
 807dbcc:	602b      	str	r3, [r5, #0]
 807dbce:	e7d3      	b.n	807db78 <_free_r+0x24>
 807dbd0:	6820      	ldr	r0, [r4, #0]
 807dbd2:	1821      	adds	r1, r4, r0
 807dbd4:	428a      	cmp	r2, r1
 807dbd6:	bf02      	ittt	eq
 807dbd8:	6811      	ldreq	r1, [r2, #0]
 807dbda:	6852      	ldreq	r2, [r2, #4]
 807dbdc:	1809      	addeq	r1, r1, r0
 807dbde:	6062      	str	r2, [r4, #4]
 807dbe0:	bf08      	it	eq
 807dbe2:	6021      	streq	r1, [r4, #0]
 807dbe4:	605c      	str	r4, [r3, #4]
 807dbe6:	e7c7      	b.n	807db78 <_free_r+0x24>
 807dbe8:	bd38      	pop	{r3, r4, r5, pc}
 807dbea:	bf00      	nop
 807dbec:	200005f4 	.word	0x200005f4

0807dbf0 <_malloc_r>:
 807dbf0:	b570      	push	{r4, r5, r6, lr}
 807dbf2:	1ccd      	adds	r5, r1, #3
 807dbf4:	4606      	mov	r6, r0
 807dbf6:	f025 0503 	bic.w	r5, r5, #3
 807dbfa:	3508      	adds	r5, #8
 807dbfc:	2d0c      	cmp	r5, #12
 807dbfe:	bf38      	it	cc
 807dc00:	250c      	movcc	r5, #12
 807dc02:	2d00      	cmp	r5, #0
 807dc04:	db01      	blt.n	807dc0a <_malloc_r+0x1a>
 807dc06:	42a9      	cmp	r1, r5
 807dc08:	d903      	bls.n	807dc12 <_malloc_r+0x22>
 807dc0a:	230c      	movs	r3, #12
 807dc0c:	6033      	str	r3, [r6, #0]
 807dc0e:	2000      	movs	r0, #0
 807dc10:	bd70      	pop	{r4, r5, r6, pc}
 807dc12:	f000 fbc9 	bl	807e3a8 <__malloc_lock>
 807dc16:	4a21      	ldr	r2, [pc, #132]	; (807dc9c <_malloc_r+0xac>)
 807dc18:	6814      	ldr	r4, [r2, #0]
 807dc1a:	4621      	mov	r1, r4
 807dc1c:	b991      	cbnz	r1, 807dc44 <_malloc_r+0x54>
 807dc1e:	4c20      	ldr	r4, [pc, #128]	; (807dca0 <_malloc_r+0xb0>)
 807dc20:	6823      	ldr	r3, [r4, #0]
 807dc22:	b91b      	cbnz	r3, 807dc2c <_malloc_r+0x3c>
 807dc24:	4630      	mov	r0, r6
 807dc26:	f000 fb07 	bl	807e238 <_sbrk_r>
 807dc2a:	6020      	str	r0, [r4, #0]
 807dc2c:	4629      	mov	r1, r5
 807dc2e:	4630      	mov	r0, r6
 807dc30:	f000 fb02 	bl	807e238 <_sbrk_r>
 807dc34:	1c43      	adds	r3, r0, #1
 807dc36:	d124      	bne.n	807dc82 <_malloc_r+0x92>
 807dc38:	230c      	movs	r3, #12
 807dc3a:	4630      	mov	r0, r6
 807dc3c:	6033      	str	r3, [r6, #0]
 807dc3e:	f000 fbb4 	bl	807e3aa <__malloc_unlock>
 807dc42:	e7e4      	b.n	807dc0e <_malloc_r+0x1e>
 807dc44:	680b      	ldr	r3, [r1, #0]
 807dc46:	1b5b      	subs	r3, r3, r5
 807dc48:	d418      	bmi.n	807dc7c <_malloc_r+0x8c>
 807dc4a:	2b0b      	cmp	r3, #11
 807dc4c:	d90f      	bls.n	807dc6e <_malloc_r+0x7e>
 807dc4e:	18cc      	adds	r4, r1, r3
 807dc50:	600b      	str	r3, [r1, #0]
 807dc52:	50cd      	str	r5, [r1, r3]
 807dc54:	4630      	mov	r0, r6
 807dc56:	f000 fba8 	bl	807e3aa <__malloc_unlock>
 807dc5a:	f104 000b 	add.w	r0, r4, #11
 807dc5e:	1d23      	adds	r3, r4, #4
 807dc60:	f020 0007 	bic.w	r0, r0, #7
 807dc64:	1ac3      	subs	r3, r0, r3
 807dc66:	d0d3      	beq.n	807dc10 <_malloc_r+0x20>
 807dc68:	425a      	negs	r2, r3
 807dc6a:	50e2      	str	r2, [r4, r3]
 807dc6c:	e7d0      	b.n	807dc10 <_malloc_r+0x20>
 807dc6e:	428c      	cmp	r4, r1
 807dc70:	684b      	ldr	r3, [r1, #4]
 807dc72:	bf1a      	itte	ne
 807dc74:	6063      	strne	r3, [r4, #4]
 807dc76:	460c      	movne	r4, r1
 807dc78:	6013      	streq	r3, [r2, #0]
 807dc7a:	e7eb      	b.n	807dc54 <_malloc_r+0x64>
 807dc7c:	460c      	mov	r4, r1
 807dc7e:	6849      	ldr	r1, [r1, #4]
 807dc80:	e7cc      	b.n	807dc1c <_malloc_r+0x2c>
 807dc82:	1cc4      	adds	r4, r0, #3
 807dc84:	f024 0403 	bic.w	r4, r4, #3
 807dc88:	42a0      	cmp	r0, r4
 807dc8a:	d005      	beq.n	807dc98 <_malloc_r+0xa8>
 807dc8c:	1a21      	subs	r1, r4, r0
 807dc8e:	4630      	mov	r0, r6
 807dc90:	f000 fad2 	bl	807e238 <_sbrk_r>
 807dc94:	3001      	adds	r0, #1
 807dc96:	d0cf      	beq.n	807dc38 <_malloc_r+0x48>
 807dc98:	6025      	str	r5, [r4, #0]
 807dc9a:	e7db      	b.n	807dc54 <_malloc_r+0x64>
 807dc9c:	200005f4 	.word	0x200005f4
 807dca0:	200005f8 	.word	0x200005f8

0807dca4 <__sfputc_r>:
 807dca4:	6893      	ldr	r3, [r2, #8]
 807dca6:	3b01      	subs	r3, #1
 807dca8:	2b00      	cmp	r3, #0
 807dcaa:	6093      	str	r3, [r2, #8]
 807dcac:	b410      	push	{r4}
 807dcae:	da08      	bge.n	807dcc2 <__sfputc_r+0x1e>
 807dcb0:	6994      	ldr	r4, [r2, #24]
 807dcb2:	42a3      	cmp	r3, r4
 807dcb4:	db01      	blt.n	807dcba <__sfputc_r+0x16>
 807dcb6:	290a      	cmp	r1, #10
 807dcb8:	d103      	bne.n	807dcc2 <__sfputc_r+0x1e>
 807dcba:	f85d 4b04 	ldr.w	r4, [sp], #4
 807dcbe:	f7ff bca5 	b.w	807d60c <__swbuf_r>
 807dcc2:	6813      	ldr	r3, [r2, #0]
 807dcc4:	1c58      	adds	r0, r3, #1
 807dcc6:	6010      	str	r0, [r2, #0]
 807dcc8:	4608      	mov	r0, r1
 807dcca:	7019      	strb	r1, [r3, #0]
 807dccc:	f85d 4b04 	ldr.w	r4, [sp], #4
 807dcd0:	4770      	bx	lr

0807dcd2 <__sfputs_r>:
 807dcd2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 807dcd4:	4606      	mov	r6, r0
 807dcd6:	460f      	mov	r7, r1
 807dcd8:	4614      	mov	r4, r2
 807dcda:	18d5      	adds	r5, r2, r3
 807dcdc:	42ac      	cmp	r4, r5
 807dcde:	d101      	bne.n	807dce4 <__sfputs_r+0x12>
 807dce0:	2000      	movs	r0, #0
 807dce2:	e007      	b.n	807dcf4 <__sfputs_r+0x22>
 807dce4:	463a      	mov	r2, r7
 807dce6:	f814 1b01 	ldrb.w	r1, [r4], #1
 807dcea:	4630      	mov	r0, r6
 807dcec:	f7ff ffda 	bl	807dca4 <__sfputc_r>
 807dcf0:	1c43      	adds	r3, r0, #1
 807dcf2:	d1f3      	bne.n	807dcdc <__sfputs_r+0xa>
 807dcf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0807dcf8 <_vfiprintf_r>:
 807dcf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 807dcfc:	460c      	mov	r4, r1
 807dcfe:	b09d      	sub	sp, #116	; 0x74
 807dd00:	4617      	mov	r7, r2
 807dd02:	461d      	mov	r5, r3
 807dd04:	4606      	mov	r6, r0
 807dd06:	b118      	cbz	r0, 807dd10 <_vfiprintf_r+0x18>
 807dd08:	6983      	ldr	r3, [r0, #24]
 807dd0a:	b90b      	cbnz	r3, 807dd10 <_vfiprintf_r+0x18>
 807dd0c:	f7ff fe2c 	bl	807d968 <__sinit>
 807dd10:	4b7c      	ldr	r3, [pc, #496]	; (807df04 <_vfiprintf_r+0x20c>)
 807dd12:	429c      	cmp	r4, r3
 807dd14:	d158      	bne.n	807ddc8 <_vfiprintf_r+0xd0>
 807dd16:	6874      	ldr	r4, [r6, #4]
 807dd18:	89a3      	ldrh	r3, [r4, #12]
 807dd1a:	0718      	lsls	r0, r3, #28
 807dd1c:	d55e      	bpl.n	807dddc <_vfiprintf_r+0xe4>
 807dd1e:	6923      	ldr	r3, [r4, #16]
 807dd20:	2b00      	cmp	r3, #0
 807dd22:	d05b      	beq.n	807dddc <_vfiprintf_r+0xe4>
 807dd24:	2300      	movs	r3, #0
 807dd26:	f04f 0b01 	mov.w	fp, #1
 807dd2a:	9503      	str	r5, [sp, #12]
 807dd2c:	9309      	str	r3, [sp, #36]	; 0x24
 807dd2e:	2320      	movs	r3, #32
 807dd30:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 807dd34:	2330      	movs	r3, #48	; 0x30
 807dd36:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 807dd3a:	46b8      	mov	r8, r7
 807dd3c:	4645      	mov	r5, r8
 807dd3e:	f815 3b01 	ldrb.w	r3, [r5], #1
 807dd42:	b10b      	cbz	r3, 807dd48 <_vfiprintf_r+0x50>
 807dd44:	2b25      	cmp	r3, #37	; 0x25
 807dd46:	d154      	bne.n	807ddf2 <_vfiprintf_r+0xfa>
 807dd48:	ebb8 0a07 	subs.w	sl, r8, r7
 807dd4c:	d00b      	beq.n	807dd66 <_vfiprintf_r+0x6e>
 807dd4e:	4653      	mov	r3, sl
 807dd50:	463a      	mov	r2, r7
 807dd52:	4621      	mov	r1, r4
 807dd54:	4630      	mov	r0, r6
 807dd56:	f7ff ffbc 	bl	807dcd2 <__sfputs_r>
 807dd5a:	3001      	adds	r0, #1
 807dd5c:	f000 80c2 	beq.w	807dee4 <_vfiprintf_r+0x1ec>
 807dd60:	9b09      	ldr	r3, [sp, #36]	; 0x24
 807dd62:	4453      	add	r3, sl
 807dd64:	9309      	str	r3, [sp, #36]	; 0x24
 807dd66:	f898 3000 	ldrb.w	r3, [r8]
 807dd6a:	2b00      	cmp	r3, #0
 807dd6c:	f000 80ba 	beq.w	807dee4 <_vfiprintf_r+0x1ec>
 807dd70:	2300      	movs	r3, #0
 807dd72:	f04f 32ff 	mov.w	r2, #4294967295
 807dd76:	9304      	str	r3, [sp, #16]
 807dd78:	9307      	str	r3, [sp, #28]
 807dd7a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 807dd7e:	931a      	str	r3, [sp, #104]	; 0x68
 807dd80:	e9cd 2305 	strd	r2, r3, [sp, #20]
 807dd84:	46a8      	mov	r8, r5
 807dd86:	2205      	movs	r2, #5
 807dd88:	485f      	ldr	r0, [pc, #380]	; (807df08 <_vfiprintf_r+0x210>)
 807dd8a:	f818 1b01 	ldrb.w	r1, [r8], #1
 807dd8e:	f000 fafd 	bl	807e38c <memchr>
 807dd92:	9b04      	ldr	r3, [sp, #16]
 807dd94:	bb78      	cbnz	r0, 807ddf6 <_vfiprintf_r+0xfe>
 807dd96:	06d9      	lsls	r1, r3, #27
 807dd98:	bf44      	itt	mi
 807dd9a:	2220      	movmi	r2, #32
 807dd9c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 807dda0:	071a      	lsls	r2, r3, #28
 807dda2:	bf44      	itt	mi
 807dda4:	222b      	movmi	r2, #43	; 0x2b
 807dda6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 807ddaa:	782a      	ldrb	r2, [r5, #0]
 807ddac:	2a2a      	cmp	r2, #42	; 0x2a
 807ddae:	d02a      	beq.n	807de06 <_vfiprintf_r+0x10e>
 807ddb0:	46a8      	mov	r8, r5
 807ddb2:	9a07      	ldr	r2, [sp, #28]
 807ddb4:	2000      	movs	r0, #0
 807ddb6:	250a      	movs	r5, #10
 807ddb8:	4641      	mov	r1, r8
 807ddba:	f811 3b01 	ldrb.w	r3, [r1], #1
 807ddbe:	3b30      	subs	r3, #48	; 0x30
 807ddc0:	2b09      	cmp	r3, #9
 807ddc2:	d969      	bls.n	807de98 <_vfiprintf_r+0x1a0>
 807ddc4:	b360      	cbz	r0, 807de20 <_vfiprintf_r+0x128>
 807ddc6:	e024      	b.n	807de12 <_vfiprintf_r+0x11a>
 807ddc8:	4b50      	ldr	r3, [pc, #320]	; (807df0c <_vfiprintf_r+0x214>)
 807ddca:	429c      	cmp	r4, r3
 807ddcc:	d101      	bne.n	807ddd2 <_vfiprintf_r+0xda>
 807ddce:	68b4      	ldr	r4, [r6, #8]
 807ddd0:	e7a2      	b.n	807dd18 <_vfiprintf_r+0x20>
 807ddd2:	4b4f      	ldr	r3, [pc, #316]	; (807df10 <_vfiprintf_r+0x218>)
 807ddd4:	429c      	cmp	r4, r3
 807ddd6:	bf08      	it	eq
 807ddd8:	68f4      	ldreq	r4, [r6, #12]
 807ddda:	e79d      	b.n	807dd18 <_vfiprintf_r+0x20>
 807dddc:	4621      	mov	r1, r4
 807ddde:	4630      	mov	r0, r6
 807dde0:	f7ff fc66 	bl	807d6b0 <__swsetup_r>
 807dde4:	2800      	cmp	r0, #0
 807dde6:	d09d      	beq.n	807dd24 <_vfiprintf_r+0x2c>
 807dde8:	f04f 30ff 	mov.w	r0, #4294967295
 807ddec:	b01d      	add	sp, #116	; 0x74
 807ddee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 807ddf2:	46a8      	mov	r8, r5
 807ddf4:	e7a2      	b.n	807dd3c <_vfiprintf_r+0x44>
 807ddf6:	4a44      	ldr	r2, [pc, #272]	; (807df08 <_vfiprintf_r+0x210>)
 807ddf8:	4645      	mov	r5, r8
 807ddfa:	1a80      	subs	r0, r0, r2
 807ddfc:	fa0b f000 	lsl.w	r0, fp, r0
 807de00:	4318      	orrs	r0, r3
 807de02:	9004      	str	r0, [sp, #16]
 807de04:	e7be      	b.n	807dd84 <_vfiprintf_r+0x8c>
 807de06:	9a03      	ldr	r2, [sp, #12]
 807de08:	1d11      	adds	r1, r2, #4
 807de0a:	6812      	ldr	r2, [r2, #0]
 807de0c:	2a00      	cmp	r2, #0
 807de0e:	9103      	str	r1, [sp, #12]
 807de10:	db01      	blt.n	807de16 <_vfiprintf_r+0x11e>
 807de12:	9207      	str	r2, [sp, #28]
 807de14:	e004      	b.n	807de20 <_vfiprintf_r+0x128>
 807de16:	4252      	negs	r2, r2
 807de18:	f043 0302 	orr.w	r3, r3, #2
 807de1c:	9207      	str	r2, [sp, #28]
 807de1e:	9304      	str	r3, [sp, #16]
 807de20:	f898 3000 	ldrb.w	r3, [r8]
 807de24:	2b2e      	cmp	r3, #46	; 0x2e
 807de26:	d10e      	bne.n	807de46 <_vfiprintf_r+0x14e>
 807de28:	f898 3001 	ldrb.w	r3, [r8, #1]
 807de2c:	2b2a      	cmp	r3, #42	; 0x2a
 807de2e:	d138      	bne.n	807dea2 <_vfiprintf_r+0x1aa>
 807de30:	9b03      	ldr	r3, [sp, #12]
 807de32:	f108 0802 	add.w	r8, r8, #2
 807de36:	1d1a      	adds	r2, r3, #4
 807de38:	681b      	ldr	r3, [r3, #0]
 807de3a:	2b00      	cmp	r3, #0
 807de3c:	9203      	str	r2, [sp, #12]
 807de3e:	bfb8      	it	lt
 807de40:	f04f 33ff 	movlt.w	r3, #4294967295
 807de44:	9305      	str	r3, [sp, #20]
 807de46:	4d33      	ldr	r5, [pc, #204]	; (807df14 <_vfiprintf_r+0x21c>)
 807de48:	2203      	movs	r2, #3
 807de4a:	f898 1000 	ldrb.w	r1, [r8]
 807de4e:	4628      	mov	r0, r5
 807de50:	f000 fa9c 	bl	807e38c <memchr>
 807de54:	b140      	cbz	r0, 807de68 <_vfiprintf_r+0x170>
 807de56:	2340      	movs	r3, #64	; 0x40
 807de58:	1b40      	subs	r0, r0, r5
 807de5a:	f108 0801 	add.w	r8, r8, #1
 807de5e:	fa03 f000 	lsl.w	r0, r3, r0
 807de62:	9b04      	ldr	r3, [sp, #16]
 807de64:	4303      	orrs	r3, r0
 807de66:	9304      	str	r3, [sp, #16]
 807de68:	f898 1000 	ldrb.w	r1, [r8]
 807de6c:	2206      	movs	r2, #6
 807de6e:	482a      	ldr	r0, [pc, #168]	; (807df18 <_vfiprintf_r+0x220>)
 807de70:	f108 0701 	add.w	r7, r8, #1
 807de74:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 807de78:	f000 fa88 	bl	807e38c <memchr>
 807de7c:	2800      	cmp	r0, #0
 807de7e:	d037      	beq.n	807def0 <_vfiprintf_r+0x1f8>
 807de80:	4b26      	ldr	r3, [pc, #152]	; (807df1c <_vfiprintf_r+0x224>)
 807de82:	bb1b      	cbnz	r3, 807decc <_vfiprintf_r+0x1d4>
 807de84:	9b03      	ldr	r3, [sp, #12]
 807de86:	3307      	adds	r3, #7
 807de88:	f023 0307 	bic.w	r3, r3, #7
 807de8c:	3308      	adds	r3, #8
 807de8e:	9303      	str	r3, [sp, #12]
 807de90:	9b09      	ldr	r3, [sp, #36]	; 0x24
 807de92:	444b      	add	r3, r9
 807de94:	9309      	str	r3, [sp, #36]	; 0x24
 807de96:	e750      	b.n	807dd3a <_vfiprintf_r+0x42>
 807de98:	fb05 3202 	mla	r2, r5, r2, r3
 807de9c:	2001      	movs	r0, #1
 807de9e:	4688      	mov	r8, r1
 807dea0:	e78a      	b.n	807ddb8 <_vfiprintf_r+0xc0>
 807dea2:	2300      	movs	r3, #0
 807dea4:	f108 0801 	add.w	r8, r8, #1
 807dea8:	250a      	movs	r5, #10
 807deaa:	4619      	mov	r1, r3
 807deac:	9305      	str	r3, [sp, #20]
 807deae:	4640      	mov	r0, r8
 807deb0:	f810 2b01 	ldrb.w	r2, [r0], #1
 807deb4:	3a30      	subs	r2, #48	; 0x30
 807deb6:	2a09      	cmp	r2, #9
 807deb8:	d903      	bls.n	807dec2 <_vfiprintf_r+0x1ca>
 807deba:	2b00      	cmp	r3, #0
 807debc:	d0c3      	beq.n	807de46 <_vfiprintf_r+0x14e>
 807debe:	9105      	str	r1, [sp, #20]
 807dec0:	e7c1      	b.n	807de46 <_vfiprintf_r+0x14e>
 807dec2:	fb05 2101 	mla	r1, r5, r1, r2
 807dec6:	2301      	movs	r3, #1
 807dec8:	4680      	mov	r8, r0
 807deca:	e7f0      	b.n	807deae <_vfiprintf_r+0x1b6>
 807decc:	ab03      	add	r3, sp, #12
 807dece:	4622      	mov	r2, r4
 807ded0:	a904      	add	r1, sp, #16
 807ded2:	4630      	mov	r0, r6
 807ded4:	9300      	str	r3, [sp, #0]
 807ded6:	4b12      	ldr	r3, [pc, #72]	; (807df20 <_vfiprintf_r+0x228>)
 807ded8:	e000      	b.n	807dedc <_vfiprintf_r+0x1e4>
 807deda:	bf00      	nop
 807dedc:	f1b0 3fff 	cmp.w	r0, #4294967295
 807dee0:	4681      	mov	r9, r0
 807dee2:	d1d5      	bne.n	807de90 <_vfiprintf_r+0x198>
 807dee4:	89a3      	ldrh	r3, [r4, #12]
 807dee6:	065b      	lsls	r3, r3, #25
 807dee8:	f53f af7e 	bmi.w	807dde8 <_vfiprintf_r+0xf0>
 807deec:	9809      	ldr	r0, [sp, #36]	; 0x24
 807deee:	e77d      	b.n	807ddec <_vfiprintf_r+0xf4>
 807def0:	ab03      	add	r3, sp, #12
 807def2:	4622      	mov	r2, r4
 807def4:	a904      	add	r1, sp, #16
 807def6:	4630      	mov	r0, r6
 807def8:	9300      	str	r3, [sp, #0]
 807defa:	4b09      	ldr	r3, [pc, #36]	; (807df20 <_vfiprintf_r+0x228>)
 807defc:	f000 f88a 	bl	807e014 <_printf_i>
 807df00:	e7ec      	b.n	807dedc <_vfiprintf_r+0x1e4>
 807df02:	bf00      	nop
 807df04:	0807ec80 	.word	0x0807ec80
 807df08:	0807ecc0 	.word	0x0807ecc0
 807df0c:	0807eca0 	.word	0x0807eca0
 807df10:	0807ec60 	.word	0x0807ec60
 807df14:	0807ecc6 	.word	0x0807ecc6
 807df18:	0807ecca 	.word	0x0807ecca
 807df1c:	00000000 	.word	0x00000000
 807df20:	0807dcd3 	.word	0x0807dcd3

0807df24 <_printf_common>:
 807df24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 807df28:	4691      	mov	r9, r2
 807df2a:	461f      	mov	r7, r3
 807df2c:	688a      	ldr	r2, [r1, #8]
 807df2e:	4606      	mov	r6, r0
 807df30:	690b      	ldr	r3, [r1, #16]
 807df32:	460c      	mov	r4, r1
 807df34:	f8dd 8020 	ldr.w	r8, [sp, #32]
 807df38:	4293      	cmp	r3, r2
 807df3a:	bfb8      	it	lt
 807df3c:	4613      	movlt	r3, r2
 807df3e:	f8c9 3000 	str.w	r3, [r9]
 807df42:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 807df46:	b112      	cbz	r2, 807df4e <_printf_common+0x2a>
 807df48:	3301      	adds	r3, #1
 807df4a:	f8c9 3000 	str.w	r3, [r9]
 807df4e:	6823      	ldr	r3, [r4, #0]
 807df50:	0699      	lsls	r1, r3, #26
 807df52:	bf42      	ittt	mi
 807df54:	f8d9 3000 	ldrmi.w	r3, [r9]
 807df58:	3302      	addmi	r3, #2
 807df5a:	f8c9 3000 	strmi.w	r3, [r9]
 807df5e:	6825      	ldr	r5, [r4, #0]
 807df60:	f015 0506 	ands.w	r5, r5, #6
 807df64:	d107      	bne.n	807df76 <_printf_common+0x52>
 807df66:	f104 0a19 	add.w	sl, r4, #25
 807df6a:	68e3      	ldr	r3, [r4, #12]
 807df6c:	f8d9 2000 	ldr.w	r2, [r9]
 807df70:	1a9b      	subs	r3, r3, r2
 807df72:	42ab      	cmp	r3, r5
 807df74:	dc2b      	bgt.n	807dfce <_printf_common+0xaa>
 807df76:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 807df7a:	6822      	ldr	r2, [r4, #0]
 807df7c:	3300      	adds	r3, #0
 807df7e:	bf18      	it	ne
 807df80:	2301      	movne	r3, #1
 807df82:	0692      	lsls	r2, r2, #26
 807df84:	d430      	bmi.n	807dfe8 <_printf_common+0xc4>
 807df86:	f104 0243 	add.w	r2, r4, #67	; 0x43
 807df8a:	4639      	mov	r1, r7
 807df8c:	4630      	mov	r0, r6
 807df8e:	47c0      	blx	r8
 807df90:	3001      	adds	r0, #1
 807df92:	d023      	beq.n	807dfdc <_printf_common+0xb8>
 807df94:	6823      	ldr	r3, [r4, #0]
 807df96:	341a      	adds	r4, #26
 807df98:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 807df9c:	f003 0306 	and.w	r3, r3, #6
 807dfa0:	f8d9 2000 	ldr.w	r2, [r9]
 807dfa4:	f04f 0900 	mov.w	r9, #0
 807dfa8:	2b04      	cmp	r3, #4
 807dfaa:	f854 3c12 	ldr.w	r3, [r4, #-18]
 807dfae:	bf08      	it	eq
 807dfb0:	1aad      	subeq	r5, r5, r2
 807dfb2:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 807dfb6:	bf14      	ite	ne
 807dfb8:	2500      	movne	r5, #0
 807dfba:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 807dfbe:	4293      	cmp	r3, r2
 807dfc0:	bfc4      	itt	gt
 807dfc2:	1a9b      	subgt	r3, r3, r2
 807dfc4:	18ed      	addgt	r5, r5, r3
 807dfc6:	454d      	cmp	r5, r9
 807dfc8:	d11a      	bne.n	807e000 <_printf_common+0xdc>
 807dfca:	2000      	movs	r0, #0
 807dfcc:	e008      	b.n	807dfe0 <_printf_common+0xbc>
 807dfce:	2301      	movs	r3, #1
 807dfd0:	4652      	mov	r2, sl
 807dfd2:	4639      	mov	r1, r7
 807dfd4:	4630      	mov	r0, r6
 807dfd6:	47c0      	blx	r8
 807dfd8:	3001      	adds	r0, #1
 807dfda:	d103      	bne.n	807dfe4 <_printf_common+0xc0>
 807dfdc:	f04f 30ff 	mov.w	r0, #4294967295
 807dfe0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 807dfe4:	3501      	adds	r5, #1
 807dfe6:	e7c0      	b.n	807df6a <_printf_common+0x46>
 807dfe8:	18e1      	adds	r1, r4, r3
 807dfea:	1c5a      	adds	r2, r3, #1
 807dfec:	2030      	movs	r0, #48	; 0x30
 807dfee:	3302      	adds	r3, #2
 807dff0:	4422      	add	r2, r4
 807dff2:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 807dff6:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 807dffa:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 807dffe:	e7c2      	b.n	807df86 <_printf_common+0x62>
 807e000:	2301      	movs	r3, #1
 807e002:	4622      	mov	r2, r4
 807e004:	4639      	mov	r1, r7
 807e006:	4630      	mov	r0, r6
 807e008:	47c0      	blx	r8
 807e00a:	3001      	adds	r0, #1
 807e00c:	d0e6      	beq.n	807dfdc <_printf_common+0xb8>
 807e00e:	f109 0901 	add.w	r9, r9, #1
 807e012:	e7d8      	b.n	807dfc6 <_printf_common+0xa2>

0807e014 <_printf_i>:
 807e014:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 807e018:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 807e01c:	460c      	mov	r4, r1
 807e01e:	7e09      	ldrb	r1, [r1, #24]
 807e020:	b085      	sub	sp, #20
 807e022:	4617      	mov	r7, r2
 807e024:	4606      	mov	r6, r0
 807e026:	296e      	cmp	r1, #110	; 0x6e
 807e028:	4698      	mov	r8, r3
 807e02a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 807e02c:	f000 80b3 	beq.w	807e196 <_printf_i+0x182>
 807e030:	d822      	bhi.n	807e078 <_printf_i+0x64>
 807e032:	2963      	cmp	r1, #99	; 0x63
 807e034:	d036      	beq.n	807e0a4 <_printf_i+0x90>
 807e036:	d80a      	bhi.n	807e04e <_printf_i+0x3a>
 807e038:	2900      	cmp	r1, #0
 807e03a:	f000 80b9 	beq.w	807e1b0 <_printf_i+0x19c>
 807e03e:	2958      	cmp	r1, #88	; 0x58
 807e040:	f000 8083 	beq.w	807e14a <_printf_i+0x136>
 807e044:	f104 0542 	add.w	r5, r4, #66	; 0x42
 807e048:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 807e04c:	e032      	b.n	807e0b4 <_printf_i+0xa0>
 807e04e:	2964      	cmp	r1, #100	; 0x64
 807e050:	d001      	beq.n	807e056 <_printf_i+0x42>
 807e052:	2969      	cmp	r1, #105	; 0x69
 807e054:	d1f6      	bne.n	807e044 <_printf_i+0x30>
 807e056:	6820      	ldr	r0, [r4, #0]
 807e058:	6813      	ldr	r3, [r2, #0]
 807e05a:	0605      	lsls	r5, r0, #24
 807e05c:	f103 0104 	add.w	r1, r3, #4
 807e060:	d52a      	bpl.n	807e0b8 <_printf_i+0xa4>
 807e062:	681b      	ldr	r3, [r3, #0]
 807e064:	6011      	str	r1, [r2, #0]
 807e066:	2b00      	cmp	r3, #0
 807e068:	da03      	bge.n	807e072 <_printf_i+0x5e>
 807e06a:	222d      	movs	r2, #45	; 0x2d
 807e06c:	425b      	negs	r3, r3
 807e06e:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 807e072:	486f      	ldr	r0, [pc, #444]	; (807e230 <_printf_i+0x21c>)
 807e074:	220a      	movs	r2, #10
 807e076:	e039      	b.n	807e0ec <_printf_i+0xd8>
 807e078:	2973      	cmp	r1, #115	; 0x73
 807e07a:	f000 809d 	beq.w	807e1b8 <_printf_i+0x1a4>
 807e07e:	d808      	bhi.n	807e092 <_printf_i+0x7e>
 807e080:	296f      	cmp	r1, #111	; 0x6f
 807e082:	d020      	beq.n	807e0c6 <_printf_i+0xb2>
 807e084:	2970      	cmp	r1, #112	; 0x70
 807e086:	d1dd      	bne.n	807e044 <_printf_i+0x30>
 807e088:	6823      	ldr	r3, [r4, #0]
 807e08a:	f043 0320 	orr.w	r3, r3, #32
 807e08e:	6023      	str	r3, [r4, #0]
 807e090:	e003      	b.n	807e09a <_printf_i+0x86>
 807e092:	2975      	cmp	r1, #117	; 0x75
 807e094:	d017      	beq.n	807e0c6 <_printf_i+0xb2>
 807e096:	2978      	cmp	r1, #120	; 0x78
 807e098:	d1d4      	bne.n	807e044 <_printf_i+0x30>
 807e09a:	2378      	movs	r3, #120	; 0x78
 807e09c:	4865      	ldr	r0, [pc, #404]	; (807e234 <_printf_i+0x220>)
 807e09e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 807e0a2:	e055      	b.n	807e150 <_printf_i+0x13c>
 807e0a4:	6813      	ldr	r3, [r2, #0]
 807e0a6:	f104 0542 	add.w	r5, r4, #66	; 0x42
 807e0aa:	1d19      	adds	r1, r3, #4
 807e0ac:	681b      	ldr	r3, [r3, #0]
 807e0ae:	6011      	str	r1, [r2, #0]
 807e0b0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 807e0b4:	2301      	movs	r3, #1
 807e0b6:	e08c      	b.n	807e1d2 <_printf_i+0x1be>
 807e0b8:	681b      	ldr	r3, [r3, #0]
 807e0ba:	f010 0f40 	tst.w	r0, #64	; 0x40
 807e0be:	6011      	str	r1, [r2, #0]
 807e0c0:	bf18      	it	ne
 807e0c2:	b21b      	sxthne	r3, r3
 807e0c4:	e7cf      	b.n	807e066 <_printf_i+0x52>
 807e0c6:	6813      	ldr	r3, [r2, #0]
 807e0c8:	6825      	ldr	r5, [r4, #0]
 807e0ca:	1d18      	adds	r0, r3, #4
 807e0cc:	6010      	str	r0, [r2, #0]
 807e0ce:	0628      	lsls	r0, r5, #24
 807e0d0:	d501      	bpl.n	807e0d6 <_printf_i+0xc2>
 807e0d2:	681b      	ldr	r3, [r3, #0]
 807e0d4:	e002      	b.n	807e0dc <_printf_i+0xc8>
 807e0d6:	0668      	lsls	r0, r5, #25
 807e0d8:	d5fb      	bpl.n	807e0d2 <_printf_i+0xbe>
 807e0da:	881b      	ldrh	r3, [r3, #0]
 807e0dc:	296f      	cmp	r1, #111	; 0x6f
 807e0de:	4854      	ldr	r0, [pc, #336]	; (807e230 <_printf_i+0x21c>)
 807e0e0:	bf14      	ite	ne
 807e0e2:	220a      	movne	r2, #10
 807e0e4:	2208      	moveq	r2, #8
 807e0e6:	2100      	movs	r1, #0
 807e0e8:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 807e0ec:	6865      	ldr	r5, [r4, #4]
 807e0ee:	2d00      	cmp	r5, #0
 807e0f0:	60a5      	str	r5, [r4, #8]
 807e0f2:	f2c0 8095 	blt.w	807e220 <_printf_i+0x20c>
 807e0f6:	6821      	ldr	r1, [r4, #0]
 807e0f8:	f021 0104 	bic.w	r1, r1, #4
 807e0fc:	6021      	str	r1, [r4, #0]
 807e0fe:	2b00      	cmp	r3, #0
 807e100:	d13d      	bne.n	807e17e <_printf_i+0x16a>
 807e102:	2d00      	cmp	r5, #0
 807e104:	f040 808e 	bne.w	807e224 <_printf_i+0x210>
 807e108:	4665      	mov	r5, ip
 807e10a:	2a08      	cmp	r2, #8
 807e10c:	d10b      	bne.n	807e126 <_printf_i+0x112>
 807e10e:	6823      	ldr	r3, [r4, #0]
 807e110:	07db      	lsls	r3, r3, #31
 807e112:	d508      	bpl.n	807e126 <_printf_i+0x112>
 807e114:	6923      	ldr	r3, [r4, #16]
 807e116:	6862      	ldr	r2, [r4, #4]
 807e118:	429a      	cmp	r2, r3
 807e11a:	bfde      	ittt	le
 807e11c:	2330      	movle	r3, #48	; 0x30
 807e11e:	f805 3c01 	strble.w	r3, [r5, #-1]
 807e122:	f105 35ff 	addle.w	r5, r5, #4294967295
 807e126:	ebac 0305 	sub.w	r3, ip, r5
 807e12a:	6123      	str	r3, [r4, #16]
 807e12c:	f8cd 8000 	str.w	r8, [sp]
 807e130:	463b      	mov	r3, r7
 807e132:	aa03      	add	r2, sp, #12
 807e134:	4621      	mov	r1, r4
 807e136:	4630      	mov	r0, r6
 807e138:	f7ff fef4 	bl	807df24 <_printf_common>
 807e13c:	3001      	adds	r0, #1
 807e13e:	d14d      	bne.n	807e1dc <_printf_i+0x1c8>
 807e140:	f04f 30ff 	mov.w	r0, #4294967295
 807e144:	b005      	add	sp, #20
 807e146:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 807e14a:	4839      	ldr	r0, [pc, #228]	; (807e230 <_printf_i+0x21c>)
 807e14c:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 807e150:	6813      	ldr	r3, [r2, #0]
 807e152:	6821      	ldr	r1, [r4, #0]
 807e154:	1d1d      	adds	r5, r3, #4
 807e156:	681b      	ldr	r3, [r3, #0]
 807e158:	6015      	str	r5, [r2, #0]
 807e15a:	060a      	lsls	r2, r1, #24
 807e15c:	d50b      	bpl.n	807e176 <_printf_i+0x162>
 807e15e:	07ca      	lsls	r2, r1, #31
 807e160:	bf44      	itt	mi
 807e162:	f041 0120 	orrmi.w	r1, r1, #32
 807e166:	6021      	strmi	r1, [r4, #0]
 807e168:	b91b      	cbnz	r3, 807e172 <_printf_i+0x15e>
 807e16a:	6822      	ldr	r2, [r4, #0]
 807e16c:	f022 0220 	bic.w	r2, r2, #32
 807e170:	6022      	str	r2, [r4, #0]
 807e172:	2210      	movs	r2, #16
 807e174:	e7b7      	b.n	807e0e6 <_printf_i+0xd2>
 807e176:	064d      	lsls	r5, r1, #25
 807e178:	bf48      	it	mi
 807e17a:	b29b      	uxthmi	r3, r3
 807e17c:	e7ef      	b.n	807e15e <_printf_i+0x14a>
 807e17e:	4665      	mov	r5, ip
 807e180:	fbb3 f1f2 	udiv	r1, r3, r2
 807e184:	fb02 3311 	mls	r3, r2, r1, r3
 807e188:	5cc3      	ldrb	r3, [r0, r3]
 807e18a:	f805 3d01 	strb.w	r3, [r5, #-1]!
 807e18e:	460b      	mov	r3, r1
 807e190:	2900      	cmp	r1, #0
 807e192:	d1f5      	bne.n	807e180 <_printf_i+0x16c>
 807e194:	e7b9      	b.n	807e10a <_printf_i+0xf6>
 807e196:	6813      	ldr	r3, [r2, #0]
 807e198:	6825      	ldr	r5, [r4, #0]
 807e19a:	1d18      	adds	r0, r3, #4
 807e19c:	6961      	ldr	r1, [r4, #20]
 807e19e:	6010      	str	r0, [r2, #0]
 807e1a0:	0628      	lsls	r0, r5, #24
 807e1a2:	681b      	ldr	r3, [r3, #0]
 807e1a4:	d501      	bpl.n	807e1aa <_printf_i+0x196>
 807e1a6:	6019      	str	r1, [r3, #0]
 807e1a8:	e002      	b.n	807e1b0 <_printf_i+0x19c>
 807e1aa:	066a      	lsls	r2, r5, #25
 807e1ac:	d5fb      	bpl.n	807e1a6 <_printf_i+0x192>
 807e1ae:	8019      	strh	r1, [r3, #0]
 807e1b0:	2300      	movs	r3, #0
 807e1b2:	4665      	mov	r5, ip
 807e1b4:	6123      	str	r3, [r4, #16]
 807e1b6:	e7b9      	b.n	807e12c <_printf_i+0x118>
 807e1b8:	6813      	ldr	r3, [r2, #0]
 807e1ba:	1d19      	adds	r1, r3, #4
 807e1bc:	6011      	str	r1, [r2, #0]
 807e1be:	2100      	movs	r1, #0
 807e1c0:	681d      	ldr	r5, [r3, #0]
 807e1c2:	6862      	ldr	r2, [r4, #4]
 807e1c4:	4628      	mov	r0, r5
 807e1c6:	f000 f8e1 	bl	807e38c <memchr>
 807e1ca:	b108      	cbz	r0, 807e1d0 <_printf_i+0x1bc>
 807e1cc:	1b40      	subs	r0, r0, r5
 807e1ce:	6060      	str	r0, [r4, #4]
 807e1d0:	6863      	ldr	r3, [r4, #4]
 807e1d2:	6123      	str	r3, [r4, #16]
 807e1d4:	2300      	movs	r3, #0
 807e1d6:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 807e1da:	e7a7      	b.n	807e12c <_printf_i+0x118>
 807e1dc:	6923      	ldr	r3, [r4, #16]
 807e1de:	462a      	mov	r2, r5
 807e1e0:	4639      	mov	r1, r7
 807e1e2:	4630      	mov	r0, r6
 807e1e4:	47c0      	blx	r8
 807e1e6:	3001      	adds	r0, #1
 807e1e8:	d0aa      	beq.n	807e140 <_printf_i+0x12c>
 807e1ea:	6823      	ldr	r3, [r4, #0]
 807e1ec:	079b      	lsls	r3, r3, #30
 807e1ee:	d413      	bmi.n	807e218 <_printf_i+0x204>
 807e1f0:	68e0      	ldr	r0, [r4, #12]
 807e1f2:	9b03      	ldr	r3, [sp, #12]
 807e1f4:	4298      	cmp	r0, r3
 807e1f6:	bfb8      	it	lt
 807e1f8:	4618      	movlt	r0, r3
 807e1fa:	e7a3      	b.n	807e144 <_printf_i+0x130>
 807e1fc:	2301      	movs	r3, #1
 807e1fe:	464a      	mov	r2, r9
 807e200:	4639      	mov	r1, r7
 807e202:	4630      	mov	r0, r6
 807e204:	47c0      	blx	r8
 807e206:	3001      	adds	r0, #1
 807e208:	d09a      	beq.n	807e140 <_printf_i+0x12c>
 807e20a:	3501      	adds	r5, #1
 807e20c:	68e3      	ldr	r3, [r4, #12]
 807e20e:	9a03      	ldr	r2, [sp, #12]
 807e210:	1a9b      	subs	r3, r3, r2
 807e212:	42ab      	cmp	r3, r5
 807e214:	dcf2      	bgt.n	807e1fc <_printf_i+0x1e8>
 807e216:	e7eb      	b.n	807e1f0 <_printf_i+0x1dc>
 807e218:	2500      	movs	r5, #0
 807e21a:	f104 0919 	add.w	r9, r4, #25
 807e21e:	e7f5      	b.n	807e20c <_printf_i+0x1f8>
 807e220:	2b00      	cmp	r3, #0
 807e222:	d1ac      	bne.n	807e17e <_printf_i+0x16a>
 807e224:	7803      	ldrb	r3, [r0, #0]
 807e226:	f104 0542 	add.w	r5, r4, #66	; 0x42
 807e22a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 807e22e:	e76c      	b.n	807e10a <_printf_i+0xf6>
 807e230:	0807ecd1 	.word	0x0807ecd1
 807e234:	0807ece2 	.word	0x0807ece2

0807e238 <_sbrk_r>:
 807e238:	b538      	push	{r3, r4, r5, lr}
 807e23a:	2300      	movs	r3, #0
 807e23c:	4c05      	ldr	r4, [pc, #20]	; (807e254 <_sbrk_r+0x1c>)
 807e23e:	4605      	mov	r5, r0
 807e240:	4608      	mov	r0, r1
 807e242:	6023      	str	r3, [r4, #0]
 807e244:	f000 fa76 	bl	807e734 <_sbrk>
 807e248:	1c43      	adds	r3, r0, #1
 807e24a:	d102      	bne.n	807e252 <_sbrk_r+0x1a>
 807e24c:	6823      	ldr	r3, [r4, #0]
 807e24e:	b103      	cbz	r3, 807e252 <_sbrk_r+0x1a>
 807e250:	602b      	str	r3, [r5, #0]
 807e252:	bd38      	pop	{r3, r4, r5, pc}
 807e254:	20000644 	.word	0x20000644

0807e258 <__sread>:
 807e258:	b510      	push	{r4, lr}
 807e25a:	460c      	mov	r4, r1
 807e25c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 807e260:	f000 f8a4 	bl	807e3ac <_read_r>
 807e264:	2800      	cmp	r0, #0
 807e266:	bfab      	itete	ge
 807e268:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 807e26a:	89a3      	ldrhlt	r3, [r4, #12]
 807e26c:	181b      	addge	r3, r3, r0
 807e26e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 807e272:	bfac      	ite	ge
 807e274:	6563      	strge	r3, [r4, #84]	; 0x54
 807e276:	81a3      	strhlt	r3, [r4, #12]
 807e278:	bd10      	pop	{r4, pc}

0807e27a <__swrite>:
 807e27a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 807e27e:	461f      	mov	r7, r3
 807e280:	898b      	ldrh	r3, [r1, #12]
 807e282:	4605      	mov	r5, r0
 807e284:	460c      	mov	r4, r1
 807e286:	05db      	lsls	r3, r3, #23
 807e288:	4616      	mov	r6, r2
 807e28a:	d505      	bpl.n	807e298 <__swrite+0x1e>
 807e28c:	2302      	movs	r3, #2
 807e28e:	2200      	movs	r2, #0
 807e290:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 807e294:	f000 f868 	bl	807e368 <_lseek_r>
 807e298:	89a3      	ldrh	r3, [r4, #12]
 807e29a:	4632      	mov	r2, r6
 807e29c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 807e2a0:	4628      	mov	r0, r5
 807e2a2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 807e2a6:	81a3      	strh	r3, [r4, #12]
 807e2a8:	463b      	mov	r3, r7
 807e2aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 807e2ae:	f000 b817 	b.w	807e2e0 <_write_r>

0807e2b2 <__sseek>:
 807e2b2:	b510      	push	{r4, lr}
 807e2b4:	460c      	mov	r4, r1
 807e2b6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 807e2ba:	f000 f855 	bl	807e368 <_lseek_r>
 807e2be:	1c43      	adds	r3, r0, #1
 807e2c0:	89a3      	ldrh	r3, [r4, #12]
 807e2c2:	bf15      	itete	ne
 807e2c4:	6560      	strne	r0, [r4, #84]	; 0x54
 807e2c6:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 807e2ca:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 807e2ce:	81a3      	strheq	r3, [r4, #12]
 807e2d0:	bf18      	it	ne
 807e2d2:	81a3      	strhne	r3, [r4, #12]
 807e2d4:	bd10      	pop	{r4, pc}

0807e2d6 <__sclose>:
 807e2d6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 807e2da:	f000 b813 	b.w	807e304 <_close_r>
	...

0807e2e0 <_write_r>:
 807e2e0:	b538      	push	{r3, r4, r5, lr}
 807e2e2:	4605      	mov	r5, r0
 807e2e4:	4c06      	ldr	r4, [pc, #24]	; (807e300 <_write_r+0x20>)
 807e2e6:	4608      	mov	r0, r1
 807e2e8:	4611      	mov	r1, r2
 807e2ea:	2200      	movs	r2, #0
 807e2ec:	6022      	str	r2, [r4, #0]
 807e2ee:	461a      	mov	r2, r3
 807e2f0:	f7fc fc5a 	bl	807aba8 <_write>
 807e2f4:	1c43      	adds	r3, r0, #1
 807e2f6:	d102      	bne.n	807e2fe <_write_r+0x1e>
 807e2f8:	6823      	ldr	r3, [r4, #0]
 807e2fa:	b103      	cbz	r3, 807e2fe <_write_r+0x1e>
 807e2fc:	602b      	str	r3, [r5, #0]
 807e2fe:	bd38      	pop	{r3, r4, r5, pc}
 807e300:	20000644 	.word	0x20000644

0807e304 <_close_r>:
 807e304:	b538      	push	{r3, r4, r5, lr}
 807e306:	2300      	movs	r3, #0
 807e308:	4c05      	ldr	r4, [pc, #20]	; (807e320 <_close_r+0x1c>)
 807e30a:	4605      	mov	r5, r0
 807e30c:	4608      	mov	r0, r1
 807e30e:	6023      	str	r3, [r4, #0]
 807e310:	f000 f9e8 	bl	807e6e4 <_close>
 807e314:	1c43      	adds	r3, r0, #1
 807e316:	d102      	bne.n	807e31e <_close_r+0x1a>
 807e318:	6823      	ldr	r3, [r4, #0]
 807e31a:	b103      	cbz	r3, 807e31e <_close_r+0x1a>
 807e31c:	602b      	str	r3, [r5, #0]
 807e31e:	bd38      	pop	{r3, r4, r5, pc}
 807e320:	20000644 	.word	0x20000644

0807e324 <_fstat_r>:
 807e324:	b538      	push	{r3, r4, r5, lr}
 807e326:	2300      	movs	r3, #0
 807e328:	4c06      	ldr	r4, [pc, #24]	; (807e344 <_fstat_r+0x20>)
 807e32a:	4605      	mov	r5, r0
 807e32c:	4608      	mov	r0, r1
 807e32e:	4611      	mov	r1, r2
 807e330:	6023      	str	r3, [r4, #0]
 807e332:	f000 f9df 	bl	807e6f4 <_fstat>
 807e336:	1c43      	adds	r3, r0, #1
 807e338:	d102      	bne.n	807e340 <_fstat_r+0x1c>
 807e33a:	6823      	ldr	r3, [r4, #0]
 807e33c:	b103      	cbz	r3, 807e340 <_fstat_r+0x1c>
 807e33e:	602b      	str	r3, [r5, #0]
 807e340:	bd38      	pop	{r3, r4, r5, pc}
 807e342:	bf00      	nop
 807e344:	20000644 	.word	0x20000644

0807e348 <_isatty_r>:
 807e348:	b538      	push	{r3, r4, r5, lr}
 807e34a:	2300      	movs	r3, #0
 807e34c:	4c05      	ldr	r4, [pc, #20]	; (807e364 <_isatty_r+0x1c>)
 807e34e:	4605      	mov	r5, r0
 807e350:	4608      	mov	r0, r1
 807e352:	6023      	str	r3, [r4, #0]
 807e354:	f000 f9d6 	bl	807e704 <_isatty>
 807e358:	1c43      	adds	r3, r0, #1
 807e35a:	d102      	bne.n	807e362 <_isatty_r+0x1a>
 807e35c:	6823      	ldr	r3, [r4, #0]
 807e35e:	b103      	cbz	r3, 807e362 <_isatty_r+0x1a>
 807e360:	602b      	str	r3, [r5, #0]
 807e362:	bd38      	pop	{r3, r4, r5, pc}
 807e364:	20000644 	.word	0x20000644

0807e368 <_lseek_r>:
 807e368:	b538      	push	{r3, r4, r5, lr}
 807e36a:	4605      	mov	r5, r0
 807e36c:	4c06      	ldr	r4, [pc, #24]	; (807e388 <_lseek_r+0x20>)
 807e36e:	4608      	mov	r0, r1
 807e370:	4611      	mov	r1, r2
 807e372:	2200      	movs	r2, #0
 807e374:	6022      	str	r2, [r4, #0]
 807e376:	461a      	mov	r2, r3
 807e378:	f000 f9cc 	bl	807e714 <_lseek>
 807e37c:	1c43      	adds	r3, r0, #1
 807e37e:	d102      	bne.n	807e386 <_lseek_r+0x1e>
 807e380:	6823      	ldr	r3, [r4, #0]
 807e382:	b103      	cbz	r3, 807e386 <_lseek_r+0x1e>
 807e384:	602b      	str	r3, [r5, #0]
 807e386:	bd38      	pop	{r3, r4, r5, pc}
 807e388:	20000644 	.word	0x20000644

0807e38c <memchr>:
 807e38c:	b2c9      	uxtb	r1, r1
 807e38e:	4402      	add	r2, r0
 807e390:	b510      	push	{r4, lr}
 807e392:	4290      	cmp	r0, r2
 807e394:	4603      	mov	r3, r0
 807e396:	d101      	bne.n	807e39c <memchr+0x10>
 807e398:	2300      	movs	r3, #0
 807e39a:	e003      	b.n	807e3a4 <memchr+0x18>
 807e39c:	781c      	ldrb	r4, [r3, #0]
 807e39e:	3001      	adds	r0, #1
 807e3a0:	428c      	cmp	r4, r1
 807e3a2:	d1f6      	bne.n	807e392 <memchr+0x6>
 807e3a4:	4618      	mov	r0, r3
 807e3a6:	bd10      	pop	{r4, pc}

0807e3a8 <__malloc_lock>:
 807e3a8:	4770      	bx	lr

0807e3aa <__malloc_unlock>:
 807e3aa:	4770      	bx	lr

0807e3ac <_read_r>:
 807e3ac:	b538      	push	{r3, r4, r5, lr}
 807e3ae:	4605      	mov	r5, r0
 807e3b0:	4c06      	ldr	r4, [pc, #24]	; (807e3cc <_read_r+0x20>)
 807e3b2:	4608      	mov	r0, r1
 807e3b4:	4611      	mov	r1, r2
 807e3b6:	2200      	movs	r2, #0
 807e3b8:	6022      	str	r2, [r4, #0]
 807e3ba:	461a      	mov	r2, r3
 807e3bc:	f000 f9b2 	bl	807e724 <_read>
 807e3c0:	1c43      	adds	r3, r0, #1
 807e3c2:	d102      	bne.n	807e3ca <_read_r+0x1e>
 807e3c4:	6823      	ldr	r3, [r4, #0]
 807e3c6:	b103      	cbz	r3, 807e3ca <_read_r+0x1e>
 807e3c8:	602b      	str	r3, [r5, #0]
 807e3ca:	bd38      	pop	{r3, r4, r5, pc}
 807e3cc:	20000644 	.word	0x20000644

0807e3d0 <__aeabi_uldivmod>:
 807e3d0:	b953      	cbnz	r3, 807e3e8 <__aeabi_uldivmod+0x18>
 807e3d2:	b94a      	cbnz	r2, 807e3e8 <__aeabi_uldivmod+0x18>
 807e3d4:	2900      	cmp	r1, #0
 807e3d6:	bf08      	it	eq
 807e3d8:	2800      	cmpeq	r0, #0
 807e3da:	bf1c      	itt	ne
 807e3dc:	f04f 31ff 	movne.w	r1, #4294967295
 807e3e0:	f04f 30ff 	movne.w	r0, #4294967295
 807e3e4:	f000 b97c 	b.w	807e6e0 <__aeabi_idiv0>
 807e3e8:	f1ad 0c08 	sub.w	ip, sp, #8
 807e3ec:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 807e3f0:	f000 f806 	bl	807e400 <__udivmoddi4>
 807e3f4:	f8dd e004 	ldr.w	lr, [sp, #4]
 807e3f8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 807e3fc:	b004      	add	sp, #16
 807e3fe:	4770      	bx	lr

0807e400 <__udivmoddi4>:
 807e400:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 807e404:	468c      	mov	ip, r1
 807e406:	9d08      	ldr	r5, [sp, #32]
 807e408:	4604      	mov	r4, r0
 807e40a:	468a      	mov	sl, r1
 807e40c:	2b00      	cmp	r3, #0
 807e40e:	d14a      	bne.n	807e4a6 <__udivmoddi4+0xa6>
 807e410:	428a      	cmp	r2, r1
 807e412:	4617      	mov	r7, r2
 807e414:	d962      	bls.n	807e4dc <__udivmoddi4+0xdc>
 807e416:	fab2 f682 	clz	r6, r2
 807e41a:	b14e      	cbz	r6, 807e430 <__udivmoddi4+0x30>
 807e41c:	f1c6 0e20 	rsb	lr, r6, #32
 807e420:	fa01 f306 	lsl.w	r3, r1, r6
 807e424:	40b7      	lsls	r7, r6
 807e426:	40b4      	lsls	r4, r6
 807e428:	fa20 fe0e 	lsr.w	lr, r0, lr
 807e42c:	ea4e 0a03 	orr.w	sl, lr, r3
 807e430:	ea4f 4817 	mov.w	r8, r7, lsr #16
 807e434:	0c23      	lsrs	r3, r4, #16
 807e436:	fa1f f987 	uxth.w	r9, r7
 807e43a:	fbba fef8 	udiv	lr, sl, r8
 807e43e:	fb08 aa1e 	mls	sl, r8, lr, sl
 807e442:	fb0e f209 	mul.w	r2, lr, r9
 807e446:	ea43 430a 	orr.w	r3, r3, sl, lsl #16
 807e44a:	429a      	cmp	r2, r3
 807e44c:	d90b      	bls.n	807e466 <__udivmoddi4+0x66>
 807e44e:	18fb      	adds	r3, r7, r3
 807e450:	f10e 31ff 	add.w	r1, lr, #4294967295
 807e454:	bf2c      	ite	cs
 807e456:	2001      	movcs	r0, #1
 807e458:	2000      	movcc	r0, #0
 807e45a:	429a      	cmp	r2, r3
 807e45c:	d902      	bls.n	807e464 <__udivmoddi4+0x64>
 807e45e:	2800      	cmp	r0, #0
 807e460:	f000 812a 	beq.w	807e6b8 <__udivmoddi4+0x2b8>
 807e464:	468e      	mov	lr, r1
 807e466:	1a9a      	subs	r2, r3, r2
 807e468:	b2a3      	uxth	r3, r4
 807e46a:	fbb2 f0f8 	udiv	r0, r2, r8
 807e46e:	fb08 2210 	mls	r2, r8, r0, r2
 807e472:	fb00 f909 	mul.w	r9, r0, r9
 807e476:	ea43 4402 	orr.w	r4, r3, r2, lsl #16
 807e47a:	45a1      	cmp	r9, r4
 807e47c:	d907      	bls.n	807e48e <__udivmoddi4+0x8e>
 807e47e:	193c      	adds	r4, r7, r4
 807e480:	f100 33ff 	add.w	r3, r0, #4294967295
 807e484:	d202      	bcs.n	807e48c <__udivmoddi4+0x8c>
 807e486:	45a1      	cmp	r9, r4
 807e488:	f200 8110 	bhi.w	807e6ac <__udivmoddi4+0x2ac>
 807e48c:	4618      	mov	r0, r3
 807e48e:	eba4 0409 	sub.w	r4, r4, r9
 807e492:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 807e496:	2100      	movs	r1, #0
 807e498:	b11d      	cbz	r5, 807e4a2 <__udivmoddi4+0xa2>
 807e49a:	40f4      	lsrs	r4, r6
 807e49c:	2300      	movs	r3, #0
 807e49e:	e9c5 4300 	strd	r4, r3, [r5]
 807e4a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 807e4a6:	428b      	cmp	r3, r1
 807e4a8:	d908      	bls.n	807e4bc <__udivmoddi4+0xbc>
 807e4aa:	2d00      	cmp	r5, #0
 807e4ac:	f000 80f2 	beq.w	807e694 <__udivmoddi4+0x294>
 807e4b0:	2100      	movs	r1, #0
 807e4b2:	e9c5 0c00 	strd	r0, ip, [r5]
 807e4b6:	4608      	mov	r0, r1
 807e4b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 807e4bc:	fab3 f183 	clz	r1, r3
 807e4c0:	2900      	cmp	r1, #0
 807e4c2:	d14e      	bne.n	807e562 <__udivmoddi4+0x162>
 807e4c4:	4563      	cmp	r3, ip
 807e4c6:	f0c0 80e8 	bcc.w	807e69a <__udivmoddi4+0x29a>
 807e4ca:	4282      	cmp	r2, r0
 807e4cc:	f240 80e5 	bls.w	807e69a <__udivmoddi4+0x29a>
 807e4d0:	4608      	mov	r0, r1
 807e4d2:	2d00      	cmp	r5, #0
 807e4d4:	d0e5      	beq.n	807e4a2 <__udivmoddi4+0xa2>
 807e4d6:	e9c5 4a00 	strd	r4, sl, [r5]
 807e4da:	e7e2      	b.n	807e4a2 <__udivmoddi4+0xa2>
 807e4dc:	b902      	cbnz	r2, 807e4e0 <__udivmoddi4+0xe0>
 807e4de:	deff      	udf	#255	; 0xff
 807e4e0:	fab2 f682 	clz	r6, r2
 807e4e4:	2e00      	cmp	r6, #0
 807e4e6:	f040 8099 	bne.w	807e61c <__udivmoddi4+0x21c>
 807e4ea:	1a8b      	subs	r3, r1, r2
 807e4ec:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 807e4f0:	fa1f f882 	uxth.w	r8, r2
 807e4f4:	2101      	movs	r1, #1
 807e4f6:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 807e4fa:	fbb3 f2fe 	udiv	r2, r3, lr
 807e4fe:	fb0e 3012 	mls	r0, lr, r2, r3
 807e502:	fb08 f902 	mul.w	r9, r8, r2
 807e506:	ea4c 4c00 	orr.w	ip, ip, r0, lsl #16
 807e50a:	45e1      	cmp	r9, ip
 807e50c:	d908      	bls.n	807e520 <__udivmoddi4+0x120>
 807e50e:	eb17 0c0c 	adds.w	ip, r7, ip
 807e512:	f102 33ff 	add.w	r3, r2, #4294967295
 807e516:	d202      	bcs.n	807e51e <__udivmoddi4+0x11e>
 807e518:	45e1      	cmp	r9, ip
 807e51a:	f200 80ca 	bhi.w	807e6b2 <__udivmoddi4+0x2b2>
 807e51e:	461a      	mov	r2, r3
 807e520:	ebac 0c09 	sub.w	ip, ip, r9
 807e524:	b2a3      	uxth	r3, r4
 807e526:	fbbc f0fe 	udiv	r0, ip, lr
 807e52a:	fb0e cc10 	mls	ip, lr, r0, ip
 807e52e:	fb08 f800 	mul.w	r8, r8, r0
 807e532:	ea43 440c 	orr.w	r4, r3, ip, lsl #16
 807e536:	45a0      	cmp	r8, r4
 807e538:	d90e      	bls.n	807e558 <__udivmoddi4+0x158>
 807e53a:	193c      	adds	r4, r7, r4
 807e53c:	f100 33ff 	add.w	r3, r0, #4294967295
 807e540:	bf2c      	ite	cs
 807e542:	f04f 0c01 	movcs.w	ip, #1
 807e546:	f04f 0c00 	movcc.w	ip, #0
 807e54a:	45a0      	cmp	r8, r4
 807e54c:	d903      	bls.n	807e556 <__udivmoddi4+0x156>
 807e54e:	f1bc 0f00 	cmp.w	ip, #0
 807e552:	f000 80a8 	beq.w	807e6a6 <__udivmoddi4+0x2a6>
 807e556:	4618      	mov	r0, r3
 807e558:	eba4 0408 	sub.w	r4, r4, r8
 807e55c:	ea40 4002 	orr.w	r0, r0, r2, lsl #16
 807e560:	e79a      	b.n	807e498 <__udivmoddi4+0x98>
 807e562:	f1c1 0420 	rsb	r4, r1, #32
 807e566:	408b      	lsls	r3, r1
 807e568:	fa02 fe01 	lsl.w	lr, r2, r1
 807e56c:	fa0c f601 	lsl.w	r6, ip, r1
 807e570:	40e2      	lsrs	r2, r4
 807e572:	fa20 f704 	lsr.w	r7, r0, r4
 807e576:	fa2c fc04 	lsr.w	ip, ip, r4
 807e57a:	fa00 f801 	lsl.w	r8, r0, r1
 807e57e:	4313      	orrs	r3, r2
 807e580:	433e      	orrs	r6, r7
 807e582:	0c1f      	lsrs	r7, r3, #16
 807e584:	0c32      	lsrs	r2, r6, #16
 807e586:	fa1f f983 	uxth.w	r9, r3
 807e58a:	fbbc f0f7 	udiv	r0, ip, r7
 807e58e:	fb07 cc10 	mls	ip, r7, r0, ip
 807e592:	fb00 fa09 	mul.w	sl, r0, r9
 807e596:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 807e59a:	45e2      	cmp	sl, ip
 807e59c:	d908      	bls.n	807e5b0 <__udivmoddi4+0x1b0>
 807e59e:	eb13 0c0c 	adds.w	ip, r3, ip
 807e5a2:	f100 32ff 	add.w	r2, r0, #4294967295
 807e5a6:	d202      	bcs.n	807e5ae <__udivmoddi4+0x1ae>
 807e5a8:	45e2      	cmp	sl, ip
 807e5aa:	f200 8089 	bhi.w	807e6c0 <__udivmoddi4+0x2c0>
 807e5ae:	4610      	mov	r0, r2
 807e5b0:	ebac 0c0a 	sub.w	ip, ip, sl
 807e5b4:	b2b6      	uxth	r6, r6
 807e5b6:	fbbc faf7 	udiv	sl, ip, r7
 807e5ba:	fb07 cc1a 	mls	ip, r7, sl, ip
 807e5be:	fb0a f909 	mul.w	r9, sl, r9
 807e5c2:	ea46 420c 	orr.w	r2, r6, ip, lsl #16
 807e5c6:	4591      	cmp	r9, r2
 807e5c8:	d906      	bls.n	807e5d8 <__udivmoddi4+0x1d8>
 807e5ca:	189a      	adds	r2, r3, r2
 807e5cc:	f10a 36ff 	add.w	r6, sl, #4294967295
 807e5d0:	d201      	bcs.n	807e5d6 <__udivmoddi4+0x1d6>
 807e5d2:	4591      	cmp	r9, r2
 807e5d4:	d87a      	bhi.n	807e6cc <__udivmoddi4+0x2cc>
 807e5d6:	46b2      	mov	sl, r6
 807e5d8:	ea4a 4000 	orr.w	r0, sl, r0, lsl #16
 807e5dc:	eba2 0209 	sub.w	r2, r2, r9
 807e5e0:	fba0 670e 	umull	r6, r7, r0, lr
 807e5e4:	42ba      	cmp	r2, r7
 807e5e6:	46b4      	mov	ip, r6
 807e5e8:	46b9      	mov	r9, r7
 807e5ea:	d302      	bcc.n	807e5f2 <__udivmoddi4+0x1f2>
 807e5ec:	d107      	bne.n	807e5fe <__udivmoddi4+0x1fe>
 807e5ee:	45b0      	cmp	r8, r6
 807e5f0:	d205      	bcs.n	807e5fe <__udivmoddi4+0x1fe>
 807e5f2:	ebb6 0c0e 	subs.w	ip, r6, lr
 807e5f6:	eb67 0303 	sbc.w	r3, r7, r3
 807e5fa:	3801      	subs	r0, #1
 807e5fc:	4699      	mov	r9, r3
 807e5fe:	2d00      	cmp	r5, #0
 807e600:	d06b      	beq.n	807e6da <__udivmoddi4+0x2da>
 807e602:	ebb8 030c 	subs.w	r3, r8, ip
 807e606:	eb62 0209 	sbc.w	r2, r2, r9
 807e60a:	fa02 f404 	lsl.w	r4, r2, r4
 807e60e:	40cb      	lsrs	r3, r1
 807e610:	40ca      	lsrs	r2, r1
 807e612:	2100      	movs	r1, #0
 807e614:	431c      	orrs	r4, r3
 807e616:	e9c5 4200 	strd	r4, r2, [r5]
 807e61a:	e742      	b.n	807e4a2 <__udivmoddi4+0xa2>
 807e61c:	40b7      	lsls	r7, r6
 807e61e:	f1c6 0220 	rsb	r2, r6, #32
 807e622:	fa01 f306 	lsl.w	r3, r1, r6
 807e626:	40b4      	lsls	r4, r6
 807e628:	fa21 fc02 	lsr.w	ip, r1, r2
 807e62c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 807e630:	fa20 f202 	lsr.w	r2, r0, r2
 807e634:	fa1f f887 	uxth.w	r8, r7
 807e638:	fbbc f1fe 	udiv	r1, ip, lr
 807e63c:	431a      	orrs	r2, r3
 807e63e:	fb0e cc11 	mls	ip, lr, r1, ip
 807e642:	fb01 f008 	mul.w	r0, r1, r8
 807e646:	0c13      	lsrs	r3, r2, #16
 807e648:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 807e64c:	4560      	cmp	r0, ip
 807e64e:	d907      	bls.n	807e660 <__udivmoddi4+0x260>
 807e650:	eb17 0c0c 	adds.w	ip, r7, ip
 807e654:	f101 33ff 	add.w	r3, r1, #4294967295
 807e658:	d201      	bcs.n	807e65e <__udivmoddi4+0x25e>
 807e65a:	4560      	cmp	r0, ip
 807e65c:	d833      	bhi.n	807e6c6 <__udivmoddi4+0x2c6>
 807e65e:	4619      	mov	r1, r3
 807e660:	ebac 0c00 	sub.w	ip, ip, r0
 807e664:	b292      	uxth	r2, r2
 807e666:	fbbc f0fe 	udiv	r0, ip, lr
 807e66a:	fb0e cc10 	mls	ip, lr, r0, ip
 807e66e:	fb00 f308 	mul.w	r3, r0, r8
 807e672:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 807e676:	4563      	cmp	r3, ip
 807e678:	d907      	bls.n	807e68a <__udivmoddi4+0x28a>
 807e67a:	eb17 0c0c 	adds.w	ip, r7, ip
 807e67e:	f100 32ff 	add.w	r2, r0, #4294967295
 807e682:	d201      	bcs.n	807e688 <__udivmoddi4+0x288>
 807e684:	4563      	cmp	r3, ip
 807e686:	d825      	bhi.n	807e6d4 <__udivmoddi4+0x2d4>
 807e688:	4610      	mov	r0, r2
 807e68a:	ebac 0303 	sub.w	r3, ip, r3
 807e68e:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 807e692:	e730      	b.n	807e4f6 <__udivmoddi4+0xf6>
 807e694:	4629      	mov	r1, r5
 807e696:	4628      	mov	r0, r5
 807e698:	e703      	b.n	807e4a2 <__udivmoddi4+0xa2>
 807e69a:	1a84      	subs	r4, r0, r2
 807e69c:	eb6c 0303 	sbc.w	r3, ip, r3
 807e6a0:	2001      	movs	r0, #1
 807e6a2:	469a      	mov	sl, r3
 807e6a4:	e715      	b.n	807e4d2 <__udivmoddi4+0xd2>
 807e6a6:	3802      	subs	r0, #2
 807e6a8:	443c      	add	r4, r7
 807e6aa:	e755      	b.n	807e558 <__udivmoddi4+0x158>
 807e6ac:	3802      	subs	r0, #2
 807e6ae:	443c      	add	r4, r7
 807e6b0:	e6ed      	b.n	807e48e <__udivmoddi4+0x8e>
 807e6b2:	3a02      	subs	r2, #2
 807e6b4:	44bc      	add	ip, r7
 807e6b6:	e733      	b.n	807e520 <__udivmoddi4+0x120>
 807e6b8:	f1ae 0e02 	sub.w	lr, lr, #2
 807e6bc:	443b      	add	r3, r7
 807e6be:	e6d2      	b.n	807e466 <__udivmoddi4+0x66>
 807e6c0:	3802      	subs	r0, #2
 807e6c2:	449c      	add	ip, r3
 807e6c4:	e774      	b.n	807e5b0 <__udivmoddi4+0x1b0>
 807e6c6:	3902      	subs	r1, #2
 807e6c8:	44bc      	add	ip, r7
 807e6ca:	e7c9      	b.n	807e660 <__udivmoddi4+0x260>
 807e6cc:	f1aa 0a02 	sub.w	sl, sl, #2
 807e6d0:	441a      	add	r2, r3
 807e6d2:	e781      	b.n	807e5d8 <__udivmoddi4+0x1d8>
 807e6d4:	3802      	subs	r0, #2
 807e6d6:	44bc      	add	ip, r7
 807e6d8:	e7d7      	b.n	807e68a <__udivmoddi4+0x28a>
 807e6da:	4629      	mov	r1, r5
 807e6dc:	e6e1      	b.n	807e4a2 <__udivmoddi4+0xa2>
 807e6de:	bf00      	nop

0807e6e0 <__aeabi_idiv0>:
 807e6e0:	4770      	bx	lr
 807e6e2:	bf00      	nop

0807e6e4 <_close>:
 807e6e4:	4b02      	ldr	r3, [pc, #8]	; (807e6f0 <_close+0xc>)
 807e6e6:	2258      	movs	r2, #88	; 0x58
 807e6e8:	f04f 30ff 	mov.w	r0, #4294967295
 807e6ec:	601a      	str	r2, [r3, #0]
 807e6ee:	4770      	bx	lr
 807e6f0:	20000644 	.word	0x20000644

0807e6f4 <_fstat>:
 807e6f4:	4b02      	ldr	r3, [pc, #8]	; (807e700 <_fstat+0xc>)
 807e6f6:	2258      	movs	r2, #88	; 0x58
 807e6f8:	f04f 30ff 	mov.w	r0, #4294967295
 807e6fc:	601a      	str	r2, [r3, #0]
 807e6fe:	4770      	bx	lr
 807e700:	20000644 	.word	0x20000644

0807e704 <_isatty>:
 807e704:	4b02      	ldr	r3, [pc, #8]	; (807e710 <_isatty+0xc>)
 807e706:	2258      	movs	r2, #88	; 0x58
 807e708:	2000      	movs	r0, #0
 807e70a:	601a      	str	r2, [r3, #0]
 807e70c:	4770      	bx	lr
 807e70e:	bf00      	nop
 807e710:	20000644 	.word	0x20000644

0807e714 <_lseek>:
 807e714:	4b02      	ldr	r3, [pc, #8]	; (807e720 <_lseek+0xc>)
 807e716:	2258      	movs	r2, #88	; 0x58
 807e718:	f04f 30ff 	mov.w	r0, #4294967295
 807e71c:	601a      	str	r2, [r3, #0]
 807e71e:	4770      	bx	lr
 807e720:	20000644 	.word	0x20000644

0807e724 <_read>:
 807e724:	4b02      	ldr	r3, [pc, #8]	; (807e730 <_read+0xc>)
 807e726:	2258      	movs	r2, #88	; 0x58
 807e728:	f04f 30ff 	mov.w	r0, #4294967295
 807e72c:	601a      	str	r2, [r3, #0]
 807e72e:	4770      	bx	lr
 807e730:	20000644 	.word	0x20000644

0807e734 <_sbrk>:
 807e734:	4b04      	ldr	r3, [pc, #16]	; (807e748 <_sbrk+0x14>)
 807e736:	4602      	mov	r2, r0
 807e738:	6819      	ldr	r1, [r3, #0]
 807e73a:	b909      	cbnz	r1, 807e740 <_sbrk+0xc>
 807e73c:	4903      	ldr	r1, [pc, #12]	; (807e74c <_sbrk+0x18>)
 807e73e:	6019      	str	r1, [r3, #0]
 807e740:	6818      	ldr	r0, [r3, #0]
 807e742:	4402      	add	r2, r0
 807e744:	601a      	str	r2, [r3, #0]
 807e746:	4770      	bx	lr
 807e748:	200005fc 	.word	0x200005fc
 807e74c:	20000e60 	.word	0x20000e60

0807e750 <_exit>:
 807e750:	e7fe      	b.n	807e750 <_exit>
	...

0807e754 <_init>:
 807e754:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 807e756:	bf00      	nop
 807e758:	bcf8      	pop	{r3, r4, r5, r6, r7}
 807e75a:	bc08      	pop	{r3}
 807e75c:	469e      	mov	lr, r3
 807e75e:	4770      	bx	lr

0807e760 <_fini>:
 807e760:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 807e762:	bf00      	nop
 807e764:	bcf8      	pop	{r3, r4, r5, r6, r7}
 807e766:	bc08      	pop	{r3}
 807e768:	469e      	mov	lr, r3
 807e76a:	4770      	bx	lr
 807e76c:	2d2d2020 	.word	0x2d2d2020
 807e770:	61724520 	.word	0x61724520
 807e774:	676e6973 	.word	0x676e6973
 807e778:	776f6420 	.word	0x776f6420
 807e77c:	616f6c6e 	.word	0x616f6c6e
 807e780:	72612064 	.word	0x72612064
 807e784:	0d206165 	.word	0x0d206165
 807e788:	2020000a 	.word	0x2020000a
 807e78c:	53202d2d 	.word	0x53202d2d
 807e790:	20646e65 	.word	0x20646e65
 807e794:	6d726946 	.word	0x6d726946
 807e798:	65726177 	.word	0x65726177
 807e79c:	000a0d20 	.word	0x000a0d20
 807e7a0:	2d2d2020 	.word	0x2d2d2020
 807e7a4:	202d2d20 	.word	0x202d2d20
 807e7a8:	656c6946 	.word	0x656c6946
 807e7ac:	7254203e 	.word	0x7254203e
 807e7b0:	66736e61 	.word	0x66736e61
 807e7b4:	203e7265 	.word	0x203e7265
 807e7b8:	444f4d59 	.word	0x444f4d59
 807e7bc:	203e4d45 	.word	0x203e4d45
 807e7c0:	646e6553 	.word	0x646e6553
 807e7c4:	20000920 	.word	0x20000920
 807e7c8:	202d2d20 	.word	0x202d2d20
 807e7cc:	50202d2d 	.word	0x50202d2d
 807e7d0:	72676f72 	.word	0x72676f72
 807e7d4:	696d6d61 	.word	0x696d6d61
 807e7d8:	4320676e 	.word	0x4320676e
 807e7dc:	6c706d6f 	.word	0x6c706d6f
 807e7e0:	64657465 	.word	0x64657465
 807e7e4:	63755320 	.word	0x63755320
 807e7e8:	73736563 	.word	0x73736563
 807e7ec:	6c6c7566 	.word	0x6c6c7566
 807e7f0:	0a0d2179 	.word	0x0a0d2179
 807e7f4:	2d202000 	.word	0x2d202000
 807e7f8:	2d2d202d 	.word	0x2d2d202d
 807e7fc:	74794220 	.word	0x74794220
 807e800:	203a7365 	.word	0x203a7365
 807e804:	0d756c25 	.word	0x0d756c25
 807e808:	20000a0a 	.word	0x20000a0a
 807e80c:	69725720 	.word	0x69725720
 807e810:	4d206574 	.word	0x4d206574
 807e814:	63696761 	.word	0x63696761
 807e818:	61725420 	.word	0x61725420
 807e81c:	72656c69 	.word	0x72656c69
 807e820:	20746120 	.word	0x20746120
 807e824:	0d786c25 	.word	0x0d786c25
 807e828:	20000a0a 	.word	0x20000a0a
 807e82c:	202d2d20 	.word	0x202d2d20
 807e830:	21202d2d 	.word	0x21202d2d
 807e834:	6f624121 	.word	0x6f624121
 807e838:	64657472 	.word	0x64657472
 807e83c:	20796220 	.word	0x20796220
 807e840:	72657375 	.word	0x72657375
 807e844:	0a0d2121 	.word	0x0a0d2121
 807e848:	2d202000 	.word	0x2d202000
 807e84c:	2d2d202d 	.word	0x2d2d202d
 807e850:	45212120 	.word	0x45212120
 807e854:	726f7272 	.word	0x726f7272
 807e858:	72756420 	.word	0x72756420
 807e85c:	20676e69 	.word	0x20676e69
 807e860:	656c6966 	.word	0x656c6966
 807e864:	776f6420 	.word	0x776f6420
 807e868:	616f6c6e 	.word	0x616f6c6e
 807e86c:	0d212164 	.word	0x0d212164
 807e870:	000a      	.short	0x000a
 807e872:	0a0d      	.short	0x0a0d
 807e874:	3d3d3d3d 	.word	0x3d3d3d3d
 807e878:	3d3d3d3d 	.word	0x3d3d3d3d
 807e87c:	3d3d3d3d 	.word	0x3d3d3d3d
 807e880:	3d3d3d3d 	.word	0x3d3d3d3d
 807e884:	77654e20 	.word	0x77654e20
 807e888:	20774620 	.word	0x20774620
 807e88c:	6e776f44 	.word	0x6e776f44
 807e890:	64616f6c 	.word	0x64616f6c
 807e894:	3d3d3d20 	.word	0x3d3d3d20
 807e898:	3d3d3d3d 	.word	0x3d3d3d3d
 807e89c:	3d3d3d3d 	.word	0x3d3d3d3d
 807e8a0:	3d3d3d3d 	.word	0x3d3d3d3d
 807e8a4:	3d3d3d3d 	.word	0x3d3d3d3d
 807e8a8:	3d3d3d3d 	.word	0x3d3d3d3d
 807e8ac:	0a0d3d3d 	.word	0x0a0d3d3d
 807e8b0:	52202000 	.word	0x52202000
 807e8b4:	74657365 	.word	0x74657365
 807e8b8:	206f7420 	.word	0x206f7420
 807e8bc:	67697274 	.word	0x67697274
 807e8c0:	20726567 	.word	0x20726567
 807e8c4:	74736e49 	.word	0x74736e49
 807e8c8:	616c6c61 	.word	0x616c6c61
 807e8cc:	6e6f6974 	.word	0x6e6f6974
 807e8d0:	2d2d2d20 	.word	0x2d2d2d20
 807e8d4:	2d2d2d2d 	.word	0x2d2d2d2d
 807e8d8:	2d2d2d2d 	.word	0x2d2d2d2d
 807e8dc:	2d2d2d2d 	.word	0x2d2d2d2d
 807e8e0:	2d2d2d2d 	.word	0x2d2d2d2d
 807e8e4:	2d2d2d2d 	.word	0x2d2d2d2d
 807e8e8:	31202d2d 	.word	0x31202d2d
 807e8ec:	20000a0d 	.word	0x20000a0d
 807e8f0:	776f4420 	.word	0x776f4420
 807e8f4:	616f6c6e 	.word	0x616f6c6e
 807e8f8:	65532064 	.word	0x65532064
 807e8fc:	65727563 	.word	0x65727563
 807e900:	616d4920 	.word	0x616d4920
 807e904:	2d206567 	.word	0x2d206567
 807e908:	2d2d2d2d 	.word	0x2d2d2d2d
 807e90c:	2d2d2d2d 	.word	0x2d2d2d2d
 807e910:	2d2d2d2d 	.word	0x2d2d2d2d
 807e914:	2d2d2d2d 	.word	0x2d2d2d2d
 807e918:	2d2d2d2d 	.word	0x2d2d2d2d
 807e91c:	2d2d2d2d 	.word	0x2d2d2d2d
 807e920:	2d2d2d2d 	.word	0x2d2d2d2d
 807e924:	2d2d2d2d 	.word	0x2d2d2d2d
 807e928:	0a0d3220 	.word	0x0a0d3220
 807e92c:	44202000 	.word	0x44202000
 807e930:	6c6e776f 	.word	0x6c6e776f
 807e934:	2064616f 	.word	0x2064616f
 807e938:	536e6f4e 	.word	0x536e6f4e
 807e93c:	72756365 	.word	0x72756365
 807e940:	6d492065 	.word	0x6d492065
 807e944:	20656761 	.word	0x20656761
 807e948:	2d2d2d2d 	.word	0x2d2d2d2d
 807e94c:	2d2d2d2d 	.word	0x2d2d2d2d
 807e950:	2d2d2d2d 	.word	0x2d2d2d2d
 807e954:	2d2d2d2d 	.word	0x2d2d2d2d
 807e958:	2d2d2d2d 	.word	0x2d2d2d2d
 807e95c:	2d2d2d2d 	.word	0x2d2d2d2d
 807e960:	2d2d2d2d 	.word	0x2d2d2d2d
 807e964:	33202d2d 	.word	0x33202d2d
 807e968:	0a0d      	.short	0x0a0d
 807e96a:	00          	.byte	0x00
 807e96b:	20          	.byte	0x20
 807e96c:	202d2d20 	.word	0x202d2d20
 807e970:	74736e49 	.word	0x74736e49
 807e974:	206c6c61 	.word	0x206c6c61
 807e978:	67616d69 	.word	0x67616d69
 807e97c:	203a2065 	.word	0x203a2065
 807e980:	6f626572 	.word	0x6f626572
 807e984:	0a0d746f 	.word	0x0a0d746f
 807e988:	776f4400 	.word	0x776f4400
 807e98c:	616f6c6e 	.word	0x616f6c6e
 807e990:	65532064 	.word	0x65532064
 807e994:	65727563 	.word	0x65727563
 807e998:	616d4920 	.word	0x616d4920
 807e99c:	000d6567 	.word	0x000d6567
 807e9a0:	2d2d2020 	.word	0x2d2d2020
 807e9a4:	63655320 	.word	0x63655320
 807e9a8:	20657275 	.word	0x20657275
 807e9ac:	67616d49 	.word	0x67616d49
 807e9b0:	6f632065 	.word	0x6f632065
 807e9b4:	63657272 	.word	0x63657272
 807e9b8:	20796c74 	.word	0x20796c74
 807e9bc:	6e776f64 	.word	0x6e776f64
 807e9c0:	64616f6c 	.word	0x64616f6c
 807e9c4:	0d206465 	.word	0x0d206465
 807e9c8:	6f44000a 	.word	0x6f44000a
 807e9cc:	6f6c6e77 	.word	0x6f6c6e77
 807e9d0:	4e206461 	.word	0x4e206461
 807e9d4:	65536e6f 	.word	0x65536e6f
 807e9d8:	65727563 	.word	0x65727563
 807e9dc:	616d4920 	.word	0x616d4920
 807e9e0:	000d6567 	.word	0x000d6567
 807e9e4:	2d2d2020 	.word	0x2d2d2020
 807e9e8:	6e6f4e20 	.word	0x6e6f4e20
 807e9ec:	75636553 	.word	0x75636553
 807e9f0:	49206572 	.word	0x49206572
 807e9f4:	6567616d 	.word	0x6567616d
 807e9f8:	726f6320 	.word	0x726f6320
 807e9fc:	74636572 	.word	0x74636572
 807ea00:	6420796c 	.word	0x6420796c
 807ea04:	6c6e776f 	.word	0x6c6e776f
 807ea08:	6564616f 	.word	0x6564616f
 807ea0c:	0a0d2064 	.word	0x0a0d2064
 807ea10:	766e4900 	.word	0x766e4900
 807ea14:	64696c61 	.word	0x64696c61
 807ea18:	6d754e20 	.word	0x6d754e20
 807ea1c:	20726562 	.word	0x20726562
 807ea20:	00000d21 	.word	0x00000d21

0807ea24 <MagicTrailerValue>:
 807ea24:	f395c277 7fefd260 0f505235 8079b62c     w...`...5RP.,.y.

0807ea34 <ARM_OSPI_FLASH0_DEV_DATA>:
 807ea34:	00000000 00004000 00001000 00000100     .....@..........
 807ea44:	00000002 000000ff                       ........

0807ea4c <DriverVersion>:
 807ea4c:	01000201                                ....

0807ea50 <TFM_Driver_OSPI_FLASH0>:
 807ea50:	0807a95d 0807a971 0807aa97 0807aa85     ]...q...........
 807ea60:	0807a975 0807a9a5 0807ab2d 0807aab9     u.......-.......
 807ea70:	0807a98b 0807a991 0807a99d 3d3d0a0d     ..............==
 807ea80:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 807ea90:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 807eaa0:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 807eab0:	3d3d3d3d 3d3d3d3d 3d3d3d3d 3d3d3d3d     ================
 807eac0:	3d3d3d3d 3d0a0d00 20202020 20202020     ====...=        
 807ead0:	20202020 43282020 4f432029 49525950           (C) COPYRI
 807eae0:	20544847 30323032 4d545320 6f726369     GHT 2020 STMicro
 807eaf0:	63656c65 6e6f7274 20736369 20202020     electronics     
 807eb00:	20202020 20202020 20202020 0a0d003d                 =...
 807eb10:	2020203d 20202020 20202020 20202020     =               
 807eb20:	20202020 20202020 20202020 20202020                     
 807eb30:	20202020 20202020 20202020 20202020                     
 807eb40:	20202020 20202020 20202020 20202020                     
 807eb50:	20202020 0d003d20 20203d0a 20202020          =...=      
 807eb60:	20202020 20202020 20202020 20202020                     
 807eb70:	20202020 41434f4c 4f4c204c 52454441         LOCAL LOADER
 807eb80:	20202020 20202020 20202020 20202020                     
 807eb90:	20202020 20202020 20202020 003d2020                   =.
 807eba0:	000d0a0d 76697244 46207265 6873616c     ....Driver Flash
 807ebb0:	696e4920 203a2074 6c696146                Init : Failed.

0807ebbf <AHBPrescTable>:
	...
 807ebc7:	04030201 09080706                       ........

0807ebcf <APBPrescTable>:
 807ebcf:	00000000 04030201                        .........

0807ebd8 <MSIRangeTable>:
 807ebd8:	000186a0 00030d40 00061a80 000c3500     ....@........5..
 807ebe8:	000f4240 001e8480 003d0900 007a1200     @B........=...z.
 807ebf8:	00f42400 016e3600 01e84800 02dc6c00     .$...6n..H...l..
	...
 807ec18:	65002e08 7365725f 20746c75 7825203d     ...e_result = %x
 807ec28:	25202c20 000a756c                        , %lu..

0807ec30 <CSWTCH.58>:
 807ec30:	08020401                                ....

0807ec34 <CSWTCH.59>:
 807ec34:	10101000 10101004 10101002               ..............

0807ec42 <UARTPrescTable>:
 807ec42:	00020001 00060004 000a0008 0010000c     ................
 807ec52:	00400020 01000080                         .@.......

0807ec5c <_global_impure_ptr>:
 807ec5c:	20000030                                0.. 

0807ec60 <__sf_fake_stderr>:
	...

0807ec80 <__sf_fake_stdin>:
	...

0807eca0 <__sf_fake_stdout>:
	...
 807ecc0:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
 807ecd0:	32313000 36353433 41393837 45444342     .0123456789ABCDE
 807ece0:	31300046 35343332 39383736 64636261     F.0123456789abcd
 807ecf0:	00006665                                ef..

0807ecf4 <__EH_FRAME_BEGIN__>:
 807ecf4:	00000000                                ....
